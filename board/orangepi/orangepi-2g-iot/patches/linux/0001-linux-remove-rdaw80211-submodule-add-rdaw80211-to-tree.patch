From 8f4d0e437ea7f5c6a9771d2b8100c1b6eaed443e Mon Sep 17 00:00:00 2001
From: Leo Soares <leojrfs@gmail.com>
Date: Tue, 13 Jun 2017 13:09:47 +0100
Subject: [PATCH 1/1] add rdaw80211 to the tree

---
 drivers/net/wireless/rdaw80211/Kconfig             |   67 +
 drivers/net/wireless/rdaw80211/Makefile            |   22 +
 drivers/net/wireless/rdaw80211/include/802.11.h    | 2382 +++++++
 drivers/net/wireless/rdaw80211/include/802.1d.h    |   40 +
 drivers/net/wireless/rdaw80211/include/ethernet.h  |  150 +
 drivers/net/wireless/rdaw80211/include/linux_osl.h |  105 +
 drivers/net/wireless/rdaw80211/include/linuxver.h  |  375 ++
 drivers/net/wireless/rdaw80211/include/p2p.h       |  498 ++
 .../net/wireless/rdaw80211/include/wland_bt_amp.h  |  439 ++
 drivers/net/wireless/rdaw80211/include/wland_d11.h |  158 +
 .../net/wireless/rdaw80211/include/wland_utils.h   |  276 +
 drivers/net/wireless/rdaw80211/include/wpa.h       |  220 +
 .../net/wireless/rdaw80211/rdacombodev/Makefile    |   31 +
 .../rdaw80211/rdacombodev/rda_5990_power_ctrl.c    | 1365 ++++
 .../rdaw80211/rdacombodev/rda_5991_power_ctrl.c    |  773 +++
 .../rdaw80211/rdacombodev/rda_5991e_power_ctrl.c   |  847 +++
 .../rdaw80211/rdacombodev/rda_5991f_power_ctrl.c   |  811 +++
 .../rdaw80211/rdacombodev/rda_5991g_power_ctrl.c   |  891 +++
 .../net/wireless/rdaw80211/rdacombodev/rda_combo.h |  199 +
 .../rdaw80211/rdacombodev/rda_combo_power_main.c   | 1363 ++++
 drivers/net/wireless/rdaw80211/rdawlan/Makefile    |   61 +
 drivers/net/wireless/rdaw80211/rdawlan/linux_osl.c |  222 +
 .../net/wireless/rdaw80211/rdawlan/wland_android.c | 1164 ++++
 .../net/wireless/rdaw80211/rdawlan/wland_android.h |   76 +
 drivers/net/wireless/rdaw80211/rdawlan/wland_bta.c |  363 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_bta.h |  427 ++
 .../net/wireless/rdaw80211/rdawlan/wland_btcoex.c  |  535 ++
 .../net/wireless/rdaw80211/rdawlan/wland_btcoex.h  |   32 +
 drivers/net/wireless/rdaw80211/rdawlan/wland_bus.c |  466 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_bus.h |  153 +
 .../wireless/rdaw80211/rdawlan/wland_cfg80211.c    | 6698 ++++++++++++++++++++
 .../wireless/rdaw80211/rdawlan/wland_cfg80211.h    |  554 ++
 .../net/wireless/rdaw80211/rdawlan/wland_cmds.c    | 1736 +++++
 drivers/net/wireless/rdaw80211/rdawlan/wland_d11.c |  186 +
 drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.c |  354 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.h |  171 +
 .../net/wireless/rdaw80211/rdawlan/wland_defs.h    |  276 +
 drivers/net/wireless/rdaw80211/rdawlan/wland_dev.h |  858 +++
 .../net/wireless/rdaw80211/rdawlan/wland_fweh.c    |  575 ++
 .../net/wireless/rdaw80211/rdawlan/wland_fweh.h    |  161 +
 .../net/wireless/rdaw80211/rdawlan/wland_fwsmgr.c  |  424 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_iw.c  | 1824 ++++++
 drivers/net/wireless/rdaw80211/rdawlan/wland_iw.h  |  132 +
 .../net/wireless/rdaw80211/rdawlan/wland_linux.c   | 1113 ++++
 .../wireless/rdaw80211/rdawlan/wland_linux_mon.c   |  400 ++
 .../net/wireless/rdaw80211/rdawlan/wland_nvram.c   |  141 +
 drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.c | 2587 ++++++++
 drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.h |  214 +
 .../net/wireless/rdaw80211/rdawlan/wland_sdio.c    | 1793 ++++++
 .../net/wireless/rdaw80211/rdawlan/wland_sdmmc.c   | 1033 +++
 .../net/wireless/rdaw80211/rdawlan/wland_sdmmc.h   |  311 +
 .../net/wireless/rdaw80211/rdawlan/wland_trap.c    |  780 +++
 .../net/wireless/rdaw80211/rdawlan/wland_trap.h    |   63 +
 .../net/wireless/rdaw80211/rdawlan/wland_trap_90.h | 1804 ++++++
 .../net/wireless/rdaw80211/rdawlan/wland_trap_91.h |  774 +++
 .../wireless/rdaw80211/rdawlan/wland_trap_91e.h    | 1147 ++++
 .../wireless/rdaw80211/rdawlan/wland_trap_91f.h    |  826 +++
 .../wireless/rdaw80211/rdawlan/wland_trap_91g.h    |  806 +++
 drivers/net/wireless/rdaw80211/rdawlan/wland_usb.c | 1499 +++++
 drivers/net/wireless/rdaw80211/rdawlan/wland_usb.h |  186 +
 .../net/wireless/rdaw80211/rdawlan/wland_utils.c   |  698 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_wid.c |  508 ++
 drivers/net/wireless/rdaw80211/rdawlan/wland_wid.h |  814 +++
 64 files changed, 45957 insertions(+)
 create mode 100644 drivers/net/wireless/rdaw80211/Kconfig
 create mode 100644 drivers/net/wireless/rdaw80211/Makefile
 create mode 100644 drivers/net/wireless/rdaw80211/include/802.11.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/802.1d.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/ethernet.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/linux_osl.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/linuxver.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/p2p.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/wland_bt_amp.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/wland_d11.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/wland_utils.h
 create mode 100644 drivers/net/wireless/rdaw80211/include/wpa.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/Makefile
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_5990_power_ctrl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_5991_power_ctrl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_5991e_power_ctrl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_5991f_power_ctrl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_5991g_power_ctrl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_combo.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdacombodev/rda_combo_power_main.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/Makefile
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/linux_osl.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_android.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_android.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_bta.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_bta.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_bus.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_bus.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_cmds.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_d11.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_defs.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_dev.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_fwsmgr.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_iw.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_iw.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_linux.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_linux_mon.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_nvram.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_sdio.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap_90.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91e.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91f.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91g.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_usb.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_usb.h
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_utils.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_wid.c
 create mode 100644 drivers/net/wireless/rdaw80211/rdawlan/wland_wid.h

diff --git a/drivers/net/wireless/rdaw80211/Kconfig b/drivers/net/wireless/rdaw80211/Kconfig
new file mode 100644
index 000000000000..8ecf4525e314
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/Kconfig
@@ -0,0 +1,67 @@
+#
+# RDA599X Wireless LAN device configuration
+#
+menuconfig RDA_WLAN
+	bool "Rda wireless(wifi bt fm) power driver and Rda wifi driver"
+	---help---
+		Need to enable this for RDA wifi bt fm.
+
+if RDA_WLAN
+config RDACBDEV
+	bool "RdaMicro 599X Wireless Combo Chip Support"
+	depends on I2C
+	default n
+	---help---
+	  This option enables pmu support for RdaMicro 599X Wireless ComBo Chip.
+	  Say Y if you want to control the chip power.
+
+config RDAWFMAC
+	tristate "Rdamicro IEEE802.11 embedded FullMac WLAN driver"
+	depends on CFG80211
+  	depends on RDACBDEV
+	---help---
+	  This module adds support for embedded wireless adapters based on
+	  Rdamicro IEEE802.11bgn FullMAC chipsets. It has to work with at least
+	  one of the bus interface support. If you choose to build a module,
+	  it'll be called rdawfmac.ko.
+
+if RDAWFMAC
+config RDAWFMAC_WEXT
+	bool "Enable WEXT support"
+	depends on RDAWFMAC
+	depends on CFG80211
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	default n
+	---help---
+	  Enables WEXT support
+
+config RDAWFMAC_SDIO
+	bool "SDIO bus interface support for FullMac driver"
+	depends on MMC
+	depends on RDAWFMAC
+	default y
+	---help---
+	  This option enables the SDIO bus interface support for Rdamicro
+	  IEEE802.11n embedded FullMAC WLAN driver. Say Y if you want to
+	  use the driver for a SDIO wireless card.
+
+config RDAWFMAC_USB
+	bool "USB bus interface support for FullMAC driver"
+	depends on USB
+	depends on RDAWFMAC
+	default n
+	---help---
+	  This option enables the USB bus interface support for Rdamicro
+	  IEEE802.11n embedded FullMAC WLAN driver. Say Y if you want to
+	  use the driver for an USB wireless card.
+
+config RDAWDBG
+	bool "RdaMicro driver debug functions"
+	depends on RDAWFMAC
+	default y
+	---help---
+	  Selecting this enables additional code for debug purposes.
+endif # RDAWFMAC
+
+endif # RDA_WLAN
diff --git a/drivers/net/wireless/rdaw80211/Makefile b/drivers/net/wireless/rdaw80211/Makefile
new file mode 100644
index 000000000000..664a0a07c613
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/Makefile
@@ -0,0 +1,22 @@
+#
+# Makefile fragment for Rdamicro 802.11n Networking Device Driver
+#
+# Copyright (c) 2014 Rdamicro Corporation
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+# common flags
+subdir-ccflags-$(CONFIG_RDAWDBG)  += -DDEBUG -Werror
+
+obj-$(CONFIG_RDAWFMAC) += rdawlan/
+obj-$(CONFIG_RDACBDEV) 	+= rdacombodev/
diff --git a/drivers/net/wireless/rdaw80211/include/802.11.h b/drivers/net/wireless/rdaw80211/include/802.11.h
new file mode 100644
index 000000000000..35ef13de8826
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/802.11.h
@@ -0,0 +1,2382 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _802_11_H_
+#define _802_11_H_
+
+#ifndef _NET_ETHERNET_H_
+#include <ethernet.h>
+#endif
+
+#include <wpa.h>
+
+#define MAC_HDR_LEN                     24          /* No Address4 - non-ESS         */
+#define MAX_SSID_LEN                    33	
+#define FCS_LEN                         4
+#define TIME_STAMP_LEN                  8
+#define BEACON_INTERVAL_LEN             2
+#define CAP_INFO_LEN                    2
+#define STATUS_CODE_LEN                 2
+#define AID_LEN                         2
+#define IE_HDR_LEN       		        2
+
+
+
+#define DOT11_TU_TO_US			        1024	/* 802.11 Time Unit is 1024 microseconds */
+
+/* Generic 802.11 frame constants */
+#define DOT11_A3_HDR_LEN		        24	/* d11 header length with A3 */
+#define DOT11_A4_HDR_LEN		        30	/* d11 header length with A4 */
+#define DOT11_MAC_HDR_LEN		        DOT11_A3_HDR_LEN	/* MAC header length */
+#define DOT11_FCS_LEN			        4	/* d11 FCS length */
+#define DOT11_ICV_LEN			        4	/* d11 ICV length */
+#define DOT11_ICV_AES_LEN		        8	/* d11 ICV/AES length */
+#define DOT11_QOS_LEN			        2	/* d11 QoS length */
+#define DOT11_HTC_LEN			        4	/* d11 HT Control field length */
+
+#define DOT11_KEY_INDEX_SHIFT		    6	/* d11 key index shift */
+#define DOT11_IV_LEN			        4	/* d11 IV length */
+#define DOT11_IV_TKIP_LEN		        8	/* d11 IV TKIP length */
+#define DOT11_IV_AES_OCB_LEN		    4	/* d11 IV/AES/OCB length */
+#define DOT11_IV_AES_CCM_LEN		    8	/* d11 IV/AES/CCM length */
+#define DOT11_IV_MAX_LEN		        8	/* maximum iv len for any encryption */
+
+/* Includes MIC */
+#define DOT11_MAX_MPDU_BODY_LEN		    2304	/* max MPDU body length */
+/* A4 header + QoS + CCMP + PDU + ICV + FCS = 2352 */
+#define DOT11_MAX_MPDU_LEN		        (DOT11_A4_HDR_LEN + \
+                    					 DOT11_QOS_LEN + \
+                    					 DOT11_IV_AES_CCM_LEN + \
+                    					 DOT11_MAX_MPDU_BODY_LEN + \
+                    					 DOT11_ICV_LEN + \
+                    					 DOT11_FCS_LEN)	/* d11 max MPDU length */
+
+#define DOT11_MAX_SSID_LEN		        32	/* d11 max ssid length */
+
+/* dot11RTSThreshold */
+#define DOT11_DEFAULT_RTS_LEN		    2347	/* d11 default RTS length */
+#define DOT11_MAX_RTS_LEN		        2347	/* d11 max RTS length */
+
+/* dot11FragmentationThreshold */
+#define DOT11_MIN_FRAG_LEN		        256	    /* d11 min fragmentation length */
+#define DOT11_MAX_FRAG_LEN		        2346	/* Max frag is also limited by aMPDUMaxLength of the attached PHY */
+#define DOT11_DEFAULT_FRAG_LEN		    2346	/* d11 default fragmentation length */
+
+/* dot11BeaconPeriod */
+#define DOT11_MIN_BEACON_PERIOD		    1	/* d11 min beacon period */
+#define DOT11_MAX_BEACON_PERIOD		    0xFFFF	/* d11 max beacon period */
+
+/* dot11DTIMPeriod */
+#define DOT11_MIN_DTIM_PERIOD		    1	/* d11 min DTIM period */
+#define DOT11_MAX_DTIM_PERIOD		    0xFF	/* d11 max DTIM period */
+
+/* 802.2 LLC/SNAP header used by 802.11 per 802.1H */
+#define DOT11_LLC_SNAP_HDR_LEN		    8	/* d11 LLC/SNAP header length */
+#define DOT11_OUI_LEN			        3	/* d11 OUI length */
+
+PRE_PACKED struct dot11_llc_snap_header {
+	u8	    dsap;				/* always 0xAA */
+	u8	    ssap;				/* always 0xAA */
+	u8	    ctl;				/* always 0x03 */
+	u8	    oui[DOT11_OUI_LEN];	/* RFC1042: 0x00 0x00 0x00
+        						 * Bridge-Tunnel: 0x00 0x00 0xF8
+        						 */
+	u16	    type;				/* ethertype */
+} POST_PACKED;
+
+/* RFC1042 header used by 802.11 per 802.1H */
+#define RFC1042_HDR_LEN	                (ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)	/* RCF1042 header length */
+
+/* Generic 802.11 MAC header */
+/*
+ * N.B.: This struct reflects the full 4 address 802.11 MAC header.
+ *		 The fields are defined such that the shorter 1, 2, and 3
+ *		 address headers just use the first k fields.
+ */
+PRE_PACKED struct dot11_header {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	a1;		/* address 1 */
+	struct ether_addr	a2;		/* address 2 */
+	struct ether_addr	a3;		/* address 3 */
+	u16			        seq;	/* sequence control */
+	struct ether_addr	a4;		/* address 4 */
+} POST_PACKED;
+
+/* Control frames */
+
+PRE_PACKED struct dot11_rts_frame {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	ta;		/* transmitter address */
+} POST_PACKED;
+
+#define	DOT11_RTS_LEN		        16		/* d11 RTS frame length */
+
+PRE_PACKED struct dot11_cts_frame {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+} POST_PACKED;
+#define	DOT11_CTS_LEN		        10		/* d11 CTS frame length */
+
+PRE_PACKED struct dot11_ack_frame {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+} POST_PACKED;
+#define	DOT11_ACK_LEN		        10		/* d11 ACK frame length */
+
+PRE_PACKED struct dot11_ps_poll_frame {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* AID */
+	struct ether_addr	bssid;	/* receiver address, STA in AP */
+	struct ether_addr	ta;		/* transmitter address */
+} POST_PACKED;
+#define	DOT11_PS_POLL_LEN	        16		/* d11 PS poll frame length */
+
+PRE_PACKED struct dot11_cf_end_frame {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	bssid;	/* transmitter address, STA in AP */
+} POST_PACKED;
+
+#define	DOT11_CS_END_LEN	        16		/* d11 CF-END frame length */
+
+/* RWL wifi protocol: The Vendor Specific Action frame is defined for vendor-specific signaling
+*  category+OUI+vendor specific content ( this can be variable)
+*/
+PRE_PACKED struct dot11_action_wifi_vendor_specific {
+	u8	                category;
+	u8	                OUI[3];
+	u8	                type;
+	u8	                subtype;
+	u8	                data[1040];
+} POST_PACKED;
+
+/* generic vender specific action frame with variable length */
+PRE_PACKED struct dot11_action_vs_frmhdr {
+	u8	                category;
+	u8	                OUI[3];
+	u8	                type;
+	u8	                subtype;
+	u8	                data[1];
+} POST_PACKED;
+
+
+#define DOT11_ACTION_VS_HDR_LEN	    6
+
+#define BCM_ACTION_OUI_BYTE0	    0x00
+#define BCM_ACTION_OUI_BYTE1	    0x90
+#define BCM_ACTION_OUI_BYTE2	    0x4c
+
+/* BA/BAR Control parameters */
+#define DOT11_BA_CTL_POLICY_NORMAL	0x0000	/* normal ack */
+#define DOT11_BA_CTL_POLICY_NOACK	0x0001	/* no ack */
+#define DOT11_BA_CTL_POLICY_MASK	0x0001	/* ack policy mask */
+
+#define DOT11_BA_CTL_MTID		    0x0002	/* multi tid BA */
+#define DOT11_BA_CTL_COMPRESSED		0x0004	/* compressed bitmap */
+
+#define DOT11_BA_CTL_NUMMSDU_MASK	0x0FC0	/* num msdu in bitmap mask */
+#define DOT11_BA_CTL_NUMMSDU_SHIFT	6	    /* num msdu in bitmap shift */
+
+#define DOT11_BA_CTL_TID_MASK		0xF000	/* tid mask */
+#define DOT11_BA_CTL_TID_SHIFT		12	    /* tid shift */
+
+/* control frame header (BA/BAR) */
+PRE_PACKED struct dot11_ctl_header {
+	u16			        fc;		/* frame control */
+	u16			        durid;	/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	ta;		/* transmitter address */
+} POST_PACKED;
+
+#define DOT11_CTL_HDR_LEN	        16		/* control frame hdr len */
+
+/* BAR frame payload */
+PRE_PACKED struct dot11_bar {
+	u16			        bar_control;	    /* BAR Control */
+	u16			        seqnum;		        /* Starting Sequence control */
+} POST_PACKED;
+#define DOT11_BAR_LEN		        4		/* BAR frame payload length */
+
+#define DOT11_BA_BITMAP_LEN	        128	    /* bitmap length */
+#define DOT11_BA_CMP_BITMAP_LEN	    8		/* compressed bitmap length */
+
+/* BA frame payload */
+PRE_PACKED struct dot11_ba {
+	u16			        ba_control;	    /* BA Control */
+	u16			        seqnum;		    /* Starting Sequence control */
+	u8			        bitmap[DOT11_BA_BITMAP_LEN];	/* Block Ack Bitmap */
+} POST_PACKED;
+
+#define DOT11_BA_LEN		        4		/* BA frame payload len (wo bitmap) */
+
+/* Management frame header */
+PRE_PACKED struct dot11_management_header {
+	u16			        fc;		    /* frame control */
+	u16			        durid;		/* duration/ID */
+	struct ether_addr	da;		    /* receiver address */
+	struct ether_addr	sa;		    /* transmitter address */
+	struct ether_addr	bssid;		/* BSS ID */
+	u16			        seq;		/* sequence control */
+} POST_PACKED;
+
+#define	DOT11_MGMT_HDR_LEN	        24		/* d11 management header length */
+
+/* Management frame payloads */
+PRE_PACKED struct dot11_bcn_prb {
+	u32			        timestamp[2];
+	u16			        beacon_interval;
+	u16			        capability;
+} POST_PACKED;
+
+#define	DOT11_BCN_PRB_LEN	        12		/* 802.11 beacon/probe frame fixed length */
+#define	DOT11_BCN_PRB_FIXED_LEN	    12		/* 802.11 beacon/probe frame fixed length */
+
+PRE_PACKED struct dot11_auth {
+	u16			        alg;		/* algorithm */
+	u16			        seq;		/* sequence control */
+	u16			        status;		/* status code */
+} POST_PACKED;
+#define DOT11_AUTH_FIXED_LEN	    6		/* length of auth frame without challenge IE */
+
+PRE_PACKED struct dot11_assoc_req {
+	u16			        capability;	/* capability information */
+	u16			        listen;		/* listen interval */
+} POST_PACKED;
+#define DOT11_ASSOC_REQ_FIXED_LEN	4	/* length of assoc frame without info elts */
+
+PRE_PACKED struct dot11_reassoc_req {
+	u16			        capability;	/* capability information */
+	u16			        listen;		/* listen interval */
+	struct ether_addr	ap;		    /* Current AP address */
+} POST_PACKED;
+
+#define DOT11_REASSOC_REQ_FIXED_LEN	10	/* length of assoc frame without info elts */
+
+PRE_PACKED struct dot11_assoc_resp {
+	u16			        capability;	/* capability information */
+	u16			        status;		/* status code */
+	u16			        aid;		/* association ID */
+} POST_PACKED;
+
+#define DOT11_ASSOC_RESP_FIXED_LEN	6	/* length of assoc resp frame without info elts */
+
+PRE_PACKED struct dot11_action_measure {
+	u8	                category;
+	u8	                action;
+	u8	                token;
+	u8	                data[1];
+} POST_PACKED;
+
+#define DOT11_ACTION_MEASURE_LEN	3	/* d11 action measurement header length */
+
+PRE_PACKED struct dot11_action_ht_ch_width {
+	u8	                category;
+	u8	                action;
+	u8	                ch_width;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_action_ht_mimops {
+	u8	                category;
+	u8	                action;
+	u8	                control;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_action_sa_query {
+	u8	                category;
+	u8	                action;
+	u16	                id;
+} POST_PACKED;
+
+#define SM_PWRSAVE_ENABLE	        1
+#define SM_PWRSAVE_MODE		        2
+
+/* ************* 802.11h related definitions. ************* */
+PRE_PACKED struct dot11_power_cnst {
+	u8                  id;
+	u8                  len;
+	u8                  power;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_power_cap {
+	u8                  min;
+	u8                  max;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_tpc_rep {
+	u8                  id;
+	u8                  len;
+	u8                  tx_pwr;
+	u8                  margin;
+} POST_PACKED;
+
+#define DOT11_MNG_IE_TPC_REPORT_LEN	2 	/* length of IE data, not including 2 byte header */
+
+PRE_PACKED struct dot11_supp_channels {
+	u8                  id;
+	u8                  len;
+	u8                  first_channel;
+	u8                  num_channels;
+} POST_PACKED;
+
+/* Extension Channel Offset IE: 802.11n-D1.0 spec. added sideband
+ * offset for 40MHz operation.  The possible 3 values are:
+ * 1 = above control channel
+ * 3 = below control channel
+ * 0 = no extension channel
+ */
+PRE_PACKED struct dot11_extch {
+	u8	        id;		    /* IE ID, 62, DOT11_MNG_EXT_CHANNEL_OFFSET */
+	u8	        len;		/* IE length */
+	u8	        extch;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_brcm_extch {
+	u8	        id;		    /* IE ID, 221, DOT11_MNG_PROPR_ID */
+	u8	        len;		/* IE length */
+	u8	        oui[3];		/* Proprietary OUI, BRCM_PROP_OUI */
+	u8	        type;       /* type inidicates what follows */
+	u8	        extch;
+} POST_PACKED;
+
+
+#define BRCM_EXTCH_IE_LEN	5
+#define BRCM_EXTCH_IE_TYPE	53	/* 802.11n ID not yet assigned */
+#define DOT11_EXTCH_IE_LEN	1
+#define DOT11_EXT_CH_MASK	0x03	/* extension channel mask */
+#define DOT11_EXT_CH_UPPER	0x01	/* ext. ch. on upper sb */
+#define DOT11_EXT_CH_LOWER	0x03	/* ext. ch. on lower sb */
+#define DOT11_EXT_CH_NONE	0x00	/* no extension ch.  */
+
+PRE_PACKED struct dot11_action_frmhdr {
+	u8	        category;
+	u8	        action;
+	u8	        data[1];
+} POST_PACKED;
+
+/* CSA IE data structure */
+PRE_PACKED struct dot11_channel_switch {
+	u8          id;	        /* id DOT11_MNG_CHANNEL_SWITCH_ID */
+	u8          len;	    /* length of IE */
+	u8          mode;	    /* mode 0 or 1 */
+	u8          channel;	/* channel switch to */
+	u8          count;	    /* number of beacons before switching */
+} POST_PACKED;
+
+
+#define DOT11_SWITCH_IE_LEN	        3	/* length of IE data, not including 2 byte header */
+/* CSA mode - 802.11h-2003 $7.3.2.20 */
+#define DOT11_CSA_MODE_ADVISORY		0	/* no DOT11_CSA_MODE_NO_TX restriction imposed */
+#define DOT11_CSA_MODE_NO_TX		1	/* no transmission upon receiving CSA frame. */
+
+PRE_PACKED struct dot11_action_switch_channel {
+	u8	                        category;
+	u8	                        action;
+	struct dot11_channel_switch chan_switch_ie;	/* for switch IE */
+	struct dot11_brcm_extch     extch_ie;		/* extension channel offset */
+} POST_PACKED;
+
+PRE_PACKED struct dot11_csa_body {
+	u8 mode;	/* mode 0 or 1 */
+	u8 reg;	/* regulatory class */
+	u8 channel;	/* channel switch to */
+	u8 count;	/* number of beacons before switching */
+} POST_PACKED;
+
+/* 11n Extended Channel Switch IE data structure */
+PRE_PACKED struct dot11_ext_csa {
+	u8 id;	/* id DOT11_MNG_EXT_CHANNEL_SWITCH_ID */
+	u8 len;	/* length of IE */
+	struct dot11_csa_body b;	/* body of the ie */
+} POST_PACKED;
+
+#define DOT11_EXT_CSA_IE_LEN	4	/* length of extended channel switch IE body */
+
+PRE_PACKED struct dot11_action_ext_csa {
+	u8	                    category;
+	u8	                    action;
+	struct dot11_ext_csa    chan_switch_ie;	/* for switch IE */
+} POST_PACKED;
+
+PRE_PACKED struct dot11y_action_ext_csa {
+	u8	                    category;
+	u8	                    action;
+	struct dot11_csa_body   b;	/* body of the ie */
+} POST_PACKED;
+
+PRE_PACKED struct dot11_obss_coex {
+	u8	id;
+	u8	len;
+	u8	info;
+} POST_PACKED;
+
+#define DOT11_OBSS_COEXINFO_LEN	            1	/* length of OBSS Coexistence INFO IE */
+#define	DOT11_OBSS_COEX_INFO_REQ		    0x01
+#define	DOT11_OBSS_COEX_40MHZ_INTOLERANT	0x02
+#define	DOT11_OBSS_COEX_20MHZ_WIDTH_REQ	    0x04
+
+PRE_PACKED struct dot11_obss_chanlist {
+	u8	id;
+	u8	len;
+	u8	regclass;
+	u8	chanlist[1];
+} POST_PACKED;
+
+
+#define DOT11_OBSS_CHANLIST_FIXED_LEN	    1	/* fixed length of regclass */
+
+PRE_PACKED struct dot11_extcap_ie {
+	u8 id;
+	u8 len;
+	u8 cap[1];
+} POST_PACKED;
+
+#define DOT11_EXTCAP_LEN_MAX	        7
+#define DOT11_EXTCAP_LEN_COEX	        1
+#define DOT11_EXTCAP_LEN_BT	            3
+#define DOT11_EXTCAP_LEN_IW	            4
+#define DOT11_EXTCAP_LEN_SI	            6
+
+#define DOT11_EXTCAP_LEN_TDLS	        5
+
+PRE_PACKED struct dot11_extcap {
+	u8 extcap[DOT11_EXTCAP_LEN_TDLS];
+} POST_PACKED;
+
+/* TDLS Capabilities */
+#define TDLS_CAP_TDLS			        37		/* TDLS support */
+#define TDLS_CAP_PU_BUFFER_STA	        28		/* TDLS Peer U-APSD buffer STA support */
+#define TDLS_CAP_PEER_PSM		        20		/* TDLS Peer PSM support */
+#define TDLS_CAP_CH_SW			        30		/* TDLS Channel switch */
+#define TDLS_CAP_PROH			        38		/* TDLS prohibited */
+#define TDLS_CAP_CH_SW_PROH		        39		/* TDLS Channel switch prohibited */
+
+#define TDLS_CAP_MAX_BIT		        39		/* TDLS max bit defined in ext cap */
+
+/* 802.11h/802.11k Measurement Request/Report IEs */
+/* Measurement Type field */
+#define DOT11_MEASURE_TYPE_BASIC 	    0	/* d11 measurement basic type */
+#define DOT11_MEASURE_TYPE_CCA 		    1	/* d11 measurement CCA type */
+#define DOT11_MEASURE_TYPE_RPI		    2	/* d11 measurement RPI type */
+#define DOT11_MEASURE_TYPE_CHLOAD		3	/* d11 measurement Channel Load type */
+#define DOT11_MEASURE_TYPE_NOISE		4	/* d11 measurement Noise Histogram type */
+#define DOT11_MEASURE_TYPE_BEACON		5	/* d11 measurement Beacon type */
+#define DOT11_MEASURE_TYPE_FRAME	    6	/* d11 measurement Frame type */
+#define DOT11_MEASURE_TYPE_STATS		7	/* d11 measurement STA Statistics type */
+#define DOT11_MEASURE_TYPE_LCI		    8	/* d11 measurement LCI type */
+#define DOT11_MEASURE_TYPE_TXSTREAM		9	/* d11 measurement TX Stream type */
+#define DOT11_MEASURE_TYPE_PAUSE		255	/* d11 measurement pause type */
+
+/* Measurement Request Modes */
+#define DOT11_MEASURE_MODE_PARALLEL 	(1<<0)	/* d11 measurement parallel */
+#define DOT11_MEASURE_MODE_ENABLE 	    (1<<1)	/* d11 measurement enable */
+#define DOT11_MEASURE_MODE_REQUEST	    (1<<2)	/* d11 measurement request */
+#define DOT11_MEASURE_MODE_REPORT 	    (1<<3)	/* d11 measurement report */
+#define DOT11_MEASURE_MODE_DUR 	        (1<<4)	/* d11 measurement dur mandatory */
+/* Measurement Report Modes */
+#define DOT11_MEASURE_MODE_LATE 	    (1<<0)	/* d11 measurement late */
+#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)	/* d11 measurement incapable */
+#define DOT11_MEASURE_MODE_REFUSED	    (1<<2)	/* d11 measurement refuse */
+/* Basic Measurement Map bits */
+#define DOT11_MEASURE_BASIC_MAP_BSS 	((u8)(1<<0))	/* d11 measurement basic map BSS */
+#define DOT11_MEASURE_BASIC_MAP_OFDM	((u8)(1<<1))	/* d11 measurement map OFDM */
+#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((u8)(1<<2))	/* d11 measurement map unknown */
+#define DOT11_MEASURE_BASIC_MAP_RADAR	((u8)(1<<3))	/* d11 measurement map radar */
+#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((u8)(1<<4))	/* d11 measurement map unmeasuremnt */
+
+PRE_PACKED struct dot11_meas_req {
+	u8      id;
+	u8      len;
+	u8      token;
+	u8      mode;
+	u8      type;
+	u8      channel;
+	u8      start_time[8];
+	u16     duration;
+} POST_PACKED;
+
+
+#define DOT11_MNG_IE_MREQ_LEN           14	/* d11 measurement request IE length */
+/* length of Measure Request IE data not including variable len */
+#define DOT11_MNG_IE_MREQ_FIXED_LEN     3	/* d11 measurement request IE fixed length */
+
+PRE_PACKED struct dot11_meas_rep 
+{
+	u8 id;
+	u8 len;
+	u8 token;
+	u8 mode;
+	u8 type;
+	PRE_PACKED union
+	{
+		PRE_PACKED struct
+		{
+			u8   channel;
+			u8   start_time[8];
+			u16  duration;
+			u8   map;
+		} POST_PACKED basic;
+		u8 data[1];
+	} POST_PACKED rep;
+} POST_PACKED;
+
+/* length of Measure Report IE data not including variable len */
+#define DOT11_MNG_IE_MREP_FIXED_LEN	    3	/* d11 measurement response IE fixed length */
+
+PRE_PACKED struct dot11_meas_rep_basic 
+{
+	u8   channel;
+	u8   start_time[8];
+	u16  duration;
+	u8   map;
+} POST_PACKED;
+
+#define DOT11_MEASURE_BASIC_REP_LEN	    12	/* d11 measurement basic report length */
+
+PRE_PACKED struct dot11_quiet
+{
+	u8                      id;
+	u8                      len;
+	u8                      count;	/* TBTTs until beacon interval in quiet starts */
+	u8                      period;	/* Beacon intervals between periodic quiet periods ? */
+	u16                     duration;	/* Length of quiet period, in TU's */
+	u16                     offset;	/* TU's offset from TBTT in Count field */
+} POST_PACKED;
+
+PRE_PACKED struct chan_map_tuple 
+{
+	u8                      channel;
+	u8                      map;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_ibss_dfs {
+	u8                      id;
+	u8                      len;
+	u8                      eaddr[ETHER_ADDR_LEN];
+	u8                      interval;
+	struct chan_map_tuple   map[1];
+} POST_PACKED;
+
+/* WME Elements */
+#define WME_OUI			            "\x00\x50\xf2"	/* WME OUI */
+#define WME_OUI_LEN		            3
+#define WME_OUI_TYPE		        2	/* WME type */
+#define WME_TYPE		            2	/* WME type, deprecated */
+#define WME_SUBTYPE_IE		        0	/* Information Element */
+#define WME_SUBTYPE_PARAM_IE	    1	/* Parameter Element */
+#define WME_SUBTYPE_TSPEC	        2	/* Traffic Specification */
+#define WME_VER			            1	/* WME version */
+
+/* WME Access Category Indices (ACIs) */
+#define AC_BE			            0	/* Best Effort */
+#define AC_BK			            1	/* Background */
+#define AC_VI			            2	/* Video */
+#define AC_VO			            3	/* Voice */
+#define AC_COUNT		            4	/* number of ACs */
+
+#define AC_BITMAP_NONE		        0x0	/* No ACs */
+#define AC_BITMAP_ALL		        0xF	/* All ACs */
+#define AC_BITMAP_TST(ab, ac)	    (((ab) & (1 << (ac))) != 0)
+#define AC_BITMAP_SET(ab, ac)	    (((ab) |= (1 << (ac))))
+#define AC_BITMAP_RESET(ab, ac)     (((ab) &= ~(1 << (ac))))
+
+/* WME Information Element (IE) */
+PRE_PACKED struct wme_ie {
+	u8                  oui[3];
+	u8                  type;
+	u8                  subtype;
+	u8                  version;
+	u8                  qosinfo;
+} POST_PACKED;
+
+#define WME_IE_LEN                  7	/* WME IE length */
+
+PRE_PACKED struct edcf_acparam {
+	u8	                ACI;
+	u8	                ECW;
+	u16                 TXOP;		/* stored in network order (ls octet first) */
+} POST_PACKED;
+
+/* WME Parameter Element (PE) */
+PRE_PACKED struct wme_param_ie {
+	u8                  oui[3];
+	u8                  type;
+	u8                  subtype;
+	u8                  version;
+	u8                  qosinfo;
+	u8                  rsvd;
+	struct edcf_acparam acparam[AC_COUNT];
+} POST_PACKED;
+
+#define WME_PARAM_IE_LEN                24          /* WME Parameter IE length */
+
+/* QoS Info field for IE as sent from AP */
+#define WME_QI_AP_APSD_MASK             0x80        /* U-APSD Supported mask */
+#define WME_QI_AP_APSD_SHIFT            7           /* U-APSD Supported shift */
+#define WME_QI_AP_COUNT_MASK            0x0f        /* Parameter set count mask */
+#define WME_QI_AP_COUNT_SHIFT           0           /* Parameter set count shift */
+
+/* QoS Info field for IE as sent from STA */
+#define WME_QI_STA_MAXSPLEN_MASK        0x60        /* Max Service Period Length mask */
+#define WME_QI_STA_MAXSPLEN_SHIFT       5           /* Max Service Period Length shift */
+#define WME_QI_STA_APSD_ALL_MASK        0xf         /* APSD all AC bits mask */
+#define WME_QI_STA_APSD_ALL_SHIFT       0           /* APSD all AC bits shift */
+#define WME_QI_STA_APSD_BE_MASK         0x8         /* APSD AC_BE mask */
+#define WME_QI_STA_APSD_BE_SHIFT        3           /* APSD AC_BE shift */
+#define WME_QI_STA_APSD_BK_MASK         0x4         /* APSD AC_BK mask */
+#define WME_QI_STA_APSD_BK_SHIFT        2           /* APSD AC_BK shift */
+#define WME_QI_STA_APSD_VI_MASK         0x2         /* APSD AC_VI mask */
+#define WME_QI_STA_APSD_VI_SHIFT        1           /* APSD AC_VI shift */
+#define WME_QI_STA_APSD_VO_MASK         0x1         /* APSD AC_VO mask */
+#define WME_QI_STA_APSD_VO_SHIFT        0           /* APSD AC_VO shift */
+
+/* ACI */
+#define EDCF_AIFSN_MIN                  1           /* AIFSN minimum value */
+#define EDCF_AIFSN_MAX                  15          /* AIFSN maximum value */
+#define EDCF_AIFSN_MASK                 0x0F        /* AIFSN mask */
+#define EDCF_ACM_MASK                   0x10        /* ACM mask */
+#define EDCF_ACI_MASK                   0x60        /* ACI mask */
+#define EDCF_ACI_SHIFT                  5           /* ACI shift */
+#define EDCF_AIFSN_SHIFT                12          /* 4 MSB(0xFFF) in ifs_ctl for AC idx */
+
+/* ECW */
+#define EDCF_ECW_MIN                    0           /* cwmin/cwmax exponent minimum value */
+#define EDCF_ECW_MAX                    15          /* cwmin/cwmax exponent maximum value */
+#define EDCF_ECW2CW(exp)                ((1 << (exp)) - 1)
+#define EDCF_ECWMIN_MASK                0x0F        /* cwmin exponent form mask */
+#define EDCF_ECWMAX_MASK                0xF0        /* cwmax exponent form mask */
+#define EDCF_ECWMAX_SHIFT               4           /* cwmax exponent form shift */
+
+/* TXOP */
+#define EDCF_TXOP_MIN                   0           /* TXOP minimum value */
+#define EDCF_TXOP_MAX                   65535       /* TXOP maximum value */
+#define EDCF_TXOP2USEC(txop)            ((txop) << 5)
+
+/* Default BE ACI value for non-WME connection STA */
+#define NON_EDCF_AC_BE_ACI_STA          0x02
+
+/* Default EDCF parameters that AP advertises for STA to use; WMM draft Table 12 */
+#define EDCF_AC_BE_ACI_STA              0x03	/* STA ACI value for best effort AC */
+#define EDCF_AC_BE_ECW_STA              0xA4	/* STA ECW value for best effort AC */
+#define EDCF_AC_BE_TXOP_STA             0x0000	/* STA TXOP value for best effort AC */
+#define EDCF_AC_BK_ACI_STA              0x27	/* STA ACI value for background AC */
+#define EDCF_AC_BK_ECW_STA              0xA4	/* STA ECW value for background AC */
+#define EDCF_AC_BK_TXOP_STA             0x0000	/* STA TXOP value for background AC */
+#define EDCF_AC_VI_ACI_STA              0x42	/* STA ACI value for video AC */
+#define EDCF_AC_VI_ECW_STA              0x43	/* STA ECW value for video AC */
+#define EDCF_AC_VI_TXOP_STA             0x005E	/* STA TXOP value for video AC */
+#define EDCF_AC_VO_ACI_STA              0x62	/* STA ACI value for audio AC */
+#define EDCF_AC_VO_ECW_STA              0x32	/* STA ECW value for audio AC */
+#define EDCF_AC_VO_TXOP_STA             0x002F	/* STA TXOP value for audio AC */
+
+/* Default EDCF parameters that AP uses; WMM draft Table 14 */
+#define EDCF_AC_BE_ACI_AP               0x03	/* AP ACI value for best effort AC */
+#define EDCF_AC_BE_ECW_AP               0x64	/* AP ECW value for best effort AC */
+#define EDCF_AC_BE_TXOP_AP              0x0000	/* AP TXOP value for best effort AC */
+#define EDCF_AC_BK_ACI_AP               0x27	/* AP ACI value for background AC */
+#define EDCF_AC_BK_ECW_AP               0xA4	/* AP ECW value for background AC */
+#define EDCF_AC_BK_TXOP_AP              0x0000	/* AP TXOP value for background AC */
+#define EDCF_AC_VI_ACI_AP               0x41	/* AP ACI value for video AC */
+#define EDCF_AC_VI_ECW_AP               0x43	/* AP ECW value for video AC */
+#define EDCF_AC_VI_TXOP_AP              0x005E	/* AP TXOP value for video AC */
+#define EDCF_AC_VO_ACI_AP               0x61	/* AP ACI value for audio AC */
+#define EDCF_AC_VO_ECW_AP               0x32	/* AP ECW value for audio AC */
+#define EDCF_AC_VO_TXOP_AP              0x002F	/* AP TXOP value for audio AC */
+
+/* EDCA Parameter IE */
+PRE_PACKED struct edca_param_ie {
+	u8                  qosinfo;
+	u8                  rsvd;
+	struct edcf_acparam acparam[AC_COUNT];
+} POST_PACKED;
+
+#define EDCA_PARAM_IE_LEN               18          /* EDCA Parameter IE length */
+
+/* QoS Capability IE */
+PRE_PACKED struct qos_cap_ie {
+	u8                  qosinfo;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_qbss_load_ie {
+	u8                  id; 			    /* 11, DOT11_MNG_QBSS_LOAD_ID */
+	u8                  length;
+	u16                 station_count; 		/* total number of STAs associated */
+	u8                  channel_utilization;	/* % of time, normalized to 255, QAP sensed medium busy */
+	u16                 aac; 			    /* available admission capacity */
+} POST_PACKED;
+
+#define BSS_LOAD_IE_SIZE 	            7	/* BSS load IE size */
+
+/* nom_msdu_size */
+#define FIXED_MSDU_SIZE                 0x8000		/* MSDU size is fixed */
+#define MSDU_SIZE_MASK	                0x7FFF		/* (Nominal or fixed) MSDU size */
+
+/* surplus_bandwidth */
+/* Represented as 3 bits of integer, binary point, 13 bits fraction */
+#define	INTEGER_SHIFT	                13	/* integer shift */
+#define FRACTION_MASK	                0x1FFF	/* fraction mask */
+
+/* Management Notification Frame */
+PRE_PACKED struct dot11_management_notification {
+	u8                  category;			/* DOT11_ACTION_NOTIFICATION */
+	u8                  action;
+	u8                  token;
+	u8                  status;
+	u8                  data[1];			/* Elements */
+} POST_PACKED;
+
+#define DOT11_MGMT_NOTIFICATION_LEN     4	/* Fixed length */
+
+/* Timeout Interval IE */
+PRE_PACKED struct ti_ie {
+	u8                  ti_type;
+	u32                 ti_val;
+} POST_PACKED;
+
+#define TI_TYPE_REASSOC_DEADLINE	    1
+#define TI_TYPE_KEY_LIFETIME		    2
+
+/* WME Action Codes */
+#define WME_ADDTS_REQUEST	            0	/* WME ADDTS request */
+#define WME_ADDTS_RESPONSE	            1	/* WME ADDTS response */
+#define WME_DELTS_REQUEST	            2	/* WME DELTS request */
+
+/* WME Setup Response Status Codes */
+#define WME_ADMISSION_ACCEPTED		    0	/* WME admission accepted */
+#define WME_INVALID_PARAMETERS		    1	/* WME invalide parameters */
+#define WME_ADMISSION_REFUSED		    3	/* WME admission refused */
+
+/* Macro to take a pointer to a beacon or probe response
+ * body and return the char* pointer to the SSID info element
+ */
+#define BCN_PRB_SSID(body) ((char*)(body) + DOT11_BCN_PRB_LEN)
+
+/* Authentication frame payload constants */
+#define DOT11_OPEN_SYSTEM	            0	/* d11 open authentication */
+#define DOT11_SHARED_KEY	            1	/* d11 shared authentication */
+#define DOT11_FAST_BSS		            2	/* d11 fast bss authentication */
+#define DOT11_CHALLENGE_LEN	            128	/* d11 challenge text length */
+
+/* Frame control macros */
+#define FC_PVER_MASK		            0x3	/* PVER mask */
+#define FC_PVER_SHIFT		            0	/* PVER shift */
+#define FC_TYPE_MASK		            0xC	/* type mask */
+#define FC_TYPE_SHIFT		            2	/* type shift */
+#define FC_SUBTYPE_MASK		            0xF0	/* subtype mask */
+#define FC_SUBTYPE_SHIFT	            4	/* subtype shift */
+#define FC_TODS			                0x100	/* to DS */
+#define FC_TODS_SHIFT		            8	/* to DS shift */
+#define FC_FROMDS		                0x200	/* from DS */
+#define FC_FROMDS_SHIFT		            9	/* from DS shift */
+#define FC_MOREFRAG		                0x400	/* more frag. */
+#define FC_MOREFRAG_SHIFT	            10	/* more frag. shift */
+#define FC_RETRY		                0x800	/* retry */
+#define FC_RETRY_SHIFT		            11	/* retry shift */
+#define FC_PM			                0x1000	/* PM */
+#define FC_PM_SHIFT		                12	/* PM shift */
+#define FC_MOREDATA		                0x2000	/* more data */
+#define FC_MOREDATA_SHIFT	            13	/* more data shift */
+#define FC_WEP			                0x4000	/* WEP */
+#define FC_WEP_SHIFT		            14	/* WEP shift */
+#define FC_ORDER		                0x8000	/* order */
+#define FC_ORDER_SHIFT		            15	/* order shift */
+
+/* sequence control macros */
+#define SEQNUM_SHIFT		            4	/* seq. number shift */
+#define SEQNUM_MAX		                0x1000	/* max seqnum + 1 */
+#define FRAGNUM_MASK		            0xF	/* frag. number mask */
+
+/* Frame Control type/subtype defs */
+/* FC Types */
+#define FC_TYPE_MNG		                0	/* management type */
+#define FC_TYPE_CTL		                1	/* control type */
+#define FC_TYPE_DATA		            2	/* data type */
+
+/* Management Subtypes */
+#define FC_SUBTYPE_ASSOC_REQ		    0	/* assoc. request */
+#define FC_SUBTYPE_ASSOC_RESP		    1	/* assoc. response */
+#define FC_SUBTYPE_REASSOC_REQ		    2	/* reassoc. request */
+#define FC_SUBTYPE_REASSOC_RESP		    3	/* reassoc. response */
+#define FC_SUBTYPE_PROBE_REQ		    4	/* probe request */
+#define FC_SUBTYPE_PROBE_RESP		    5	/* probe response */
+#define FC_SUBTYPE_BEACON		        8	/* beacon */
+#define FC_SUBTYPE_ATIM			        9	/* ATIM */
+#define FC_SUBTYPE_DISASSOC		        10	/* disassoc. */
+#define FC_SUBTYPE_AUTH			        11	/* authentication */
+#define FC_SUBTYPE_DEAUTH		        12	/* de-authentication */
+#define FC_SUBTYPE_ACTION		        13	/* action */
+#define FC_SUBTYPE_ACTION_NOACK		    14	/* action no-ack */
+
+/* Control Subtypes */
+#define FC_SUBTYPE_CTL_WRAPPER		    7	/* Control Wrapper */
+#define FC_SUBTYPE_BLOCKACK_REQ		    8	/* Block Ack Req */
+#define FC_SUBTYPE_BLOCKACK		        9	/* Block Ack */
+#define FC_SUBTYPE_PS_POLL		        10	/* PS poll */
+#define FC_SUBTYPE_RTS			        11	/* RTS */
+#define FC_SUBTYPE_CTS			        12	/* CTS */
+#define FC_SUBTYPE_ACK			        13	/* ACK */
+#define FC_SUBTYPE_CF_END		        14	/* CF-END */
+#define FC_SUBTYPE_CF_END_ACK		    15	/* CF-END ACK */
+
+/* Data Subtypes */
+#define FC_SUBTYPE_DATA			        0	/* Data */
+#define FC_SUBTYPE_DATA_CF_ACK		    1	/* Data + CF-ACK */
+#define FC_SUBTYPE_DATA_CF_POLL		    2	/* Data + CF-Poll */
+#define FC_SUBTYPE_DATA_CF_ACK_POLL	    3	/* Data + CF-Ack + CF-Poll */
+#define FC_SUBTYPE_NULL			        4	/* Null */
+#define FC_SUBTYPE_CF_ACK		        5	/* CF-Ack */
+#define FC_SUBTYPE_CF_POLL		        6	/* CF-Poll */
+#define FC_SUBTYPE_CF_ACK_POLL		    7	/* CF-Ack + CF-Poll */
+#define FC_SUBTYPE_QOS_DATA		        8	/* QoS Data */
+#define FC_SUBTYPE_QOS_DATA_CF_ACK	    9	/* QoS Data + CF-Ack */
+#define FC_SUBTYPE_QOS_DATA_CF_POLL	    10	/* QoS Data + CF-Poll */
+#define FC_SUBTYPE_QOS_DATA_CF_ACK_POLL	11	/* QoS Data + CF-Ack + CF-Poll */
+#define FC_SUBTYPE_QOS_NULL		        12	/* QoS Null */
+#define FC_SUBTYPE_QOS_CF_POLL		    14	/* QoS CF-Poll */
+#define FC_SUBTYPE_QOS_CF_ACK_POLL	    15	/* QoS CF-Ack + CF-Poll */
+
+/* Data Subtype Groups */
+#define FC_SUBTYPE_ANY_QOS(s)		    (((s) & 8) != 0)
+#define FC_SUBTYPE_ANY_NULL(s)		    (((s) & 4) != 0)
+#define FC_SUBTYPE_ANY_CF_POLL(s)	    (((s) & 2) != 0)
+#define FC_SUBTYPE_ANY_CF_ACK(s)	    (((s) & 1) != 0)
+
+/* Type/Subtype Combos */
+#define FC_KIND_MASK		            (FC_TYPE_MASK | FC_SUBTYPE_MASK)	/* FC kind mask */
+
+#define FC_KIND(t, s)	                (((t) << FC_TYPE_SHIFT) | ((s) << FC_SUBTYPE_SHIFT))	/* FC kind */
+
+#define FC_SUBTYPE(fc)	                (((fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT)	/* Subtype from FC */
+#define FC_TYPE(fc)	                    (((fc) & FC_TYPE_MASK) >> FC_TYPE_SHIFT)	/* Type from FC */
+
+#define FC_ASSOC_REQ	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)	    /* assoc. request */
+#define FC_ASSOC_RESP	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)	    /* assoc. response */
+#define FC_REASSOC_REQ	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)	/* reassoc. request */
+#define FC_REASSOC_RESP	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)	/* reassoc. response */
+#define FC_PROBE_REQ	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)	    /* probe request */
+#define FC_PROBE_RESP	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)	    /* probe response */
+#define FC_BEACON	                    FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)		    /* beacon */
+#define FC_DISASSOC	                    FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)	    /* disassoc */
+#define FC_AUTH		                    FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)		    /* authentication */
+#define FC_DEAUTH	                    FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)		    /* deauthentication */
+#define FC_ACTION	                    FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)		    /* action */
+#define FC_ACTION_NOACK	                FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION_NOACK)	/* action no-ack */
+
+#define FC_CTL_WRAPPER	                FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTL_WRAPPER)	/* Control Wrapper */
+#define FC_BLOCKACK_REQ	                FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK_REQ)	/* Block Ack Req */
+#define FC_BLOCKACK	                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK)	    /* Block Ack */
+#define FC_PS_POLL	                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)	    /* PS poll */
+#define FC_RTS		                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)		    /* RTS */
+#define FC_CTS		                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)		    /* CTS */
+#define FC_ACK		                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)		    /* ACK */
+#define FC_CF_END	                    FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)		    /* CF-END */
+#define FC_CF_END_ACK	                FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)	    /* CF-END ACK */
+
+#define FC_DATA		                    FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)		    /* data */
+#define FC_NULL_DATA	                FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)		    /* null data */
+#define FC_DATA_CF_ACK	                FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)	/* data CF ACK */
+#define FC_QOS_DATA	                    FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)	    /* QoS data */
+#define FC_QOS_NULL	                    FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)	    /* QoS null */
+
+/* QoS Control Field */
+
+/* 802.1D Priority */
+#define QOS_PRIO_SHIFT		            0	/* QoS priority shift */
+#define QOS_PRIO_MASK		            0x0007	/* QoS priority mask */
+#define QOS_PRIO(qos)		            (((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)	/* QoS priority */
+
+/* Traffic Identifier */
+#define QOS_TID_SHIFT		            0	/* QoS TID shift */
+#define QOS_TID_MASK		            0x000f	/* QoS TID mask */
+#define QOS_TID(qos)		            (((qos) & QOS_TID_MASK) >> QOS_TID_SHIFT)	/* QoS TID */
+
+/* End of Service Period (U-APSD) */
+#define QOS_EOSP_SHIFT		            4	/* QoS End of Service Period shift */
+#define QOS_EOSP_MASK		            0x0010	/* QoS End of Service Period mask */
+#define QOS_EOSP(qos)		            (((qos) & QOS_EOSP_MASK) >> QOS_EOSP_SHIFT)	/* Qos EOSP */
+
+/* Ack Policy */
+#define QOS_ACK_NORMAL_ACK	            0	/* Normal Ack */
+#define QOS_ACK_NO_ACK		            1	/* No Ack (eg mcast) */
+#define QOS_ACK_NO_EXP_ACK	            2	/* No Explicit Ack */
+#define QOS_ACK_BLOCK_ACK	            3	/* Block Ack */
+#define QOS_ACK_SHIFT		            5	/* QoS ACK shift */
+#define QOS_ACK_MASK		            0x0060	/* QoS ACK mask */
+#define QOS_ACK(qos)		            (((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)	/* QoS ACK */
+
+/* A-MSDU flag */
+#define QOS_AMSDU_SHIFT		            7	/* AMSDU shift */
+#define QOS_AMSDU_MASK		            0x0080	/* AMSDU mask */
+
+/* Management Frames */
+
+/* Management Frame Constants */
+
+/* Fixed fields */
+#define DOT11_MNG_AUTH_ALGO_LEN		    2	/* d11 management auth. algo. length */
+#define DOT11_MNG_AUTH_SEQ_LEN		    2	/* d11 management auth. seq. length */
+#define DOT11_MNG_BEACON_INT_LEN	    2	/* d11 management beacon interval length */
+#define DOT11_MNG_CAP_LEN		        2	/* d11 management cap. length */
+#define DOT11_MNG_AP_ADDR_LEN		    6	/* d11 management AP address length */
+#define DOT11_MNG_LISTEN_INT_LEN	    2	/* d11 management listen interval length */
+#define DOT11_MNG_REASON_LEN		    2	/* d11 management reason length */
+#define DOT11_MNG_AID_LEN		        2	/* d11 management AID length */
+#define DOT11_MNG_STATUS_LEN		    2	/* d11 management status length */
+#define DOT11_MNG_TIMESTAMP_LEN		    8	/* d11 management timestamp length */
+
+/* DUR/ID field in assoc resp is 0xc000 | AID */
+#define DOT11_AID_MASK			        0x3fff	/* d11 AID mask */
+
+/* Reason Codes */
+#define DOT11_RC_RESERVED		        0	/* d11 RC reserved */
+#define DOT11_RC_UNSPECIFIED		    1	/* Unspecified reason */
+#define DOT11_RC_AUTH_INVAL		        2	/* Previous authentication no longer valid */
+#define DOT11_RC_DEAUTH_LEAVING		    3	/* Deauthenticated because sending station is leaving (or has left) IBSS or ESS */
+#define DOT11_RC_INACTIVITY		        4	/* Disassociated due to inactivity */
+#define DOT11_RC_BUSY			        5	/* Disassociated because AP is unable to handle all currently associated stations */
+#define DOT11_RC_INVAL_CLASS_2		    6	/* Class 2 frame received from nonauthenticated station */
+#define DOT11_RC_INVAL_CLASS_3		    7	/* Class 3 frame received from nonassociated station */
+#define DOT11_RC_DISASSOC_LEAVING	    8	/* Disassociated because sending station is leaving (or has left) BSS */
+#define DOT11_RC_NOT_AUTH		        9	/* Station requesting (re)association is not authenticated with responding station */
+#define DOT11_RC_BAD_PC			        10	/* Unacceptable power capability element */
+#define DOT11_RC_BAD_CHANNELS		    11	/* Unacceptable supported channels element */
+/* 12 is unused */
+
+/* 32-39 are QSTA specific reasons added in 11e */
+#define DOT11_RC_UNSPECIFIED_QOS	    32	/* unspecified QoS-related reason */
+#define DOT11_RC_INSUFFCIENT_BW		    33	/* QAP lacks sufficient bandwidth */
+#define DOT11_RC_EXCESSIVE_FRAMES	    34	/* excessive number of frames need ack */
+#define DOT11_RC_TX_OUTSIDE_TXOP	    35	/* transmitting outside the limits of txop */
+#define DOT11_RC_LEAVING_QBSS		    36	/* QSTA is leaving the QBSS (or restting) */
+#define DOT11_RC_BAD_MECHANISM		    37	/* does not want to use the mechanism */
+#define DOT11_RC_SETUP_NEEDED		    38	/* mechanism needs a setup */
+#define DOT11_RC_TIMEOUT		        39	/* timeout */
+
+#define DOT11_RC_MAX			        23	/* Reason codes > 23 are reserved */
+
+#define DOT11_RC_TDLS_PEER_UNREACH	    25
+#define DOT11_RC_TDLS_DOWN_UNSPECIFIED	26
+
+/* Status Codes */
+#define DOT11_SC_SUCCESS		        0	/* Successful */
+#define DOT11_SC_FAILURE		        1	/* Unspecified failure */
+#define DOT11_SC_TDLS_WAKEUP_SCH_ALT    2	/* TDLS wakeup schedule rejected but alternative */
+#define DOT11_SC_TDLS_WAKEUP_SCH_REJ    3	/* TDLS wakeup schedule rejected */
+#define DOT11_SC_TDLS_SEC_DISABLED	    5	/* TDLS Security disabled */
+#define DOT11_SC_LIFETIME_REJ		    6	/* Unacceptable lifetime */
+#define DOT11_SC_NOT_SAME_BSS		    7	/* Not in same BSS */
+#define DOT11_SC_CAP_MISMATCH		    10	/* Cannot support all requested capabilities in the Capability Information field*/
+#define DOT11_SC_REASSOC_FAIL		    11	/* Reassociation denied due to inability to confirm that association exists */
+#define DOT11_SC_ASSOC_FAIL		        12	/* Association denied due to reason outside the scope of this standard */
+#define DOT11_SC_AUTH_MISMATCH		    13	/* Responding station does not support the specified authentication algorithm */
+#define DOT11_SC_AUTH_SEQ		        14	/* Received an Authentication frame
+                    						 * with authentication transaction
+                    						 * sequence number out of expected
+                    						 * sequence
+                    						 */
+#define DOT11_SC_AUTH_CHALLENGE_FAIL	15	/* Authentication rejected because of challenge failure */
+#define DOT11_SC_AUTH_TIMEOUT		    16	/* Authentication rejected due to timeout waiting for next frame in sequence */
+#define DOT11_SC_ASSOC_BUSY_FAIL	    17	/* Association denied because AP is unable to handle additional associated stations */
+#define DOT11_SC_ASSOC_RATE_MISMATCH	18	/* Association denied due to requesting
+                    						 * station not supporting all of the data rates in the BSSBasicRateSet parameter
+                    						 */
+#define DOT11_SC_ASSOC_SHORT_REQUIRED	19	/* Association denied due to requesting station not supporting the Short Preamble option */
+#define DOT11_SC_ASSOC_PBCC_REQUIRED	20	/* Association denied due to requesting station not supporting the PBCC Modulation option */
+#define DOT11_SC_ASSOC_AGILITY_REQUIRED	21	/* Association denied due to requesting station not supporting the Channel Agility option */
+#define DOT11_SC_ASSOC_SPECTRUM_REQUIRED	22	/* Association denied because Spectrum Management capability is required. */
+#define DOT11_SC_ASSOC_BAD_POWER_CAP	23	/* Association denied because the info in the Power Cap element is unacceptable. */
+#define DOT11_SC_ASSOC_BAD_SUP_CHANNELS	24	/* Association denied because the info in the Supported Channel element is unacceptable */
+#define DOT11_SC_ASSOC_SHORTSLOT_REQUIRED	25	/* Association denied due to requesting station not supporting the Short Slot Time option */
+#define DOT11_SC_ASSOC_ERPBCC_REQUIRED	26	/* Association denied due to requesting station not supporting the ER-PBCC Modulation option
+						 */
+#define DOT11_SC_ASSOC_DSSOFDM_REQUIRED	27	/* Association denied due to requesting station not supporting the DSS-OFDM option */
+#define DOT11_SC_ASSOC_R0KH_UNREACHABLE	28	/* Association denied due to AP being unable to reach the R0 Key Holder	 */
+#define DOT11_SC_ASSOC_TRY_LATER	    30	/* Association denied temporarily, try again later
+						 */
+#define DOT11_SC_ASSOC_MFP_VIOLATION	31	/* Association denied due to Robust Management frame policy violation */
+
+#define	DOT11_SC_DECLINED		        37	/* request declined */
+#define	DOT11_SC_INVALID_PARAMS		    38	/* One or more params have invalid values */
+#define DOT11_SC_INVALID_PAIRWISE_CIPHER	42 /* invalid pairwise cipher */
+#define	DOT11_SC_INVALID_AKMP		    43	/* Association denied due to invalid AKMP */
+#define DOT11_SC_INVALID_RSNIE_CAP	    45	/* invalid RSN IE capabilities */
+#define DOT11_SC_DLS_NOT_ALLOWED	    48	/* DLS is not allowed in the BSS by policy */
+#define	DOT11_SC_INVALID_PMKID		    53	/* Association denied due to invalid PMKID */
+#define	DOT11_SC_INVALID_MDID		    54	/* Association denied due to invalid MDID */
+#define	DOT11_SC_INVALID_FTIE		    55	/* Association denied due to invalid FTIE */
+
+#define DOT11_SC_UNEXP_MSG			    70	/* Unexpected message */
+#define DOT11_SC_INVALID_SNONCE		    71	/* Invalid SNonce */
+#define DOT11_SC_INVALID_RSNIE		    72	/* Invalid contents of RSNIE */
+
+/* Info Elts, length of INFORMATION portion of Info Elts */
+#define DOT11_MNG_DS_PARAM_LEN			1	/* d11 management DS parameter length */
+#define DOT11_MNG_IBSS_PARAM_LEN		2	/* d11 management IBSS parameter length */
+
+/* TIM Info element has 3 bytes fixed info in INFORMATION field,
+ * followed by 1 to 251 bytes of Partial Virtual Bitmap
+ */
+#define DOT11_MNG_TIM_FIXED_LEN			3	/* d11 management TIM fixed length */
+#define DOT11_MNG_TIM_DTIM_COUNT		0	/* d11 management DTIM count */
+#define DOT11_MNG_TIM_DTIM_PERIOD		1	/* d11 management DTIM period */
+#define DOT11_MNG_TIM_BITMAP_CTL		2	/* d11 management TIM BITMAP control  */
+#define DOT11_MNG_TIM_PVB			    3	/* d11 management TIM PVB */
+
+/* TLV defines */
+#define TLV_TAG_OFF		                0	/* tag offset */
+#define TLV_LEN_OFF		                1	/* length offset */
+#define TLV_HDR_LEN		                2	/* header length */
+#define TLV_BODY_OFF		            2	/* body offset */
+
+/* Management Frame Information Element IDs */
+#define DOT11_MNG_SSID_ID			    0	/* d11 management SSID id */
+#define DOT11_MNG_RATES_ID			    1	/* d11 management rates id */
+#define DOT11_MNG_FH_PARMS_ID			2	/* d11 management FH parameter id */
+#define DOT11_MNG_DS_PARMS_ID			3	/* d11 management DS parameter id */
+#define DOT11_MNG_CF_PARMS_ID			4	/* d11 management CF parameter id */
+#define DOT11_MNG_TIM_ID			    5	/* d11 management TIM id */
+#define DOT11_MNG_IBSS_PARMS_ID			6	/* d11 management IBSS parameter id */
+#define DOT11_MNG_COUNTRY_ID			7	/* d11 management country id */
+#define DOT11_MNG_HOPPING_PARMS_ID		8	/* d11 management hopping parameter id */
+#define DOT11_MNG_HOPPING_TABLE_ID		9	/* d11 management hopping table id */
+#define DOT11_MNG_REQUEST_ID			10	/* d11 management request id */
+#define DOT11_MNG_QBSS_LOAD_ID 			11	/* d11 management QBSS Load id */
+#define DOT11_MNG_EDCA_PARAM_ID			12	/* 11E EDCA Parameter id */
+#define DOT11_MNG_CHALLENGE_ID			16	/* d11 management chanllenge id */
+#define DOT11_MNG_PWR_CONSTRAINT_ID		32	/* 11H PowerConstraint */
+#define DOT11_MNG_PWR_CAP_ID			33	/* 11H PowerCapability */
+#define DOT11_MNG_TPC_REQUEST_ID 		34	/* 11H TPC Request */
+#define DOT11_MNG_TPC_REPORT_ID			35	/* 11H TPC Report */
+#define DOT11_MNG_SUPP_CHANNELS_ID		36	/* 11H Supported Channels */
+#define DOT11_MNG_CHANNEL_SWITCH_ID		37	/* 11H ChannelSwitch Announcement */
+#define DOT11_MNG_MEASURE_REQUEST_ID	38	/* 11H MeasurementRequest */
+#define DOT11_MNG_MEASURE_REPORT_ID		39	/* 11H MeasurementReport */
+#define DOT11_MNG_QUIET_ID			    40	/* 11H Quiet */
+#define DOT11_MNG_IBSS_DFS_ID			41	/* 11H IBSS_DFS */
+#define DOT11_MNG_ERP_ID			    42	/* d11 management ERP id */
+#define DOT11_MNG_TS_DELAY_ID			43	/* d11 management TS Delay id */
+#define	DOT11_MNG_HT_CAP			    45	/* d11 mgmt HT cap id */
+#define DOT11_MNG_QOS_CAP_ID			46	/* 11E QoS Capability id */
+#define DOT11_MNG_NONERP_ID			    47	/* d11 management NON-ERP id */
+#define DOT11_MNG_RSN_ID			    48	/* d11 management RSN id */
+#define DOT11_MNG_EXT_RATES_ID			50	/* d11 management ext. rates id */
+#define DOT11_MNG_AP_CHREP_ID		    51	/* 11k AP Channel report id */
+#define DOT11_MNG_NBR_REP_ID		    52	/* 11k Neighbor report id */
+#define DOT11_MNG_MDIE_ID		        54	/* 11r Mobility domain id */
+#define DOT11_MNG_FTIE_ID		        55	/* 11r Fast Bss Transition id */
+#define DOT11_MNG_FT_TI_ID		        56	/* 11r Timeout Interval id */
+#define	DOT11_MNG_REGCLASS_ID			59	/* d11 management regulatory class id */
+#define DOT11_MNG_EXT_CSA_ID			60	/* d11 Extended CSA */
+#define	DOT11_MNG_HT_ADD			    61	/* d11 mgmt additional HT info */
+#define	DOT11_MNG_EXT_CHANNEL_OFFSET	62	/* d11 mgmt ext channel offset */
+#ifdef BCMWAPI_WAI
+#define DOT11_MNG_WAPI_ID               68  /* d11 management WAPI id */
+#endif
+#define DOT11_MNG_WAPI_ID			    68	/* d11 management WAPI id */
+#define DOT11_MNG_TIME_ADVERTISE_ID	    69	/* 11p time advertisement */
+#define DOT11_MNG_RRM_CAP_ID		    70	/* 11k radio measurement capability */
+#define	DOT11_MNG_HT_BSS_COEXINFO_ID		72	/* d11 mgmt OBSS Coexistence INFO */
+#define	DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID	73	/* d11 mgmt OBSS Intolerant Channel list */
+#define	DOT11_MNG_HT_OBSS_ID			74	/* d11 mgmt OBSS HT info */
+#define DOT11_MNG_CHANNEL_USAGE			97 /* 11v channel usage */
+#define DOT11_MNG_TIME_ZONE_ID			98	/* 11v time zone */
+#define DOT11_MNG_LINK_IDENTIFIER_ID	101	/* 11z TDLS Link Identifier IE */
+#define DOT11_MNG_WAKEUP_SCHEDULE_ID	102 /* 11z TDLS Wakeup Schedule IE */
+#define DOT11_MNG_CHANNEL_SWITCH_TIMING_ID	104 /* 11z TDLS Channel Switch Timing IE */
+#define DOT11_MNG_PTI_CONTROL_ID		105	/* 11z TDLS PTI Control IE */
+#define DOT11_MNG_PU_BUFFER_STATUS_ID	106	/* 11z TDLS PU Buffer Status IE */
+#define DOT11_MNG_INTERWORKING_ID		107	/* 11u interworking */
+#define DOT11_MNG_ADVERTISEMENT_ID		108	/* 11u advertisement protocol */
+#define DOT11_MNG_EXP_BW_REQ_ID			109	/* 11u expedited bandwith request */
+#define DOT11_MNG_QOS_MAP_ID			110	/* 11u QoS map set */
+#define DOT11_MNG_ROAM_CONSORT_ID		111	/* 11u roaming consortium */
+#define DOT11_MNG_EMERGCY_ALERT_ID		112	/* 11u emergency alert identifier */
+#define	DOT11_MNG_EXT_CAP_ID		    127	/* d11 mgmt ext capability */
+#define	DOT11_MNG_VHT_CAP_ID		    191	/* d11 mgmt VHT cap id */
+#define	DOT11_MNG_VHT_OPERATION_ID	    192	/* d11 mgmt VHT op id */
+
+#define DOT11_MNG_WPA_ID			    221	/* d11 management WPA id */
+#define DOT11_MNG_PROPR_ID			    221	/* d11 management proprietary id */
+/* should start using this one instead of above two */
+#define DOT11_MNG_VS_ID				    221	/* d11 management Vendor Specific IE */
+
+/* Rate element Basic flag and rate mask */
+#define DOT11_RATE_BASIC			    0x80	/* flag for a Basic Rate */
+#define DOT11_RATE_MASK				    0x7F	/* mask for numeric part of rate */
+
+/* ERP info element bit values */
+#define DOT11_MNG_ERP_LEN			    1	    /* ERP is currently 1 byte long */
+#define DOT11_MNG_NONERP_PRESENT		0x01	/* NonERP (802.11b) STAs are present in the BSS */
+#define DOT11_MNG_USE_PROTECTION		0x02	/* Use protection mechanisms for ERP-OFDM frames */
+#define DOT11_MNG_BARKER_PREAMBLE		0x04	/* Short Preambles: 0 == allowed, 1 == not allowed */
+/* TS Delay element offset & size */
+#define DOT11_MGN_TS_DELAY_LEN		    4	/* length of TS DELAY IE */
+#define TS_DELAY_FIELD_SIZE			    4	/* TS DELAY field size */
+
+/* Capability Information Field */
+#define DOT11_CAP_ESS				    0x0001	/* d11 cap. ESS */
+#define DOT11_CAP_IBSS				    0x0002	/* d11 cap. IBSS */
+#define DOT11_CAP_POLLABLE			    0x0004	/* d11 cap. pollable */
+#define DOT11_CAP_POLL_RQ			    0x0008	/* d11 cap. poll request */
+#define DOT11_CAP_PRIVACY			    0x0010	/* d11 cap. privacy */
+#define DOT11_CAP_SHORT				    0x0020	/* d11 cap. short */
+#define DOT11_CAP_PBCC				    0x0040	/* d11 cap. PBCC */
+#define DOT11_CAP_AGILITY			    0x0080	/* d11 cap. agility */
+#define DOT11_CAP_SPECTRUM			    0x0100	/* d11 cap. spectrum */
+#define DOT11_CAP_SHORTSLOT			    0x0400	/* d11 cap. shortslot */
+#define DOT11_CAP_RRM			        0x1000	/* d11 cap. 11k radio measurement */
+#define DOT11_CAP_CCK_OFDM			    0x2000	/* d11 cap. CCK/OFDM */
+
+/* Extended capabilities IE bitfields */
+/* 20/40 BSS Coexistence Management support bit position */
+#define DOT11_EXT_CAP_OBSS_COEX_MGMT		0
+/* scheduled PSMP support bit position */
+#define DOT11_EXT_CAP_SPSMP					6
+/* BSS Transition Management support bit position */
+#define DOT11_EXT_CAP_BSS_TRANSITION_MGMT	19
+/* Interworking support bit position */
+#define DOT11_EXT_CAP_IW					31
+/* service Interval granularity bit position and mask */
+#define DOT11_EXT_CAP_SI					41
+#define DOT11_EXT_CAP_SI_MASK				0x0E
+
+/*
+ * Action Frame Constants
+ */
+#define DOT11_ACTION_HDR_LEN		        2	/* action frame category + action field */
+#define DOT11_ACTION_CAT_OFF		        0	/* category offset */
+#define DOT11_ACTION_ACT_OFF		        1	/* action offset */
+
+/* Action Category field (sec 7.3.1.11) */
+#define DOT11_ACTION_CAT_ERR_MASK	        0x80	/* category error mask */
+#define DOT11_ACTION_CAT_MASK		        0x7F	/* category mask */
+#define DOT11_ACTION_CAT_SPECT_MNG	        0	/* category spectrum management */
+#define DOT11_ACTION_CAT_QOS		        1	/* category QoS */
+#define DOT11_ACTION_CAT_DLS		        2	/* category DLS */
+#define DOT11_ACTION_CAT_BLOCKACK	        3	/* category block ack */
+#define DOT11_ACTION_CAT_PUBLIC		        4	/* category public */
+#define DOT11_ACTION_CAT_RRM		        5	/* category radio measurements */
+#define DOT11_ACTION_CAT_FBT	            6	/* category fast bss transition */
+#define DOT11_ACTION_CAT_HT		            7	/* category for HT */
+#define	DOT11_ACTION_CAT_SA_QUERY	        8	/* security association query */
+#define	DOT11_ACTION_CAT_PDPA		        9	/* protected dual of public action */
+#define DOT11_ACTION_CAT_BSSMGMT	        10	/* category for BSS transition management */
+#define DOT11_ACTION_NOTIFICATION	        17
+#define DOT11_ACTION_CAT_VSP		        126	/* protected vendor specific */
+#define DOT11_ACTION_CAT_VS		            127	/* category Vendor Specific */
+
+/* Spectrum Management Action IDs (sec 7.4.1) */
+#define DOT11_SM_ACTION_M_REQ		        0	/* d11 action measurement request */
+#define DOT11_SM_ACTION_M_REP		        1	/* d11 action measurement response */
+#define DOT11_SM_ACTION_TPC_REQ		        2	/* d11 action TPC request */
+#define DOT11_SM_ACTION_TPC_REP		        3	/* d11 action TPC response */
+#define DOT11_SM_ACTION_CHANNEL_SWITCH	    4	/* d11 action channel switch */
+#define DOT11_SM_ACTION_EXT_CSA		        5	/* d11 extened CSA for 11n */
+
+/* HT action ids */
+#define DOT11_ACTION_ID_HT_CH_WIDTH	        0	/* notify channel width action id */
+#define DOT11_ACTION_ID_HT_MIMO_PS	        1	/* mimo ps action id */
+
+/* Public action ids */
+#define DOT11_PUB_ACTION_BSS_COEX_MNG	    0	/* 20/40 Coexistence Management action id */
+#define DOT11_PUB_ACTION_CHANNEL_SWITCH	    4	/* d11 action channel switch */
+
+/* Block Ack action types */
+#define DOT11_BA_ACTION_ADDBA_REQ	        0	/* ADDBA Req action frame type */
+#define DOT11_BA_ACTION_ADDBA_RESP	        1	/* ADDBA Resp action frame type */
+#define DOT11_BA_ACTION_DELBA		        2	/* DELBA action frame type */
+
+/* ADDBA action parameters */
+#define DOT11_ADDBA_PARAM_AMSDU_SUP	        0x0001	/* AMSDU supported under BA */
+#define DOT11_ADDBA_PARAM_POLICY_MASK	    0x0002	/* policy mask(ack vs delayed) */
+#define DOT11_ADDBA_PARAM_POLICY_SHIFT	    1	    /* policy shift */
+#define DOT11_ADDBA_PARAM_TID_MASK	        0x003C	/* tid mask */
+#define DOT11_ADDBA_PARAM_TID_SHIFT	        2	    /* tid shift */
+#define DOT11_ADDBA_PARAM_BSIZE_MASK	    0xFFC0	/* buffer size mask */
+#define DOT11_ADDBA_PARAM_BSIZE_SHIFT	    6	/* buffer size shift */
+
+#define DOT11_ADDBA_POLICY_DELAYED	        0	/* delayed BA policy */
+#define DOT11_ADDBA_POLICY_IMMEDIATE	    1	/* immediate BA policy */
+
+/* Fast Transition action types */
+#define DOT11_FT_ACTION_FT_RESERVED		    0
+#define DOT11_FT_ACTION_FT_REQ			    1	/* FBT request - for over-the-DS FBT */
+#define DOT11_FT_ACTION_FT_RES			    2	/* FBT response - for over-the-DS FBT */
+#define DOT11_FT_ACTION_FT_CON			    3	/* FBT confirm - for OTDS with RRP */
+#define DOT11_FT_ACTION_FT_ACK			    4	/* FBT ack */
+
+/* DLS action types */
+#define DOT11_DLS_ACTION_REQ				0	/* DLS Request */
+#define DOT11_DLS_ACTION_RESP				1	/* DLS Response */
+#define DOT11_DLS_ACTION_TD				    2	/* DLS Teardown */
+
+/* Wireless Network Management (WNM) action types */
+#define DOT11_WNM_ACTION_EVENT_REQ			0
+#define DOT11_WNM_ACTION_EVENT_REP			1
+#define DOT11_WNM_ACTION_DIAG_REQ			2
+#define DOT11_WNM_ACTION_DIAG_REP			3
+#define DOT11_WNM_ACTION_LOC_CFG_REQ		4
+#define DOT11_WNM_ACTION_LOC_RFG_RESP		5
+#define DOT11_WNM_ACTION_BSS_TRANS_QURY		6
+#define DOT11_WNM_ACTION_BSS_TRANS_REQ		7
+#define DOT11_WNM_ACTION_BSS_TRANS_RESP		8
+#define DOT11_WNM_ACTION_FMS_REQ			9
+#define DOT11_WNM_ACTION_FMS_RESP			10
+#define DOT11_WNM_ACTION_COL_INTRFRNCE_REQ	11
+#define DOT11_WNM_ACTION_COL_INTRFRNCE_REP	12
+#define DOT11_WNM_ACTION_TFS_REQ			13
+#define DOT11_WNM_ACTION_TFS_RESP			14
+#define DOT11_WNM_ACTION_TFS_NOTIFY			15
+#define DOT11_WNM_ACTION_WNM_SLEEP_REQ		16
+#define DOT11_WNM_ACTION_WNM_SLEEP_RESP		17
+#define DOT11_WNM_ACTION_TIM_BCAST_REQ		18
+#define DOT11_WNM_ACTION_TIM_BCAST_RESP		19
+#define DOT11_WNM_ACTION_QOS_TRFC_CAP_UPD	20
+#define DOT11_WNM_ACTION_CHAN_USAGE_REQ		21
+#define DOT11_WNM_ACTION_CHAN_USAGE_RESP	22
+#define DOT11_WNM_ACTION_DMS_REQ			23
+#define DOT11_WNM_ACTION_DMS_RESP			24
+#define DOT11_WNM_ACTION_TMNG_MEASUR_REQ	25
+#define DOT11_WNM_ACTION_NOTFCTN_REQ		26
+#define DOT11_WNM_ACTION_NOTFCTN_RES		27
+
+#define DOT11_MNG_COUNTRY_ID_LEN            3
+
+/* DLS Request frame header */
+PRE_PACKED struct dot11_dls_req {
+	u8 category;			/* category of action frame (2) */
+	u8 action;				/* DLS action: req (0) */
+	struct ether_addr	da;		/* destination address */
+	struct ether_addr	sa;		/* source address */
+	u16 cap;				/* capability */
+	u16 timeout;			/* timeout value */
+	u8 data[1];				/* IE:support rate, extend support rate, HT cap */
+} POST_PACKED;
+
+#define DOT11_DLS_REQ_LEN                   18	/* Fixed length */
+
+/* DLS response frame header */
+PRE_PACKED struct dot11_dls_resp {
+	u8                  category;/* category of action frame (2) */
+	u8                  action;	 /* DLS action: req (0) */
+	u16                 status;	 /* status code field */
+	struct ether_addr	da;		 /* destination address */
+	struct ether_addr	sa;		 /* source address */
+	u8 data[1];				     /* optional: capability, rate ... */
+} POST_PACKED;
+
+#define DOT11_DLS_RESP_LEN                  16	/* Fixed length */
+
+
+/* BSS Management Transition Query frame header */
+PRE_PACKED struct dot11_bss_trans_query {
+	u8                  category;/* category of action frame (10) */
+	u8                  action;	 /* WNM action: trans_query (6) */
+	u8                  token;	 /* dialog token */
+	u8                  reason;	 /* transition query reason */
+	u8                  data[1]; /* Elements */
+} POST_PACKED;
+
+#define DOT11_BSS_TRANS_QUERY_LEN           4	/* Fixed length */
+
+/* BSS Management Transition Request frame header */
+PRE_PACKED struct dot11_bss_trans_req {
+	u8                  category;		/* category of action frame (10) */
+	u8                  action;			/* WNM action: trans_req (7) */
+	u8                  token;			/* dialog token */
+	u8                  reqmode;		/* transition request mode */
+	u16                 disassoc_tmr;	/* disassociation timer */
+	u8                  validity_intrvl;/* validity interval */
+	u8                  data[1];		/* optional: BSS term duration, ... */
+								/* ...session info URL, list */
+} POST_PACKED;
+
+#define DOT11_BSS_TRANS_REQ_LEN             7	/* Fixed length */
+
+#define DOT11_BSS_TERM_DUR_LEN              12	/* Fixed length if present */
+
+
+/* BSS Mgmt Transition Request Mode Field - 802.11v */
+#define DOT11_BSS_TRNS_REQMODE_PREF_LIST_INCL		0x01
+#define DOT11_BSS_TRNS_REQMODE_ABRIDGED				0x02
+#define DOT11_BSS_TRNS_REQMODE_DISASSOC_IMMINENT	0x04
+#define DOT11_BSS_TRNS_REQMODE_BSS_TERM_INCL		0x08
+#define DOT11_BSS_TRNS_REQMODE_ESS_DISASSOC_IMNT	0x10
+
+
+/* BSS Management transition response frame header */
+PRE_PACKED struct dot11_bss_trans_res {
+	u8 category;			/* category of action frame (10) */
+	u8 action;				/* WNM action: trans_res (8) */
+	u8 token;				/* dialog token */
+	u8 status;				/* transition status */
+	u8 term_delay;			/* validity interval */
+	u8 data[1];				/* optional: BSS term duration, ... */
+							/* ...session info URL, list */
+} POST_PACKED;
+
+#define DOT11_BSS_TRANS_RES_LEN                         5	/* Fixed length */
+
+/* BSS Mgmt Transition Response Status Field */
+#define DOT11_BSS_TRNS_RES_STATUS_ACCEPT				0
+#define DOT11_BSS_TRNS_RES_STATUS_REJECT				1
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_INSUFF_BCN		2
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_INSUFF_CAP		3
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_TERM_UNDESIRED	4
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_TERM_DELAY_REQ	5
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_BSS_LIST_PROVIDED	6
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_NO_SUITABLE_BSS	7
+#define DOT11_BSS_TRNS_RES_STATUS_REJ_LEAVING_ESS		8
+
+
+/* Neighbor Report BSSID Information Field */
+#define DOT11_NBR_RPRT_BSSID_INFO_REACHABILTY		    0x0003
+#define DOT11_NBR_RPRT_BSSID_INFO_SEC				    0x0004
+#define DOT11_NBR_RPRT_BSSID_INFO_KEY_SCOPE			    0x0008
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP				    0x03f0
+
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_SPEC_MGMT		    0x0010
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_QOS			    0x0020
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_APSD			    0x0040
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_RDIO_MSMT		    0x0080
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_DEL_BA		    0x0100
+#define DOT11_NBR_RPRT_BSSID_INFO_CAP_IMM_BA		    0x0200
+
+/* Neighbor Report Subelements */
+#define DOT11_NBR_RPRT_SUBELEM_BSS_CANDDT_PREF_ID	3
+
+
+PRE_PACKED struct dot11_addba_req {
+	u8  category;				/* category of action frame (3) */
+	u8  action;				    /* action: addba req */
+	u8  token;				    /* identifier */
+	u16 addba_param_set;		/* parameter set */
+	u16 timeout;				/* timeout in seconds */
+	u16 start_seqnum;		    /* starting sequence number */
+} POST_PACKED;
+
+#define DOT11_ADDBA_REQ_LEN		        9	/* length of addba req frame */
+
+PRE_PACKED struct dot11_addba_resp {
+	u8  category;				/* category of action frame (3) */
+	u8  action;				    /* action: addba resp */
+	u8  token;				    /* identifier */
+	u16 status;				    /* status of add request */
+	u16 addba_param_set;		/* negotiated parameter set */
+	u16 timeout;				/* negotiated timeout in seconds */
+} POST_PACKED;
+
+#define DOT11_ADDBA_RESP_LEN		    9	/* length of addba resp frame */
+
+/* DELBA action parameters */
+#define DOT11_DELBA_PARAM_INIT_MASK	    0x0800	/* initiator mask */
+#define DOT11_DELBA_PARAM_INIT_SHIFT	11	/* initiator shift */
+#define DOT11_DELBA_PARAM_TID_MASK	    0xf000	/* tid mask */
+#define DOT11_DELBA_PARAM_TID_SHIFT	    12	/* tid shift */
+
+PRE_PACKED struct dot11_delba {
+	u8  category;			/* category of action frame (3) */
+	u8  action;				/* action: addba req */
+	u16 delba_param_set;	/* paarmeter set */
+	u16 reason;				/* reason for dellba */
+} POST_PACKED;
+
+#define DOT11_DELBA_LEN			        6	/* length of delba frame */
+
+/* SA Query action field value */
+#define SA_QUERY_REQUEST		        0
+#define SA_QUERY_RESPONSE		        1
+
+/* ************* 802.11r related definitions. ************* */
+
+/* Over-the-DS Fast Transition Request frame header */
+PRE_PACKED struct dot11_ft_req {
+	u8 category;			/* category of action frame (6) */
+	u8 action;			/* action: ft req */
+	u8 sta_addr[ETHER_ADDR_LEN];
+	u8 tgt_ap_addr[ETHER_ADDR_LEN];
+	u8 data[1];			/* Elements */
+} POST_PACKED;
+
+#define DOT11_FT_REQ_FIXED_LEN          14
+
+/* Over-the-DS Fast Transition Response frame header */
+PRE_PACKED struct dot11_ft_res {
+	u8  category;			/* category of action frame (6) */
+	u8  action;			    /* action: ft resp */
+	u8  sta_addr[ETHER_ADDR_LEN];
+	u8  tgt_ap_addr[ETHER_ADDR_LEN];
+	u16 status;			    /* status code */
+	u8  data[1];			/* Elements */
+} POST_PACKED;
+
+#define DOT11_FT_RES_FIXED_LEN 16
+
+
+/* ************* 802.11k related definitions. ************* */
+
+/* Radio measurements enabled capability ie */
+
+#define DOT11_RRM_CAP_LEN		5	/* length of rrm cap bitmap */
+PRE_PACKED struct dot11_rrm_cap_ie {
+	u8                  cap[DOT11_RRM_CAP_LEN];
+} POST_PACKED;
+
+/* Bitmap definitions for cap ie */
+#define DOT11_RRM_CAP_LINK			0
+#define DOT11_RRM_CAP_NEIGHBOR_REPORT	1
+#define DOT11_RRM_CAP_PARALLEL		2
+#define DOT11_RRM_CAP_REPEATED		3
+#define DOT11_RRM_CAP_BCN_PASSIVE	4
+#define DOT11_RRM_CAP_BCN_ACTIVE	5
+#define DOT11_RRM_CAP_BCN_TABLE		6
+#define DOT11_RRM_CAP_BCN_REP_COND	7
+#define DOT11_RRM_CAP_AP_CHANREP	16
+
+
+/* Operating Class (formerly "Regulatory Class") definitions */
+#define DOT11_OP_CLASS_NONE			255
+
+
+/* Radio Measurements action ids */
+#define DOT11_RM_ACTION_RM_REQ		0	/* Radio measurement request */
+#define DOT11_RM_ACTION_RM_REP		1	/* Radio measurement report */
+#define DOT11_RM_ACTION_LM_REQ		2	/* Link measurement request */
+#define DOT11_RM_ACTION_LM_REP		3	/* Link measurement report */
+#define DOT11_RM_ACTION_NR_REQ		4	/* Neighbor report request */
+#define DOT11_RM_ACTION_NR_REP		5	/* Neighbor report response */
+
+/* Generic radio measurement action frame header */
+PRE_PACKED struct dot11_rm_action {
+	u8 category;				/* category of action frame (5) */
+	u8 action;				/* radio measurement action */
+	u8 token;				/* dialog token */
+	u8 data[1];
+} POST_PACKED;
+
+#define DOT11_RM_ACTION_LEN 3
+
+PRE_PACKED struct dot11_rmreq {
+	u8  category;				/* category of action frame (5) */
+	u8  action;				/* radio measurement action */
+	u8  token;				/* dialog token */
+	u16 reps;				/* no. of repetitions */
+} POST_PACKED;
+
+#define DOT11_RMREQ_LEN	5
+
+PRE_PACKED struct dot11_rm_ie {
+	u8 id;
+	u8 len;
+	u8 token;
+	u8 mode;
+	u8 type;
+} POST_PACKED;
+
+#define DOT11_RM_IE_LEN	            5
+
+/* Definitions for "mode" bits in rm req */
+#define DOT11_RMREQ_MODE_PARALLEL	1
+#define DOT11_RMREQ_MODE_ENABLE		2
+#define DOT11_RMREQ_MODE_REQUEST	4
+#define DOT11_RMREQ_MODE_REPORT		8
+#define DOT11_RMREQ_MODE_DURMAND	0x10	/* Duration Mandatory */
+
+/* Definitions for "mode" bits in rm rep */
+#define DOT11_RMREP_MODE_LATE		1
+#define DOT11_RMREP_MODE_INCAPABLE	2
+#define DOT11_RMREP_MODE_REFUSED	4
+
+PRE_PACKED struct dot11_rmreq_bcn {
+	u8 id;
+	u8 len;
+	u8 token;
+	u8 mode;
+	u8 type;
+	u8 reg;
+	u8 channel;
+	u16 interval;
+	u16 duration;
+	u8 bcn_mode;
+	struct ether_addr	bssid;
+} POST_PACKED;
+
+#define DOT11_RMREQ_BCN_LEN	        18
+
+PRE_PACKED struct dot11_rmrep_bcn {
+	u8 reg;
+	u8 channel;
+	u32 starttime[2];
+	u16 duration;
+	u8 frame_info;
+	u8 rcpi;
+	u8 rsni;
+	struct ether_addr	bssid;
+	u8 antenna_id;
+	u32 parent_tsf;
+} POST_PACKED;
+
+#define DOT11_RMREP_BCN_LEN	            26
+
+/* Beacon request measurement mode */
+#define DOT11_RMREQ_BCN_PASSIVE	        0
+#define DOT11_RMREQ_BCN_ACTIVE	        1
+#define DOT11_RMREQ_BCN_TABLE	        2
+
+/* Sub-element IDs for Beacon Request */
+#define DOT11_RMREQ_BCN_SSID_ID	        0
+#define DOT11_RMREQ_BCN_REPINFO_ID	    1
+#define DOT11_RMREQ_BCN_REPDET_ID	    2
+#define DOT11_RMREQ_BCN_REQUEST_ID	    10
+#define DOT11_RMREQ_BCN_APCHREP_ID	    51
+
+/* Reporting Detail element definition */
+#define DOT11_RMREQ_BCN_REPDET_FIXED	0	/* Fixed length fields only */
+#define DOT11_RMREQ_BCN_REPDET_REQUEST	1	/* + requested information elems */
+#define DOT11_RMREQ_BCN_REPDET_ALL	    2	/* All fields */
+
+/* Sub-element IDs for Beacon Report */
+#define DOT11_RMREP_BCN_FRM_BODY	    1
+
+/* Neighbor measurement report */
+PRE_PACKED struct dot11_rmrep_nbr {
+	struct ether_addr	bssid;
+	u32	                bssid_info;
+	u8                  reg;
+	u8                  channel;
+	u8                  phytype;
+	u8                  sub_elements[1]; 	/* Variable size data */
+} POST_PACKED;
+
+#define DOT11_RMREP_NBR_LEN	            13
+
+/* MLME Enumerations */
+#define DOT11_BSSTYPE_INFRASTRUCTURE	0	/* d11 infrastructure */
+#define DOT11_BSSTYPE_INDEPENDENT		1	/* d11 independent */
+#define DOT11_BSSTYPE_ANY			    2	/* d11 any BSS type */
+#define DOT11_SCANTYPE_ACTIVE			0	/* d11 scan active */
+#define DOT11_SCANTYPE_PASSIVE			1	/* d11 scan passive */
+
+/* Link Measurement */
+PRE_PACKED struct dot11_lmreq {
+	u8 category;				/* category of action frame (5) */
+	u8 action;				    /* radio measurement action */
+	u8 token;				    /* dialog token */
+	u8 txpwr;				    /* Transmit Power Used */
+	u8 maxtxpwr;				/* Max Transmit Power */
+} POST_PACKED;
+
+#define DOT11_LMREQ_LEN	                5
+
+PRE_PACKED struct dot11_lmrep {
+	u8                      category;				/* category of action frame (5) */
+	u8                      action;				/* radio measurement action */
+	u8                      token;				/* dialog token */
+	struct dot11_tpc_rep    tpc;			/* TPC element */
+	u8                      rxant;				/* Receive Antenna ID */
+	u8                      txant;				/* Transmit Antenna ID */
+	u8 rcpi;				/* RCPI */
+	u8 rsni;				/* RSNI */
+} POST_PACKED;
+
+#define DOT11_LMREP_LEN	                11
+
+/* 802.11 BRCM "Compromise" Pre N constants */
+#define PREN_PREAMBLE		            24	/* green field preamble time */
+#define PREN_MM_EXT		                12	/* extra mixed mode preamble time */
+#define PREN_PREAMBLE_EXT	            4	/* extra preamble (multiply by unique_streams-1) */
+
+/* 802.11N PHY constants */
+#define RIFS_11N_TIME		            2	/* NPHY RIFS time */
+
+/* 802.11 HT PLCP format 802.11n-2009, sec 20.3.9.4.3
+ * HT-SIG is composed of two 24 bit parts, HT-SIG1 and HT-SIG2
+ */
+/* HT-SIG1 */
+#define HT_SIG1_MCS_MASK	            0x00007F
+#define HT_SIG1_CBW		                0x000080
+#define HT_SIG1_HT_LENGTH	            0xFFFF00
+
+/* HT-SIG2 */
+#define HT_SIG2_SMOOTHING	            0x000001
+#define HT_SIG2_NOT_SOUNDING	        0x000002
+#define HT_SIG2_RESERVED	            0x000004
+#define HT_SIG2_AGGREGATION	            0x000008
+#define HT_SIG2_STBC_MASK	            0x000030
+#define HT_SIG2_STBC_SHIFT	            4
+#define HT_SIG2_FEC_CODING	            0x000040
+#define HT_SIG2_SHORT_GI	            0x000080
+#define HT_SIG2_ESS_MASK	            0x000300
+#define HT_SIG2_ESS_SHIFT	            8
+#define HT_SIG2_CRC		                0x03FC00
+#define HT_SIG2_TAIL		            0x1C0000
+
+/* 802.11 A PHY constants */
+#define APHY_SLOT_TIME		            9	/* APHY slot time */
+#define APHY_SIFS_TIME		            16	/* APHY SIFS time */
+#define APHY_DIFS_TIME		            (APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))	/* APHY DIFS time */
+#define APHY_PREAMBLE_TIME	            16	/* APHY preamble time */
+#define APHY_SIGNAL_TIME	            4	/* APHY signal time */
+#define APHY_SYMBOL_TIME	            4	/* APHY symbol time */
+#define APHY_SERVICE_NBITS	            16	/* APHY service nbits */
+#define APHY_TAIL_NBITS		            6	/* APHY tail nbits */
+#define	APHY_CWMIN		                15	/* APHY cwmin */
+
+/* 802.11 B PHY constants */
+#define BPHY_SLOT_TIME		            20	/* BPHY slot time */
+#define BPHY_SIFS_TIME		            10	/* BPHY SIFS time */
+#define BPHY_DIFS_TIME		            50	/* BPHY DIFS time */
+#define BPHY_PLCP_TIME		            192	/* BPHY PLCP time */
+#define BPHY_PLCP_SHORT_TIME	        96	/* BPHY PLCP short time */
+#define	BPHY_CWMIN		                31	/* BPHY cwmin */
+
+/* 802.11 G constants */
+#define DOT11_OFDM_SIGNAL_EXTENSION	    6	/* d11 OFDM signal extension */
+
+#define PHY_CWMAX		                1023	/* PHY cwmax */
+
+#define	DOT11_MAXNUMFRAGS	            16	/* max # fragments per MSDU */
+
+
+/* for VHT-A1 */
+/* SIG-A1 reserved bits */
+#define VHT_SIGA1_CONST_MASK 		    0x800004
+
+#define VHT_SIGA1_20MHZ_VAL 		    0x000000
+#define VHT_SIGA1_40MHZ_VAL 		    0x000001
+#define VHT_SIGA1_80MHZ_VAL 		    0x000002
+#define VHT_SIGA1_160MHZ_VAL 		    0x000003
+
+#define VHT_SIGA1_STBC 			        0x000008
+
+#define VHT_SIGA1_GID_MAX_GID 		    0x3f
+#define VHT_SIGA1_GID_SHIFT 		    4
+#define VHT_SIGA1_GID_TO_AP 		    0x00
+#define VHT_SIGA1_GID_NOT_TO_AP 	    0x3f
+
+#define VHT_SIGA1_NSTS_SHIFT 		    10
+#define VHT_SIGA1_NSTS_SHIFT_MASK_USER0 0x001C00
+
+#define VHT_SIGA1_PARTIAL_AID_SHIFT     13
+
+/* for VHT-A2 */
+#define VHT_SIGA2_GI_NONE               0x000000
+#define VHT_SIGA2_GI_SHORT              0x000001
+#define VHT_SIGA2_GI_W_MOD10            0x000002
+#define VHT_SIGA2_CODING_LDPC           0x000004
+#define VHT_SIGA2_BEAMFORM_ENABLE       0x000100
+#define VHT_SIGA2_MCS_SHIFT             4
+
+#define VHT_SIGA2_B9_RESERVED           0x000200
+#define VHT_SIGA2_TAIL_MASK             0xfc0000
+#define VHT_SIGA2_TAIL_VALUE            0x000000
+
+#define VHT_SIGA2_SVC_BITS              16
+#define VHT_SIGA2_TAIL_BITS             6
+
+
+/* dot11Counters Table - 802.11 spec., Annex D */
+struct d11cnt {
+	u32		txfrag;		/* dot11TransmittedFragmentCount */
+	u32		txmulti;	/* dot11MulticastTransmittedFrameCount */
+	u32		txfail;		/* dot11FailedCount */
+	u32		txretry;	/* dot11RetryCount */
+	u32		txretrie;	/* dot11MultipleRetryCount */
+	u32		rxdup;		/* dot11FrameduplicateCount */
+	u32		txrts;		/* dot11RTSSuccessCount */
+	u32		txnocts;	/* dot11RTSFailureCount */
+	u32		txnoack;	/* dot11ACKFailureCount */
+	u32		rxfrag;		/* dot11ReceivedFragmentCount */
+	u32		rxmulti;	/* dot11MulticastReceivedFrameCount */
+	u32		rxcrc;		/* dot11FCSErrorCount */
+	u32		txfrmsnt;	/* dot11TransmittedFrameCount */
+	u32		rxundec;	/* dot11WEPUndecryptableCount */
+};
+
+/* OUI for BRCM proprietary IE */
+#define BRCM_PROP_OUI		"\x00\x90\x4C"	/* Broadcom proprietary OUI */
+
+
+/* BRCM OUI: Used in the proprietary(221) IE in all broadcom devices */
+#define BRCM_OUI		    "\x00\x10\x18"	/* Broadcom OUI */
+
+/* BRCM info element */
+PRE_PACKED struct brcm_ie {
+	u8	id;		    /* IE ID, 221, DOT11_MNG_PROPR_ID */
+	u8	len;		/* IE length */
+	u8	oui[3];		/* Proprietary OUI, BRCM_OUI */
+	u8	ver;		/* type/ver of this IE */
+	u8	assoc;		/* # of assoc STAs */
+	u8	flags;		/* misc flags */
+	u8	flags1;		/* misc flags */
+	u16	amsdu_mtu_pref;	/* preferred A-MSDU MTU */
+} POST_PACKED;
+
+
+/* brcm_ie flags */
+#define	BRF_LZWDS		            0x4	/* lazy wds enabled */
+#define	BRF_BLOCKACK		        0x8	/* BlockACK capable */
+
+/* brcm_ie flags1 */
+#define	BRF1_AMSDU		            0x1	/* A-MSDU capable */
+#define BRF1_WMEPS		            0x4	/* AP is capable of handling WME + PS w/o APSD */
+#define BRF1_PSOFIX		            0x8	/* AP has fixed PS mode out-of-order packets */
+#define	BRF1_RX_LARGE_AGG	        0x10	/* device can rx large aggregates */
+#define BRF1_RFAWARE_DCS	        0x20    /* RFAWARE dynamic channel selection (DCS) */
+#define BRF1_SOFTAP		            0x40    /* Configure as Broadcom SOFTAP */
+
+/* Vendor IE structure */
+PRE_PACKED struct vndr_ie {
+	u8  id;
+	u8  len;
+	u8  oui [3];
+	u8  data [1]; 	/* Variable size data */
+} POST_PACKED;
+
+#define VNDR_IE_HDR_LEN		        2	/* id + len field */
+#define VNDR_IE_MIN_LEN		        3	/* size of the oui field */
+#define VNDR_IE_FIXED_LEN	        (VNDR_IE_HDR_LEN + VNDR_IE_MIN_LEN)
+#define VNDR_IE_MAX_LEN		        256	/* verdor IE max length */
+
+/* ************* HT definitions. ************* */
+#define MCSSET_LEN	                16	/* 16-bits per 8-bit set to give 128-bits bitmap of MCS Index */
+#define MAX_MCS_NUM	                (128)	/* max mcs number = 128 */
+
+PRE_PACKED struct ht_cap_ie {
+	u16	                cap;
+	u8	                params;
+	u8	                supp_mcs[MCSSET_LEN];
+	u16	                ext_htcap;
+	u32	                txbf_cap;
+	u8	                as_cap;
+} POST_PACKED;
+
+/* CAP IE: HT 1.0 spec. simply stole a 802.11 IE, we use our prop. IE until this is resolved */
+/* the capability IE is primarily used to convey this nodes abilities */
+PRE_PACKED struct ht_prop_cap_ie {
+	u8	                id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	u8	                len;		/* IE length */
+	u8	                oui[3];		/* Proprietary OUI, BRCM_PROP_OUI */
+	u8	                type;           /* type inidicates what follows */
+	struct ht_cap_ie    cap_ie;
+} POST_PACKED;
+
+#define HT_PROP_IE_OVERHEAD	            4	/* overhead bytes for prop oui ie */
+#define HT_CAP_IE_LEN		            26	/* HT capability len (based on .11n d2.0) */
+#define HT_CAP_IE_TYPE		            51
+
+#define HT_CAP_LDPC_CODING	            0x0001	/* Support for rx of LDPC coded pkts */
+#define HT_CAP_40MHZ		            0x0002  /* false:20Mhz, true:20/40MHZ supported */
+#define HT_CAP_MIMO_PS_MASK	            0x000C  /* Mimo PS mask */
+#define HT_CAP_MIMO_PS_SHIFT	        0x0002	/* Mimo PS shift */
+#define HT_CAP_MIMO_PS_OFF	            0x0003	/* Mimo PS, no restriction */
+#define HT_CAP_MIMO_PS_RTS	            0x0001	/* Mimo PS, send RTS/CTS around MIMO frames */
+#define HT_CAP_MIMO_PS_ON	            0x0000	/* Mimo PS, MIMO disallowed */
+#define HT_CAP_GF		                0x0010	/* Greenfield preamble support */
+#define HT_CAP_SHORT_GI_20	            0x0020	/* 20MHZ short guard interval support */
+#define HT_CAP_SHORT_GI_40	            0x0040	/* 40Mhz short guard interval support */
+#define HT_CAP_TX_STBC		            0x0080	/* Tx STBC support */
+#define HT_CAP_RX_STBC_MASK	            0x0300	/* Rx STBC mask */
+#define HT_CAP_RX_STBC_SHIFT	        8	/* Rx STBC shift */
+#define HT_CAP_DELAYED_BA	            0x0400	/* delayed BA support */
+#define HT_CAP_MAX_AMSDU	            0x0800	/* Max AMSDU size in bytes , 0=3839, 1=7935 */
+
+#define HT_CAP_DSSS_CCK	                0x1000	/* DSSS/CCK supported by the BSS */
+#define HT_CAP_PSMP		                0x2000	/* Power Save Multi Poll support */
+#define HT_CAP_40MHZ_INTOLERANT         0x4000	/* 40MHz Intolerant */
+#define HT_CAP_LSIG_TXOP	            0x8000	/* L-SIG TXOP protection support */
+
+#define HT_CAP_RX_STBC_NO		        0x0	/* no rx STBC support */
+#define HT_CAP_RX_STBC_ONE_STREAM	    0x1	/* rx STBC support of 1 spatial stream */
+#define HT_CAP_RX_STBC_TWO_STREAM	    0x2	/* rx STBC support of 1-2 spatial streams */
+#define HT_CAP_RX_STBC_THREE_STREAM	    0x3	/* rx STBC support of 1-3 spatial streams */
+
+#define VHT_MAX_MPDU		            11454	/* max mpdu size for now (bytes) */
+#define VHT_MPDU_MSDU_DELTA	            56		/* Difference in spec - vht mpdu, amsdu len */
+/* Max AMSDU len - per spec */
+#define VHT_MAX_AMSDU		            (VHT_MAX_MPDU - VHT_MPDU_MSDU_DELTA)
+
+#define HT_MAX_AMSDU		            7935	/* max amsdu size (bytes) per the HT spec */
+#define HT_MIN_AMSDU		            3835	/* min amsdu size (bytes) per the HT spec */
+
+#define HT_PARAMS_RX_FACTOR_MASK	    0x03	/* ampdu rcv factor mask */
+#define HT_PARAMS_DENSITY_MASK		    0x1C	/* ampdu density mask */
+#define HT_PARAMS_DENSITY_SHIFT	        2	/* ampdu density shift */
+
+/* HT/AMPDU specific define */
+#define AMPDU_MAX_MPDU_DENSITY          7       /* max mpdu density; in 1/4 usec units */
+#define AMPDU_DENSITY_NONE              0       /* No density requirement */
+#define AMPDU_DENSITY_1over4_US         1       /* 1/4 us density */
+#define AMPDU_DENSITY_1over2_US         2       /* 1/2 us density */
+#define AMPDU_DENSITY_1_US              3       /*   1 us density */
+#define AMPDU_DENSITY_2_US              4       /*   2 us density */
+#define AMPDU_DENSITY_4_US              5       /*   4 us density */
+#define AMPDU_DENSITY_8_US              6       /*   8 us density */
+#define AMPDU_DENSITY_16_US             7       /*  16 us density */
+#define AMPDU_RX_FACTOR_8K              0       /* max rcv ampdu len (8kb) */
+#define AMPDU_RX_FACTOR_16K             1       /* max rcv ampdu len (16kb) */
+#define AMPDU_RX_FACTOR_32K             2       /* max rcv ampdu len (32kb) */
+#define AMPDU_RX_FACTOR_64K             3       /* max rcv ampdu len (64kb) */
+#define AMPDU_RX_FACTOR_BASE            8*1024  /* ampdu factor base for rx len */
+
+#define AMPDU_DELIMITER_LEN	            4	/* length of ampdu delimiter */
+#define AMPDU_DELIMITER_LEN_MAX	        63	/* max length of ampdu delimiter(enforced in HW) */
+
+#define HT_CAP_EXT_PCO			        0x0001
+#define HT_CAP_EXT_PCO_TTIME_MASK	    0x0006
+#define HT_CAP_EXT_PCO_TTIME_SHIFT	    1
+#define HT_CAP_EXT_MCS_FEEDBACK_MASK	0x0300
+#define HT_CAP_EXT_MCS_FEEDBACK_SHIFT	8
+#define HT_CAP_EXT_HTC			        0x0400
+#define HT_CAP_EXT_RD_RESP		        0x0800
+
+PRE_PACKED struct ht_add_ie {
+	u8	                ctl_ch;			/* control channel number */
+	u8	                byte1;			/* ext ch,rec. ch. width, RIFS support */
+	u16	                opmode;			/* operation mode */
+	u16	                misc_bits;		/* misc bits */
+	u8	                basic_mcs[MCSSET_LEN];  /* required MCS set */
+} POST_PACKED;
+
+/* ADD IE: HT 1.0 spec. simply stole a 802.11 IE, we use our prop. IE until this is resolved */
+/* the additional IE is primarily used to convey the current BSS configuration */
+PRE_PACKED struct ht_prop_add_ie {
+	u8	                id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	u8	                len;		/* IE length */
+	u8	                oui[3];		/* Proprietary OUI, BRCM_PROP_OUI */
+	u8	                type;		/* indicates what follows */
+	struct ht_add_ie    add_ie;
+} POST_PACKED;
+
+#define HT_ADD_IE_LEN	            22
+#define HT_ADD_IE_TYPE	            52
+
+/* byte1 defn's */
+#define HT_BW_ANY		            0x04	/* set, STA can use 20 or 40MHz */
+#define HT_RIFS_PERMITTED     	    0x08	/* RIFS allowed */
+
+/* opmode defn's */
+#define HT_OPMODE_MASK	            0x0003	/* protection mode mask */
+#define HT_OPMODE_SHIFT		        0	/* protection mode shift */
+#define HT_OPMODE_PURE		        0x0000	/* protection mode PURE */
+#define HT_OPMODE_OPTIONAL	        0x0001	/* protection mode optional */
+#define HT_OPMODE_HT20IN40	        0x0002	/* protection mode 20MHz HT in 40MHz BSS */
+#define HT_OPMODE_MIXED	            0x0003	/* protection mode Mixed Mode */
+#define HT_OPMODE_NONGF	            0x0004	/* protection mode non-GF */
+#define DOT11N_TXBURST		        0x0008	/* Tx burst limit */
+#define DOT11N_OBSS_NONHT	        0x0010	/* OBSS Non-HT STA present */
+
+/* misc_bites defn's */
+#define HT_BASIC_STBC_MCS	        0x007f	/* basic STBC MCS */
+#define HT_DUAL_STBC_PROT	        0x0080	/* Dual STBC Protection */
+#define HT_SECOND_BCN		        0x0100	/* Secondary beacon support */
+#define HT_LSIG_TXOP		        0x0200	/* L-SIG TXOP Protection full support */
+#define HT_PCO_ACTIVE		        0x0400	/* PCO active */
+#define HT_PCO_PHASE		        0x0800	/* PCO phase */
+#define HT_DUALCTS_PROTECTION	    0x0080	/* DUAL CTS protection needed */
+
+/* Tx Burst Limits */
+#define DOT11N_2G_TXBURST_LIMIT	    6160	/* 2G band Tx burst limit per 802.11n Draft 1.10 (usec) */
+#define DOT11N_5G_TXBURST_LIMIT	    3080	/* 5G band Tx burst limit per 802.11n Draft 1.10 (usec) */
+
+/* Macros for opmode */
+#define GET_HT_OPMODE(add_ie)		        ((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) >> HT_OPMODE_SHIFT)
+#define HT_MIXEDMODE_PRESENT(add_ie)	    ((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_MIXED)	/* mixed mode present */
+#define HT_HT20_PRESENT(add_ie)	            ((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_HT20IN40)	/* 20MHz HT present */
+#define HT_OPTIONAL_PRESENT(add_ie)	        ((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_OPTIONAL)	/* Optional protection present */
+#define HT_USE_PROTECTION(add_ie)	        (HT_HT20_PRESENT((add_ie)) || HT_MIXEDMODE_PRESENT((add_ie))) /* use protection */
+#define HT_NONGF_PRESENT(add_ie)	        ((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_NONGF) == HT_OPMODE_NONGF)	/* non-GF present */
+#define DOT11N_TXBURST_PRESENT(add_ie)	    ((ltoh16_ua(&add_ie->opmode) & DOT11N_TXBURST) == DOT11N_TXBURST)	/* Tx Burst present */
+#define DOT11N_OBSS_NONHT_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) == DOT11N_OBSS_NONHT)	/* OBSS Non-HT present */
+
+PRE_PACKED struct obss_params {
+	u16	passive_dwell;
+	u16	active_dwell;
+	u16	bss_widthscan_interval;
+	u16	passive_total;
+	u16	active_total;
+	u16	chanwidth_transition_dly;
+	u16	activity_threshold;
+} POST_PACKED;
+
+PRE_PACKED struct dot11_obss_ie {
+	u8	            id;
+	u8	            len;
+	struct obss_params  obss_params;
+} POST_PACKED;
+
+
+#define DOT11_OBSS_SCAN_IE_LEN	sizeof(struct obss_params)	/* HT OBSS len (based on 802.11n d3.0) */
+
+/* HT control field */
+#define HT_CTRL_LA_TRQ		    0x00000002	/* sounding request */
+#define HT_CTRL_LA_MAI		    0x0000003C	/* MCS request or antenna selection indication */
+#define HT_CTRL_LA_MAI_SHIFT	2
+#define HT_CTRL_LA_MAI_MRQ	    0x00000004	/* MCS request */
+#define HT_CTRL_LA_MAI_MSI	    0x00000038	/* MCS request sequence identifier */
+#define HT_CTRL_LA_MFSI		    0x000001C0	/* MFB sequence identifier */
+#define HT_CTRL_LA_MFSI_SHIFT	6
+#define HT_CTRL_LA_MFB_ASELC	0x0000FE00	/* MCS feedback, antenna selection command/data */
+#define HT_CTRL_LA_MFB_ASELC_SH	9
+#define HT_CTRL_LA_ASELC_CMD	0x00000C00	/* ASEL command */
+#define HT_CTRL_LA_ASELC_DATA	0x0000F000	/* ASEL data */
+#define HT_CTRL_CAL_POS		    0x00030000	/* Calibration position */
+#define HT_CTRL_CAL_SEQ		    0x000C0000	/* Calibration sequence */
+#define HT_CTRL_CSI_STEERING	0x00C00000	/* CSI/Steering */
+#define HT_CTRL_CSI_STEER_SHIFT	22
+#define HT_CTRL_CSI_STEER_NFB	0		/* no fedback required */
+#define HT_CTRL_CSI_STEER_CSI	1		/* CSI, H matrix */
+#define HT_CTRL_CSI_STEER_NCOM	2		/* non-compressed beamforming */
+#define HT_CTRL_CSI_STEER_COM	3		/* compressed beamforming */
+#define HT_CTRL_NDP_ANNOUNCE	0x01000000	/* NDP announcement */
+#define HT_CTRL_AC_CONSTRAINT	0x40000000	/* AC Constraint */
+#define HT_CTRL_RDG_MOREPPDU	0x80000000	/* RDG/More PPDU */
+
+#define HT_OPMODE_OPTIONAL	    0x0001	/* protection mode optional */
+#define HT_OPMODE_HT20IN40	    0x0002	/* protection mode 20MHz HT in 40MHz BSS */
+#define HT_OPMODE_MIXED	        0x0003	/* protection mode Mixed Mode */
+#define HT_OPMODE_NONGF	        0x0004	/* protection mode non-GF */
+#define DOT11N_TXBURST		    0x0008	/* Tx burst limit */
+#define DOT11N_OBSS_NONHT	    0x0010	/* OBSS Non-HT STA present */
+
+/* ************* VHT definitions. ************* */
+
+PRE_PACKED struct vht_cap_ie {
+	u32  vht_cap_info;
+	/* supported MCS set - 64 bit field */
+	u16	rx_mcs_map;
+	u16  rx_max_rate;
+	u16  tx_mcs_map;
+	u16	tx_max_rate;
+} POST_PACKED;
+
+/* 4B cap_info + 8B supp_mcs */
+#define VHT_CAP_IE_LEN 12
+/* 32bit - cap info */
+#define VHT_CAP_INFO_MAX_MPDU_LEN_MASK			0x00000003
+#define VHT_CAP_INFO_SUPP_CHAN_WIDTH_MASK       0x0000000c
+#define VHT_CAP_INFO_LDPC                       0x00000010
+#define VHT_CAP_INFO_SGI_80MHZ                  0x00000020
+
+#define VHT_CAP_INFO_SGI_160MHZ                 0x00000040
+#define VHT_CAP_INFO_TX_STBC                    0x00000080
+
+#define VHT_CAP_INFO_RX_STBC_MASK               0x00000700
+#define VHT_CAP_INFO_RX_STBC_SHIFT              8
+#define VHT_CAP_INFO_SU_BEAMFMR                 0x00000800
+#define VHT_CAP_INFO_SU_BEAMFMEE                0x00001000
+#define VHT_CAP_INFO_NUM_BMFMR_ANT_MASK         0x0000e000
+#define VHT_CAP_INFO_NUM_BMFMR_ANT_SHIFT        13
+
+#define VHT_CAP_INFO_NUM_SOUNDING_DIM_MASK      0x00070000
+#define VHT_CAP_INFO_NUM_SOUNDING_DIM_SHIFT     16
+#define VHT_CAP_INFO_MU_BEAMFMR                 0x00080000
+#define VHT_CAP_INFO_MU_BEAMFMEE                0x00100000
+#define VHT_CAP_INFO_TXOPPS                     0x00200000
+#define VHT_CAP_INFO_HTCVHT                     0x00400000
+#define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_MASK      0x03800000
+#define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_SHIFT     23
+
+#define VHT_CAP_INFO_LINK_ADAPT_CAP_MASK        0x0c000000
+#define VHT_CAP_INFO_LINK_ADAPT_CAP_SHIFT       26
+
+/* 64-bit Supp MCS. */
+#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_MASK	0x1fff
+#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_SHIFT	0
+
+#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_MASK	0x1fff
+#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_SHIFT	0
+
+#define VHT_CAP_MCS_MAP_0_7						0
+#define VHT_CAP_MCS_MAP_0_8						1
+#define VHT_CAP_MCS_MAP_0_9						2
+#define VHT_CAP_MCS_MAP_NONE					3
+
+#define VHT_CAP_MCS_MAP_NSS_MAX					8
+
+/* VHT Capabilities Supported Channel Width */
+enum vht_cap_chan_width {
+	VHT_CAP_CHAN_WIDTH_20_40  = 0x00,
+	VHT_CAP_CHAN_WIDTH_80	  = 0x04,
+	VHT_CAP_CHAN_WIDTH_160	  = 0x08
+};
+
+/* VHT Capabilities Supported max MPDU LEN */
+enum vht_cap_max_mpdu_len {
+	VHT_CAP_MPDU_MAX_4K		= 0x00,
+	VHT_CAP_MPDU_MAX_8K		= 0x01,
+	VHT_CAP_MPDU_MAX_11K	= 0x02
+};
+
+/* VHT Operation Element */
+PRE_PACKED struct vht_op_ie {
+	u8	chan_width;
+	u8	chan1;
+	u8	chan2;
+	u16	supp_mcs;  /*  same def as above in vht cap */
+} POST_PACKED;
+
+
+enum vht_op_chan_width {
+	VHT_OP_CHAN_WIDTH_20_40	= 0,
+	VHT_OP_CHAN_WIDTH_80	= 1,
+	VHT_OP_CHAN_WIDTH_160	= 2,
+	VHT_OP_CHAN_WIDTH_80_80	= 3
+} ;
+
+/* Def for rx & tx basic mcs maps - ea ss num has 2 bits of info */
+#define VHT_MCS_MAP_GET_SS_IDX(nss)                     (((nss)-1)*2)
+#define VHT_MCS_MAP_GET_MCS_PER_SS(nss, mcsMap)         (((mcsMap) >> VHT_MCS_MAP_GET_SS_IDX(nss)) & 0x3)
+#define VHT_MCS_MAP_SET_MCS_PER_SS(nss, numMcs, mcsMap) ((mcsMap) |= (((numMcs) & 0x3) << VHT_MCS_MAP_GET_SS_IDX(nss)))
+
+/* ************* WPA definitions. ************* */
+#define WPA_OUI			        "\x00\x50\xF2"	/* WPA OUI */
+#define WPA_OUI_LEN		        3		        /* WPA OUI length */
+#define WPA_OUI_TYPE		    1
+#define WPA_VERSION		        1		        /* WPA version */
+#define WPA2_OUI		        "\x00\x0F\xAC"	/* WPA2 OUI */
+#define WPA2_OUI_LEN		    3		        /* WPA2 OUI length */
+#define WPA2_VERSION		    1		        /* WPA2 version */
+#define WPA2_VERSION_LEN	    2		        /* WAP2 version length */
+
+/* ************* WPS definitions. ************* */
+#define WPS_OUI			        "\x00\x50\xF2"	/* WPS OUI */
+#define WPS_OUI_LEN		        3		        /* WPS OUI length */
+#define WPS_OUI_TYPE		    4
+
+#define RSN_OUI				    "\x00\x0F\xAC"	/* RSN OUI */
+
+
+/* ************* WFA definitions. ************* */
+
+#ifdef P2P_IE_OVRD
+#define WFA_OUI			        MAC_OUI
+#else
+#define WFA_OUI			        "\x50\x6F\x9A"	/* WFA OUI */
+#endif /* P2P_IE_OVRD */
+
+#define WFA_OUI_LEN		        3		/* WFA OUI length */
+#ifdef P2P_IE_OVRD
+#define WFA_OUI_TYPE_P2P	    MAC_OUI_TYPE_P2P
+#else
+#define WFA_OUI_TYPE_P2P	    9
+#endif
+
+#define WFA_OUI_TYPE_TPC	    8
+
+#ifdef WLTDLS
+#define WFA_OUI_TYPE_WFD	    10
+#endif /* WTDLS */
+
+/* RSN authenticated key managment suite */
+#define RSN_AKM_NONE		    0	/* None (IBSS) */
+#define RSN_AKM_UNSPECIFIED	    1	/* Over 802.1x */
+#define RSN_AKM_PSK		        2	/* Pre-shared Key */
+#define RSN_AKM_FBT_1X		    3	/* Fast Bss transition using 802.1X */
+#define RSN_AKM_FBT_PSK		    4	/* Fast Bss transition using Pre-shared Key */
+#define RSN_AKM_MFP_1X		    5	/* SHA256 key derivation, using 802.1X */
+#define RSN_AKM_MFP_PSK		    6	/* SHA256 key derivation, using Pre-shared Key */
+#define RSN_AKM_TPK			    7	/* TPK(TDLS Peer Key) handshake */
+
+/* Key related defines */
+#define DOT11_MAX_DEFAULT_KEYS	4	/* number of default keys */
+#define DOT11_MAX_KEY_SIZE	    32	/* max size of any key */
+#define DOT11_MAX_IV_SIZE	    16	/* max size of any IV */
+#define DOT11_EXT_IV_FLAG	    (1<<5)	/* flag to indicate IV is > 4 bytes */
+#define DOT11_WPA_KEY_RSC_LEN   8       /* WPA RSC key len */
+
+#define WEP1_KEY_SIZE		    5	/* max size of any WEP key */
+#define WEP1_KEY_HEX_SIZE	    10	/* size of WEP key in hex. */
+#define WEP128_KEY_SIZE		    13	/* max size of any WEP key */
+#define WEP128_KEY_HEX_SIZE	    26	/* size of WEP key in hex. */
+#define TKIP_MIC_SIZE		    8	/* size of TKIP MIC */
+#define TKIP_EOM_SIZE		    7	/* max size of TKIP EOM */
+#define TKIP_EOM_FLAG		    0x5a	/* TKIP EOM flag byte */
+#define TKIP_KEY_SIZE		    32	/* size of any TKIP key */
+#define TKIP_MIC_AUTH_TX	    16	/* offset to Authenticator MIC TX key */
+#define TKIP_MIC_AUTH_RX	    24	/* offset to Authenticator MIC RX key */
+#define TKIP_MIC_SUP_RX		    TKIP_MIC_AUTH_TX	/* offset to Supplicant MIC RX key */
+#define TKIP_MIC_SUP_TX		    TKIP_MIC_AUTH_RX	/* offset to Supplicant MIC TX key */
+#define AES_KEY_SIZE		    16	/* size of AES key */
+#define AES_MIC_SIZE		    8	/* size of AES MIC */
+#define BIP_KEY_SIZE		    16	/* size of BIP key */
+
+/* WCN */
+#define WCN_OUI			         "\x00\x50\xf2"	/* WCN OUI */
+#define WCN_TYPE		        4	/* WCN type */
+#ifdef BCMWAPI_WPI
+#define SMS4_KEY_LEN            16
+#define SMS4_WPI_CBC_MAC_LEN    16
+#endif
+
+
+/* 802.11r protocol definitions */
+
+/* Mobility Domain IE */
+PRE_PACKED struct dot11_mdid_ie {
+	u8 id;
+	u8 len;
+	u16 mdid;		/* Mobility Domain Id */
+	u8 cap;
+} POST_PACKED;
+
+#define FBT_MDID_CAP_OVERDS	0x01	/* Fast Bss transition over the DS support */
+#define FBT_MDID_CAP_RRP	0x02	/* Resource request protocol support */
+
+/* Fast Bss Transition IE */
+PRE_PACKED struct dot11_ft_ie {
+	u8 id;
+	u8 len;
+	u16 mic_control;		/* Mic Control */
+	u8 mic[16];
+	u8 anonce[32];
+	u8 snonce[32];
+} POST_PACKED;
+
+#define TIE_TYPE_RESERVED		    0
+#define TIE_TYPE_REASSOC_DEADLINE	1
+#define TIE_TYPE_KEY_LIEFTIME		2
+#define TIE_TYPE_ASSOC_COMEBACK		3
+
+PRE_PACKED struct dot11_timeout_ie {
+	u8  id;
+	u8  len;
+	u8  type;		/* timeout interval type */
+	u32 value;		/* timeout interval value */
+} POST_PACKED;
+
+/* GTK ie */
+PRE_PACKED struct dot11_gtk_ie {
+	u8  id;
+	u8  len;
+	u16 key_info;
+	u8  key_len;
+	u8  rsc[8];
+	u8  data[1];
+} POST_PACKED;
+
+#define BSSID_INVALID               "\x00\x00\x00\x00\x00\x00"
+#define BSSID_BROADCAST             "\xFF\xFF\xFF\xFF\xFF\xFF"
+
+
+/* ************* WMM Parameter definitions. ************* */
+#define WMM_OUI			            "\x00\x50\xF2"	/* WNN OUI */
+#define WMM_OUI_LEN		            3		/* WMM OUI length */
+#define WMM_OUI_TYPE	            2		/* WMM OUT type */
+#define WMM_VERSION		            1
+#define WMM_VERSION_LEN	            1
+
+/* WMM OUI subtype */
+#define WMM_OUI_SUBTYPE_PARAMETER	        1
+#define WMM_PARAMETER_IE_LEN		        24
+
+/* Link Identifier Element */
+PRE_PACKED struct link_id_ie {
+	u8                  id;
+	u8                  len;
+	struct ether_addr	bssid;
+	struct ether_addr	tdls_init_mac;
+	struct ether_addr	tdls_resp_mac;
+} POST_PACKED;
+
+#define TDLS_LINK_ID_IE_LEN		            18
+
+/* Link Wakeup Schedule Element */
+PRE_PACKED struct wakeup_sch_ie {
+	u8      id;
+	u8      len;
+	u32     offset;			    /* in ms between TSF0 and start of 1st Awake Window */
+	u32     interval;		    /* in ms bwtween the start of 2 Awake Windows */
+	u32     awake_win_slots;	/* in backof slots, duration of Awake Window */
+	u32     max_wake_win;	    /* in ms, max duration of Awake Window */
+	u16     idle_cnt;		    /* number of consecutive Awake Windows */
+} POST_PACKED;
+
+#define TDLS_WAKEUP_SCH_IE_LEN		        18
+
+/* Channel Switch Timing Element */
+PRE_PACKED struct channel_switch_timing_ie {
+	u8 id;
+	u8 len;
+	u16 switch_time;		/* in ms, time to switch channels */
+	u16 switch_timeout;	/* in ms */
+} POST_PACKED;
+
+#define TDLS_CHANNEL_SWITCH_TIMING_IE_LEN	4
+
+/* PTI Control Element */
+PRE_PACKED struct pti_control_ie {
+	u8 id;
+	u8 len;
+	u8 tid;
+	u16 seq_control;
+} POST_PACKED;
+
+#define TDLS_PTI_CONTROL_IE_LEN		        3
+
+/* PU Buffer Status Element */
+PRE_PACKED struct pu_buffer_status_ie {
+	u8 id;
+	u8 len;
+	u8 status;
+} POST_PACKED;
+
+#define TDLS_PU_BUFFER_STATUS_IE_LEN	    1
+#define TDLS_PU_BUFFER_STATUS_AC_BK		    1
+#define TDLS_PU_BUFFER_STATUS_AC_BE		    2
+#define TDLS_PU_BUFFER_STATUS_AC_VI		    4
+#define TDLS_PU_BUFFER_STATUS_AC_VO		    8
+
+#ifdef BCMWAPI_WAI
+#define WAPI_IE_MIN_LEN                     20  /* WAPI IE min length */
+#define WAPI_VERSION                        1   /* WAPI version */
+#define WAPI_VERSION_LEN                    2   /* WAPI version length */
+#define WAPI_OUI                            "\x00\x14\x72"  /* WAPI OUI */
+#define WAPI_OUI_LEN                        DOT11_OUI_LEN   /* WAPI OUI length */
+#endif /* BCMWAPI_WAI */
+
+
+/* Basic Frame Type Codes (2-bit) */
+enum BASICTYPE_T
+{
+    CONTROL         = 0x04,
+    DATA_BASICTYPE  = 0x08,
+    MANAGEMENT      = 0x00,
+    RESERVED        = 0x0C
+};
+
+enum STA_PS_STATE_T
+{
+    ACTIVE_PS      = 0,
+    POWER_SAVE     = 1
+};
+
+enum TIMBIT_T{
+    AID0_BIT       = 0,
+    DTIM_BIT       = 1
+};
+
+
+enum REQUEUE_STATUS_T
+{
+    RE_Q_ERROR       = 0,
+    NO_PKT_IN_QUEUE  = 1,
+    PKT_REQUEUED     = 2,
+    END_OF_QUEUE     = 3,
+    PKT_NOT_REQUEUED = 4
+};
+
+/* Element ID  of various Information Elements */
+enum ELEMENTID_T{
+    ISSID         = 0,   /* Service Set Identifier   */
+    ISUPRATES     = 1,   /* Supported Rates          */
+    IFHPARMS      = 2,   /* FH parameter set         */
+    IDSPARMS      = 3,   /* DS parameter set         */
+    ICFPARMS      = 4,   /* CF parameter set         */
+    ITIM          = 5,   /* Traffic Information Map  */
+    IIBPARMS      = 6,   /* IBSS parameter set       */
+    ICTEXT        = 16,  /* Challenge Text           */
+    IERPINFO      = 42,  /* ERP Information          */
+    IEXSUPRATES   = 50,  /* Extended Supported Rates */            
+    IWAPI         = 68          
+};
+
+/* Capability Information field bit assignments  */
+enum CAPABILITY_T
+{
+    ESS            = 0x01,   /* ESS capability               */
+    IBSS           = 0x02,   /* IBSS mode                    */
+    POLLABLE       = 0x04,   /* CF Pollable                  */
+    POLLREQ        = 0x08,   /* Request to be polled         */
+    PRIVACY        = 0x10,   /* WEP encryption supported     */
+    SHORTPREAMBLE  = 0x20,   /* Short Preamble is supported  */
+    SHORTSLOT      = 0x400,  /* Short Slot is supported      */
+    PBCC           = 0x40,   /* PBCC                         */
+    CHANNELAGILITY = 0x80,   /* Channel Agility              */
+    SPECTRUM_MGMT  = 0x100,  /* Spectrum Management          */
+    DSSS_OFDM      = 0x2000  /* DSSS-OFDM                    */
+};
+
+/* BSS type */
+enum BSSTYPE_T{
+    INFRASTRUCTURE  = 1,
+    INDEPENDENT     = 2,
+    ANY_BSS         = 3
+};
+
+/* Authentication/Association states of STAs maintained by the Access Point  */
+enum STATIONSTATE_T
+{
+    AUTH_COMPLETE      = 1,   /* Authenticated                     */
+    AUTH_KEY_SEQ1      = 2,   /* Shared Key Auth (Sequence 1) done */
+    ASOC               = 3    /* Associated                        */
+};
+
+enum OFFSET_T
+{
+    TYPE_OFFSET        = 0,
+    LENGTH_OFFSET      = 1,
+    DTIM_CNT_OFFSET    = 2,
+    DTIM_PERIOD_OFFSET = 3,
+    BMAP_CTRL_OFFSET   = 4,
+    TIM_OFFSET         = 5
+};
+
+/* Frame Type and Subtype Codes (6-bit) */
+enum TYPESUBTYPE_T
+{
+    ASSOC_REQ             = 0x00,
+    ASSOC_RSP             = 0x10,
+    REASSOC_REQ           = 0x20,
+    REASSOC_RSP           = 0x30,
+    PROBE_REQ             = 0x40,
+    PROBE_RSP             = 0x50,
+    BEACON                = 0x80,
+    ATIM                  = 0x90,
+    DISASOC               = 0xA0,
+    AUTH                  = 0xB0,
+    DEAUTH                = 0xC0,
+    ACTION                = 0xD0,
+    PS_POLL               = 0xA4,
+    RTS                   = 0xB4,
+    CTS                   = 0xC4,
+    ACK                   = 0xD4,
+    CFEND                 = 0xE4,
+    CFEND_ACK             = 0xF4,
+    DATA                  = 0x08,
+    DATA_ACK              = 0x18,
+    DATA_POLL             = 0x28,
+    DATA_POLL_ACK         = 0x38,
+    NULL_FRAME            = 0x48,
+    CFACK                 = 0x58,
+    CFPOLL                = 0x68,
+    CFPOLL_ACK            = 0x78,
+    QOS_DATA              = 0x88,
+    QOS_DATA_ACK          = 0x98,
+    QOS_DATA_POLL         = 0xA8,
+    QOS_DATA_POLL_ACK     = 0xB8,
+    QOS_NULL_FRAME        = 0xC8,
+    QOS_CFPOLL            = 0xE8,
+    QOS_CFPOLL_ACK        = 0xF8,
+    BLOCKACK_REQ          = 0x84,
+    BLOCKACK              = 0x94
+};
+
+#endif /* _802_11_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/802.1d.h b/drivers/net/wireless/rdaw80211/include/802.1d.h
new file mode 100644
index 000000000000..deae5ef6f845
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/802.1d.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _802_1_D_
+#define _802_1_D_
+
+/* 802.1D priority defines */
+#define	PRIO_8021D_NONE		2	/* None = - */
+#define	PRIO_8021D_BK		1	/* BK - Background */
+#define	PRIO_8021D_BE		0	/* BE - Best-effort */
+#define	PRIO_8021D_EE		3	/* EE - Excellent-effort */
+#define	PRIO_8021D_CL		4	/* CL - Controlled Load */
+#define	PRIO_8021D_VI		5	/* Vi - Video */
+#define	PRIO_8021D_VO		6	/* Vo - Voice */
+#define	PRIO_8021D_NC		7	/* NC - Network Control */
+
+#define	MAXPRIO			    7	/* 0-7 */
+#define NUMPRIO			    (MAXPRIO + 1)
+
+#define ALLPRIO		        -1	/* All prioirty */
+
+/* Converts prio to precedence since the numerical value of
+ * PRIO_8021D_BE and PRIO_8021D_NONE are swapped.
+ */
+#define PRIO2PREC(prio) \
+	(((prio) == PRIO_8021D_NONE || (prio) == PRIO_8021D_BE) ? ((prio^2)) : (prio))
+
+#endif /* _802_1_D__ */
diff --git a/drivers/net/wireless/rdaw80211/include/ethernet.h b/drivers/net/wireless/rdaw80211/include/ethernet.h
new file mode 100644
index 000000000000..1dd15475591a
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/ethernet.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ETHERNET_H_	 
+#define _ETHERNET_H_
+
+/* The number of bytes in an ethernet (MAC) address.*/
+#define	ETHER_ADDR_LEN		        6
+
+/* The number of bytes in the type field.*/
+#define	ETHER_TYPE_LEN		        2
+
+/* The number of bytes in the trailing CRC field.*/
+#define	ETHER_CRC_LEN		        4
+
+/* The length of the combined header.*/
+#define	ETHER_HDR_LEN		        (ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
+
+/* The minimum packet length. */
+#define	ETHER_MIN_LEN		        64
+
+/* The minimum packet user data length.*/
+#define	ETHER_MIN_DATA		        46
+
+/* The maximum packet length.*/
+#define	ETHER_MAX_LEN		        1518
+
+/* The maximum packet user data length. */
+#define	ETHER_MAX_DATA		        1500
+
+/* ether types */
+#define ETHER_TYPE_MIN		        0x0600		/* Anything less than MIN is a length */
+#define	ETHER_TYPE_IP		        0x0800		/* IP */
+#define ETHER_TYPE_ARP		        0x0806		/* ARP */
+#define ETHER_TYPE_8021Q	        0x8100		/* 802.1Q */
+#define	ETHER_TYPE_IPV6		        0x86dd		/* IPv6 */
+#define	ETHER_TYPE_BRCM		        0x886c		/* Broadcom Corp. */
+#define	ETHER_TYPE_802_1X	        0x888e		/* 802.1x */
+#define	ETHER_TYPE_802_1X_PREAUTH   0x88c7	/* 802.1x preauthentication */
+#define ETHER_TYPE_WAI		        0x88b4		/* WAI */
+#define ETHER_TYPE_89_0D	        0x890d		/* 89-0d frame for TDLS */
+
+#define ETHER_TYPE_IPV6		        0x86dd		/* IPV6 */
+
+/* ether header */
+#define ETHER_DEST_OFFSET	        (0 * ETHER_ADDR_LEN)	/* dest address offset */
+#define ETHER_SRC_OFFSET	        (1 * ETHER_ADDR_LEN)	/* src address offset */
+#define ETHER_TYPE_OFFSET	        (2 * ETHER_ADDR_LEN)	/* ether type offset */
+
+/*
+ * A macro to validate a length with
+ */
+#define	ETHER_IS_VALID_LEN(foo)	    ((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+#define ETHER_FILL_MCAST_ADDR_FROM_IP(ea, mgrp_ip) {		\
+		((u8 *)ea)[0] = 0x01;			\
+		((u8 *)ea)[1] = 0x00;			\
+		((u8 *)ea)[2] = 0x5e;			\
+		((u8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
+		((u8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
+		((u8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
+}
+
+#ifndef __INCif_etherh     /* Quick and ugly hack for VxWorks */
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+PRE_PACKED struct ether_header {
+	u8	ether_dhost[ETHER_ADDR_LEN];
+	u8	ether_shost[ETHER_ADDR_LEN];
+	u16	ether_type;
+} POST_PACKED;
+
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+PRE_PACKED struct	ether_addr {
+	u8   octet[ETHER_ADDR_LEN];
+} POST_PACKED;
+#endif	/* !__INCif_etherh Quick and ugly hack for VxWorks */
+
+/*
+ * Takes a pointer, set, test, clear, toggle locally admininistered
+ * address bit in the 48-bit Ethernet address.
+ */
+#define ETHER_SET_LOCALADDR(ea)	    (((u8 *)(ea))[0] = (((u8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	    (((u8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	    (((u8 *)(ea))[0] = (((u8 *)(ea))[0] & 0xfd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((u8 *)(ea))[0] = (((u8 *)(ea))[0] ^ 2))
+
+/* Takes a pointer, marks unicast address bit in the MAC address */
+#define ETHER_SET_UNICAST(ea)	    (((u8 *)(ea))[0] = (((u8 *)(ea))[0] & ~1))
+
+/*
+ * Takes a pointer, returns true if a 48-bit multicast address
+ * (including broadcast, since it is all ones)
+ */
+#define ETHER_ISMULTI(ea)           (((const u8 *)(ea))[0] & 1)
+
+
+/* compare two ethernet addresses - assumes the pointers can be referenced as shorts */
+#define	ether_cmp(a, b)	            (!(((short*)(a))[0] == ((short*)(b))[0]) | \
+                        			 !(((short*)(a))[1] == ((short*)(b))[1]) | \
+                        			 !(((short*)(a))[2] == ((short*)(b))[2]))
+
+/* copy an ethernet address - assumes the pointers can be referenced as shorts */
+#define	ether_copy(s, d)            { \
+                            		((short*)(d))[0] = ((const short*)(s))[0]; \
+                            		((short*)(d))[1] = ((const short*)(s))[1]; \
+                            		((short*)(d))[2] = ((const short*)(s))[2]; }
+
+
+static const struct ether_addr      ether_bcast = {{255, 255, 255, 255, 255, 255}};
+static const struct ether_addr      ether_null = {{0, 0, 0, 0, 0, 0}};
+
+#define ETHER_ISBCAST(ea)	        ((((u8 *)(ea))[0] &		\
+        	                          ((u8 *)(ea))[1] &		\
+                    				  ((u8 *)(ea))[2] &		\
+                    				  ((u8 *)(ea))[3] &		\
+                    				  ((u8 *)(ea))[4] &		\
+                    				  ((u8 *)(ea))[5]) == 0xff)
+#define ETHER_ISNULLADDR(ea)	    ((((u8 *)(ea))[0] |		\
+                    				  ((u8 *)(ea))[1] |		\
+                    				  ((u8 *)(ea))[2] |		\
+                    				  ((u8 *)(ea))[3] |		\
+                    				  ((u8 *)(ea))[4] |		\
+                    				  ((u8 *)(ea))[5]) == 0)
+
+#define ETHER_MOVE_HDR(d, s) \
+do { \
+	struct ether_header t; \
+	t = *(struct ether_header *)(s); \
+	*(struct ether_header *)(d) = t; \
+} while (0)
+
+
+#endif /* _ETHERNET_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/linux_osl.h b/drivers/net/wireless/rdaw80211/include/linux_osl.h
new file mode 100644
index 000000000000..3543fec1f32e
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/linux_osl.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LINUX_OSL_H_
+#define _LINUX_OSL_H_
+
+/*
+ * BINOSL selects the slightly slower function-call-based binary compatible osl.
+ * Macros expand to calls to functions defined in linux_osl.c .
+ */
+#include <linuxver.h>           /* use current 2.4.x calling conventions */
+#include <linux/kernel.h>       /* for vsn/printf's */
+#include <linux/string.h>       /* for mem*, str* */
+
+
+typedef void (*pktfree_fn)(void *ctx, void *pkt, unsigned int status);
+
+
+/* OSL initialization */
+extern struct osl_info *osl_attach(void *pdev, uint bustype, bool pkttag);
+extern void osl_detach(struct osl_info *osh);
+
+/* ASSERT */
+#if defined(BCMASSERT_LOG)
+#define ASSERT(exp) \
+	  do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(const char *exp, const char *file, int line);
+#else
+	#ifdef __GNUC__
+		#define GCC_VERSION \
+			(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+		#if GCC_VERSION > 30100
+			#define ASSERT(exp)	do {} while (0)
+		#else
+			/* ASSERT could cause segmentation fault on GCC3.1, use empty instead */
+			#define ASSERT(exp)
+		#endif /* GCC_VERSION > 30100 */
+	#endif /* __GNUC__ */
+#endif 
+
+
+/* Pkttag flag should be part of public information */
+struct osl_pubinfo{
+	bool                pkttag;
+	uint                pktalloced; 	/* Number of allocated packet buffers */
+	bool                mmbus;		    /* Bus supports memory-mapped register accesses */
+	pktfree_fn          tx_fn;          /* Callback function for osl_pktfree */
+	void               *tx_ctx;		    /* Context to the callback function */
+};
+
+struct osl_info {
+	struct osl_pubinfo   pub;
+	uint                 magic;
+	void                *pdev;
+	atomic_t             malloced;
+	uint                 failed;
+	uint                 bustype;
+	spinlock_t           pktalloc_lock;
+};
+
+/* microsecond delay */
+extern void  osl_delay(uint usec);
+extern void *osl_malloc(struct osl_info *osh, uint size);
+extern void  osl_free(struct osl_info *osh, void *addr, uint size);
+extern uint  osl_malloced(struct osl_info *osh);
+
+
+/* packet primitives */
+#define	PKTDATA(osh, skb)		    (((struct sk_buff*)(skb))->data)
+#define	PKTLEN(osh, skb)		    (((struct sk_buff*)(skb))->len)
+#define PKTHEADROOM(osh, skb)		(((struct sk_buff*)(skb))->data-(((struct sk_buff*)(skb))->head))
+#define	PKTNEXT(osh, skb)		    (((struct sk_buff*)(skb))->next)
+#define	PKTSETNEXT(osh, skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
+#define	PKTSETLEN(osh, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
+
+#define	PKTLINK(skb)			    (((struct sk_buff*)(skb))->prev)
+#define	PKTSETLINK(skb, x)		    (((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
+#define	PKTPRIO(skb)			    (((struct sk_buff*)(skb))->priority)
+#define	PKTSETPRIO(skb, x)		    (((struct sk_buff*)(skb))->priority = (x))
+#define PKTSUMNEEDED(skb)		    (((struct sk_buff*)(skb))->ip_summed == CHECKSUM_HW)
+#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff*)(skb))->ip_summed = ((x) ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE))
+
+extern void *osl_open_image(const char* filename, int open_mode, int mode);
+extern int   osl_get_image_block(char * buf, int len, void * image);
+extern void  osl_close_image(void * image);
+
+extern void  osl_pktfree(struct osl_info *osh, void *skb, bool send);
+extern void *osl_pktget(struct osl_info *osh, uint len);
+
+#endif	/* _LINUX_OSL_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/linuxver.h b/drivers/net/wireless/rdaw80211/include/linuxver.h
new file mode 100644
index 000000000000..1fb8707e19be
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/linuxver.h
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _linuxver_h_
+#define _linuxver_h_
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+#include <linux/config.h>
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
+#include <generated/autoconf.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)) */
+#include <linux/module.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0))
+/* __NO_VERSION__ must be defined for all linkables except one in 2.2 */
+#ifdef __UNDEF_NO_VERSION__
+#undef __NO_VERSION__
+#else
+#define __NO_VERSION__
+#endif
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define module_param(_name_, _type_, _perm_)	                MODULE_PARM(_name_, "i")
+#define module_param_string(_name_, _string_, _size_, _perm_) 	MODULE_PARM(_string_, "c" __MODULE_STRING(_size_))
+#endif
+
+/* linux/malloc.h is deprecated, use linux/slab.h instead. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 9))
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#undef IP_TOS
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)) */
+#include <asm/io.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+#include <linux/workqueue.h>
+#else
+#include <linux/tqueue.h>
+#ifndef work_struct
+#define work_struct                 tq_struct
+#endif
+#ifndef INIT_WORK
+#define INIT_WORK(_work, _func, _data)  INIT_TQUEUE((_work), (_func), (_data))
+#endif
+#ifndef schedule_work
+#define schedule_work(_work)        schedule_task((_work))
+#endif
+#ifndef flush_scheduled_work
+#define flush_scheduled_work()      flush_scheduled_tasks()
+#endif
+#endif	/* LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define DAEMONIZE(a)                daemonize(a); \
+                    	            allow_signal(SIGKILL); \
+                    	            allow_signal(SIGTERM);
+#else /* Linux 2.4 (w/o preemption patch) */
+#define RAISE_RX_SOFTIRQ() 	        cpu_raise_softirq(smp_processor_id(), NET_RX_SOFTIRQ)
+#define DAEMONIZE(a)                daemonize(); \
+                                	do { if (a) \
+                                		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a)))); \
+                                	} while (0);
+#endif /* LINUX_VERSION_CODE  */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#ifdef	CONFIG_NET_RADIO
+#define	CONFIG_WIRELESS_EXT
+#endif
+#endif	/* < 2.6.17 */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+#include <linux/sched.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
+#include <net/lib80211.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
+#include <linux/ieee80211.h>
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14)
+#include <net/ieee80211.h>
+#endif
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30) */
+
+
+#ifndef __exit
+#define __exit
+#endif
+#ifndef __devexit
+#define __devexit
+#endif
+#ifndef __devinit
+#define __devinit	__init
+#endif
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+#ifndef __devexit_p
+#define __devexit_p(x)	x
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18))
+#ifdef MODULE
+#define module_init(x) 	int  init_module(void) { return x(); }
+#define module_exit(x) 	void cleanup_module(void) { x(); }
+#else
+#define module_init(x)	__initcall(x);
+#define module_exit(x)	__exitcall(x);
+#endif
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 48))
+#define list_for_each(pos, head) 	    for (pos = (head)->next; pos != (head); pos = pos->next)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 14))
+#define net_device                      device
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 43))
+#define dev_kfree_skb_any(a)		    dev_kfree_skb(a)
+#define netif_down(dev)			        do { (dev)->start = 0; } while (0)
+
+/* pcmcia-cs provides its own netdevice compatibility layer */
+#ifndef _COMPAT_NETDEVICE_H
+/*
+ * SoftNet
+ *
+ * For pre-softnet kernels we need to tell the upper layer not to
+ * re-enter start_xmit() while we are in there. However softnet
+ * guarantees not to enter while we are in there so there is no need
+ * to do the netif_stop_queue() dance unless the transmit queue really
+ * gets stuck. This should also improve performance according to tests
+ * done by Aman Singla.
+ */
+
+#define dev_kfree_skb_irq(a)	        dev_kfree_skb(a)
+#define netif_wake_queue(dev) 	        do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while (0)
+#define netif_stop_queue(dev)	        set_bit(0, &(dev)->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy      = 0;
+	dev->interrupt  = 0;
+	dev->start      = 1;
+}
+
+#define netif_queue_stopped(dev)	    (dev)->tbusy
+#define netif_running(dev)		        (dev)->start
+
+#endif /* _COMPAT_NETDEVICE_H */
+
+/* 2.4.x renamed bottom halves to tasklets */
+#define tasklet_struct				    tq_struct
+
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet, void (*func)(unsigned long), unsigned long data)
+{
+	tasklet->next    = NULL;
+	tasklet->sync    = 0;
+	tasklet->routine = (void (*)(void *))func;
+	tasklet->data    = (void *)data;
+}
+#define tasklet_kill(tasklet)	        { do {} while (0); }
+
+/* 2.4.x introduced del_timer_sync() */
+#define del_timer_sync(timer)           del_timer(timer)
+#else
+#define netif_down(dev)
+#endif /* SoftNet */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3))
+/* Emit code to initialise a tq_struct's routine and data pointers */
+#define PREPARE_TQUEUE(_tq, _routine, _data)	\
+	do {							            \
+		(_tq)->routine = _routine;			    \
+		(_tq)->data    = _data;				    \
+	} while (0)
+
+/* Emit code to initialise all of a tq_struct */
+#define INIT_TQUEUE(_tq, _routine, _data)		\
+	do {							            \
+		INIT_LIST_HEAD(&(_tq)->list);			\
+		(_tq)->sync = 0;				        \
+		PREPARE_TQUEUE((_tq), (_routine), (_data));	\
+	} while (0)
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3) */
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#define CHECKSUM_HW	                CHECKSUM_PARTIAL
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19) */
+
+struct tsk_ctl{
+	void 	            *parent;  /* some external entity that the thread supposed to work for */
+	struct	task_struct *p_task;
+	long 	             thr_pid;
+	int 	             prio; /* priority */
+	struct	semaphore    sema;
+	int	                 terminated;
+	struct	completion   completed;
+};
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define SMP_RD_BARRIER_DEPENDS(x)   smp_read_barrier_depends(x)
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)*/
+#define SMP_RD_BARRIER_DEPENDS(x)   smp_rmb(x)
+#endif/*LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)*/
+
+#define PROC_START(thread_func, owner, tsk_ctl, flags) \
+{ \
+	sema_init(&((tsk_ctl)->sema), 0); \
+	init_completion(&((tsk_ctl)->completed)); \
+	(tsk_ctl)->parent     = owner; \
+	(tsk_ctl)->terminated = false; \
+	(tsk_ctl)->thr_pid = kernel_thread(thread_func, tsk_ctl, flags); \
+	WLAND_DBG(DEFAULT, TRACE,"thr:%lx created\n", (tsk_ctl)->thr_pid); \
+	if ((tsk_ctl)->thr_pid > 0) \
+		wait_for_completion(&((tsk_ctl)->completed)); \
+	WLAND_DBG(DEFAULT, TRACE,"thr:%lx started\n", (tsk_ctl)->thr_pid); \
+}
+
+#define PROC_STOP(tsk_ctl) \
+{ \
+	(tsk_ctl)->terminated = true; \
+	smp_wmb(); \
+	up(&((tsk_ctl)->sema));	\
+	wait_for_completion(&((tsk_ctl)->completed)); \
+	WLAND_DBG(DEFAULT, TRACE,"thr:%lx terminated OK\n", (tsk_ctl)->thr_pid); \
+	(tsk_ctl)->thr_pid = -1; \
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
+#define KILL_PROC(nr, sig) \
+{ \
+    struct task_struct *tsk; \
+    struct pid *pid;                 \
+    pid = find_get_pid((pid_t)nr);   \
+    tsk = pid_task(pid, PIDTYPE_PID);\
+    if (tsk) send_sig(sig, tsk, 1);  \
+}
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30))
+#define KILL_PROC(pid, sig) \
+{ \
+	struct task_struct *tsk; \
+	tsk = find_task_by_vpid(pid); \
+	if (tsk) send_sig(sig, tsk, 1); \
+}
+#else
+#define KILL_PROC(pid, sig) \
+{ \
+	kill_proc(pid, sig, 1); \
+}
+#endif
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#include <linux/time.h>
+#include <linux/wait.h>
+#else
+#include <linux/sched.h>
+
+#define __wait_event_interruptible_timeout(wq, condition, ret)		\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			ret = schedule_timeout(ret);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+
+#define wait_event_interruptible_timeout(wq, condition, timeout)	\
+({									\
+	long __ret = timeout;						\
+	if (!(condition))						\
+		__wait_event_interruptible_timeout(wq, condition, __ret); \
+	__ret;								\
+})
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+#define netdev_priv(dev)            dev->priv
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)) */
+
+/* Detect compiler type. */
+#if defined(__GNUC__) || defined(__lint)
+	#define GNU_COMPILER
+#elif defined(__CC_ARM) && __CC_ARM
+	#define ARMCC_COMPILER
+#else
+	#error "Unknown compiler!"
+#endif 
+
+/* Declare compiler-specific directives for structure packing. */
+#if defined(__GNUC__) || defined(__lint)
+	#define	PRE_PACKED
+	#define	POST_PACKED	__attribute__ ((packed))
+#elif defined(__CC_ARM)
+	#define	PRE_PACKED	__packed
+	#define	POST_PACKED
+#else
+	#error "Unknown Compiler!"
+#endif
+
+#ifndef INLINE
+	#if defined(MICROSOFT_COMPILER)
+		#define INLINE __inline
+	#elif defined(GNU_COMPILER)
+		#define INLINE __inline__
+	#elif defined(ARMCC_COMPILER)
+		#define INLINE	__inline
+	#else
+		#define INLINE
+	#endif 
+#endif /* INLINE */
+
+#endif /* _linuxver_h_ */
diff --git a/drivers/net/wireless/rdaw80211/include/p2p.h b/drivers/net/wireless/rdaw80211/include/p2p.h
new file mode 100644
index 000000000000..7b94cba16085
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/p2p.h
@@ -0,0 +1,498 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _P2P_H_
+#define _P2P_H_
+
+
+#include <802.11.h>
+
+
+/* WiFi P2P OUI values */
+#define P2P_OUI			        WFA_OUI			/* WiFi P2P OUI */
+#define P2P_VER			        WFA_OUI_TYPE_P2P	/* P2P version: 9=WiFi P2P v1.0 */
+
+#define P2P_IE_ID		        0xdd			/* P2P IE element ID */
+
+/* WiFi P2P IE */
+PRE_PACKED struct wifi_p2p_ie {
+	u8	id;		/* IE ID: 0xDD */
+	u8	len;		/* IE length */
+	u8	OUI[3];		/* WiFi P2P specific OUI: P2P_OUI */
+	u8	oui_type;	/* Identifies P2P version: P2P_VER */
+	u8	subelts[1];	/* variable length subelements */
+} POST_PACKED;
+
+#define P2P_IE_FIXED_LEN	    6
+
+#define P2P_ATTR_ID_OFF		    0
+#define P2P_ATTR_LEN_OFF	    1
+#define P2P_ATTR_DATA_OFF	    3
+
+#define P2P_ATTR_ID_LEN		    1	/* ID filed length */
+#define P2P_ATTR_LEN_LEN	    2	/* length field length */
+#define P2P_ATTR_HDR_LEN	    3 /* ID + 2-byte length field spec 1.02 */
+
+/* P2P IE Subelement IDs from WiFi P2P Technical Spec 1.00 */
+#define P2P_SEID_STATUS			0	/* Status */
+#define P2P_SEID_MINOR_RC		1	/* Minor Reason Code */
+#define P2P_SEID_P2P_INFO		2	/* P2P Capability (capabilities info) */
+#define P2P_SEID_DEV_ID			3	/* P2P Device ID */
+#define P2P_SEID_INTENT			4	/* Group Owner Intent */
+#define P2P_SEID_CFG_TIMEOUT	5	/* Configuration Timeout */
+#define P2P_SEID_CHANNEL		6	/* Channel */
+#define P2P_SEID_GRP_BSSID		7	/* P2P Group BSSID */
+#define P2P_SEID_XT_TIMING		8	/* Extended Listen Timing */
+#define P2P_SEID_INTINTADDR		9	/* Intended P2P Interface Address */
+#define P2P_SEID_P2P_MGBTY		10	/* P2P Manageability */
+#define P2P_SEID_CHAN_LIST		11	/* Channel List */
+#define P2P_SEID_ABSENCE		12	/* Notice of Absence */
+#define P2P_SEID_DEV_INFO		13	/* Device Info */
+#define P2P_SEID_GROUP_INFO		14	/* Group Info */
+#define P2P_SEID_GROUP_ID		15	/* Group ID */
+#define P2P_SEID_P2P_IF			16	/* P2P Interface */
+#define P2P_SEID_OP_CHANNEL		17	/* Operating Channel */
+#define P2P_SEID_INVITE_FLAGS	18	/* Invitation Flags */
+#define P2P_SEID_VNDR			221	/* Vendor-specific subelement */
+
+#define P2P_SE_VS_ID_SERVICES	0x1b /* BRCM proprietary subel: L2 Services */
+
+
+/* WiFi P2P IE subelement: P2P Capability (capabilities info) */
+PRE_PACKED struct wifi_p2p_info_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_P2P_INFO */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	dev;		/* Device Capability Bitmap */
+	u8	group;		/* Group Capability Bitmap */
+} POST_PACKED;
+
+/* P2P Capability subelement's Device Capability Bitmap bit values */
+#define P2P_CAPSE_DEV_SERVICE_DIS	0x1 /* Service Discovery */
+#define P2P_CAPSE_DEV_CLIENT_DIS	0x2 /* Client Discoverability */
+#define P2P_CAPSE_DEV_CONCURRENT	0x4 /* Concurrent Operation */
+#define P2P_CAPSE_DEV_INFRA_MAN		0x8 /* P2P Infrastructure Managed */
+#define P2P_CAPSE_DEV_LIMIT			0x10 /* P2P Device Limit */
+#define P2P_CAPSE_INVITE_PROC		0x20 /* P2P Invitation Procedure */
+
+/* P2P Capability subelement's Group Capability Bitmap bit values */
+#define P2P_CAPSE_GRP_OWNER			0x1 /* P2P Group Owner */
+#define P2P_CAPSE_PERSIST_GRP		0x2 /* Persistent P2P Group */
+#define P2P_CAPSE_GRP_LIMIT			0x4 /* P2P Group Limit */
+#define P2P_CAPSE_GRP_INTRA_BSS		0x8 /* Intra-BSS Distribution */
+#define P2P_CAPSE_GRP_X_CONNECT		0x10 /* Cross Connection */
+#define P2P_CAPSE_GRP_PERSISTENT	0x20 /* Persistent Reconnect */
+#define P2P_CAPSE_GRP_FORMATION		0x40 /* Group Formation */
+
+/* WiFi P2P IE subelement: Group Owner Intent */
+PRE_PACKED struct wifi_p2p_intent_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_INTENT */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	intent;		/* Intent Value 0...15 (0=legacy 15=master only) */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: Configuration Timeout */
+PRE_PACKED struct wifi_p2p_cfg_tmo_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_CFG_TIMEOUT */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	go_tmo;		/* GO config timeout in units of 10 ms */
+	u8	client_tmo;	/* Client config timeout in units of 10 ms */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: Listen Channel */
+PRE_PACKED struct wifi_p2p_listen_channel_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_CHANNEL */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	country[3];	/* Country String */
+	u8	op_class;	/* Operating Class */
+	u8	channel;	/* Channel */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: P2P Group BSSID */
+PRE_PACKED struct wifi_p2p_grp_bssid_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_GRP_BSSID */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	mac[6];		/* P2P group bssid */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: P2P Group ID */
+PRE_PACKED struct wifi_p2p_grp_id_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_GROUP_ID */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	mac[6];		/* P2P device address */
+	u8	ssid[1];	/* ssid. device id. variable length */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: P2P Interface */
+PRE_PACKED struct wifi_p2p_intf_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_P2P_IF */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	mac[6];		/* P2P device address */
+	u8	ifaddrs;	/* P2P Interface Address count */
+	u8	ifaddr[1][6];	/* P2P Interface Address list */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: Status */
+PRE_PACKED struct wifi_p2p_status_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_STATUS */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	status;		/* Status Code: P2P_STATSE_* */
+} POST_PACKED;
+
+/* Status subelement Status Code definitions */
+#define P2P_STATSE_SUCCESS			0
+				/* Success */
+#define P2P_STATSE_FAIL_INFO_CURR_UNAVAIL	1	/* Failed, information currently unavailable */
+#define P2P_STATSE_PASSED_UP				P2P_STATSE_FAIL_INFO_CURR_UNAVAIL
+				/* Old name for above in P2P spec 1.08 and older */
+#define P2P_STATSE_FAIL_INCOMPAT_PARAMS		2	/* Failed, incompatible parameters */
+#define P2P_STATSE_FAIL_LIMIT_REACHED		3	/* Failed, limit reached */
+#define P2P_STATSE_FAIL_INVALID_PARAMS		4	/* Failed, invalid parameters */
+#define P2P_STATSE_FAIL_UNABLE_TO_ACCOM		5	/* Failed, unable to accomodate request */
+#define P2P_STATSE_FAIL_PROTO_ERROR			6	/* Failed, previous protocol error or disruptive behaviour */
+#define P2P_STATSE_FAIL_NO_COMMON_CHAN		7	/* Failed, no common channels */
+#define P2P_STATSE_FAIL_UNKNOWN_GROUP		8	/* Failed, unknown P2P Group */
+#define P2P_STATSE_FAIL_INTENT				9	/* Failed, both peers indicated Intent 15 in GO Negotiation */
+#define P2P_STATSE_FAIL_INCOMPAT_PROVIS		10	/* Failed, incompatible provisioning method */
+#define P2P_STATSE_FAIL_USER_REJECT			11	/* Failed, rejected by user */
+
+/* WiFi P2P IE attribute: Extended Listen Timing */
+PRE_PACKED struct wifi_p2p_ext_se_s {
+	u8	eltId;		/* ID: P2P_SEID_EXT_TIMING */
+	u8	len[2];		/* length not including eltId, len fields */
+	u8	avail[2];	/* availibility period */
+	u8	interval[2];	/* availibility interval */
+} POST_PACKED;
+
+#define P2P_EXT_MIN	10	/* minimum 10ms */
+
+/* WiFi P2P IE subelement: Intended P2P Interface Address */
+PRE_PACKED struct wifi_p2p_intintad_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_INTINTADDR */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	mac[6];		/* intended P2P interface MAC address */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: Channel */
+PRE_PACKED struct wifi_p2p_channel_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_STATUS */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	band;		/* Regulatory Class (band) */
+	u8	channel;	/* Channel */
+} POST_PACKED;
+
+/* Channel Entry structure within the Channel List SE */
+PRE_PACKED struct wifi_p2p_chanlist_entry_s {
+	u8	band;						/* Regulatory Class (band) */
+	u8	num_channels;				/* # of channels in the channel list */
+	u8	channels[WL_NUMCHANNELS];	/* Channel List */
+} POST_PACKED;
+
+#define WIFI_P2P_CHANLIST_SE_MAX_ENTRIES 2
+
+/* WiFi P2P IE subelement: Channel List */
+PRE_PACKED struct wifi_p2p_chanlist_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_CHAN_LIST */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	country[3];	/* Country String */
+	u8	num_entries;	/* # of channel entries */
+	struct wifi_p2p_chanlist_entry_s	entries[WIFI_P2P_CHANLIST_SE_MAX_ENTRIES];
+						/* Channel Entry List */
+} POST_PACKED;
+
+/* WiFi Primary Device Type structure */
+PRE_PACKED struct wifi_p2p_pri_devtype_s {
+	u16	cat_id;		/* Category ID */
+	u8	OUI[3];		/* WFA OUI: 0x0050F2 */
+	u8	oui_type;	/* WPS_OUI_TYPE */
+	u16	sub_cat_id;	/* Sub Category ID */
+} POST_PACKED;
+
+/* WiFi P2P IE's Device Info subelement */
+PRE_PACKED struct wifi_p2p_devinfo_se_s {
+	u8	eltId;			/* SE ID: P2P_SEID_DEVINFO */
+	u8	len[2];			/* SE length not including eltId, len fields */
+	u8	mac[6];			/* P2P Device MAC address */
+	u16	wps_cfg_meths;		/* Config Methods: reg_prototlv.h WPS_CONFMET_* */
+	u8	pri_devtype[8];		/* Primary Device Type */
+} POST_PACKED;
+
+#define P2P_DEV_TYPE_LEN	8
+
+/* WiFi P2P IE's Group Info subelement Client Info Descriptor */
+PRE_PACKED struct wifi_p2p_cid_fixed_s {
+	u8	len;
+	u8	devaddr[ETHER_ADDR_LEN];	/* P2P Device Address */
+	u8	ifaddr[ETHER_ADDR_LEN];		/* P2P Interface Address */
+	u8	devcap;				/* Device Capability */
+	u8	cfg_meths[2];			/* Config Methods: reg_prototlv.h WPS_CONFMET_* */
+	u8	pridt[P2P_DEV_TYPE_LEN];	/* Primary Device Type */
+	u8	secdts;				/* Number of Secondary Device Types */
+} POST_PACKED;
+
+/* WiFi P2P IE's Device ID subelement */
+PRE_PACKED struct wifi_p2p_devid_se_s {
+	u8	eltId;
+	u8	len[2];
+	struct ether_addr	addr;			/* P2P Device MAC address */
+} POST_PACKED;
+
+/* WiFi P2P IE subelement: P2P Manageability */
+PRE_PACKED struct wifi_p2p_mgbt_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_P2P_MGBTY */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	mg_bitmap;	/* manageability bitmap */
+} POST_PACKED;
+
+/* mg_bitmap field bit values */
+#define P2P_MGBTSE_P2PDEVMGMT_FLAG   0x1 /* AP supports Managed P2P Device */
+
+/* WiFi P2P IE subelement: Group Info */
+PRE_PACKED struct wifi_p2p_grpinfo_se_s {
+	u8	eltId;			/* SE ID: P2P_SEID_GROUP_INFO */
+	u8	len[2];			/* SE length not including eltId, len fields */
+} POST_PACKED;
+
+/* WiFi IE subelement: Operating Channel */
+PRE_PACKED struct wifi_p2p_op_channel_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_OP_CHANNEL */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	country[3];	/* Country String */
+	u8	op_class;	/* Operating Class */
+	u8	channel;	/* Channel */
+} POST_PACKED;
+
+/* WiFi IE subelement: INVITATION FLAGS */
+PRE_PACKED struct wifi_p2p_invite_flags_se_s {
+	u8	eltId;		/* SE ID: P2P_SEID_INVITE_FLAGS */
+	u8	len[2];		/* SE length not including eltId, len fields */
+	u8	flags;		/* Flags */
+} POST_PACKED;
+
+/* WiFi P2P Action Frame */
+PRE_PACKED struct wifi_p2p_action_frame {
+	u8	category;	/* P2P_AF_CATEGORY */
+	u8	OUI[3];		/* OUI - P2P_OUI */
+	u8	type;		/* OUI Type - P2P_VER */
+	u8	subtype;	/* OUI Subtype - P2P_AF_* */
+	u8	dialog_token;	/* nonzero, identifies req/resp tranaction */
+	u8	elts[1];	/* Variable length information elements.  Max size =
+				 * ACTION_FRAME_SIZE - sizeof(this structure) - 1
+				 */
+} POST_PACKED;
+
+#define P2P_AF_CATEGORY		        0x7f
+#define P2P_AF_FIXED_LEN	        7
+
+/* WiFi P2P Action Frame OUI Subtypes */
+#define P2P_AF_NOTICE_OF_ABSENCE	0	/* Notice of Absence */
+#define P2P_AF_PRESENCE_REQ		    1	/* P2P Presence Request */
+#define P2P_AF_PRESENCE_RSP		    2	/* P2P Presence Response */
+#define P2P_AF_GO_DISC_REQ		    3	/* GO Discoverability Request */
+
+
+/* WiFi P2P Public Action Frame */
+PRE_PACKED struct wifi_p2p_pub_act_frame {
+	u8	category;	/* P2P_PUB_AF_CATEGORY */
+	u8	action;		/* P2P_PUB_AF_ACTION */
+	u8	oui[3];		/* P2P_OUI */
+	u8	oui_type;	/* OUI type - P2P_VER */
+	u8	subtype;	/* OUI subtype - P2P_TYPE_* */
+	u8	dialog_token;	/* nonzero, identifies req/rsp transaction */
+	u8	elts[1];	/* Variable length information elements.  Max size =
+        				 * ACTION_FRAME_SIZE - sizeof(this structure) - 1
+        				 */
+} POST_PACKED;
+
+#define P2P_PUB_AF_FIXED_LEN	8
+#define P2P_PUB_AF_CATEGORY	    0x04
+#define P2P_PUB_AF_ACTION	    0x09
+
+/* WiFi P2P Public Action Frame OUI Subtypes */
+#define P2P_PAF_GON_REQ		    0	/* Group Owner Negotiation Req */
+#define P2P_PAF_GON_RSP		    1	/* Group Owner Negotiation Rsp */
+#define P2P_PAF_GON_CONF	    2	/* Group Owner Negotiation Confirm */
+#define P2P_PAF_INVITE_REQ	    3	/* P2P Invitation Request */
+#define P2P_PAF_INVITE_RSP	    4	/* P2P Invitation Response */
+#define P2P_PAF_DEVDIS_REQ	    5	/* Device Discoverability Request */
+#define P2P_PAF_DEVDIS_RSP	    6	/* Device Discoverability Response */
+#define P2P_PAF_PROVDIS_REQ	    7	/* Provision Discovery Request */
+#define P2P_PAF_PROVDIS_RSP	    8	/* Provision Discovery Response */
+#define P2P_PAF_SUBTYPE_INVALID	255	/* Invalid Subtype */
+
+/* TODO: Stop using these obsolete aliases for P2P_PAF_GON_* */
+#define P2P_TYPE_MNREQ		P2P_PAF_GON_REQ
+#define P2P_TYPE_MNRSP		P2P_PAF_GON_RSP
+#define P2P_TYPE_MNCONF		P2P_PAF_GON_CONF
+
+/* WiFi P2P IE subelement: Notice of Absence */
+PRE_PACKED struct wifi_p2p_noa_desc {
+	u8	cnt_type;	/* Count/Type */
+	u32	duration;	/* Duration */
+	u32	interval;	/* Interval */
+	u32	start;		/* Start Time */
+} POST_PACKED;
+
+PRE_PACKED struct wifi_p2p_noa_se {
+	u8	eltId;		/* Subelement ID */
+	u8	len[2];		/* Length */
+	u8	index;		/* Index */
+	u8	ops_ctw_parms;	/* CTWindow and OppPS Parameters */
+	struct wifi_p2p_noa_desc	desc[1];	/* Notice of Absence Descriptor(s) */
+} POST_PACKED;
+
+#define P2P_NOA_SE_FIXED_LEN	5
+
+/* cnt_type field values */
+#define P2P_NOA_DESC_CNT_RESERVED	0	/* reserved and should not be used */
+#define P2P_NOA_DESC_CNT_REPEAT		255	/* continuous schedule */
+#define P2P_NOA_DESC_TYPE_PREFERRED	1	/* preferred values */
+#define P2P_NOA_DESC_TYPE_ACCEPTABLE	2	/* acceptable limits */
+
+/* ctw_ops_parms field values */
+#define P2P_NOA_CTW_MASK	0x7f
+#define P2P_NOA_OPS_MASK	0x80
+#define P2P_NOA_OPS_SHIFT	7
+
+#define P2P_CTW_MIN	10	/* minimum 10TU */
+
+/*
+ * P2P Service Discovery related
+ */
+#define	P2PSD_ACTION_CATEGORY		0x04	/* Public action frame */
+#define	P2PSD_ACTION_ID_GAS_IREQ	0x0a    /* Action value for GAS Initial Request AF */
+#define	P2PSD_ACTION_ID_GAS_IRESP	0x0b	/* Action value for GAS Initial Response AF */
+#define	P2PSD_ACTION_ID_GAS_CREQ	0x0c	/* Action value for GAS Comback Request AF */
+#define	P2PSD_ACTION_ID_GAS_CRESP	0x0d	/* Action value for GAS Comback Response AF */
+#define P2PSD_AD_EID				0x6c	/* Advertisement Protocol IE ID */
+#define P2PSD_ADP_TUPLE_QLMT_PAMEBI	0x00	/* Query Response Length Limit 7 bits plus PAME-BI 1 bit */
+#define P2PSD_ADP_PROTO_ID			0x00	/* Advertisement Protocol ID. Always 0 for P2P SD */
+#define P2PSD_GAS_OUI				P2P_OUI	/* WFA OUI */
+#define P2PSD_GAS_OUI_SUBTYPE		P2P_VER	/* OUI Subtype for GAS IE */
+#define P2PSD_GAS_NQP_INFOID		0xDDDD	/* NQP Query Info ID: 56797 */
+#define P2PSD_GAS_COMEBACKDEALY		0x00	/* Not used in the Native GAS protocol */
+
+/* Service Protocol Type */
+enum p2psd_svc_protype {
+	SVC_RPOTYPE_ALL = 0,
+	SVC_RPOTYPE_BONJOUR = 1,
+	SVC_RPOTYPE_UPNP = 2,
+	SVC_RPOTYPE_WSD = 3,
+	SVC_RPOTYPE_VENDOR = 255
+} ;
+
+/* Service Discovery response status code */
+enum p2psd_resp_status{
+	P2PSD_RESP_STATUS_SUCCESS = 0,
+	P2PSD_RESP_STATUS_PROTYPE_NA = 1,
+	P2PSD_RESP_STATUS_DATA_NA = 2,
+	P2PSD_RESP_STATUS_BAD_REQUEST = 3
+} ;
+
+/* Advertisement Protocol IE tuple field */
+PRE_PACKED struct wifi_p2psd_adp_tpl {
+	u8	llm_pamebi;	/* Query Response Length Limit bit 0-6, set to 0 plus
+            				* Pre-Associated Message Exchange BSSID Independent bit 7, set to 0
+            				*/
+	u8	adp_id;		/* Advertisement Protocol ID: 0 for NQP Native Query Protocol */
+} POST_PACKED;
+
+/* Advertisement Protocol IE */
+PRE_PACKED struct wifi_p2psd_adp_ie {
+	u8	                    id;		/* IE ID: 0x6c - 108 */
+	u8	                    len;	/* IE length */
+	struct wifi_p2psd_adp_tpl   adp_tpl;/* Advertisement Protocol Tuple field. Only one
+                    				* tuple is defined for P2P Service Discovery
+                    				*/
+} POST_PACKED;
+
+/* NQP Vendor-specific Content */
+PRE_PACKED struct wifi_p2psd_nqp_query_vsc {
+	u8	oui_subtype;	/* OUI Subtype: 0x09 */
+	u16	svc_updi;		/* Service Update Indicator */
+	u8	svc_tlvs[1];	/* wifi_p2psd_qreq_tlv_t type for service request,
+            				 * wifi_p2psd_qresp_tlv_t type for service response
+            				 */
+} POST_PACKED;
+
+/* Service Request TLV */
+PRE_PACKED struct wifi_p2psd_qreq_tlv {
+	u16	len;			/* Length: 5 plus size of Query Data */
+	u8	svc_prot;		/* Service Protocol Type */
+	u8	svc_tscid;		/* Service Transaction ID */
+	u8	query_data[1];	/* Query Data, passed in from above Layer 2 */
+} POST_PACKED;
+
+/* Query Request Frame, defined in generic format, instead of NQP specific */
+PRE_PACKED struct wifi_p2psd_qreq_frame {
+	u16	info_id;	    /* Info ID: 0xDDDD */
+	u16	len;		    /* Length of service request TLV, 5 plus the size of request data */
+	u8	oui[3];		    /* WFA OUI: 0x0050F2 */
+	u8	qreq_vsc[1];    /* Vendor-specific Content: wifi_p2psd_nqp_query_vsc_t type for NQP */
+} POST_PACKED;
+
+/* GAS Initial Request AF body, "elts" in wifi_p2p_pub_act_frame */
+PRE_PACKED struct wifi_p2psd_gas_ireq_frame {
+	struct wifi_p2psd_adp_ie	adp_ie;		/* Advertisement Protocol IE */
+	u16					    qreq_len;	/* Query Request Length */
+	u8	                    qreq_frm[1];	/* Query Request Frame wifi_p2psd_qreq_frame_t */
+} POST_PACKED;
+
+/* Service Response TLV */
+PRE_PACKED struct wifi_p2psd_qresp_tlv {
+	u16	len;			/* Length: 5 plus size of Query Data */
+	u8	svc_prot;		/* Service Protocol Type */
+	u8	svc_tscid;		/* Service Transaction ID */
+	u8	status;			/* Value defined in Table 57 of P2P spec. */
+	u8	query_data[1];	/* Response Data, passed in from above Layer 2 */
+} POST_PACKED;
+
+/* Query Response Frame, defined in generic format, instead of NQP specific */
+PRE_PACKED struct wifi_p2psd_qresp_frame {
+	u16	info_id;	    /* Info ID: 0xDDDD */
+	u16	len;		    /* Lenth of service response TLV, 6 plus the size of resp data */
+	u8	oui[3];		    /* WFA OUI: 0x0050F2 */
+	u8	qresp_vsc[1];   /* Vendor-specific Content: wifi_p2psd_qresp_tlv_t type for NQP */
+
+} POST_PACKED;
+
+/* GAS Initial Response AF body, "elts" in wifi_p2p_pub_act_frame */
+PRE_PACKED struct wifi_p2psd_gas_iresp_frame {
+	u16	                    status;			/* Value defined in Table 7-23 of IEEE P802.11u */
+	u16	                    cb_delay;		/* GAS Comeback Delay */
+	struct wifi_p2psd_adp_ie	adp_ie;		/* Advertisement Protocol IE */
+	u16		                qresp_len;	/* Query Response Length */
+	u8	                    qresp_frm[1];	/* Query Response Frame wifi_p2psd_qresp_frame_t */
+} POST_PACKED;
+
+/* GAS Comeback Response AF body, "elts" in wifi_p2p_pub_act_frame */
+PRE_PACKED struct wifi_p2psd_gas_cresp_frame {
+	u16	                    status;			/* Value defined in Table 7-23 of IEEE P802.11u */
+	u8	                    fragment_id;	/* Fragmentation ID */
+	u16	                    cb_delay;		/* GAS Comeback Delay */
+	struct wifi_p2psd_adp_ie	adp_ie;		/* Advertisement Protocol IE */
+	u16	                    qresp_len;		/* Query Response Length */
+	u8	                    qresp_frm[1];	/* Query Response Frame wifi_p2psd_qresp_frame_t */
+} POST_PACKED;
+
+/* Wi-Fi GAS Public Action Frame */
+PRE_PACKED struct wifi_p2psd_gas_pub_act_frame {
+	u8	category;		/* 0x04 Public Action Frame */
+	u8	action;			/* 0x6c Advertisement Protocol */
+	u8	dialog_token;	/* nonzero, identifies req/rsp transaction */
+	u8	query_data[1];	/* Query Data. wifi_p2psd_gas_ireq_frame_t or wifi_p2psd_gas_iresp_frame_t format */
+} POST_PACKED;
+
+#endif /* _P2P_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/wland_bt_amp.h b/drivers/net/wireless/rdaw80211/include/wland_bt_amp.h
new file mode 100644
index 000000000000..933ab3c74b4d
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/wland_bt_amp.h
@@ -0,0 +1,439 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_BT_AMP_H_
+#define _WLAND_BT_AMP_H_
+
+#define BT_SIG_SNAP_MPROT						"\xAA\xAA\x03\x00\x19\x58"
+
+/* BT-AMP 802.11 PAL Protocols */
+#define BTA_PROT_L2CAP								1
+#define	BTA_PROT_ACTIVITY_REPORT					2
+#define BTA_PROT_SECURITY							3
+#define BTA_PROT_LINK_SUPERVISION_REQUEST			4
+#define BTA_PROT_LINK_SUPERVISION_REPLY				5
+
+/* BT-AMP 802.11 PAL AMP_ASSOC Type IDs */
+#define BTA_TYPE_ID_MAC_ADDRESS						1
+#define BTA_TYPE_ID_PREFERRED_CHANNELS				2
+#define BTA_TYPE_ID_CONNECTED_CHANNELS				3
+#define BTA_TYPE_ID_CAPABILITIES					4
+#define BTA_TYPE_ID_VERSION							5
+
+
+/* AMP HCI CMD packet format */
+typedef PRE_PACKED struct amp_hci_cmd {
+	u16 opcode;
+	u8 plen;
+	u8 parms[1];
+} POST_PACKED amp_hci_cmd_t;
+
+#define HCI_CMD_PREAMBLE_SIZE				OFFSETOF(amp_hci_cmd_t, parms)
+#define HCI_CMD_DATA_SIZE					255
+
+/* AMP HCI CMD opcode layout */
+#define HCI_CMD_OPCODE(ogf, ocf)			((((ogf) & 0x3F) << 10) | ((ocf) & 0x03FF))
+#define HCI_CMD_OGF(opcode)					((u8)(((opcode) >> 10) & 0x3F))
+#define HCI_CMD_OCF(opcode)					((opcode) & 0x03FF)
+
+/* AMP HCI command opcodes */
+#define HCI_Read_Failed_Contact_Counter		HCI_CMD_OPCODE(0x05, 0x0001)
+#define HCI_Reset_Failed_Contact_Counter	HCI_CMD_OPCODE(0x05, 0x0002)
+#define HCI_Read_Link_Quality				HCI_CMD_OPCODE(0x05, 0x0003)
+#define HCI_Read_Local_AMP_Info				HCI_CMD_OPCODE(0x05, 0x0009)
+#define HCI_Read_Local_AMP_ASSOC			HCI_CMD_OPCODE(0x05, 0x000A)
+#define HCI_Write_Remote_AMP_ASSOC			HCI_CMD_OPCODE(0x05, 0x000B)
+#define HCI_Create_Physical_Link			HCI_CMD_OPCODE(0x01, 0x0035)
+#define HCI_Accept_Physical_Link_Request	HCI_CMD_OPCODE(0x01, 0x0036)
+#define HCI_Disconnect_Physical_Link		HCI_CMD_OPCODE(0x01, 0x0037)
+#define HCI_Create_Logical_Link				HCI_CMD_OPCODE(0x01, 0x0038)
+#define HCI_Accept_Logical_Link				HCI_CMD_OPCODE(0x01, 0x0039)
+#define HCI_Disconnect_Logical_Link			HCI_CMD_OPCODE(0x01, 0x003A)
+#define HCI_Logical_Link_Cancel				HCI_CMD_OPCODE(0x01, 0x003B)
+#define HCI_Flow_Spec_Modify				HCI_CMD_OPCODE(0x01, 0x003C)
+#define HCI_Write_Flow_Control_Mode			HCI_CMD_OPCODE(0x01, 0x0067)
+#define HCI_Read_Best_Effort_Flush_Timeout	HCI_CMD_OPCODE(0x01, 0x0069)
+#define HCI_Write_Best_Effort_Flush_Timeout	HCI_CMD_OPCODE(0x01, 0x006A)
+#define HCI_Short_Range_Mode				HCI_CMD_OPCODE(0x01, 0x006B)
+#define HCI_Reset							HCI_CMD_OPCODE(0x03, 0x0003)
+#define HCI_Read_Connection_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0015)
+#define HCI_Write_Connection_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0016)
+#define HCI_Read_Link_Supervision_Timeout	HCI_CMD_OPCODE(0x03, 0x0036)
+#define HCI_Write_Link_Supervision_Timeout	HCI_CMD_OPCODE(0x03, 0x0037)
+#define HCI_Enhanced_Flush					HCI_CMD_OPCODE(0x03, 0x005F)
+#define HCI_Read_Logical_Link_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0061)
+#define HCI_Write_Logical_Link_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0062)
+#define HCI_Set_Event_Mask_Page_2			HCI_CMD_OPCODE(0x03, 0x0063)
+#define HCI_Read_Location_Data_Command		HCI_CMD_OPCODE(0x03, 0x0064)
+#define HCI_Write_Location_Data_Command		HCI_CMD_OPCODE(0x03, 0x0065)
+#define HCI_Read_Local_Version_Info			HCI_CMD_OPCODE(0x04, 0x0001)
+#define HCI_Read_Local_Supported_Commands	HCI_CMD_OPCODE(0x04, 0x0002)
+#define HCI_Read_Buffer_Size				HCI_CMD_OPCODE(0x04, 0x0005)
+#define HCI_Read_Data_Block_Size			HCI_CMD_OPCODE(0x04, 0x000A)
+
+/* AMP HCI command parameters */
+typedef PRE_PACKED struct read_local_cmd_parms {
+	u8 plh;
+	u8 offset[2];			/* length so far */
+	u8 max_remote[2];
+} POST_PACKED read_local_cmd_parms_t;
+
+typedef PRE_PACKED struct write_remote_cmd_parms {
+	u8 plh;
+	u8 offset[2];
+	u8 len[2];
+	u8 frag[1];
+} POST_PACKED write_remote_cmd_parms_t;
+
+typedef PRE_PACKED struct phy_link_cmd_parms {
+	u8 plh;
+	u8 key_length;
+	u8 key_type;
+	u8 key[1];
+} POST_PACKED phy_link_cmd_parms_t;
+
+typedef PRE_PACKED struct dis_phy_link_cmd_parms {
+	u8 plh;
+	u8 reason;
+} POST_PACKED dis_phy_link_cmd_parms_t;
+
+typedef PRE_PACKED struct log_link_cmd_parms {
+	u8 plh;
+	u8 txflow[16];
+	u8 rxflow[16];
+} POST_PACKED log_link_cmd_parms_t;
+
+typedef PRE_PACKED struct ext_flow_spec {
+	u8 id;
+	u8 service_type;
+	u8 max_sdu[2];
+	u8 sdu_ia_time[4];
+	u8 access_latency[4];
+	u8 flush_timeout[4];
+} POST_PACKED ext_flow_spec_t;
+
+typedef PRE_PACKED struct log_link_cancel_cmd_parms {
+	u8 plh;
+	u8 tx_fs_ID;
+} POST_PACKED log_link_cancel_cmd_parms_t;
+
+typedef PRE_PACKED struct flow_spec_mod_cmd_parms {
+	u8 llh[2];
+	u8 txflow[16];
+	u8 rxflow[16];
+} POST_PACKED flow_spec_mod_cmd_parms_t;
+
+typedef PRE_PACKED struct plh_pad {
+	u8 plh;
+	u8 pad;
+} POST_PACKED plh_pad_t;
+
+typedef PRE_PACKED union hci_handle {
+	u16 bredr;
+	plh_pad_t amp;
+} POST_PACKED hci_handle_t;
+
+typedef PRE_PACKED struct ls_to_cmd_parms {
+	hci_handle_t handle;
+	u8 timeout[2];
+} POST_PACKED ls_to_cmd_parms_t;
+
+typedef PRE_PACKED struct befto_cmd_parms {
+	u8 llh[2];
+	u8 befto[4];
+} POST_PACKED befto_cmd_parms_t;
+
+typedef PRE_PACKED struct srm_cmd_parms {
+	u8 plh;
+	u8 srm;
+} POST_PACKED srm_cmd_parms_t;
+
+typedef PRE_PACKED struct ld_cmd_parms {
+	u8 ld_aware;
+	u8 ld[2];
+	u8 ld_opts;
+	u8 l_opts;
+} POST_PACKED ld_cmd_parms_t;
+
+typedef PRE_PACKED struct eflush_cmd_parms {
+	u8 llh[2];
+	u8 packet_type;
+} POST_PACKED eflush_cmd_parms_t;
+
+/* Generic AMP extended flow spec service types */
+#define EFS_SVCTYPE_NO_TRAFFIC		0
+#define EFS_SVCTYPE_BEST_EFFORT		1
+#define EFS_SVCTYPE_GUARANTEED		2
+
+/* AMP HCI event packet format */
+typedef PRE_PACKED struct amp_hci_event {
+	u8 ecode;
+	u8 plen;
+	u8 parms[1];
+} POST_PACKED amp_hci_event_t;
+
+#define HCI_EVT_PREAMBLE_SIZE			OFFSETOF(amp_hci_event_t, parms)
+
+/* AMP HCI event codes */
+#define HCI_Command_Complete			0x0E
+#define HCI_Command_Status			0x0F
+#define HCI_Flush_Occurred			0x11
+#define HCI_Enhanced_Flush_Complete		0x39
+#define HCI_Physical_Link_Complete		0x40
+#define HCI_Channel_Select			0x41
+#define HCI_Disconnect_Physical_Link_Complete	0x42
+#define HCI_Logical_Link_Complete		0x45
+#define HCI_Disconnect_Logical_Link_Complete	0x46
+#define HCI_Flow_Spec_Modify_Complete		0x47
+#define HCI_Number_of_Completed_Data_Blocks	0x48
+#define HCI_Short_Range_Mode_Change_Complete	0x4C
+#define HCI_Status_Change_Event			0x4D
+#define HCI_Vendor_Specific			0xFF
+
+/* AMP HCI event mask bit positions */
+#define HCI_Physical_Link_Complete_Event_Mask			0x0001
+#define HCI_Channel_Select_Event_Mask				0x0002
+#define HCI_Disconnect_Physical_Link_Complete_Event_Mask	0x0004
+#define HCI_Logical_Link_Complete_Event_Mask			0x0020
+#define HCI_Disconnect_Logical_Link_Complete_Event_Mask		0x0040
+#define HCI_Flow_Spec_Modify_Complete_Event_Mask		0x0080
+#define HCI_Number_of_Completed_Data_Blocks_Event_Mask		0x0100
+#define HCI_Short_Range_Mode_Change_Complete_Event_Mask		0x1000
+#define HCI_Status_Change_Event_Mask				0x2000
+#define HCI_All_Event_Mask					0x31e7
+/* AMP HCI event parameters */
+typedef PRE_PACKED struct cmd_status_parms {
+	u8 status;
+	u8 cmdpkts;
+	u16 opcode;
+} POST_PACKED cmd_status_parms_t;
+
+typedef PRE_PACKED struct cmd_complete_parms {
+	u8 cmdpkts;
+	u16 opcode;
+	u8 parms[1];
+} POST_PACKED cmd_complete_parms_t;
+
+typedef PRE_PACKED struct flush_occurred_evt_parms {
+	u16 handle;
+} POST_PACKED flush_occurred_evt_parms_t;
+
+typedef PRE_PACKED struct write_remote_evt_parms {
+	u8 status;
+	u8 plh;
+} POST_PACKED write_remote_evt_parms_t;
+
+typedef PRE_PACKED struct read_local_evt_parms {
+	u8 status;
+	u8 plh;
+	u16 len;
+	u8 frag[1];
+} POST_PACKED read_local_evt_parms_t;
+
+typedef PRE_PACKED struct read_local_info_evt_parms {
+	u8      status;
+	u8      AMP_status;
+	u32  	bandwidth;
+	u32  	gbandwidth;
+	u32  	latency;
+	u32  	PDU_size;
+	u8      ctrl_type;
+	u16     PAL_cap;
+	u16     AMP_ASSOC_len;
+	u32  	max_flush_timeout;
+	u32  	be_flush_timeout;
+} POST_PACKED read_local_info_evt_parms_t;
+
+typedef PRE_PACKED struct log_link_evt_parms {
+	u8  status;
+	u16 llh;
+	u8  plh;
+	u8  tx_fs_ID;
+} POST_PACKED log_link_evt_parms_t;
+
+typedef PRE_PACKED struct disc_log_link_evt_parms {
+	u8 status;
+	u16 llh;
+	u8 reason;
+} POST_PACKED disc_log_link_evt_parms_t;
+
+typedef PRE_PACKED struct log_link_cancel_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 tx_fs_ID;
+} POST_PACKED log_link_cancel_evt_parms_t;
+
+typedef PRE_PACKED struct flow_spec_mod_evt_parms {
+	u8 status;
+	u16 llh;
+} POST_PACKED flow_spec_mod_evt_parms_t;
+
+typedef PRE_PACKED struct phy_link_evt_parms {
+	u8 status;
+	u8 plh;
+} POST_PACKED phy_link_evt_parms_t;
+
+typedef PRE_PACKED struct dis_phy_link_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 reason;
+} POST_PACKED dis_phy_link_evt_parms_t;
+
+typedef PRE_PACKED struct read_ls_to_evt_parms {
+	u8 status;
+	hci_handle_t handle;
+	u16 timeout;
+} POST_PACKED read_ls_to_evt_parms_t;
+
+typedef PRE_PACKED struct read_lla_ca_to_evt_parms {
+	u8  status;
+	u16 timeout;
+} POST_PACKED read_lla_ca_to_evt_parms_t;
+
+typedef PRE_PACKED struct read_data_block_size_evt_parms {
+	u8  status;
+	u16 ACL_pkt_len;
+	u16 data_block_len;
+	u16 data_block_num;
+} POST_PACKED read_data_block_size_evt_parms_t;
+
+typedef PRE_PACKED struct data_blocks {
+	u16 handle;
+	u16 pkts;
+	u16 blocks;
+} POST_PACKED data_blocks_t;
+
+typedef PRE_PACKED struct num_completed_data_blocks_evt_parms {
+	u16 num_blocks;
+	u8 num_handles;
+	data_blocks_t completed[1];
+} POST_PACKED num_completed_data_blocks_evt_parms_t;
+
+typedef PRE_PACKED struct befto_evt_parms {
+	u8 status;
+	u32 befto;
+} POST_PACKED befto_evt_parms_t;
+
+typedef PRE_PACKED struct srm_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 srm;
+} POST_PACKED srm_evt_parms_t;
+
+typedef PRE_PACKED struct contact_counter_evt_parms {
+	u8 status;
+	u8 llh[2];
+	u16 counter;
+} POST_PACKED contact_counter_evt_parms_t;
+
+typedef PRE_PACKED struct contact_counter_reset_evt_parms {
+	u8 status;
+	u8 llh[2];
+} POST_PACKED contact_counter_reset_evt_parms_t;
+
+typedef PRE_PACKED struct read_linkq_evt_parms {
+	u8 status;
+	hci_handle_t handle;
+	u8 link_quality;
+} POST_PACKED read_linkq_evt_parms_t;
+
+typedef PRE_PACKED struct ld_evt_parms {
+	u8 status;
+	u8 ld_aware;
+	u8 ld[2];
+	u8 ld_opts;
+	u8 l_opts;
+} POST_PACKED ld_evt_parms_t;
+
+typedef PRE_PACKED struct eflush_complete_evt_parms {
+	u16 handle;
+} POST_PACKED eflush_complete_evt_parms_t;
+
+typedef PRE_PACKED struct vendor_specific_evt_parms {
+	u8 len;
+	u8 parms[1];
+} POST_PACKED vendor_specific_evt_parms_t;
+
+typedef PRE_PACKED struct local_version_info_evt_parms {
+	u8 status;
+	u8 hci_version;
+	u16 hci_revision;
+	u8 pal_version;
+	u16 mfg_name;
+	u16 pal_subversion;
+} POST_PACKED local_version_info_evt_parms_t;
+
+#define MAX_SUPPORTED_CMD_BYTE	64
+typedef PRE_PACKED struct local_supported_cmd_evt_parms {
+	u8 status;
+	u8 cmd[MAX_SUPPORTED_CMD_BYTE];
+} POST_PACKED local_supported_cmd_evt_parms_t;
+
+typedef PRE_PACKED struct status_change_evt_parms {
+	u8 status;
+	u8 amp_status;
+} POST_PACKED status_change_evt_parms_t;
+
+/* AMP HCI error codes */
+#define HCI_SUCCESS				            0x00
+#define HCI_ERR_ILLEGAL_COMMAND			    0x01
+#define HCI_ERR_NO_CONNECTION			    0x02
+#define HCI_ERR_MEMORY_FULL			        0x07
+#define HCI_ERR_CONNECTION_TIMEOUT		    0x08
+#define HCI_ERR_MAX_NUM_OF_CONNECTIONS		0x09
+#define HCI_ERR_CONNECTION_EXISTS		    0x0B
+#define HCI_ERR_CONNECTION_DISALLOWED		0x0C
+#define HCI_ERR_CONNECTION_ACCEPT_TIMEOUT	0x10
+#define HCI_ERR_UNSUPPORTED_VALUE		    0x11
+#define HCI_ERR_ILLEGAL_PARAMETER_FMT		0x12
+#define HCI_ERR_CONN_TERM_BY_LOCAL_HOST		0x16
+#define HCI_ERR_UNSPECIFIED			        0x1F
+#define HCI_ERR_UNIT_KEY_USED			    0x26
+#define HCI_ERR_QOS_REJECTED			    0x2D
+#define HCI_ERR_PARAM_OUT_OF_RANGE		    0x30
+#define HCI_ERR_NO_SUITABLE_CHANNEL		    0x39
+#define HCI_ERR_CHANNEL_MOVE			    0xFF
+
+/* AMP HCI ACL Data packet format */
+typedef PRE_PACKED struct amp_hci_ACL_data {
+	u16	handle;			/* 12-bit connection handle + 2-bit PB and 2-bit BC flags */
+	u16	dlen;			/* data total length */
+	u8  data[1];
+} POST_PACKED amp_hci_ACL_data_t;
+
+#define HCI_ACL_DATA_PREAMBLE_SIZE	OFFSETOF(amp_hci_ACL_data_t, data)
+
+#define HCI_ACL_DATA_BC_FLAGS		(0x0 << 14)
+#define HCI_ACL_DATA_PB_FLAGS		(0x3 << 12)
+
+#define HCI_ACL_DATA_HANDLE(handle)	((handle) & 0x0fff)
+#define HCI_ACL_DATA_FLAGS(handle)	((handle) >> 12)
+
+/* AMP Activity Report packet formats */
+typedef PRE_PACKED struct amp_hci_activity_report {
+	u8	ScheduleKnown;
+	u8	NumReports;
+	u8	data[1];
+} POST_PACKED amp_hci_activity_report_t;
+
+typedef PRE_PACKED struct amp_hci_activity_report_triple {
+	u32	StartTime;
+	u32	Duration;
+	u32	Periodicity;
+} POST_PACKED amp_hci_activity_report_triple_t;
+
+#define HCI_AR_SCHEDULE_KNOWN		0x01
+
+#endif /* _WLAND_BT_AMP_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/wland_d11.h b/drivers/net/wireless/rdaw80211/include/wland_d11.h
new file mode 100644
index 000000000000..5d7c1f8c2bb6
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/wland_d11.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_WLAND_D11_H_
+#define	_WLAND_D11_H_
+
+/* d11 io type */
+#define WLAND_D11N_IOTYPE		        1
+#define WLAND_D11AC_IOTYPE		        2
+
+
+/* bit 0~7 channel number
+ * for 80+80 channels: bit 0~3 low channel id, bit 4~7 high channel id
+ */
+#define WLAND_CHSPEC_CH_MASK		    0x00FF
+#define WLAND_CHSPEC_CH_SHIFT		    0
+#define WLAND_CHSPEC_CHL_MASK		    0x000F
+#define WLAND_CHSPEC_CHL_SHIFT		    0
+#define WLAND_CHSPEC_CHH_MASK		    0x00F0
+#define WLAND_CHSPEC_CHH_SHIFT		    4
+
+/* bit 8~16 for dot 11n IO types
+ * bit 8~9 sideband
+ * bit 10~11 bandwidth
+ * bit 12~13 spectral band
+ * bit 14~15 not used
+ */
+#define WLAND_CHSPEC_D11N_SB_MASK	    0x0300
+#define WLAND_CHSPEC_D11N_SB_L		    0x0100	/* control lower */
+#define WLAND_CHSPEC_D11N_SB_N		    0x0300	/* none */
+#define WLAND_CHSPEC_D11N_BW_MASK	    0x0c00
+#define WLAND_CHSPEC_D11N_BW_20	        0x0800
+#define WLAND_CHSPEC_D11N_BW_40	        0x0c00
+#define WLAND_CHSPEC_D11N_BND_MASK	    0x3000
+#define WLAND_CHSPEC_D11N_BND_5G	    0x1000
+#define WLAND_CHSPEC_D11N_BND_2G	    0x2000
+
+/* bit 8~16 for dot 11ac IO types
+ * bit 8~10 sideband
+ * bit 11~13 bandwidth
+ * bit 14~15 spectral band
+ */
+#define WLAND_CHSPEC_D11AC_SB_MASK	    0x0700
+#define WLAND_CHSPEC_D11AC_SB_L	        0x0900
+#define WLAND_CHSPEC_D11AC_SB_U	        0x0B00
+#define WLAND_CHSPEC_D11AC_BW_MASK	    0x3800
+#define WLAND_CHSPEC_D11AC_BW_20	    0x1000
+#define WLAND_CHSPEC_D11AC_BW_40	    0x1800
+#define WLAND_CHSPEC_D11AC_BW_80	    0x2000
+#define WLAND_CHSPEC_D11AC_BW_160	    0x2800
+#define WLAND_CHSPEC_D11AC_BW_8080	    0x3000
+#define WLAND_CHSPEC_D11AC_BND_MASK	    0xC000
+#define WLAND_CHSPEC_D11AC_BND_2G	    0x0000
+#define WLAND_CHSPEC_D11AC_BND_5G	    0xc000
+
+#define CHAN_BAND_2G		            0
+#define CHAN_BAND_5G		            1
+
+/* channel defines */
+#define CH_10MHZ_APART			        2
+#define CH_MIN_2G_CHANNEL		        1
+#define CH_MAX_2G_CHANNEL		        14	/* Max channel in 2G band */
+#define CH_MIN_5G_CHANNEL		        34
+
+/*
+ * max # supported channels. The max channel no is 216, this is that + 1
+ * rounded up to a multiple of NBBY (8). DO NOT MAKE it > 255: channels are
+ * u8's all over
+*/
+#define	MAXCHANNEL		                224
+
+#define WL_CHANSPEC_CHAN_MASK		    0x00ff
+
+#define WL_CHANSPEC_BAND_MASK	        0xf000
+#define WL_CHANSPEC_BAND_SHIFT	        12
+#define WL_CHANSPEC_BAND_5G		        0x1000
+#define WL_CHANSPEC_BAND_2G		        0x2000
+#define INVCHANSPEC			            255
+
+#define WL_CHAN_VALID_HW		        (1 << 0) /* valid with current HW */
+#define WL_CHAN_VALID_SW		        (1 << 1) /* valid with country sett. */
+#define WL_CHAN_BAND_5G			        (1 << 2) /* 5GHz-band channel */
+#define WL_CHAN_RADAR			        (1 << 3) /* radar sensitive  channel */
+#define WL_CHAN_INACTIVE		        (1 << 4) /* inactive due to radar */
+#define WL_CHAN_PASSIVE			        (1 << 5) /* channel in passive mode */
+#define WL_CHAN_RESTRICTED		        (1 << 6) /* restricted use channel */
+
+/* values for band specific 40MHz capabilities  */
+#define WLC_N_BW_20ALL			        0
+#define WLC_N_BW_40ALL			        1
+#define WLC_N_BW_20IN2G_40IN5G		    2
+
+/* band types */
+#define	WLC_BAND_AUTO			        0	/* auto-select */
+#define	WLC_BAND_5G			            1	/* 5 Ghz */
+#define	WLC_BAND_2G			            2	/* 2.4 Ghz */
+#define	WLC_BAND_ALL			        3	/* all bands */
+
+/* defined rate in 500kbps */
+#define WLAND_RATE_1M	                2	/* in 500kbps units */
+#define WLAND_RATE_2M	                4	/* in 500kbps units */
+#define WLAND_RATE_5M5	                11	/* in 500kbps units */
+#define WLAND_RATE_11M	                22	/* in 500kbps units */
+#define WLAND_RATE_6M	                12	/* in 500kbps units */
+#define WLAND_RATE_9M	                18	/* in 500kbps units */
+#define WLAND_RATE_12M	                24	/* in 500kbps units */
+#define WLAND_RATE_18M	                36	/* in 500kbps units */
+#define WLAND_RATE_24M	                48	/* in 500kbps units */
+#define WLAND_RATE_36M	                72	/* in 500kbps units */
+#define WLAND_RATE_48M	                96	/* in 500kbps units */
+#define WLAND_RATE_54M	                108	/* in 500kbps units */
+
+
+enum wland_chan_bw {
+	CHAN_BW_20,
+	CHAN_BW_40,
+	CHAN_BW_80,
+	CHAN_BW_80P80,
+	CHAN_BW_160
+};
+
+enum wland_chan_sb {
+	WLAND_CHAN_SB_NONE = 0,
+	WLAND_CHAN_SB_L,
+	WLAND_CHAN_SB_U
+};
+
+struct wland_chan {
+	u16                 chspec;
+	u8                  chnum;
+	u8                  band;
+	enum wland_chan_bw  bw;
+	enum wland_chan_sb  sb;
+};
+
+struct wland_d11inf {
+	u8                  io_type;
+
+	void (*encchspec)(struct wland_chan *ch);
+	void (*decchspec)(struct wland_chan *ch);
+};
+
+extern void wland_d11_attach(struct wland_d11inf *d11inf);
+
+#endif	/* _WLAND_D11_H_ */
diff --git a/drivers/net/wireless/rdaw80211/include/wland_utils.h b/drivers/net/wireless/rdaw80211/include/wland_utils.h
new file mode 100644
index 000000000000..e6fa26e94488
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/wland_utils.h
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_WLAND_UTILS_H_
+#define	_WLAND_UTILS_H_
+
+#include <linux/skbuff.h>
+#include <802.11.h>
+
+#ifndef ABS
+#define	ABS(a)			            (((a) < 0) ? -(a) : (a))
+#endif /* ABS */
+
+#ifndef MIN
+#define	MIN(a, b)		            (((a) < (b)) ? (a) : (b))
+#endif /* MIN */
+
+#ifndef MAX
+#define	MAX(a, b)		            (((a) > (b)) ? (a) : (b))
+#endif /* MAX */
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		udelay(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* osl multi-precedence packet queue */
+#define PKTQ_LEN_DEFAULT        128	/* Max 128 packets */
+#define PKTQ_MAX_PREC           16	/* Maximum precedence levels */
+
+/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
+#define	PKTBUFSZ	            2048
+
+#ifndef setbit
+#ifndef NBBY			        /* the BSD family defines NBBY */
+#define	NBBY	8		        /* 8 bits per byte */
+#endif				            /* #ifndef NBBY */
+#define	setbit(a, i)	        (((u8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	        (((u8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	            (((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	            ((((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif				            /* setbit */
+
+#define	NBITS(type)	            (sizeof(type) * 8)
+#define NBITVAL(nbits)	        (1 << (nbits))
+#define MAXBITVAL(nbits)	    ((1 << (nbits)) - 1)
+#define	NBITMASK(nbits)	        MAXBITVAL(nbits)
+#define MAXNBVAL(nbyte)	        MAXBITVAL((nbyte) * 8)
+
+
+/* callback function, taking one arg */
+typedef void (*timer_cb_fn_t)(void *);
+
+
+struct pktq_prec {
+	struct sk_buff_head skblist;
+	u16                 max;		/* maximum number of queued packets */
+};
+
+/* multi-priority pkt queue */
+struct pktq {
+	u16              num_prec;	/* number of precedences in use */
+	u16              hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+	u16              max;	    /* total max packets */
+	u16              len;	    /* total number of packets */
+	/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+	struct pktq_prec q[PKTQ_MAX_PREC];
+};
+
+struct wland_drv_timer{
+	struct timer_list   tl;
+	timer_cb_fn_t       func;
+	void               *data;
+	u32                 time_period;
+	bool                timer_is_periodic;
+	bool                timer_is_canceled;
+	u16                 event;
+};
+
+/* operations on a specific precedence in packet queue */
+static inline int pktq_plen(struct pktq *pq, int prec)
+{
+	return pq->q[prec].skblist.qlen;
+}
+
+static inline int pktq_pavail(struct pktq *pq, int prec)
+{
+	return pq->q[prec].max - pq->q[prec].skblist.qlen;
+}
+
+static inline bool pktq_pfull(struct pktq *pq, int prec)
+{
+	return pq->q[prec].skblist.qlen >= pq->q[prec].max;
+}
+
+static inline bool pktq_pempty(struct pktq *pq, int prec)
+{
+	return skb_queue_empty(&pq->q[prec].skblist);
+}
+
+static inline struct sk_buff *pktq_ppeek(struct pktq *pq, int prec)
+{
+	return skb_peek(&pq->q[prec].skblist);
+}
+
+static inline struct sk_buff *pktq_ppeek_tail(struct pktq *pq, int prec)
+{
+	return skb_peek_tail(&pq->q[prec].skblist);
+}
+
+extern void wland_timer_handler(ulong fcontext);
+
+static inline void wland_init_timer(struct wland_drv_timer *timer, timer_cb_fn_t func, void *data, u16 event)
+{
+	/* first, setup the timer to trigger the wland_timer_handler proxy */
+	init_timer(&timer->tl);
+	timer->tl.function       = wland_timer_handler;
+	timer->tl.data           = (u32) timer;
+
+	/* then tell the proxy which function to call and what to pass it */
+	timer->func              = func;
+	timer->data              = data;
+	timer->event             = event;
+	timer->timer_is_canceled = true;
+	timer->timer_is_periodic = false;
+}
+
+static inline void wland_add_timer(struct wland_drv_timer *timer, u32 MillisecondPeriod, bool period)
+{
+	timer->time_period       = MillisecondPeriod;
+	timer->timer_is_periodic = period;
+	timer->timer_is_canceled = false;
+	timer->tl.expires        = jiffies + (MillisecondPeriod * HZ) / 1000;
+	
+	add_timer(&timer->tl);	
+}
+
+static inline void wland_mod_timer(struct wland_drv_timer *timer, u32 MillisecondPeriod)
+{
+	timer->time_period       = MillisecondPeriod;
+	timer->timer_is_periodic = false;
+	timer->timer_is_canceled = false;
+	
+	mod_timer(&timer->tl, jiffies + (MillisecondPeriod * HZ) / 1000);
+}
+
+static inline void wland_del_timer(struct wland_drv_timer *timer)
+{
+	if(!timer->timer_is_canceled)
+	{
+		del_timer(&timer->tl);
+		timer->timer_is_canceled = true;
+	}
+}
+
+static inline void wland_sched_timeout(u32 millisec)
+{ 
+	ulong timeout = 0, expires = 0;
+	expires = jiffies + msecs_to_jiffies(millisec);
+	timeout = millisec;
+
+	while(timeout)
+	{
+		timeout = schedule_timeout(timeout);
+		
+		if(time_after(jiffies, expires))
+			break;
+	}
+}
+
+static inline int pktq_avail(struct pktq *pq)
+{
+	return (int)(pq->max - pq->len);
+}
+
+static inline bool pktq_full(struct pktq *pq)
+{
+	return pq->len >= pq->max;
+}
+
+static inline bool pktq_empty(struct pktq *pq)
+{
+	return pq->len == 0;
+}
+
+/*
+ * bitfield macros using masking and shift
+ *
+ * remark: the mask parameter should be a shifted mask.
+ */
+static inline void brcmu_maskset32(u32 *var, u32 mask, u8 shift, u32 value)
+{
+	value = (value << shift) & mask;
+	*var  = (*var & ~mask) | value;
+}
+
+static inline u32 brcmu_maskget32(u32 var, u32 mask, u8 shift)
+{
+	return (var & mask) >> shift;
+}
+
+static inline void brcmu_maskset16(u16 *var, u16 mask, u8 shift, u16 value)
+{
+	value = (value << shift) & mask;
+	*var = (*var & ~mask) | value;
+}
+
+static inline u16 brcmu_maskget16(u16 var, u16 mask, u8 shift)
+{
+	return (var & mask) >> shift;
+}
+
+#ifdef DEBUG
+extern void wland_dbg_hex_dump(int level, const void *data, size_t size, const char *fmt, ...);
+#else
+static inline void wland_dbg_hex_dump(int level,const void *data, size_t size, const char *fmt, ...)
+{
+}
+#endif
+
+extern struct sk_buff *wland_pktq_penq(struct pktq *pq, int prec,struct sk_buff *p);
+extern struct sk_buff *wland_pktq_penq_head(struct pktq *pq, int prec, struct sk_buff *p);
+extern struct sk_buff *wland_pktq_pdeq(struct pktq *pq, int prec);
+extern struct sk_buff *wland_pktq_pdeq_tail(struct pktq *pq, int prec);
+extern struct sk_buff *wland_pktq_pdeq_match(struct pktq *pq, int prec, bool (*match_fn)(struct sk_buff *p, void *arg), void *arg);
+
+/* packet primitives */
+extern struct sk_buff *wland_pkt_buf_get_skb(uint len);
+extern void wland_pkt_buf_free_skb(struct sk_buff *skb);
+
+/* Empty the queue at particular precedence level */
+/* callback function fn(pkt, arg) returns true if pkt belongs to if */
+extern void wland_pktq_pflush(struct pktq *pq, int prec, bool dir, bool (*fn)(struct sk_buff *, void *), void *arg);
+
+/* operations on a set of precedences in packet queue */
+extern int  wland_pktq_mlen(struct pktq *pq, uint prec_bmp);
+extern struct sk_buff *wland_pktq_mdeq(struct pktq *pq);
+
+extern void wland_pktq_init(struct pktq *pq, int num_prec, int max_len);
+/* prec_out may be NULL if caller is not interested in return value */
+extern struct sk_buff *wland_pktq_peek_tail(struct pktq *pq, int *prec_out);
+extern void wland_pktq_flush(struct pktq *pq, bool dir,	bool (*fn)(struct sk_buff *, void *), void *arg);
+
+extern void get_ssid(u8*data, u8*ssid, u8*p_ssid_len);
+extern u16  get_cap_info(u8*data);
+extern void get_ssid(u8* data, u8* ssid, u8* p_ssid_len);
+extern void get_BSSID(u8* data, u8* bssid);
+extern u8   get_current_channel(u8 *pu8msa, u16 u16RxLen);
+extern u8  *get_data_rate(u8 *pu8msa, u16 u16RxLen, u8 type, u8 *rate_size);
+extern u8  *get_tim_elm(u8* pu8msa, u16 u16RxLen, u16 u16TagParamOffset);
+extern u16  get_beacon_period(u8* data);
+extern u8   num_2_char(u8 num);
+extern void num_2_str(u8 num, u8* str);
+#endif /* _WLAND_UTILS_H_ */
+
diff --git a/drivers/net/wireless/rdaw80211/include/wpa.h b/drivers/net/wireless/rdaw80211/include/wpa.h
new file mode 100644
index 000000000000..bb056df65462
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/include/wpa.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WPA_H_
+#define _WPA_H_
+
+#include <ethernet.h>
+
+
+/* Reason Codes */
+
+/* 13 through 23 taken from IEEE Std 802.11i-2004 */
+#define DOT11_RC_INVALID_WPA_IE		13	/* Invalid info. element */
+#define DOT11_RC_MIC_FAILURE		14	/* Michael failure */
+#define DOT11_RC_4WH_TIMEOUT		15	/* 4-way handshake timeout */
+#define DOT11_RC_GTK_UPDATE_TIMEOUT	16	/* Group key update timeout */
+#define DOT11_RC_WPA_IE_MISMATCH	17	/* WPA IE in 4-way handshake differs from (re-)assoc. request/probe response */
+#define DOT11_RC_INVALID_MC_CIPHER	18	/* Invalid multicast cipher */
+#define DOT11_RC_INVALID_UC_CIPHER	19	/* Invalid unicast cipher */
+#define DOT11_RC_INVALID_AKMP		20	/* Invalid authenticated key management protocol */
+#define DOT11_RC_BAD_WPA_VERSION	21	/* Unsupported WPA version */
+#define DOT11_RC_INVALID_WPA_CAP	22	/* Invalid WPA IE capabilities */
+#define DOT11_RC_8021X_AUTH_FAIL	23	/* 802.1X authentication failure */
+
+#define WPA2_PMKID_LEN	            16
+
+/* WPA IE fixed portion */
+PRE_PACKED struct wpa_ie_fixed
+{
+	u8 tag;	    /* TAG */
+	u8 length;	/* TAG length */
+	u8 oui[3];	/* IE OUI */
+	u8 oui_type;	/* OUI type */
+	PRE_PACKED struct 
+	{
+		u8 low;
+		u8 high;
+	} POST_PACKED version;	/* IE version */
+} POST_PACKED;
+
+#define WPA_IE_OUITYPE_LEN	        4
+#define WPA_IE_FIXED_LEN	        8
+#define WPA_IE_TAG_FIXED_LEN	    6
+
+PRE_PACKED struct wpa_rsn_ie_fixed
+{
+	u8 tag;	    /* TAG */
+	u8 length;	/* TAG length */
+	PRE_PACKED struct 
+	{
+		u8 low;
+		u8 high;
+	} POST_PACKED version;	/* IE version */
+} POST_PACKED;
+
+#define WPA_RSN_IE_FIXED_LEN	    4
+#define WPA_RSN_IE_TAG_FIXED_LEN	2
+
+typedef u8 wpa_pmkid_t[WPA2_PMKID_LEN];
+
+/* WPA suite/multicast suite */
+typedef PRE_PACKED struct
+{
+	u8 oui[3];
+	u8 type;
+} POST_PACKED wpa_suite_t, wpa_suite_mcast_t;
+
+#define WPA_SUITE_LEN	4
+
+/* WPA unicast suite list/key management suite list */
+typedef PRE_PACKED struct
+{
+	PRE_PACKED struct {
+		u8 low;
+		u8 high;
+	} POST_PACKED count;
+	wpa_suite_t list[1];
+} POST_PACKED wpa_suite_ucast_t, wpa_suite_auth_key_mgmt_t;
+
+#define WPA_IE_SUITE_COUNT_LEN	2
+
+typedef PRE_PACKED struct
+{
+	PRE_PACKED struct {
+		u8 low;
+		u8 high;
+	} POST_PACKED count;
+	wpa_pmkid_t list[1];
+} POST_PACKED wpa_pmkid_list_t;
+
+/* WPA cipher suites */
+#define WPA_CIPHER_NONE		            0	/* None */
+#define WPA_CIPHER_WEP_40	            1	/* WEP (40-bit) */
+#define WPA_CIPHER_TKIP		            2	/* TKIP: default for WPA */
+#define WPA_CIPHER_AES_OCB	            3	/* AES (OCB) */
+#define WPA_CIPHER_AES_CCM	            4	/* AES (CCM) */
+#define WPA_CIPHER_WEP_104	            5	/* WEP (104-bit) */
+#define WPA_CIPHER_BIP		            6	/* WEP (104-bit) */
+#define WPA_CIPHER_TPK		            7	/* Group addressed traffic not allowed */
+#ifdef BCMWAPI_WPI
+#define WAPI_CIPHER_NONE	            WPA_CIPHER_NONE
+#define WAPI_CIPHER_SMS4	            11
+#define WAPI_CSE_WPI_SMS4	            1
+#endif /* BCMWAPI_WPI */
+
+
+#define IS_WPA_CIPHER(cipher)	       ((cipher) == WPA_CIPHER_NONE || \
+                				        (cipher) == WPA_CIPHER_WEP_40 || \
+                				        (cipher) == WPA_CIPHER_WEP_104 || \
+                				        (cipher) == WPA_CIPHER_TKIP || \
+                				        (cipher) == WPA_CIPHER_AES_OCB || \
+                				        (cipher) == WPA_CIPHER_AES_CCM || \
+                				        (cipher) == WPA_CIPHER_TPK)
+
+#ifdef BCMWAPI_WAI
+#define IS_WAPI_CIPHER(cipher)	        ((cipher) == WAPI_CIPHER_NONE || (cipher) == WAPI_CSE_WPI_SMS4)
+
+/* convert WAPI_CSE_WPI_XXX to WAPI_CIPHER_XXX */
+#define WAPI_CSE_WPI_2_CIPHER(cse)      ((cse) == WAPI_CSE_WPI_SMS4 ? WAPI_CIPHER_SMS4 : WAPI_CIPHER_NONE)
+
+#define WAPI_CIPHER_2_CSE_WPI(cipher)   ((cipher) == WAPI_CIPHER_SMS4 ? WAPI_CSE_WPI_SMS4 : WAPI_CIPHER_NONE)
+#endif /* BCMWAPI_WAI */
+
+
+/* WPA TKIP countermeasures parameters */
+#define WPA_TKIP_CM_DETECT	            60	/* multiple MIC failure window (seconds) */
+#define WPA_TKIP_CM_BLOCK	            60	/* countermeasures active window (seconds) */
+
+/* RSN IE defines */
+#define RSN_CAP_LEN		                2	/* Length of RSN capabilities field (2 octets) */
+
+/* RSN Capabilities defined in 802.11i */
+#define RSN_CAP_PREAUTH			        0x0001
+#define RSN_CAP_NOPAIRWISE		        0x0002
+#define RSN_CAP_PTK_REPLAY_CNTR_MASK	0x000C
+#define RSN_CAP_PTK_REPLAY_CNTR_SHIFT	2
+#define RSN_CAP_GTK_REPLAY_CNTR_MASK	0x0030
+#define RSN_CAP_GTK_REPLAY_CNTR_SHIFT	4
+#define RSN_CAP_1_REPLAY_CNTR		    0
+#define RSN_CAP_2_REPLAY_CNTRS		    1
+#define RSN_CAP_4_REPLAY_CNTRS		    2
+#define RSN_CAP_16_REPLAY_CNTRS		    3
+#ifdef MFP
+#define RSN_CAP_MFPR			        0x0040
+#define RSN_CAP_MFPC			        0x0080
+#endif
+
+/* WPA capabilities defined in 802.11i */
+#define WPA_CAP_4_REPLAY_CNTRS		    RSN_CAP_4_REPLAY_CNTRS
+#define WPA_CAP_16_REPLAY_CNTRS		    RSN_CAP_16_REPLAY_CNTRS
+#define WPA_CAP_REPLAY_CNTR_SHIFT	    RSN_CAP_PTK_REPLAY_CNTR_SHIFT
+#define WPA_CAP_REPLAY_CNTR_MASK	    RSN_CAP_PTK_REPLAY_CNTR_MASK
+
+/* WPA capabilities defined in 802.11zD9.0 */
+#define WPA_CAP_PEER_KEY_ENABLE		    (0x1 << 1)	/* bit 9 */
+
+/* WPA Specific defines */
+#define WPA_CAP_LEN	                    RSN_CAP_LEN	/* Length of RSN capabilities in RSN IE (2 octets) */
+#define WPA_PMKID_CNT_LEN	            2 	/* Length of RSN PMKID count (2 octests) */
+
+#define	WPA_CAP_WPA2_PREAUTH		    RSN_CAP_PREAUTH
+
+#ifdef BCMWAPI_WAI
+#define WAPI_CAP_PREAUTH		        RSN_CAP_PREAUTH
+
+/* Other WAI definition */
+#define WAPI_WAI_REQUEST		        0x00F1
+#define WAPI_UNICAST_REKEY		        0x00F2
+#define WAPI_STA_AGING			        0x00F3
+#define WAPI_MUTIL_REKEY		        0x00F4
+#define WAPI_STA_STATS			        0x00F5
+
+#define WAPI_USK_REKEY_COUNT		    0x4000000 /* 0xA00000 */
+#define WAPI_MSK_REKEY_COUNT		    0x4000000 /* 0xA00000 */
+#endif /* BCMWAPI_WAI */
+
+/* The following macros describe the bitfield map used by the firmware to determine its 11i mode */
+#define NO_ENCRYPT			             0
+#define ENCRYPT_ENABLED	                (1 << 0)
+#define WEP					            (1 << 1)
+#define WEP_EXTENDED		            (1 << 2)
+#define WPA					            (1 << 3)
+#define WPA2				            (1 << 4)
+#define AES					            (1 << 5)
+#define TKIP					        (1 << 6)
+
+#define WPA2_PMKID_COUNT_LEN	        2
+
+enum SECURITY_T{
+	NO_SECURITY   = 0,
+	WEP_40        = 0x3,
+	WEP_104       = 0x7,
+	WPA_AES       = 0x29,
+	WPA_TKIP      = 0x49,
+	WPA_AES_TKIP  = 0x69,		/* Aes or Tkip */
+	WPA2_AES      = 0x31,
+	WPA2_TKIP     = 0x51,
+	WPA2_AES_TKIP = 0x71,	/* Aes or Tkip */
+}; 
+
+enum AUTHTYPE_T{
+	OPEN_SYSTEM   = 1,
+	SHARED_KEY    = 2,
+	ANY           = 3,
+    IEEE8021      = 5
+};
+#endif /* _WPA_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/Makefile b/drivers/net/wireless/rdaw80211/rdacombodev/Makefile
new file mode 100644
index 000000000000..95a22cd0f6a8
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/Makefile
@@ -0,0 +1,31 @@
+#
+# Makefile fragment for Rdamicro 802.11 Networking Device Driver
+#
+# Copyright (c) 2014 Rdamicro Corporation
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+subdir-ccflags-y := -Werror
+subdir-ccflags-y += -Iinclude_rda
+
+MODULEPFX := rdacombodev
+
+obj-$(CONFIG_RDACBDEV) := $(MODULEPFX).o
+
+$(MODULEPFX)-objs := \
+	rda_combo_power_main.o \
+	rda_5990_power_ctrl.o  \
+	rda_5991_power_ctrl.o  \
+	rda_5991e_power_ctrl.o \
+	rda_5991f_power_ctrl.o \
+	rda_5991g_power_ctrl.o
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_5990_power_ctrl.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5990_power_ctrl.c
new file mode 100644
index 000000000000..877cacccec18
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5990_power_ctrl.c
@@ -0,0 +1,1365 @@
+#include "rda_combo.h"
+
+static u8 wifi_is_on = 0;
+
+#ifndef RDA_COMBO_FROM_FIRMWARE
+
+static const u16 wifi_off_data[][2] =
+{
+	{ 0x3F, 0x0001 }, //page up
+	{ 0x31, 0x0B40 }, //power off wifi
+	{ 0x3F, 0x0000 }, //page down
+};
+
+static const u16 wifi_en_data_90[][2] =
+{
+	{0x3f, 0x0001},
+#ifdef WLAN_USE_DCDC 	/*houzhen update Mar 15 2012 */
+	{0x23, 0x8F21},//20111001 higher AVDD voltage to improve EVM to 0x8f21 download current -1db 0x8fA1>>0x8bA1
+#else
+	{0x23, 0x0FA1},
+#endif
+	{0x31, 0x0B40 }, //power off wifi
+//	  {0x22, 0xD3C7},//for ver.c 20111109, txswitch
+	{0x24, 0x8048},//freq_osc_in[1:0]00  0x80C8 >> 0x80CB
+	{0x27, 0x4925},//for ver.c20111109, txswitch
+	//				  {0x28, 0x80A1}, //BT_enable
+	{0x31, 0x8140},//enable wifi
+	{0x32, 0x0113},//set_ rdenout_ldooff_wf=0; rden4in_ldoon_wf=1
+	{0x33, 0x0507},//stable time chenggangdeng
+	//				  {0x39, 0x0004},	//uart switch to wf
+	{0x3F, 0x0000}, //page down
+};
+
+static const u16 wifi_dc_cal_data[][2]=
+{
+	{0x3f, 0x0000},
+	{0x30, 0x0248},
+	{0x30, 0x0249},
+	//{wait 200ms; } here
+};
+
+static const u16 wifi_dig_reset_data_90[][2]=
+{
+	{0x3F,	0x0001},
+	{0x31,	0x8D40},
+	{0x31,	0x8F40},
+	{0x31,	0x8b40},
+	{0x3F,	0x0000},
+};
+
+static const u16 wifi_rf_init_data_90_verE[][2] =
+{
+	{0x3f, 0x0000},
+	//{;;set_rf_swi},ch
+	{0x05, 0x8000},
+	{0x06, 0x0101},
+	{0x07, 0x0101},
+	{0x08, 0x0101},
+	{0x09, 0x3040},
+	{0x0A, 0x002C},//aain_0
+	{0x0D, 0x0507},
+	{0x0E, 0x2300},
+	{0x0F, 0x5689},//
+	//{;;//set_RF  },
+	{0x10, 0x0f78},//20110824
+	{0x11, 0x0602},
+	{0x13, 0x0652},//adc_tuning_bit[011]
+	{0x14, 0x8886},
+	{0x15, 0x0910},
+	{0x16, 0x049f},
+#ifdef WLAN_USE_CRYSTAL
+	{0x17, 0x0990},
+	{0x18, 0x049F},
+#else
+	{0x17, 0x0910},
+	{0x18, 0x249F},
+#endif
+	{0x19, 0x3C01},
+	{0x1C, 0x0934},
+	{0x1D, 0xFF00},//for ver.D20120119for temperature 70 degree
+	//{0x1F, 0x01F8},//for ver.c20111109
+	//{0x1F, 0x0300},//for burst tx 
+	{0x20, 0x06E4},
+	{0x21, 0x0ACF},//for ver.c20111109,dr dac reset,dr txflt reset
+	{0x22, 0x24DC},
+#ifdef WLAN_FOR_CTA
+	{0x23, 0x0BFF},
+#else
+	{0x23, 0x23FF},
+#endif
+	{0x24, 0x00FC},
+	{0x26, 0x004F},//004F >> 005f premote pa
+	{0x27, 0x171D},///mdll*7
+	{0x28, 0x031D},///mdll*7
+#ifdef WLAN_USE_CRYSTAL
+	{0x2A, 0x2860},//et0x2849-8.5p	:yd 0x2861-7pf C1,C2=6.8p
+#else
+	{0x2A, 0x7860},
+#endif
+	{0x2B, 0x0804},//bbpll,or ver.c20111116
+	{0x32, 0x8a08},
+	{0x33, 0x1D02},//liuyanan
+	//{;;//agc_gain},
+#if 1
+	{0x36, 0x02f4}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x25d4}, //0414;//aain_4
+	{0x3A, 0x2584}, //1804;//gain_3
+	{0x3B, 0x2dc4}, //1C04;//aain_2
+	{0x3C, 0x2d04}, //1C02;//gain_1
+	{0x3D, 0x2c02}, //3C01;//gain_0
+#else
+	{0x36, 0x01f8}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x2073}, //0414;//aain_4
+	{0x3A, 0x2473}, //1804;//gain_3
+	{0x3B, 0x2dc7}, //1C04;//aain_2
+	{0x3C, 0x2d07}, //1C02;//gain_1
+	{0x3D, 0x2c04}, //3C01;//gain_0
+#endif
+	{0x33, 0x1502},//liuyanan
+	//{;;SET_channe},_to_11
+	{0x1B, 0x0001},//set_channel
+	{0x30, 0x024D},
+	{0x29, 0xD468},
+	{0x29, 0x1468},
+	{0x30, 0x0249},
+	{0x3f, 0x0000},
+};
+
+static const u16 wifi_rf_init_data_90_verD[][2] =
+{
+	{0x3f, 0x0000},
+	//{;;set_rf_swi},ch
+	{0x05, 0x8000},
+	{0x06, 0x0101},
+	{0x07, 0x0101},
+	{0x08, 0x0101},
+	{0x09, 0x3040},
+	{0x0A, 0x002C},//aain_0
+	{0x0D, 0x0507},
+	{0x0E, 0x2300},//2012_02_20
+	{0x0F, 0x5689},//
+	//{;;//set_RF  },
+	{0x10, 0x0f78},//20110824
+	{0x11, 0x0602},
+	{0x13, 0x0652},//adc_tuning_bit[011]
+	{0x14, 0x8886},
+	{0x15, 0x0910},
+	{0x16, 0x049f},
+#ifdef WLAN_USE_CRYSTAL
+	{0x17, 0x0990},
+	{0x18, 0x049F},
+#else
+	{0x17, 0x0910},
+	{0x18, 0x249F},
+#endif
+	{0x19, 0x3C01},//sdm_vbit[3:0]=1111
+	{0x1C, 0x0934},
+	{0x1D, 0xFF00},//for ver.D20120119for temperature 70 degree 0xCE00 >> 0xFF00
+	{0x1F, 0x0300},//div2_band_48g_dr=1;div2_band_48g_reg[8:0]
+	{0x20, 0x06E4},
+	{0x21, 0x0ACF},//for ver.c20111109,dr dac reset,dr txflt reset
+	{0x22, 0x24DC},
+#ifdef WLAN_FOR_CTA
+	{0x23, 0x0BFF},
+#else
+	{0x23, 0x23FF},
+#endif
+	{0x24, 0x00FC},
+	{0x26, 0x004F},//004F >> 005f premote pa
+	{0x27, 0x171D},///mdll*7
+	{0x28, 0x031D},///mdll*7
+#ifdef WLAN_USE_CRYSTAL
+	{0x2A, 0x2860},//et0x2849-8.5p  :yd 0x2861-7pf
+#else
+	{0x2A, 0x7860},
+#endif
+	{0x2B, 0x0804},//bbpll,or ver.c20111116
+	{0x32, 0x8a08},
+	{0x33, 0x1D02},//liuyanan
+	//{;;//agc_gain},
+#if 1
+	{0x36, 0x02f4}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x25d4}, //0414;//aain_4
+	{0x3A, 0x2584}, //1804;//gain_3
+	{0x3B, 0x2dc4}, //1C04;//aain_2
+	{0x3C, 0x2d04}, //1C02;//gain_1
+	{0x3D, 0x2c02}, //3C01;//gain_0
+#else
+	{0x36, 0x01f8}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x2073}, //0414;//aain_4
+	{0x3A, 0x2473}, //1804;//gain_3
+	{0x3B, 0x2dc7}, //1C04;//aain_2
+	{0x3C, 0x2d07}, //1C02;//gain_1
+	{0x3D, 0x2c04}, //3C01;//gain_0
+#endif
+	{0x33, 0x1502},//liuyanan
+	//{;;SET_channe},_to_11
+	{0x1B, 0x0001},//set_channel
+	{0x30, 0x024D},
+	{0x29, 0xD468},
+	{0x29, 0x1468},
+	{0x30, 0x0249},
+	{0x3f, 0x0000},
+};
+
+static const u16 wifi_tm_en_data_90[][2] =
+{
+	{0x3F,0x0001},
+#ifdef WLAN_USE_DCDC 	/*houzhen update Mar 15 2012 */
+	{0x23, 0x8F21},//20111001 higher AVDD voltage to improve EVM to 0x8f21 download current -1db 0x8fA1>>0x8bA1
+#else
+	{0x23, 0x0FA1},
+#endif
+	{0x22,0xD3C7},//for ver.c 20111109, tx
+	{0x24,0x8048},//freq_osc_in[1:0]00  0x80C8 >> 0x80CB
+	{0x27,0x4925},//for ver.c20111109, txs
+	{0x28,0x80A1}, //BT_enable
+	{0x29,0x111F},
+	{0x31,0x8140},
+	{0x32,0x0113},//set_ rdenout_ldooff_wf
+	{0x39,0x0004},//uart switch to wf
+	{0x3f,0x0000},
+};
+
+static const u16 wifi_tm_rf_init_data_90[][2] =
+{
+	{0x3f,0x0000},
+	//set_rf_switch
+	{0x06,0x0101},
+	{0x07,0x0101},
+	{0x08,0x0101},
+	{0x09,0x3040},
+	{0x0A,0x002C},//aain_0
+	{0x0D,0x0507},
+	{0x0E,0x2300},//2012_02_20
+	{0x0F,0x5689},//
+	//set_RF
+	{0x10,0x0f78},//20110824
+	{0x11,0x0602},
+	{0x13,0x0652},//adc_tuning_bit[011]
+	{0x14,0x8886},
+	{0x15,0x0910},
+	{0x16,0x049f},
+#ifdef WLAN_USE_CRYSTAL
+	{0x17,0x0990},
+	{0x18,0x049F},
+#else
+	{0x17,0x0910},
+	{0x18,0x249F},
+#endif
+	{0x19,0x3C01},//sdm_vbit[3:0]=1111
+	{0x1C,0x0934},
+	{0x1D,0xFF00},//for ver.D20120119for temperature 70 degree
+	{0x1F,0x0300},//div2_band_48g_dr=1;div2_band_48g_reg[8:0]1000000000
+	{0x20,0x06E4},
+	{0x21,0x0ACF},//for ver.c20111109,dr dac reset,dr txflt reset
+	{0x22,0x24DC},
+#ifdef WLAN_FOR_CTA
+	{0x23, 0x03FF},
+#else
+	{0x23, 0x0BFF},
+#endif
+	{0x24,0x00FC},
+	{0x26,0x004F},
+	{0x27,0x171D},///mdll*7
+	{0x28,0x031D},///mdll*7
+#ifdef WLAN_USE_CRYSTAL
+	{0x2A,0x2860},
+#else
+	{0x2A,0x7860},
+#endif
+	{0x2B,0x0804},//bbpll,or ver.c20111116
+	{0x32,0x8a08},
+	{0x33,0x1D02},//liuyanan
+	//agc_gain
+#if 1
+	{0x36, 0x02f4}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x25d4}, //0414;//aain_4
+	{0x3A, 0x2584}, //1804;//gain_3
+	{0x3B, 0x2dc4}, //1C04;//aain_2
+	{0x3C, 0x2d04}, //1C02;//gain_1
+	{0x3D, 0x2c02}, //3C01;//gain_0
+#else
+	{0x36, 0x01f8}, //00F8;//gain_7
+	{0x37, 0x01f4}, //0074;//aain_6
+	{0x38, 0x21d4}, //0014;//gain_5
+	{0x39, 0x2073}, //0414;//aain_4
+	{0x3A, 0x2473}, //1804;//gain_3
+	{0x3B, 0x2dc7}, //1C04;//aain_2
+	{0x3C, 0x2d07}, //1C02;//gain_1
+	{0x3D, 0x2c04}, //3C01;//gain_0
+#endif
+	{0x30,0x0248},
+	{0x30,0x0249},
+	//wait 200ms;
+	{0x33,0x1502},//liuyanan
+	//SET_channel_to_11
+	{0x1B,0x0001},//set_channel
+	{0x3f,0x0000},
+};
+#endif
+
+/*houzhen update Mar 15 2012
+  should be called when power up/down bt
+  */
+static int rda5990_wf_setup_A2_power(int enable)
+{
+	int ret;
+	u16 temp_data=0;
+	printk(KERN_INFO "***rda5990_wf_setup_A2_power start! \n");
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if(ret)
+		goto err;
+
+	if(enable) {
+		ret=i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x22, &temp_data);
+		if(ret)
+			goto err;
+		printk(KERN_INFO "***0xA2 readback value:0x%X \n", temp_data);
+
+		temp_data |=0x0200;   /*en reg4_pa bit*/
+#ifdef WLAN_USE_CRYSTAL
+		temp_data &= ~(1 << 14); //disable xen_out
+#endif
+		ret=i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x22, temp_data);
+		if(ret)
+			goto err;
+	} else {
+		ret=i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x28, &temp_data);
+		if(ret)
+			goto err;
+		if(temp_data&0x8000) { // bt is on
+			goto out;
+		} else {
+			ret=i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x22, &temp_data);
+			if(ret)
+				goto err;
+			temp_data&=0xfdff;
+
+			ret=i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x22, temp_data);
+			if(ret)
+				goto err;
+		}
+	}
+
+out:
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if(ret)
+		goto err;
+	printk(KERN_INFO "***rda5990_wf_setup_A2_power succeed! \n");
+	return 0;
+
+err:
+	printk(KERN_INFO "***rda5990_wf_setup_A2_power failed! \n");
+	return -1;
+}
+
+
+int rda_5990_wifi_rf_init(void)
+{
+	int ret = 0;
+
+	rda_combo_i2c_lock();
+
+	if( rda_wlan_version() == WLAN_VERSION_90_D) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			wifi_rf_init_data_90_verD);
+		if(ret)
+			goto err;
+	} else if(rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			wifi_rf_init_data_90_verE);
+		if(ret)
+			goto err;
+	} else {
+		printk("unknown version of this chip\n");
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***rda_5990_wifi_rf_init_succceed \n");
+	msleep(5);	 //5ms delay
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_5990_wifi_rf_init failed! \n");
+	return -1;
+}
+
+int rda_5990_wifi_dc_cal(void)
+{
+	int ret = 0;
+
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_dc_cal_data);
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***rda_wifi_rf_dc_calsuccceed \n");
+	msleep(50);   //50ms delay
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***rda_wifi_rf_dc_calf_failed! \n");
+	return -1;
+}
+
+int rda_5990_wifi_en(void)
+{
+	int ret = 0;
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+
+	msleep(8);
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_en_data_90);
+		if(ret)
+			goto err;
+	}
+
+	ret=rda5990_wf_setup_A2_power(1);	//en pa_reg for wf
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+
+	msleep(8);	 //8ms delay
+
+	printk(KERN_INFO "***rda_5990_wifi_en_succceed \n");
+	//in rda platform should close 26M after wifi power on success
+	disable_26m_rtc(CLOCK_WLAN);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	printk(KERN_INFO "***rda_5990_wifi_en failed! \n");
+	return -1;
+}
+
+static int rda_5990_wifi_debug_en(int enable)
+{
+	int ret = 0;
+	u16 temp_data = 0;
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret < 0)
+		goto err;
+	if (enable == 1) {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x80A1);
+		if (ret < 0)
+			goto err;
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			goto err;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data | (1 << 2));
+		if (ret < 0)
+			goto err;
+	} else {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x00A1);
+		if (ret < 0)
+			goto err;
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			goto err;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data & (~(1 << 2)));
+		if (ret < 0)
+			goto err;
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if (ret < 0)
+		goto err;
+
+err:
+	rda_combo_i2c_unlock();
+	return ret;
+}
+
+int rda_5990_tm_wifi_en(void)
+{
+	int ret = 0;
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+	msleep(5);
+	rda_combo_i2c_lock();
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+			rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			wifi_tm_en_data_90);
+		if(ret)
+			goto err;
+	}
+	rda_combo_i2c_unlock();
+	msleep(8);	 //8ms delay
+	printk(KERN_INFO "***rda_5990_tm_wifi_en succceed \n");
+	disable_26m_rtc(CLOCK_WLAN);
+	return 0;
+err:
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	printk(KERN_INFO "***rda_5990_tm_wifi_en failed! \n");
+	return -1;
+}
+
+int rda_5990_tm_wifi_rf_init(void)
+{
+	int ret = 0;
+	rda_combo_i2c_lock();
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+			rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			wifi_tm_rf_init_data_90);
+		if(ret)
+			goto err;
+	}else
+		return -1;
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_5990_tm_wifi_rf_init \n");
+	msleep(5);	 //5ms delay
+	return 0;
+
+err:
+	printk(KERN_INFO "***rda_5990_tm_wifi_rf_init failed! \n");
+	return -1;
+}
+/*houzhen add 2012 04 09
+  add to ensure wf dig powerup
+  */
+
+int rda_5990_wifi_dig_reset(void)
+{
+	int ret = 0;
+
+	msleep(8);	 //8ms delay
+
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_dig_reset_data_90);
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+
+	msleep(8);	 //8ms delay
+
+	printk(KERN_INFO "***rda_5990_wifi_dig_reset \n");
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***rda_5990_wifi_dig_reset failed! \n");
+	return -1;
+}
+
+int rda_5990_wifi_power_off(void)
+{
+	int ret = 0;
+	u16 temp=0x0000;
+	printk(KERN_INFO "rda_5990_wifi_power_off \n");
+
+	if(!rda_wifi_rf_client) {
+		printk(KERN_INFO "rda_5990_wifi_power_off failed on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret=rda5990_wf_setup_A2_power(0);	//disable pa_reg for wf
+	if(ret)
+		goto err;
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E){
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client,
+			0x3f, 0x0001);   //page up
+		if(ret)
+			goto err;
+
+		ret=i2c_read_1_addr_2_data(rda_wifi_rf_client,
+			0x28, &temp);	//poll bt status
+		if(ret)
+			goto err;
+
+		if(temp&0x8000) {
+			ret = i2c_write_1_addr_2_data(rda_wifi_rf_client,
+				0x3f, 0x0000);   //page down
+			if(ret)
+				goto err;
+
+			ret = i2c_write_1_addr_2_data(rda_wifi_rf_client,
+				0x0f, 0x2223);   // set antenna for bt
+			if(ret)
+				goto err;
+
+		}
+	}
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_off_data);
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+
+	wifi_is_on = 0;
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 0);
+	rda_release_firmware();
+#endif
+	printk(KERN_INFO "***rda_5990_wifi_power_off success!!! \n");
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_5990_wifi_power_off failed! \n");
+	return -1;
+
+}
+
+int rda_5990_wifi_power_on(void)
+{
+	int ret;
+	char retry = 3;
+
+	if(!rda_wifi_rf_client) {
+		printk(KERN_INFO "rda_5990_wifi_power_on failed on:i2c client \n");
+		return -1;
+	}
+
+_retry:
+	if( !check_test_mode() )
+	{
+		ret = rda_5990_wifi_en();
+		if(ret < 0)
+			goto err;
+
+		ret = rda_5990_wifi_rf_init();
+		if(ret < 0)
+			goto err;
+
+		ret = rda_5990_wifi_dc_cal();
+		if(ret < 0)
+			goto err;
+
+		msleep(20);   //20ms delay
+		ret=rda_5990_wifi_dig_reset();	//houzhen add to ensure wf power up safely
+
+		if(ret < 0)
+			goto err;
+		msleep(20);   //20ms delay
+	}
+	else{
+		ret = rda_5990_tm_wifi_en();
+		if(ret < 0)
+			goto err;
+
+		ret = rda_5990_tm_wifi_rf_init();
+		if(ret < 0)
+			goto err;
+	}
+	printk(KERN_INFO "rda_5990_wifi_power_on_succeed!! \n");
+	wifi_is_on = 1;
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 1);
+#endif
+	return 0;
+
+err:
+	printk(KERN_INFO "rda_5990_wifi_power_on_failed retry:%d \n", retry);
+	if(retry -- > 0)	{
+		rda_5990_wifi_power_off();
+		goto _retry;
+	}
+	wifi_is_on = 0;
+	return -1;
+}
+
+int rda_5990_fm_power_on(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if(!rda_wifi_rf_client){
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_on failed!\n");
+		return -1;
+	}
+
+	enable_32k_rtc(CLOCK_FM);
+	msleep(8);
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);   // page down
+		if(ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0x3f, 0x0001);
+			goto err;
+		}
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x22, &temp); //read 0xA2
+		if(ret < 0) {
+			printk(KERN_INFO "%s() read from address(0x%02x) failed! \n",
+				__func__, 0x22);
+			goto err;
+		}
+		temp = temp & (~(1 << 15)); 	//clear bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x22, temp);	 //write back
+		if(ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0x3f, 0x0001);
+			goto err;
+		}
+	}
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);  // page up
+	if(ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	printk(KERN_INFO "***rda_fm_power_on failed! \n");
+	return -1;
+}
+
+int rda_5990_fm_power_off(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if(!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_off failed!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);   // page down
+	if(ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E){
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x22, &temp);	//read 0xA2
+		if(ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0x22);
+			goto err;
+		}
+		temp = temp | (1 << 15);		//set bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x22, temp);	 //write back
+		if(ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0x3f, 0x0001);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);   // page up
+	if(ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_fm_power_off failed! \n");
+	return -1;
+}
+
+#ifndef RDA_COMBO_FROM_FIRMWARE
+static const u16 rda_5990_bt_off_data[][2] =
+{
+	{0x3f, 0x0001 }, //pageup
+	{0x28, 0x00A1 }, //power off bt
+	{0x3f, 0x0000 }, //pagedown
+};
+
+/*houzhen update 2012 03 06*/
+static const u16 rda_5990_bt_en_data[][2] =
+{
+	{0x3f, 0x0001 },		//pageup
+#ifdef WLAN_USE_DCDC
+	{0x23, 0x8FA1}, 	  // //20111001 higher AVDD voltage to improve EVM
+#else
+	{0x23, 0x0FA1},
+#endif
+	{0x24, 0x8048}, 	  // ;//freq_osc_in[1:0]00
+	{0x26, 0x47A5}, 	  //  reg_vbit_normal_bt[2:0] =111
+	{0x27, 0x4925}, 	  // //for ver.c20111109, txswitch
+	{0x29, 0x111F}, 	  // // rden4in_ldoon_bt=1
+	{0x32, 0x0111}, 	  // set_ rdenout_ldooff_wf=0;
+	{0x39, 0x0000}, 	  //	  //uart switch to bt
+
+	{0x28, 0x80A1}, 		// bt en
+	{0x3f, 0x0000}, 		//pagedown
+};
+
+static const u16 rda_5990_bt_dc_cal[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0129 },
+	{0x30, 0x012B },
+	{0x3f, 0x0000 },
+};
+
+static const u16 rda_5990_bt_set_rf_switch_data[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x0F, 0x2223 },
+	{0x3f, 0x0000 },
+};
+
+static const u16 RDA5990_bt_enable_clk_data[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0040 },
+	{0x2a, 0x285d },
+	{0x3f, 0x0000 },
+};
+
+static const u16 RDA5990_bt_dig_reset_data[][2] =
+{
+	{0x3f, 0x0001 }, //pageup
+	{0x28, 0x86A1 },
+	{0x28, 0x87A1 },
+	{0x28, 0x85A1 },
+	{0x3f, 0x0000 }, //pagedown
+};
+
+/*houzhen update 2012 03 06*/
+static const u16 rda_5990_bt_rf_data[][2] =
+{
+	{0x3f, 0x0000}, //pagedown
+	{0x01, 0x1FFF},
+	{0x06, 0x07F7},
+	{0x08, 0x29E7},
+	{0x09, 0x0520},
+	{0x0B, 0x03DF},
+	{0x0C, 0x85E8},
+	{0x0F, 0x0DBC},
+	{0x12, 0x07F7},
+	{0x13, 0x0327},
+	{0x14, 0x0CCC},
+	{0x15, 0x0526},
+	{0x16, 0x8918},
+	{0x18, 0x8800},
+	{0x19, 0x10C8},
+	{0x1A, 0x9078},
+	{0x1B, 0x80E2},
+	{0x1C, 0x361F},
+	{0x1D, 0x4363},
+	{0x1E, 0x303F},
+	{0x23, 0x2222},
+	{0x24, 0x359D},
+	{0x27, 0x0011},
+	{0x28, 0x124F},
+	{0x39, 0xA5FC},
+	{0x3f, 0x0001}, //page 1
+	{0x00, 0x043F},
+	{0x01, 0x467F},
+	{0x02, 0x28FF},
+	{0x03, 0x67FF},
+	{0x04, 0x57FF},
+	{0x05, 0x7BFF},
+	{0x06, 0x3FFF},
+	{0x07, 0x7FFF},
+	{0x18, 0xF3F5},
+	{0x19, 0xF3F5},
+	{0x1A, 0xE7F3},
+	{0x1B, 0xF1FF},
+	{0x1C, 0xFFFF},
+	{0x1D, 0xFFFF},
+	{0x1E, 0xFFFF},
+	{0x1F, 0xFFFF},
+	//	{0x22, 0xD3C7},
+	//	{0x23, 0x8fa1},
+	//	{0x24, 0x80c8},
+	//	{0x26, 0x47A5},
+	//	{0x27, 0x4925},
+	//	{0x28, 0x85a1},
+	//	{0x29, 0x111f},
+	//	{0x32, 0x0111},
+	//	{0x39, 0x0000},
+	{0x3f, 0x0000}, //pagedown
+};
+#endif
+
+/*houzhen update Mar 15 2012
+  should be called when power up/down bt
+  */
+static int rda5990_bt_setup_A2_power(int enable)
+{
+	int ret;
+	u16 temp_data=0;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if(ret)
+		goto err;
+
+	if(enable) {
+		ret=i2c_read_1_addr_2_data(rda_bt_rf_client,0x22,&temp_data);
+		if(ret)
+			goto err;
+		printk(KERN_INFO "***0xA2 readback value:0x%X \n", temp_data);
+
+		temp_data |=0x0200;   /*en reg4_pa bit*/
+
+		ret=i2c_write_1_addr_2_data(rda_bt_rf_client,0x22,temp_data);
+		if(ret)
+			goto err;
+	} else {
+		ret=i2c_read_1_addr_2_data(rda_bt_rf_client,0x31,&temp_data);
+		if(ret)
+			goto err;
+
+		if(temp_data&0x8000) {	// wf is on
+			goto out;
+		} else {
+			ret=i2c_read_1_addr_2_data(rda_bt_rf_client,0x22,&temp_data);
+			if(ret)
+				goto err;
+			temp_data&=0xfdff;
+
+			ret=i2c_write_1_addr_2_data(rda_bt_rf_client,0x22,temp_data);
+			if(ret)
+				goto err;
+		}
+
+	}
+
+out:
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+	if(ret)
+		goto err;
+	return 0;
+
+err:
+	printk(KERN_INFO "***rda5990_bt_setup_A2_power failed! \n");
+	return -1;
+}
+
+int rda_5990_bt_power_on(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "rda_bt_power_on \n");
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_bt_power_on failed on:i2c client \n");
+		return -1;
+	}
+	enable_26m_regulator(CLOCK_BT);
+	enable_26m_rtc(CLOCK_BT);
+	enable_32k_rtc(CLOCK_BT);
+	msleep(8);
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5990_bt_en_data);
+		if(ret)
+			goto err;
+	}
+
+	ret=rda5990_bt_setup_A2_power(1);
+	if(ret) {
+		printk(KERN_INFO
+			"***rda5990_bt_setup_A2_power fail!!! \n");
+		goto err;
+	}
+
+	printk(KERN_INFO "***rda_bt_power_on success!!! \n");
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 1);
+#endif
+	rda_combo_i2c_unlock();
+	/*houzhen update 2012 03 06*/
+	msleep(10); 	//delay 10 ms after power on
+	disable_26m_rtc(CLOCK_BT);
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	printk(KERN_INFO "***rda_bt_power_on failed! \n");
+	return -1;
+
+}
+
+int rda_5990_bt_power_off(void)
+{
+	int ret = 0;
+	printk(KERN_INFO "rda_5990_bt_power_off \n");
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_5990_bt_power_off failed on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5990_bt_off_data);
+		if(ret)
+			goto err;
+	}
+
+	msleep(10);   //10ms
+	printk(KERN_INFO "***rda_5990_bt_power_off success!!! \n");
+	ret=rda5990_bt_setup_A2_power(0);//disable ldo_pa reg
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_5990_bt_power_off failed! \n");
+	return -1;
+
+}
+
+
+static int RDA5990_bt_rf_init(void)
+{
+	int ret = 0;
+
+	if(!rda_bt_rf_client){
+		printk(KERN_INFO "RDA5990_bt_rf_init on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5990_bt_rf_data);
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***RDA5990_bt_rf_init success!!! \n");
+	msleep(5);	 //5ms
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_rf_init failed! \n");
+	return -1;
+}
+
+/*houzhen add 2012 04 09
+  add to ensure bt dig powerup
+  */
+static int RDA5990_bt_dig_reset(void)
+{
+	int ret = 0;
+
+	if(!rda_bt_rf_client){
+		printk(KERN_INFO "RDA5990_bt_dig_reset on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_bt_rf_client,
+		RDA5990_bt_dig_reset_data);
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+
+	printk(KERN_INFO "***RDA5990_bt_dig_reset success!!! \n");
+	msleep(5);	 //5ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_dig_reset failed! \n");
+	return -1;
+}
+
+
+static int RDA5990_bt_dc_cal(void)
+{
+	int ret = 0;
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_bt_rf_client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5990_bt_dc_cal);
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_bt_dc_cal success!!! \n");
+	msleep(200);   //200ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_bt_dc_cal	failed! \n");
+	return -1;
+
+}
+
+
+/*houzhen update Mar 15 2012
+  bypass RDA5990_bt_set_rf_switch when wf is already on
+*/
+
+static int RDA5990_bt_set_rf_switch(void)
+{
+	int ret = 0;
+	u16 temp_data=0;
+
+	if(!rda_bt_rf_client || !rda_wifi_rf_client){
+		printk(KERN_INFO
+			"RDA5990_bt_set_rf_switch failed on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	if(rda_wlan_version() == WLAN_VERSION_90_D ||
+		rda_wlan_version() == WLAN_VERSION_90_E) {
+		ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+		if(ret)
+			goto err;
+
+		ret=i2c_read_1_addr_2_data(rda_bt_rf_client,0x31,&temp_data);
+		if(ret)
+			goto err;
+
+		if(temp_data&0x8000) { // if wf is already on
+			printk(KERN_INFO
+				"wf already en, bypass RDA5990_bt_set_rf_switch function \n");
+			ret = i2c_write_1_addr_2_data(rda_bt_rf_client,
+				0x3f, 0x0000);
+			if(ret)
+				goto err;
+
+			rda_combo_i2c_unlock();
+			return 0;
+		}
+
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			rda_5990_bt_set_rf_switch_data);
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_set_rf_switch success!!! \n");
+	msleep(50);   //50ms
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_set_rf_switch  failed! \n");
+	return -1;
+
+}
+
+
+/*houzhen update Mar 15 2012
+  bypass RDA5990_bt_enable_clk when wf is already on
+  */
+static int RDA5990_bt_enable_clk(void)
+{
+	int ret = 0;
+	u16 temp_data=0;
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO
+			"RDA5990_bt_enable_clk failed on:i2c client \n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if(ret)
+		goto err;
+
+	ret=i2c_read_1_addr_2_data(rda_bt_rf_client,0x31,&temp_data);
+
+	if(ret)
+		goto err;
+
+	if(temp_data&0x8000){ // if wf is already on
+		printk(KERN_INFO
+			"wf already en, bypass RDA5990_bt_enable_clk function \n");
+		ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+		if(ret)
+			goto err;
+		rda_combo_i2c_unlock();
+		return 0;
+	}
+
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client,
+		RDA5990_bt_enable_clk_data);
+	if(ret)
+		goto err;
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_enable_clk success!!! \n");
+	msleep(50);   //50ms
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5990_bt_enable_clk	failed! \n");
+	return -1;
+}
+
+long rda_5990_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch(cmd) {
+	case RDA_WIFI_POWER_ON_IOCTL:
+		ret = rda_5990_wifi_power_on();
+		break;
+
+	case RDA_WIFI_POWER_OFF_IOCTL:
+		ret = rda_5990_wifi_power_off();
+		break;
+
+	case RDA_WIFI_DEBUG_MODE_IOCTL:
+		{
+			int enable = 0;
+			if(copy_from_user(&enable, (void*)arg, sizeof(int))) {
+				printk(KERN_ERR "copy_from_user enable failed!\n");
+				return -EFAULT;
+			}
+			ret = rda_5990_wifi_debug_en(enable);
+			break;
+		}
+	case RDA_BT_POWER_ON_IOCTL:
+		ret = rda_5990_bt_power_on();
+		break;
+
+	/* should call this function after bt_power_on*/
+	case RDA_BT_EN_CLK:
+		ret = RDA5990_bt_enable_clk();
+		break;
+
+	case RDA_BT_RF_INIT_IOCTL:
+		ret = RDA5990_bt_rf_init();
+		break;
+
+	case RDA_BT_DC_CAL_IOCTL:
+		ret = RDA5990_bt_dc_cal();
+		break;
+
+	case RDA_BT_DC_DIG_RESET_IOCTL:
+		ret = RDA5990_bt_dig_reset();
+		break;
+
+	case RDA_BT_RF_SWITCH_IOCTL:
+		ret = RDA5990_bt_set_rf_switch();
+		break;
+
+	case RDA_BT_POWER_OFF_IOCTL:
+		ret = rda_5990_bt_power_off();
+		break;
+
+	default:
+		ret = -EFAULT;
+		printk(KERN_ERR "******rda_5990_pw_ioctl cmd[0x%02x]******.\n", cmd);
+		break;
+	}
+
+	printk(KERN_INFO "rda_bt_pw_ioctl cmd=0x%02x \n", cmd);
+	return ret;
+}
+
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991_power_ctrl.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991_power_ctrl.c
new file mode 100644
index 000000000000..a5d95a0fea8f
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991_power_ctrl.c
@@ -0,0 +1,773 @@
+#include "rda_combo.h"
+#ifndef RDA_COMBO_FROM_FIRMWARE
+
+#ifdef WLAN_USE_DCDC
+static const u16 pmu_setting_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x22, 0xA1F3},		//Pu_rf_dr=0;Nonov_delay_dig=11,Nonov_delay_ana=11
+	{0x24, 0x8808},		//pu_dcdc_dr_ana=0;pu_ldo_dr_ana=0;AVDD=2.07V;sleep vol=0000;clk_mode_sel_dr_ana =0
+	{0x26, 0x8255},		//sleep voltage=800mV;clk_mode_sel_dr_dig=0
+	{0x23, 0xC200},		//Dcdc_en_ana=1
+	{0x25, 0xC27F},		//Dcdc_en_dig=1;sleep_ldo_vout=111=1.1v
+	{0x29, 0x1113},
+	{0x32, 0x1113},
+	{0x37, 0x0B8A},
+	{0x39, 0x1200},		//for dcdc;uart_bypass_en
+	{0x3F, 0x0000},
+};
+#else
+static const u16 pmu_setting_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x22, 0xA1F3},		//Pu_rf_dr=0;Nonov_delay_dig=11,Nonov_delay_ana=11
+	{0x24, 0x8808},		//pu_dcdc_dr_ana=0;pu_ldo_dr_ana=0;AVDD=2.07V;sleep vol=0000;clk_mode_sel_dr_ana =0
+	{0x26, 0x8255},		//sleep voltage=800mV;clk_mode_sel_dr_dig=0;pu_ldo_dr_dig=1;pu_ldo_reg_dig =1
+	{0x23, 0x4200},		//Dcdc_en_ana=0
+	{0x25, 0x427F},		//Dcdc_en_dig=0;sleep_ldo_vout=111=1.1v
+	{0x29, 0x1113},
+	{0x32, 0x1113},
+	{0x37, 0x0B8A},
+	{0x39, 0x1200},		//for dcdc;uart_bypass_en
+	{0x3F, 0x0000},
+};
+#endif
+
+/*add according to hongjun's new config*/
+static const u16 soft_reset_5991[][2] = {
+	{0x3F, 0x0000},
+	{0x30, 0x8000},
+	{0x30, 0x0000},
+};
+
+static const u16 wf_en_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x8B40},		//;WIFI_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 wifi_disable_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x0B40},		//;WIFI_en=0
+	{0x3F, 0x0000},
+};
+
+static const u16 wf_rf_setting_5991[][2] = {
+	{0x3F, 0x0000},
+	{0x10, 0x9f33},		//wf_lna_bpf_en =1
+	{0x11, 0xFF8A},
+	{0x13, 0x5054},
+	{0x14, 0x988C},		//wf_pll_regbit_presc[3:0]=1100,for temperatrue
+	{0x15, 0x596F},
+	{0x16, 0x200B},		//wf_pll_r_bit[1:0] =01;wf_pll_r_bit[1:0]=00
+	{0x19, 0x9C01},		//wf_pll_sinc_mode[2:0]=001 ,ver D
+	{0x1C, 0x06E4},		//wf_dac_cm_bit[1:0]=00,1.1V
+	{0x1D, 0x3A8C},
+	{0x22, 0xFF4B},		//ver D
+	{0x23, 0xAA3C},
+	{0x24, 0x88C4},		//wf_dac_cal_dr=1;ver D
+	{0x28, 0x1320},
+	{0x2A, 0x0036},         //CL=7.3pf crystal, 2A=0x0036
+	{0x2B, 0x41BB},		//wf_ovd_resbit_for_wf_tx[7:0]=FF;wf_pa_cap2_open_for_wf_tx=1
+	{0x2D, 0xFF03},		//wf_pa_capbit_for_wf_tx[7:0]=3
+	{0x2F, 0x00DE},		//wf_dsp_resetn_tx_dr=1;wf_dsp_resetn_tx_reg=1; ;;wf_dsp_resetn_rx_dr=1;wf_dsp_resetn_rx_reg=1;
+	{0x34, 0x3000},		//wf_dac_clk_inv[1:0]=11
+	{0x39, 0x8000},
+	{0x40, 0x7FFF},		//wf_tmx_gain,wf_pabias
+	{0x41, 0xFFFF},		//wf_pabias
+};
+
+static const u16 wf_agc_setting_for_dccal_5991[][2] = {
+	{0x3F, 0x0000},
+	{0x0F, 0x61F7},		//;//0F
+	{0x0E, 0x61F0},		//
+	{0x0D, 0x60F0},		//
+	{0x0C, 0x6070},		//
+	{0x0B, 0x6030},		//
+	{0x0A, 0x6010},		//
+	{0x09, 0x7033},		//
+	{0x08, 0x6830},		//;;//08
+	{0x3F, 0x0001},
+	{0x07, 0x7031},		//;;//07
+	{0x06, 0x7011},		//;;//06
+	{0x05, 0x7871},		//
+	{0x04, 0x7831},		//;;//04
+	{0x03, 0x7811},		//;;//03
+	{0x02, 0x7801},		//;;//02
+	{0x01, 0x7800},		//;;//01
+	{0x00, 0x7800},		//;;//00
+	{0x3F, 0x0000},
+};
+
+static const u16 wf_agc_setting_5991[][2] = {
+	{0x3F, 0x0000},
+	{0x0F, 0x01F7},		//;//0F
+	{0x0E, 0x01F0},		//
+	{0x0D, 0x00F0},		//
+	{0x0C, 0x0070},		//
+	{0x0B, 0x0030},		//
+	{0x0A, 0x0010},		//
+	{0x09, 0x3033},		//
+	{0x08, 0x0830},		//;;//08
+	{0x3F, 0x0001},
+	{0x07, 0x7031},		//;;//07
+	{0x06, 0x7011},		//;;//06
+	{0x05, 0x7871},		//
+	{0x04, 0x7831},		//;;//04
+	{0x03, 0x7811},		//;;//03
+	{0x02, 0x7801},		//;;//02
+	{0x01, 0x7800},		//;;//01
+	{0x00, 0x7800},		//;;//00
+	{0x3F, 0x0000},
+};
+
+static const u16 wf_calibration_5991[][2] = {
+#if 1 //hongjun's new config
+        {0x3F,0x0000},
+        {0x1a,0x0026},//2487MHZ
+        {0x1B,0xDC00},//2487MHZ
+        {0x28,0x1F20},
+        {0x28,0x1320},
+        {0x30,0x0159},//frequency mode
+        {0x30,0x0158},
+        {0x30,0x0159},//dc_cal
+        DELAY_MS(200)
+#else
+	{0x3F, 0x0000},
+	{0x30, 0x0148},
+	DELAY_MS(100)
+	{0x28, 0x1F20},	//mdll_startup
+	{0x28, 0x1320},		//mdll_startup_done
+	{0x30, 0x0149},
+	DELAY_MS(100)
+	{0x30, 0x0349},	//wf_chip_self_cal_en=1
+#endif
+};
+
+static const u16 bt_rf_setting_5991[][2] = {
+	{0x3F, 0x0000},
+	{0x02, 0x0E00},		//BT_Agc<2:0>;
+	{0x08, 0xEFFF},		//bt_lna_gain2_7[2:0=11111
+	{0x0A, 0x09FF},		//bt_rxflt_gain_5=11
+	{0x11, 0x0035},		//
+	{0x13, 0x2C68},		//
+	{0x14, 0x91C4},		//bt_adc_digi_pwr_bit_reg[2:0]=011
+	{0x18, 0x2010},		//bt_pll_phase_ctrl_dly[1:0]=00
+	{0x30, 0x0141},
+	{0x3F, 0x0001},
+	{0x01, 0x66F3},		//bt_tmx_therm_gain_f[3:0]=0011
+	{0x3F, 0x0000},
+	{0x2E, 0xCAA3},		//bt_swtrx_dr=1;bt_swtrx_reg=1
+	{0x37, 0x4411},		//PSK
+	{0x38, 0x1348},		//PSK
+	{0x3B, 0x2200},		//GFSK
+	{0x3C, 0x0124},		//GFSK
+	{0x3F, 0x0001},
+	{0x00, 0xBBBB},		//
+	{0x01, 0x66F3},		//
+	{0x02, 0xBBBB},		//
+	{0x03, 0x66F3},		//
+	{0x04, 0xBBBB},		//
+	{0x05, 0x66F3},		//
+	{0x06, 0xBBBB},		//
+	{0x07, 0x66FF},		//
+	{0x08, 0xBBBB},		//
+	{0x09, 0x66F7},		//
+	{0x0A, 0xBBBB},		//
+	{0x0B, 0x66F0},		//
+	{0x39, 0x1200},		//uart_bypass_en=0
+	{0x3F, 0x0000},
+};
+
+static const u16 control_mode_disable_5991[][2] = {
+#if 1 //hongjun's new config
+        {0x3F,0x0000},
+        {0x30,0x0149},//channel mode
+        {0x30,0x014D},
+        {0x30,0x0141},
+#else
+	{0x3F, 0x0000},
+	{0x30, 0x0141},
+#endif
+};
+
+static const u16 bt_en_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x85A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 bt_disable_5991[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x05A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+// add for pta
+static const u16 rda_5991_bt_dc_ca_fix_gain[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0141 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+	{0x30, 0x0341 },  //force gain level to 7 before lna issue fixed
+	{0x2e, 0x8aa3 },  //force gain level to 7 before lna issue fixed
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991_bt_dc_ca_fix_gain_no_wf[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991_bt_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x2e, 0xcaa3 },  //force gain level to 7 before lna issue fixed
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991_bt_no_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x2e, 0x8aa3 },  //force gain level to 7 before lna issue fixed
+	{0x3f, 0x0000 },
+};
+// add for pta
+#endif
+
+static int check_wifi_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x31, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int check_bt_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_bt_rf_client, 0x28, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int power_on(int isWifi)
+{
+	int ret = 0;
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, pmu_setting_5991);
+	if (ret)
+		goto err;
+	printk(KERN_INFO "%s write pmu_setting succeed!! \n", __func__);
+
+	if (isWifi) {		// for wifi
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+	} else {		// for bt
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(5);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, soft_reset_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write soft_reset succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_rf_setting_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_rf_setting_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write bt_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client,
+		wf_agc_setting_for_dccal_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_agc_setting_for_dccal succeed!! \n",
+		__func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_calibration_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_calibration succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_agc_setting_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_agc_setting succeed!! \n", __func__);
+
+	return 0;
+power_off:
+	if (isWifi) {		// for wifi
+		rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991);
+	} else {
+		rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991);
+	}
+err:
+	return -1;
+}
+
+static int rda_5991_wifi_debug_en(void)
+{
+	u16 temp_data = 0;
+	int ret = 0;
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret < 0)
+		return -1;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x80a1);
+	if (ret < 0)
+		return -1;
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+	if (ret < 0)
+		return -1;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+		temp_data | 0x04);
+	if (ret < 0)
+		return -1;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if (ret < 0)
+		return -1;
+	return ret;
+}
+
+int rda_5991_wifi_power_on(void)
+{
+	int ret = 0, bt_power_on = 0;
+
+	//if bt is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+	bt_power_on = check_bt_power_on();
+	printk(KERN_INFO "%s bt_power_on=%d \n", __func__, bt_power_on);
+
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+
+		//add for pta
+		//handle btswtrx dr
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991_bt_no_force_swtrx);
+		if (ret)
+			goto err;
+		printk(KERN_INFO
+			"%s write rda_5991_bt_no_force_swtrx succeed!! \n",
+			__func__);
+		// add for pta
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(1);
+		if (ret)
+			goto err;
+	}
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client,
+		control_mode_disable_5991);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write control_mode_disable succeed!! \n",
+		__func__);
+	if(check_test_mode()) {
+		rda_5991_wifi_debug_en();
+		printk(KERN_INFO
+			"%s: IN test mode, switch uart to WIFI succeed!! \n",
+			__func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(100);
+	disable_26m_rtc(CLOCK_WLAN);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 1);
+#endif
+	return ret;
+
+power_off:
+	rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991);
+err:
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991_wifi_power_off(void)
+{
+	int ret = 0;
+	int bt_power_on = 0;  // add for pta
+	rda_combo_i2c_lock();
+	bt_power_on = check_bt_power_on();
+
+	//add for pta
+	if(bt_power_on) {
+
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991_bt_force_swtrx);
+
+		if (ret) {
+			printk(KERN_INFO
+				"%s  rda_5991_bt_force_swtrx failed!! \n",
+				__func__);
+		} else {
+			printk(KERN_INFO
+				"%s  rda_5991_bt_force_swtrx succeed!! \n",
+				__func__);
+		}
+
+	}
+	// add for pta
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+
+int rda_5991_bt_power_on(void)
+{
+	int ret = 0, wifi_power_on = 0;
+
+	//if wifi is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_BT);
+	enable_26m_rtc(CLOCK_BT);
+	enable_32k_rtc(CLOCK_BT);
+
+	wifi_power_on = check_wifi_power_on();
+	printk(KERN_INFO "%s wifi_power_on=%d \n", __func__, wifi_power_on);
+
+	if (wifi_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(0);
+		if (ret)
+			goto err;
+	}
+
+	printk(KERN_INFO "%s succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	disable_26m_rtc(CLOCK_BT);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 1);
+#endif
+	return ret;
+
+err:
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991_bt_power_off(void)
+{
+	int ret = 0;
+	rda_combo_i2c_lock();
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+// add for pta
+static int RDA5991_bt_dc_cal_fix_gain(void)
+{
+	int ret = 0;
+	int is_wfen;
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_bt_rf_client is NULL!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+	is_wfen= check_wifi_power_on();
+	//check the version and make sure this applies to 5991
+	if(rda_wlan_version() == WLAN_VERSION_91) {
+		if(is_wfen) {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991_bt_dc_ca_fix_gain);
+		} else {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991_bt_dc_ca_fix_gain_no_wf);
+		}
+
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991_bt_dc_cal_fix_gain_update  success!!! \n");
+	msleep(200);   //200ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991_bt_dc_cal_fix_gain	failed! \n");
+	return -1;
+
+}
+
+// add for pta
+
+long rda_5991_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case RDA_WIFI_POWER_ON_IOCTL:
+		ret = rda_5991_wifi_power_on();
+		break;
+
+	case RDA_WIFI_POWER_OFF_IOCTL:
+		ret = rda_5991_wifi_power_off();
+		break;
+
+	case RDA_BT_POWER_ON_IOCTL:
+		ret = rda_5991_bt_power_on();
+		break;
+
+	case RDA_BT_POWER_OFF_IOCTL:
+		ret = rda_5991_bt_power_off();
+		break;
+
+	case RDA_WIFI_DEBUG_MODE_IOCTL:
+		ret = rda_5991_wifi_debug_en();
+		break;
+		// add for pta
+	case RDA_BT_DC_CAL_IOCTL_FIX_5991_LNA_GAIN:
+		ret = RDA5991_bt_dc_cal_fix_gain();
+		break;
+		// add for pta
+	default:
+		break;
+	}
+
+	printk(KERN_INFO "rda_bt_pw_ioctl cmd=0x%02x \n", cmd);
+	return ret;
+}
+
+int rda_5991_fm_power_on(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_on failed!\n");
+		return -1;
+	}
+
+	enable_32k_rtc(CLOCK_FM);
+	msleep(8);
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91) {
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+			 	__func__, 0xA7);
+			goto err;
+		}
+		temp = temp | 0x1;	//set bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp);	//read 0xB9
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xB9);
+			goto err;
+		}
+		temp = temp | (0x1 << 15);	//set bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xB9, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	printk(KERN_INFO "***rda_fm_power_on failed! \n");
+	return -1;
+}
+
+int rda_5991_fm_power_off(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_off failed!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+		 	"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91) {
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp & ~(0x1);	//clear bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_fm_power_off failed! \n");
+	return -1;
+}
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991e_power_ctrl.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991e_power_ctrl.c
new file mode 100644
index 000000000000..e528388e9e73
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991e_power_ctrl.c
@@ -0,0 +1,847 @@
+#include "rda_combo.h"
+#ifndef RDA_COMBO_FROM_FIRMWARE
+
+#ifdef WLAN_USE_DCDC
+		static const u16 pmu_setting_5991e[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906}, //{0x24,  0x8908}  sleep mode with analog power on
+	{0x26,	0x8055},
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xA108},
+	{0x23,	0xA200}, //{0x23,  0x8200}
+	{0x25,	0xA247}, //{0x25,  0x8247} heavy_load_dig
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+};
+#else
+static const u16 pmu_setting_5991e[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906},
+	{0x26,	0x8555},
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xC208},
+	{0x23,	0x0200},
+	{0x25,	0x027F},
+	{0x3F,  0x0000},
+};
+#endif
+static const u16 soft_reset_5991e[][2] = {
+	{0x3F, 0x0000},
+	{0x30, 0x8000},
+	{0x30, 0x0000},
+};
+static const u16 wf_en_5991e[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x8B40},		//;WIFI_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 wifi_disable_5991e[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x0B40},		//;WIFI_en=0
+	{0x26, 0x8055},
+	{0x3F, 0x0000},
+};
+
+#ifdef COMBO_WITH_26MHZ
+static const u16 wf_rf_setting_5991e[][2] = {
+	{0x3F,  0x0000},
+	{0x05,	0x0000},
+	{0x06,	0x1124}, //wf_bbpll_cpaux_bit[2:0]=100
+	{0x07,	0x0820},
+	{0x10,	0x9ff7},
+	{0x11,	0xFFFA},//filter bandwidth
+	{0x13,	0x5054},
+	{0x14,	0x988C},
+	{0x15,	0x58e8},
+	{0x16,	0x200B},
+	{0x19,	0x9C01},
+	{0x1C,	0x06E4},
+	{0x1D,	0x3A8C},
+	{0x22,	0xFF7B},
+	{0x23,	0x283C},//dc cal
+	{0x24,	0xA0C4},
+	{0x28,	0x4320},
+	{0x2A,	0x1036},//{0x2A,  0x0077}
+	{0x2B,	0x41BB},
+	{0x2D,	0xFF03},
+	{0x2F,	0x15DE},
+	{0x34,	0x3000},
+	{0x35,	0x8011},
+	{0x39,	0x6018},
+	{0x3B,	0x3218},
+	{0x3D,	0xFF00},//rxon delay
+	{0x40,	0xFFFF},//wf_tmx_gain,wf_pabias;20140825
+	{0x41,	0xFFFF},
+	{0x7D,	0x4020},//paon delay
+	{0x3F,  0x0001},
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+	{0x30,	0x0100},
+	{0x28,	0x4F20},
+	 DELAY_MS(1)
+	{0x28,	0x4320},
+	{0x30,	0x0149},
+};
+#else
+static const u16 wf_rf_setting_5991e[][2] = {
+};
+#endif
+
+static const u16 wf_agc_setting_for_dccal_5991e[][2] = {
+
+};
+
+static const u16 wf_agc_setting_5991e[][2] = {
+	{0x3F,  0x0000},
+#ifdef CHINA_VERSION
+	{0x0F,	0x01F0},
+	{0x0E,	0x01F0},
+	{0x0D,	0x00F0},
+	{0x0C,	0x0070},
+	{0x0B,	0x0030},
+	{0x0A,	0x0010},
+	{0x09,	0x3031},
+	{0x08,	0x0830},
+	{0x3F,  0x0001},
+	{0x07,	0x7030},
+	{0x06,	0x7010},
+	{0x05,	0x7870},
+	{0x04,	0x7830},
+	{0x03,	0x7810},
+	{0x02,	0x7800},
+	{0x01,	0x7800},
+	{0x00,	0x7800},
+#else /*High SNR*/
+	{0x0F,	0x01F7},
+	{0x0E,	0x01F0},
+	{0x0D,	0x00F0},
+	{0x0C,	0x0070},
+	{0x0B,	0x0030},
+	{0x0A,	0x0010},
+	{0x09,	0x3033},
+	{0x08,	0x0830},
+	{0x3F,  0x0001},
+	{0x07,	0x7030},
+	{0x06,	0x7010},
+	{0x05,	0x7870},
+	{0x04,	0x7830},
+	{0x03,	0x7811},
+	{0x02,	0x7800},
+	{0x01,	0x7800},
+	{0x00,	0x7800},
+#endif /*CHINA_VERSION*/
+	{0x3F,  0x0000},
+};
+
+static const u16 wf_calibration_5991e[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0148},
+	{0x30,	0x0149},
+	 DELAY_MS(50)
+};
+
+static const u16 fix_agc_gain_5991e[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0349},
+};
+
+static const u16 bt_rf_setting_5991e[][2] = {
+	{0x3F,  0x0000},
+#ifdef COMBO_WITH_26MHZ
+	{0x2E,	0xCAB3},
+#else
+#endif /* COMBO_WITH_26MHZ */
+	{0x02,	0x0E00},
+	{0x08,	0xEFFF},
+	{0x0A,	0x09FF},
+	{0x11,	0x00B5},
+	{0x13,	0x07C0},
+	{0x14,	0xFDC4},
+	{0x18,	0x2010},
+	{0x19,	0x7956},
+	{0x1B,	0xDF7F},//  0xDFFF  10.5 db  0xDF7F 14.5
+	{0x26,	0x6640},
+	{0x2B,	0x007F},
+	{0x2C,	0x600F},
+	{0x2D,	0x007F},
+	{0x2F,	0x1000},
+	{0x30,	0x0141},
+	{0x37,	0x3333}, //PSK
+	{0x38,	0x357A}, //PSK
+	{0x3B,	0x1111}, //GFSK
+	{0x3C,	0x1235}, //GFSK
+	{0x3F,  0x0001},
+	{0x00,	0x0000},
+	{0x01,	0xFFE7}, // bt power
+	{0x02,	0x0000},
+	{0x03,	0xFFE7},
+	{0x04,	0x0000},
+	{0x05,	0xFFE5},
+	{0x06,	0x0000},
+	{0x07,	0xFFE5},
+	{0x08,	0x0000},
+	{0x09,	0xFFD1},
+	{0x0A,	0x0000},
+	{0x0B,	0xFFD1},
+	//{0x39,	0x1208},
+	{0x3F,  0x0000},
+};
+
+static const u16 control_mode_disable_5991e[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0141},
+};
+
+static const u16 bt_en_5991e[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x85A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 bt_disable_5991e[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x05A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+// add for pta
+static const u16 rda_5991e_bt_dc_ca_fix_gain[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0141 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+//	{0x30, 0x0341 },  //force gain level to 7 before lna issue fixed
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#else
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991e_bt_dc_ca_fix_gain_no_wf[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991e_bt_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0xcab3 },  //force gain level to 7 before lna issue fixed
+#else
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991e_bt_no_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#else
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+
+
+static const u16  bt_dc_cal_5991e[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0140},
+	{0x30,  0x0141},
+	 DELAY_MS(50)
+};
+
+#endif
+
+static int check_wifi_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x31, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int check_bt_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_bt_rf_client, 0x28, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int power_on(int isWifi)
+{
+	int ret = 0;
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, pmu_setting_5991e);
+	if (ret)
+		goto err;
+	printk(KERN_INFO "%s write pmu_setting succeed!! \n", __func__);
+
+	if (isWifi) {		// for wifi
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991e);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+	} else {		// for bt
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991e);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(5);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, soft_reset_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write soft_reset succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_rf_setting_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_rf_setting_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write bt_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_agc_setting_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_agc_setting succeed!! \n",
+	       __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_calibration_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_calibration succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, fix_agc_gain_5991e);
+	if(ret)
+		goto power_off;
+	printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	return 0;
+power_off:
+	if (isWifi) {		// for wifi
+		rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991e);
+	} else {
+		rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991e);
+	}
+err:
+	return -1;
+}
+
+static int rda_5991e_wifi_debug_en(int enable)
+{
+	u16 temp_data = 0;
+	int ret = 0;
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret < 0)
+		return -1;
+	if (enable == 1) {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x80a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data | (1 << 2));
+		if (ret < 0)
+			return -1;
+	} else {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x00a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+				temp_data & (~(1 << 2)));
+		if (ret < 0)
+			return -1;
+	}
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if (ret < 0)
+		return -1;
+	return ret;
+}
+
+int rda_5991e_wifi_power_on(void)
+{
+	int ret = 0, bt_power_on = 0;
+	u16 value;
+	bool need_retry;
+	int retry_count = 0;
+
+	//if bt is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+retry:
+	need_retry = false;
+	bt_power_on = check_bt_power_on();
+	printk(KERN_INFO "%s bt_power_on=%d \n", __func__, bt_power_on);
+
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991e);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+
+		//add for pta
+		//handle btswtrx dr
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991e_bt_no_force_swtrx);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write rda_5991_bt_no_force_swtrx succeed!! \n",
+			__func__);
+		// add for pta
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(1);
+		if (ret)
+			goto err;
+	}
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, control_mode_disable_5991e);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write control_mode_disable succeed!! \n", __func__);
+	if (check_test_mode()) {
+		rda_5991e_wifi_debug_en(1);
+		printk(KERN_INFO "%s: IN test mode, switch uart to WIFI succeed!! \n",
+			__func__);
+	}
+
+	//wait for 1ms
+	mdelay(1);
+	//WF_BBPLL unlock workaround
+	i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x07, &value);
+	if(!(value & (1 << 15))){
+		need_retry = true;
+		ret = -1;
+	}
+	if(need_retry && (++retry_count < 1)){
+		rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991e);
+		goto retry;
+	}
+	rda_combo_i2c_unlock();
+	msleep(100);
+	disable_26m_rtc(CLOCK_WLAN);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 1);
+#endif
+	return ret;
+
+power_off:
+	rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991e);
+err:
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991e_wifi_power_off(void)
+{
+	int ret = 0, bt_power_on = 0;
+	rda_combo_i2c_lock();
+	bt_power_on = check_bt_power_on();
+	//add for pta
+	if(bt_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991e_bt_force_swtrx);
+		if (ret) {
+			printk(KERN_INFO "%s  rda_5991_bt_force_swtrx failed!! \n",
+				__func__);
+		} else {
+			printk(KERN_INFO "%s  rda_5991_bt_force_swtrx succeed!! \n",
+				__func__);
+		}
+	}
+	// add for pta
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991e);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+
+	bt_power_on = check_bt_power_on();
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, fix_agc_gain_5991e);
+		printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+
+int rda_5991e_bt_power_on(void)
+{
+	int ret = 0, wifi_power_on = 0;
+
+	//if wifi is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_BT);
+	enable_26m_rtc(CLOCK_BT);
+	enable_32k_rtc(CLOCK_BT);
+
+	wifi_power_on = check_wifi_power_on();
+	printk(KERN_INFO "%s wifi_power_on=%d \n", __func__, wifi_power_on);
+
+	if (wifi_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991e);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(0);
+		if (ret)
+			goto err;
+	}
+
+	printk(KERN_INFO "%s succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	disable_26m_rtc(CLOCK_BT);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 1);
+#endif
+	return ret;
+
+err:
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991e_bt_power_off(void)
+{
+	int ret = 0;
+	rda_combo_i2c_lock();
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991e);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+// add for pta
+static int RDA5991e_bt_dc_cal_fix_gain(void)
+{
+	int ret = 0;
+	int is_wfen;
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_bt_rf_client is NULL!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+	is_wfen= check_wifi_power_on();
+	//check the version and make sure this applies to 5991
+	if(rda_wlan_version() == WLAN_VERSION_91_E) {
+		if(is_wfen) {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991e_bt_dc_ca_fix_gain);
+		} else {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991e_bt_dc_ca_fix_gain_no_wf);
+		}
+
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991e_bt_dc_cal_fix_gain success!!!\n");
+	msleep(200);   //200ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991e_bt_dc_cal_fix_gain failed! \n");
+	return -1;
+
+}
+// add for pta
+long rda_5991e_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case RDA_WIFI_POWER_ON_IOCTL:
+		ret = rda_5991e_wifi_power_on();
+		break;
+
+	case RDA_WIFI_POWER_OFF_IOCTL:
+		ret = rda_5991e_wifi_power_off();
+		break;
+
+	case RDA_BT_POWER_ON_IOCTL:
+		ret = rda_5991e_bt_power_on();
+		break;
+
+	case RDA_BT_POWER_OFF_IOCTL:
+		ret = rda_5991e_bt_power_off();
+		break;
+
+	case RDA_WIFI_DEBUG_MODE_IOCTL:
+		{
+			int enable = 0;
+			if(copy_from_user(&enable, (void*)arg, sizeof(int))) {
+				printk(KERN_ERR "copy_from_user enable failed!\n");
+				return -EFAULT;
+			}
+			ret = rda_5991e_wifi_debug_en(enable);
+			break;
+		}
+		// add for pta
+	case RDA_BT_DC_CAL_IOCTL_FIX_5991_LNA_GAIN:
+		ret = RDA5991e_bt_dc_cal_fix_gain();
+		break;
+		// add for pta
+	default:
+		break;
+	}
+
+	printk(KERN_INFO "rda_bt_pw_ioctl cmd=0x%02x \n", cmd);
+	return ret;
+}
+
+int rda_5991e_fm_power_on(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+		       "rda_wifi_rf_client is NULL, rda_fm_power_on failed!\n");
+		return -1;
+	}
+
+	enable_32k_rtc(CLOCK_FM);
+	msleep(8);
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_E) {
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO "%s() read from address(0x%02x) failed! \n",
+			       __func__, 0xA7);
+			goto err;
+		}
+		temp = temp | 0x1;	//set bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				 __func__, 0xA7, temp);
+			goto err;
+		}
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp);	//read 0xB9
+		if (ret < 0) {
+			printk(KERN_INFO  "%s() read from address(0x%02x) failed! \n",
+			       __func__, 0xB9);
+			goto err;
+		}
+
+		temp = temp & 0x7fff; //set bit[15]=0
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp); //write back
+			if (ret < 0) {
+				printk(KERN_INFO
+					"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+					__func__, 0xB9, temp);
+			goto err;
+		}
+
+		temp = temp | (0x1 << 15);	//set bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xB9, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	printk(KERN_INFO "***rda_fm_power_on failed! \n");
+	return -1;
+}
+
+int rda_5991e_fm_power_off(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+		       "rda_wifi_rf_client is NULL, rda_fm_power_off failed!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_E) {
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp & ~(0x1);	//clear bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_fm_power_off failed! \n");
+	return -1;
+}
+
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991f_power_ctrl.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991f_power_ctrl.c
new file mode 100644
index 000000000000..3f7be4c3e421
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991f_power_ctrl.c
@@ -0,0 +1,811 @@
+#include "rda_combo.h"
+#ifndef RDA_COMBO_FROM_FIRMWARE
+
+#ifdef WLAN_USE_DCDC
+static const u16 pmu_setting_5991f[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906}, //{0x24,  0x8908}  sleep mode with analog power on
+	{0x26,	0x8055}, //0x8055
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xC208},
+	{0x23,	0xA200}, //{0x23,  0x8200}
+	{0x25,	0xA247}, //{0x25,  0x8247} heavy_load_dig
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+};
+#else
+static const u16 pmu_setting_5991f[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906},
+	{0x26,	0x8555},
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xC208},
+	{0x23,	0x0200},
+	{0x25,	0x027F},
+	{0x3F,  0x0000},
+};
+#endif
+
+/*add according to hongjun's new config*/
+static const u16 soft_reset_5991f[][2] = {
+	{0x3F, 0x0000},
+	{0x30, 0x8000},
+	{0x30, 0x0000},
+};
+
+static const u16 wf_en_5991f[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x8B40},		//;WIFI_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 wifi_disable_5991f[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x0B40},		//;WIFI_en=0
+	{0x26, 0x8055},
+	{0x3F, 0x0000},
+};
+
+#ifdef COMBO_WITH_26MHZ
+static const u16 wf_rf_setting_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x05,	0x0000},
+	{0x06,	0x1124}, //wf_bbpll_cpaux_bit[2:0]=100
+	{0x07,	0x0820},
+	{0x10,	0x9ff7},
+	{0x11,	0xFFFA},//filter bandwidth
+	{0x13,	0x5054},
+	{0x14,	0x988C},
+	{0x15,	0x58e8},
+	{0x16,	0x200B},
+	{0x19,	0x9C01},
+	{0x1C,	0x06E4},
+	{0x1D,	0x3A8C},
+	{0x22,	0xFF7B},
+	{0x23,	0x283C},//dc cal
+	{0x24,	0xA0C4},
+	{0x28,	0x4320},
+	{0x2A,	0x1036},//{0x2A,  0x0077}
+	{0x2B,	0x41BB},
+	{0x2D,	0xFF03},
+	{0x2F,	0x15DE},
+	{0x34,	0x3000},
+	{0x35,	0x8011},
+	{0x39,	0x6018},
+	{0x3B,	0x3218},
+	{0x3D,	0xFF00},//rxon delay
+	{0x40,	0xFFFF},//wf_tmx_gain,wf_pabias;20140825
+	{0x41,	0xFFFF},
+	{0x7D,	0x4020},//paon delay
+	{0x3F,  0x0001},
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+	{0x30,	0x0100},
+	{0x28,	0x4F20},
+	 DELAY_MS(1)
+	{0x28,	0x4320},
+	{0x30,	0x0149},
+};
+#else
+static const u16 wf_rf_setting_5991f[][2] = {
+};
+#endif
+
+static const u16 wf_agc_setting_for_dccal_5991f[][2] = {
+
+};
+
+static const u16 wf_agc_setting_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x0F,	0x01F7},//lower max gain
+	{0x0E,	0x01F0},
+	{0x0D,	0x00F0},
+	{0x0C,	0x0070},
+	{0x0B,	0x0030},
+	{0x0A,	0x0010},
+	//{0x09,	0x3033},
+	{0x09,	0x3031},//20140825
+	{0x08,	0x0830},
+	{0x3F,  0x0001},
+	{0x07,	0x7030},
+	{0x06,	0x7010},
+	{0x05,	0x7870},
+	{0x04,	0x7830},
+	//{0x03,	0x7811},
+	{0x03,	0x7810},//20140825
+	{0x02,	0x7800},
+	{0x01,	0x7800},
+	{0x00,	0x7800},
+	{0x3F,  0x0000},
+};
+
+static const u16 wf_calibration_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0148},
+	{0x30,	0x0149},
+	 DELAY_MS(50)
+};
+
+static const u16 fix_agc_gain_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0349},
+};
+
+static const u16 bt_rf_setting_5991f[][2] = {
+	{0x3F,  0x0000},
+#ifdef COMBO_WITH_26MHZ
+	{0x2E,	0xCAB3},
+#endif /* COMBO_WITH_26MHZ */
+	{0x02,	0x0E00},
+	{0x08,	0xEFFF},
+	{0x0A,	0x09FF},
+	{0x11,	0x00B5},
+	{0x13,	0x07C0},
+	{0x14,	0xFDC4},
+	{0x18,	0x2010},
+	{0x19,	0x7956},
+	{0x1B,	0xDF7F},
+	{0x26,	0x6640},
+	{0x2B,	0x007F},
+	{0x2C,	0x600F},
+	{0x2D,	0x007F},
+	{0x2F,	0x1000},
+	{0x30,	0x0141},
+	{0x37,	0x3333}, //PSK
+	{0x38,	0x357A}, //PSK
+	{0x3B,	0x1111}, //GFSK
+	{0x3C,	0x1235}, //GFSK
+	{0x3F,  0x0001},
+	{0x00,	0xFFFF},
+	{0x01,	0xFFE7}, // bt power
+	{0x02,	0xFFFF},
+	{0x03,	0xFFF7},
+	{0x04,	0xFFFF},
+	{0x05,	0xFFE5},
+	{0x06,	0xFFFF},
+	{0x07,	0xFFE5},
+	{0x08,	0xFFFF},
+	{0x09,	0xFFD1},
+	{0x0A,	0xFFFF},
+	{0x0B,	0xFFD1},
+	//{0x39,	0x1208},
+	{0x3F,  0x0000},
+};
+
+static const u16 control_mode_disable_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0341},
+};
+
+static const u16 bt_en_5991f[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x85A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 bt_disable_5991f[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x05A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+// add for pta
+static const u16 rda_5991f_bt_dc_ca_fix_gain[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0141 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+//	{0x30, 0x0341 },  //force gain level to 7 before lna issue fixed
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991f_bt_dc_ca_fix_gain_no_wf[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991f_bt_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0xcab3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991f_bt_no_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+
+
+static const u16  bt_dc_cal_5991f[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0140},
+	{0x30,  0x0141},
+	 DELAY_MS(50)
+};
+#endif
+
+static int check_wifi_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x31, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int check_bt_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_bt_rf_client, 0x28, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int power_on(int isWifi)
+{
+	int ret = 0;
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, pmu_setting_5991f);
+	if (ret)
+		goto err;
+	printk(KERN_INFO "%s write pmu_setting succeed!! \n", __func__);
+
+	if (isWifi) {		// for wifi
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991f);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+	} else {		// for bt
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991f);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(5);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, soft_reset_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write soft_reset succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_rf_setting_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_rf_setting_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write bt_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_agc_setting_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_agc_setting succeed!! \n",
+	       __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_calibration_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_calibration succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, fix_agc_gain_5991f);
+	if(ret)
+		goto power_off;
+	printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	return 0;
+power_off:
+	if (isWifi) {		// for wifi
+		rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991f);
+	} else {
+		rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991f);
+	}
+err:
+	return -1;
+}
+
+static int rda_5991f_wifi_debug_en(int enable)
+{
+	u16 temp_data = 0;
+	int ret = 0;
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret < 0)
+		return -1;
+	if (enable == 1) {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x80a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret =  i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data | (1 << 2));
+		if (ret < 0)
+			return -1;
+	} else {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x00a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data & (~(1 << 2)));
+		if (ret < 0)
+			return -1;
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if (ret < 0)
+		return -1;
+	return ret;
+}
+
+int rda_5991f_wifi_power_on(void)
+{
+	int ret = 0, bt_power_on = 0;
+
+	//if bt is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+	bt_power_on = check_bt_power_on();
+	printk(KERN_INFO "%s bt_power_on=%d \n", __func__, bt_power_on);
+
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991f);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+
+		//add for pta
+		//handle btswtrx dr
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991f_bt_no_force_swtrx);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write rda_5991_bt_no_force_swtrx succeed!! \n",
+			__func__);
+		// add for pta
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(1);
+		if (ret)
+			goto err;
+	}
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, control_mode_disable_5991f);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write control_mode_disable succeed!! \n", __func__);
+	if (check_test_mode()) {
+		rda_5991f_wifi_debug_en(1);
+		printk(KERN_INFO "%s: IN test mode, switch uart to WIFI succeed!! \n",
+			__func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(100);
+	disable_26m_rtc(CLOCK_WLAN);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 1);
+#endif
+	return ret;
+
+power_off:
+	rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991f);
+err:
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991f_wifi_power_off(void)
+{
+	int ret = 0, bt_power_on = 0;
+	rda_combo_i2c_lock();
+	bt_power_on = check_bt_power_on();
+	//add for pta
+	if(bt_power_on){
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991f_bt_force_swtrx);
+		if (ret) {
+			printk(KERN_INFO "%s  rda_5991_bt_force_swtrx failed!! \n",
+				__func__);
+		} else {
+			printk(KERN_INFO "%s  rda_5991_bt_force_swtrx succeed!! \n",
+				__func__);
+		}
+	}
+	// add for pta
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991f);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+
+	bt_power_on = check_bt_power_on();
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, fix_agc_gain_5991f);
+		printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+
+int rda_5991f_bt_power_on(void)
+{
+	int ret = 0, wifi_power_on = 0;
+
+	//if wifi is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_BT);
+	enable_26m_rtc(CLOCK_BT);
+	enable_32k_rtc(CLOCK_BT);
+
+	wifi_power_on = check_wifi_power_on();
+	printk(KERN_INFO "%s wifi_power_on=%d \n", __func__, wifi_power_on);
+
+	if (wifi_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991f);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(0);
+		if (ret)
+			goto err;
+	}
+
+	printk(KERN_INFO "%s succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	disable_26m_rtc(CLOCK_BT);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 1);
+#endif
+	return ret;
+
+err:
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991f_bt_power_off(void)
+{
+	int ret = 0;
+	rda_combo_i2c_lock();
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991f);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+// add for pta
+static int RDA5991f_bt_dc_cal_fix_gain(void)
+{
+	int ret = 0;
+	int is_wfen;
+
+	if(!rda_bt_rf_client){
+		printk(KERN_INFO "rda_bt_rf_client is NULL!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+	is_wfen= check_wifi_power_on();
+	//check the version and make sure this applies to 5991
+	if(rda_wlan_version() == WLAN_VERSION_91_F) {
+		if(is_wfen) {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991f_bt_dc_ca_fix_gain);
+		} else {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991f_bt_dc_ca_fix_gain_no_wf);
+		}
+
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991f_bt_dc_cal_fix_gain success!!!\n");
+	msleep(200);   //200ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991f_bt_dc_cal_fix_gain failed! \n");
+	return -1;
+
+}
+// add for pta
+long rda_5991f_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case RDA_WIFI_POWER_ON_IOCTL:
+		ret = rda_5991f_wifi_power_on();
+		break;
+
+	case RDA_WIFI_POWER_OFF_IOCTL:
+		ret = rda_5991f_wifi_power_off();
+		break;
+
+	case RDA_BT_POWER_ON_IOCTL:
+		ret = rda_5991f_bt_power_on();
+		break;
+
+	case RDA_BT_POWER_OFF_IOCTL:
+		ret = rda_5991f_bt_power_off();
+		break;
+
+	case RDA_WIFI_DEBUG_MODE_IOCTL:
+		{
+			int enable = 0;
+			if(copy_from_user(&enable, (void*)arg, sizeof(int))) {
+				printk(KERN_ERR "copy_from_user enable failed!\n");
+				return -EFAULT;
+			}
+			ret = rda_5991f_wifi_debug_en(enable);
+			break;
+		}
+		// add for pta
+	case RDA_BT_DC_CAL_IOCTL_FIX_5991_LNA_GAIN:
+		ret = RDA5991f_bt_dc_cal_fix_gain();
+		break;
+		// add for pta
+	default:
+		break;
+	}
+
+	printk(KERN_INFO "rda_bt_pw_ioctl cmd=0x%02x \n", cmd);
+	return ret;
+}
+
+int rda_5991f_fm_power_on(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_on failed!\n");
+		return -1;
+	}
+
+	enable_32k_rtc(CLOCK_FM);
+	msleep(8);
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_F) {
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO "%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp | 0x1;	//set bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp);	//read 0xB9
+		if (ret < 0) {
+			printk(KERN_INFO  "%s() read from address(0x%02x) failed! \n",
+				__func__, 0xB9);
+			goto err;
+		}
+
+		temp = temp & 0x7fff; //set bit[15]=0
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp); //write back
+			if (ret < 0) {
+				printk(KERN_INFO
+					"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xB9, temp);
+			goto err;
+		}
+
+		temp = temp | (0x1 << 15);	//set bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xB9, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	printk(KERN_INFO "***rda_fm_power_on failed! \n");
+	return -1;
+}
+
+int rda_5991f_fm_power_off(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+		       "rda_wifi_rf_client is NULL, rda_fm_power_off failed!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_F) {
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp & ~(0x1);	//clear bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_fm_power_off failed! \n");
+	return -1;
+}
+
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991g_power_ctrl.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991g_power_ctrl.c
new file mode 100644
index 000000000000..26c8eda29e99
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_5991g_power_ctrl.c
@@ -0,0 +1,891 @@
+#include "rda_combo.h"
+#ifndef RDA_COMBO_FROM_FIRMWARE
+
+#ifdef WLAN_USE_DCDC
+static const u16 pmu_setting_5991g[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906}, //{0x24,  0x8908}  sleep mode with analog power on
+	{0x26,	0x8055}, //0x8055
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xA108},
+	{0x23,	0xA200}, //{0x23,  0x8200}
+	{0x25,	0xA247}, //{0x25,  0x8247} heavy_load_dig
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+};
+#else
+static const u16 pmu_setting_5991g[][2] = {
+	{0x3F,  0x0001},
+#ifdef WLAN_USE_CRYSTAL
+	{0x22,	0x21F3},
+#else
+	{0x22,	0xA1F3},
+#endif
+	{0x24,	0x8906},
+	{0x26,	0x8555},
+	{0x29,	0x1113},
+	{0x32,	0x1113},
+	{0x33,	0x0510},
+	{0x39,	0xC208},
+	{0x23,	0x0200},
+	{0x25,	0x027F},
+	{0x3F,  0x0000},
+};
+#endif
+
+/*add according to hongjun's new config*/
+static const u16 soft_reset_5991g[][2] = {
+	{0x3F, 0x0000},
+	{0x30, 0x8000},
+	{0x30, 0x0000},
+};
+
+static const u16 wf_en_5991g[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x8B40},		//;WIFI_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 wifi_disable_5991g[][2] = {
+	{0x3F, 0x0001},
+	{0x31, 0x0B40},		//;WIFI_en=0
+	{0x26, 0x8055},
+	{0x3F, 0x0000},
+};
+
+#ifdef COMBO_WITH_26MHZ
+static const u16 wf_rf_setting_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x05,	0x0000},
+	{0x06,	0x1124}, //wf_bbpll_cpaux_bit[2:0]=100
+	{0x07,	0x0820},
+	{0x10,	0x9ff7},
+	{0x11,	0xFFFA},//filter bandwidth
+	{0x13,	0x5054},
+	{0x14,	0x988C},
+	{0x15,	0x58E8},
+	{0x16,	0x200B},
+	{0x19,	0x9C01},
+	{0x1C,	0x06E4},
+	{0x1D,	0x3A8C},
+	{0x22,	0xFF7B},
+	{0x23,	0x283C},//dc cal
+	{0x24,	0xA0C4},
+	{0x28,	0x4320},
+	{0x2A,	0x1036},//{0x2A,  0x0077}
+	{0x2B,	0x41BB},
+	{0x2D,	0xFF03},
+	{0x2F,	0x15DE},
+	{0x34,	0x3000},
+	{0x35,	0x8011},
+	{0x39,	0x6018},
+	{0x3B,	0x3218},
+	{0x3D,	0xFF00},//rxon delay
+	{0x40,	0xFFFF},//wf_tmx_gain,wf_pabias;20140825
+	{0x41,	0xFFFF},
+	{0x7D,	0x4020},//paon delay
+	{0x3F,  0x0001},
+	{0x37,	0x0B8A},
+	{0x3F,  0x0000},
+	{0x30,	0x0100},
+	{0x28,	0x4F20},
+	 DELAY_MS(1)
+	{0x28,	0x4320},
+	{0x30,	0x0149},
+};
+#else
+static const u16 wf_rf_setting_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x03,  0x16AA},
+	{0x04,  0xAAAB},
+	{0x76,  0xA6D5}, //change bbpll freq for 24MHZ
+	{0x77,  0x5555}, //change bbpll freq for 24MHZ
+	{0x78,  0xA700}, //change bbpll freq for 24MHZ
+	{0x79,  0x0000}, //change bbpll freq for 24MHZ
+	{0x7A,  0xA72A}, //change bbpll freq for 24MHZ
+	{0x7B,  0xAAAB}, //change bbpll freq for 24MHZ
+	{0x05,	0x0000},
+	{0x06,	0x1124}, //wf_bbpll_cpaux_bit[2:0]=100
+	{0x07,	0x0820},
+	{0x10,  0x9ff7},
+	{0x11,  0xFFFA},
+	{0x13,  0x5054},
+	{0x14,  0x988C},
+	{0x15,  0x58E8},
+	{0x16,  0x200B},
+	{0x19,  0x9C01},
+	{0x1C,  0x06E4},
+	{0x1D,  0x3A8C},
+	{0x22,  0xFF7B},
+	{0x23,  0x3D3C},
+	{0x24,  0xA0C4},
+	{0x27,  0x5318},
+	{0x28,  0x3318},
+	{0x29,  0x04EB},//;<10>:xtal_pllref_pd_dr<2>:xtal_pllref_pd_reg
+	{0x2A,  0x1036},
+	{0x2B,  0x41BB},
+	{0x2D,  0xFF03},
+	{0x2F,	0x15DE},
+	{0x34,  0x3000},
+	{0x35,  0x8011},
+	{0x39,	0x6018},
+	{0x40,  0x7FFF},//wf_tmx_gain,wf_pabias;20140912
+	{0x41,  0xFFFF},
+	{0x7D,	0x4020},//paon delay
+	{0x3F,  0x0001},
+	{0x37,  0x0B8A},
+	{0x3F,  0x0000},
+	{0x30,  0x0100},
+	{0x28,  0x3F18},
+	 DELAY_MS(1)
+	{0x28,  0x3318},
+	{0x30,  0x0149},
+};
+#endif
+
+static const u16 wf_agc_setting_for_dccal_5991g[][2] = {
+
+};
+
+static const u16 wf_agc_setting_5991g[][2] = {
+	{0x3F,  0x0000},
+#ifdef G_CHINA_VERSION
+	{0x0F,	0x01F0},
+	{0x0E,	0x01F0},
+	{0x0D,	0x00F0},
+	{0x0C,	0x0070},
+	{0x0B,	0x0030},
+	{0x0A,	0x0010},
+	{0x09,	0x3031},
+	{0x08,	0x0830},
+	{0x3F,  0x0001},
+	{0x07,	0x7030},
+	{0x06,	0x7010},
+	{0x05,	0x7870},
+	{0x04,	0x7830},
+	{0x03,	0x7810},
+	{0x02,	0x7800},
+	{0x01,	0x7800},
+	{0x00,	0x7800},
+#else /*High SNR*/
+	{0x0F,	0x01F7},
+	{0x0E,	0x01F0},
+	{0x0D,	0x00F0},
+	{0x0C,	0x0070},
+	{0x0B,	0x0030},
+	{0x0A,	0x0010},
+	{0x09,	0x3033},
+	{0x08,	0x0830},
+	{0x3F,  0x0001},
+	{0x07,	0x7030},
+	{0x06,	0x7010},
+	{0x05,	0x7870},
+	{0x04,	0x7830},
+	{0x03,	0x7811},
+	{0x02,	0x7800},
+	{0x01,	0x7800},
+	{0x00,	0x7800},
+#endif /*G_CHINA_VERSION*/
+	{0x3F,  0x0000},
+};
+
+static const u16 wf_calibration_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0148},
+	{0x30,	0x0149},
+	 DELAY_MS(50)
+};
+
+static const u16 fix_agc_gain_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0349},
+};
+
+static const u16 bt_rf_setting_5991g[][2] = {
+	{0x3F,  0x0000},
+#ifdef COMBO_WITH_26MHZ
+	{0x2E,	0xCAB3},
+#else
+	{0x1C,  0xAAAB},//<0>: mdll_always_on
+	{0x2E,  0xCAA3},//	<4>:bt_pll_ref from xtal/mdll
+#endif
+	{0x02,	0x0E00},
+	{0x08,	0xEFFF},
+	{0x0A,	0x09FF},
+	{0x11,	0x00B5},
+	{0x13,	0x07C0},
+	{0x14,	0xFDC4},
+	{0x18,	0x2010},
+	{0x19,	0x7956},
+	{0x1B,	0xDFE0},
+	{0x26,	0x7800},
+	{0x2B,	0x007F},
+	{0x2C,	0x600F},
+	{0x2D,	0x007F},
+	{0x2F,	0x1000},
+	{0x30,	0x0141},
+	{0x37,	0x4244}, //PSK
+	{0x38,	0x4688}, //PSK
+	{0x3B,	0x2122}, //GFSK
+	{0x3C,	0x2355}, //GFSK
+	{0x3F,  0x0001},
+	{0x00,	0xFFFF},
+	{0x01,	0xFFFF}, // bt power
+	{0x02,	0xFFFF},
+	{0x03,	0xFFF7},
+	{0x04,	0xFFFF},
+	{0x05,	0xFFF7},
+	{0x06,	0xFFFF},
+	{0x07,	0xFFF1},
+	{0x08,	0xFFFF},
+	{0x09,	0xFFE1},
+	{0x0A,	0xFFFF},
+	{0x0B,	0xFFE1},
+	//{0x39,	0x1208},
+	{0x3F,  0x0000},
+};
+
+static const u16 control_mode_disable_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x30,	0x0141},
+};
+
+static const u16 bt_en_5991g[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x85A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+static const u16 bt_disable_5991g[][2] = {
+	{0x3F, 0x0001},
+	{0x28, 0x05A1},		//;bt_en=1
+	{0x3F, 0x0000},
+};
+
+// add for pta
+static const u16 rda_5991g_bt_dc_ca_fix_gain[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0141 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+//	{0x30, 0x0341 },  //force gain level to 7 before lna issue fixed
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#else
+	{0x2e, 0x8aa3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991g_bt_dc_ca_fix_gain_no_wf[][2] =
+{
+	{0x3f, 0x0000 },
+	{0x30, 0x0140 },
+	{0x30, 0x0141 },
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991g_bt_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0xcab3 },  //force gain level to 7 before lna issue fixed
+#else
+	{0x2e, 0xcaa3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+// add for pta
+static const u16 rda_5991g_bt_no_force_swtrx[][2] =
+{
+	{0x3f, 0x0000 },
+#ifdef COMBO_WITH_26MHZ
+	{0x2e, 0x8ab3 },  //force gain level to 7 before lna issue fixed
+#else
+	{0x2e, 0x8aa3 },  //force gain level to 7 before lna issue fixed
+#endif
+	{0x3f, 0x0000 },
+};
+// add for pta
+
+
+
+static const u16  bt_dc_cal_5991g[][2] = {
+	{0x3F,  0x0000},
+	{0x30,  0x0140},
+	{0x30,  0x0141},
+	 DELAY_MS(50)
+};
+#endif
+
+static int check_wifi_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x31, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int check_bt_power_on(void)
+{
+	int ret = 0;
+	u16 temp_data;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_bt_rf_client, 0x28, &temp_data);
+	if (ret)
+		goto err;
+
+	ret = i2c_write_1_addr_2_data(rda_bt_rf_client, 0x3f, 0x0000);
+	if (temp_data & 0x8000)
+		return 1;
+err:
+	return 0;
+}
+
+static int power_on(int isWifi)
+{
+	int ret = 0;
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, pmu_setting_5991g);
+	if (ret)
+		goto err;
+	printk(KERN_INFO "%s write pmu_setting succeed!! \n", __func__);
+
+	if (isWifi) {		// for wifi
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991g);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+	} else {		// for bt
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991g);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(5);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, soft_reset_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write soft_reset succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	rda_combo_i2c_lock();
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_rf_setting_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_rf_setting_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write bt_rf_setting succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_agc_setting_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_agc_setting succeed!! \n",
+		__func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_calibration_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write wf_calibration succeed!! \n", __func__);
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, fix_agc_gain_5991g);
+	if(ret)
+		goto power_off;
+	printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	return 0;
+power_off:
+	if (isWifi) {		// for wifi
+		rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991g);
+	} else {
+		rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991g);
+	}
+err:
+	return -1;
+}
+
+static int rda_5991g_wifi_debug_en(int enable)
+{
+	u16 temp_data = 0;
+	int ret = 0;
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret < 0)
+		return -1;
+	if (enable == 1) {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x80a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data | (1 << 2));
+		if (ret < 0)
+			return -1;
+	} else {
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x28, 0x00a1);
+		if (ret < 0)
+			return -1;
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			&temp_data);
+		if (ret < 0)
+			return -1;
+
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39,
+			temp_data & (~(1 << 2)));
+		if (ret < 0)
+			return -1;
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	if (ret < 0)
+		return -1;
+	return ret;
+}
+
+int rda_5991g_wifi_power_on(void)
+{
+	int ret = 0, bt_power_on = 0;
+
+	//if bt is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_WLAN);
+	enable_32k_rtc(CLOCK_WLAN);
+	enable_26m_rtc(CLOCK_WLAN);
+	bt_power_on = check_bt_power_on();
+	printk(KERN_INFO "%s bt_power_on=%d \n", __func__, bt_power_on);
+
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client, wf_en_5991g);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write wf_en succeed!! \n", __func__);
+
+		//add for pta
+		//handle btswtrx dr
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+		rda_5991g_bt_no_force_swtrx);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write rda_5991_bt_no_force_swtrx succeed!! \n",
+			__func__);
+		// add for pta
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(1);
+		if (ret)
+			goto err;
+	}
+
+	ret = rda_write_data_to_rf(rda_wifi_rf_client,
+		control_mode_disable_5991g);
+	if (ret)
+		goto power_off;
+	printk(KERN_INFO "%s write control_mode_disable succeed!! \n", __func__);
+	if (check_test_mode()) {
+		rda_5991g_wifi_debug_en(1);
+		printk(KERN_INFO
+			"%s: IN test mode, switch uart to WIFI succeed!! \n",
+			__func__);
+	}
+
+	rda_combo_i2c_unlock();
+	msleep(100);
+	disable_26m_rtc(CLOCK_WLAN);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 1);
+#endif
+	return ret;
+
+power_off:
+	rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991g);
+err:
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991g_wifi_power_off(void)
+{
+	int ret = 0, bt_power_on = 0;
+	rda_combo_i2c_lock();
+	bt_power_on = check_bt_power_on();
+	//add for pta
+	if(bt_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client,
+			rda_5991g_bt_force_swtrx);
+		if (ret) {
+			printk(KERN_INFO
+				"%s  rda_5991_bt_force_swtrx failed!! \n",
+				__func__);
+		} else {
+			printk(KERN_INFO
+				"%s  rda_5991_bt_force_swtrx succeed!! \n",
+				__func__);
+		}
+	}
+	// add for pta
+	ret = rda_write_data_to_rf(rda_wifi_rf_client, wifi_disable_5991g);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+
+	bt_power_on = check_bt_power_on();
+	if (bt_power_on) {
+		ret = rda_write_data_to_rf(rda_wifi_rf_client,
+			fix_agc_gain_5991g);
+		printk(KERN_INFO "%s write fix_agc_gain succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_WLAN);
+	disable_32k_rtc(CLOCK_WLAN);
+	disable_26m_regulator(CLOCK_WLAN);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&wifi_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+
+int rda_5991g_bt_power_on(void)
+{
+	int ret = 0, wifi_power_on = 0;
+
+	//if wifi is power on wait until it's complete
+	wait_for_completion(&rda_wifi_bt_comp);
+
+	rda_combo_i2c_lock();
+	enable_26m_regulator(CLOCK_BT);
+	enable_26m_rtc(CLOCK_BT);
+	enable_32k_rtc(CLOCK_BT);
+
+	wifi_power_on = check_wifi_power_on();
+	printk(KERN_INFO "%s wifi_power_on=%d \n", __func__, wifi_power_on);
+
+	if (wifi_power_on) {
+		ret = rda_write_data_to_rf(rda_bt_rf_client, bt_en_5991g);
+		if (ret)
+			goto err;
+		printk(KERN_INFO "%s write bt_en succeed!! \n", __func__);
+		rda_combo_i2c_unlock();
+		msleep(5);
+		rda_combo_i2c_lock();
+	} else {
+		ret = power_on(0);
+		if (ret)
+			goto err;
+	}
+
+	printk(KERN_INFO "%s succeed!! \n", __func__);
+
+	rda_combo_i2c_unlock();
+	msleep(10);
+	disable_26m_rtc(CLOCK_BT);
+	complete(&rda_wifi_bt_comp);
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 1);
+#endif
+	return ret;
+
+err:
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+	return -1;
+}
+
+int rda_5991g_bt_power_off(void)
+{
+	int ret = 0;
+	rda_combo_i2c_lock();
+	ret = rda_write_data_to_rf(rda_bt_rf_client, bt_disable_5991g);
+	if (ret) {
+		printk(KERN_INFO "%s failed!! \n", __func__);
+	} else {
+		printk(KERN_INFO "%s succeed!! \n", __func__);
+	}
+	disable_26m_rtc(CLOCK_BT);
+	disable_32k_rtc(CLOCK_BT);
+	disable_26m_regulator(CLOCK_BT);
+	rda_combo_i2c_unlock();
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	atomic_set(&bt_fw_status, 0);
+	rda_release_firmware();
+#endif
+	return ret;
+}
+// add for pta
+static int RDA5991g_bt_dc_cal_fix_gain(void)
+{
+	int ret = 0;
+	int is_wfen;
+
+	if(!rda_bt_rf_client) {
+		printk(KERN_INFO "rda_bt_rf_client is NULL!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+	is_wfen= check_wifi_power_on();
+	//check the version and make sure this applies to 5991
+	if(rda_wlan_version() == WLAN_VERSION_91_G) {
+		if(is_wfen) {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991g_bt_dc_ca_fix_gain);
+		} else {
+			ret = rda_write_data_to_rf(rda_bt_rf_client,
+				rda_5991g_bt_dc_ca_fix_gain_no_wf);
+		}
+
+		if(ret)
+			goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991g_bt_dc_cal_fix_gain success!!!\n");
+	msleep(200);   //200ms
+
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***RDA5991g_bt_dc_cal_fix_gain failed! \n");
+	return -1;
+
+}
+// add for pta
+long rda_5991g_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case RDA_WIFI_POWER_ON_IOCTL:
+		ret = rda_5991g_wifi_power_on();
+		break;
+
+	case RDA_WIFI_POWER_OFF_IOCTL:
+		ret = rda_5991g_wifi_power_off();
+		break;
+
+	case RDA_BT_POWER_ON_IOCTL:
+		ret = rda_5991g_bt_power_on();
+		break;
+
+	case RDA_BT_POWER_OFF_IOCTL:
+		ret = rda_5991g_bt_power_off();
+		break;
+
+	case RDA_WIFI_DEBUG_MODE_IOCTL:
+		{
+			int enable = 0;
+			if(copy_from_user(&enable, (void*)arg, sizeof(int))) {
+				printk(KERN_ERR "copy_from_user enable failed!\n");
+				return -EFAULT;
+			}
+			ret = rda_5991g_wifi_debug_en(enable);
+			break;
+		}
+		// add for pta
+	case RDA_BT_DC_CAL_IOCTL_FIX_5991_LNA_GAIN:
+		ret = RDA5991g_bt_dc_cal_fix_gain();
+		break;
+		// add for pta
+	default:
+		break;
+	}
+
+	printk(KERN_INFO "rda_bt_pw_ioctl cmd=0x%02x \n", cmd);
+	return ret;
+}
+
+int rda_5991g_fm_power_on(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_on failed!\n");
+		return -1;
+	}
+
+	enable_32k_rtc(CLOCK_FM);
+	msleep(8);
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_G) {
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp | 0x1;	//set bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x39, &temp);	//read 0xB9
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xB9);
+			goto err;
+		}
+
+		temp = temp & 0x7fff; //set bit[15]=0
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp); //write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+       				__func__, 0xB9, temp);
+			goto err;
+		}
+
+		temp = temp | (0x1 << 15);	//set bit[15]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x39, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xB9, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			 __func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	return 0;
+
+err:
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	printk(KERN_INFO "***rda_fm_power_on failed! \n");
+	return -1;
+}
+
+int rda_5991g_fm_power_off(void)
+{
+	int ret = 0;
+	u16 temp = 0;
+
+	if (!rda_wifi_rf_client) {
+		printk(KERN_INFO
+			"rda_wifi_rf_client is NULL, rda_fm_power_off failed!\n");
+		return -1;
+	}
+
+	rda_combo_i2c_lock();
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);	// page down
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	if (rda_wlan_version() == WLAN_VERSION_91_G) {
+		ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x27, &temp);	//read 0xA7
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() read from address(0x%02x) failed! \n",
+				__func__, 0xA7);
+			goto err;
+		}
+		temp = temp & ~(0x1);	//clear bit[0]
+		ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x27, temp);	//write back
+		if (ret < 0) {
+			printk(KERN_INFO
+				"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+				__func__, 0xA7, temp);
+			goto err;
+		}
+	}
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);	// page up
+	if (ret < 0) {
+		printk(KERN_INFO
+			"%s() write address(0x%02x) with value(0x%04x) failed! \n",
+			__func__, 0x3f, 0x0001);
+		goto err;
+	}
+
+	rda_combo_i2c_unlock();
+	disable_32k_rtc(CLOCK_FM);
+	return 0;
+err:
+	rda_combo_i2c_unlock();
+	printk(KERN_INFO "***rda_fm_power_off failed! \n");
+	return -1;
+}
+
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo.h b/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo.h
new file mode 100644
index 000000000000..2103ec2e37b9
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo.h
@@ -0,0 +1,199 @@
+#ifndef __RDA_COMBO_H__
+#define __RDA_COMBO_H__
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/i2c.h>
+#include <linux/wakelock.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <asm-generic/ioctl.h>
+#include <asm/uaccess.h>
+
+#define RDA_COMBO_FIRMWARE_NAME "rda_combo.bin"
+#define RDA_FIRMWARE_VERSION 3
+#define RDA_FIRMWARE_TYPE_SIZE 16		//firmware type size
+#define RDA_FIRMWARE_DATA_NAME_SIZE 50	//firmware data_type size
+
+#pragma pack(push)
+#pragma pack(1)
+struct rda_device_firmware_head {
+	char firmware_type[RDA_FIRMWARE_TYPE_SIZE];
+	u32 version;
+	u32 data_num;
+};
+struct rda_firmware_data_type {
+	char data_name[RDA_FIRMWARE_DATA_NAME_SIZE];
+	u16 crc;
+	s8 chip_version;
+	u32 size;
+};
+#pragma pack(pop)
+
+struct rda_firmware {
+	const u8 *data;
+	u32 num;
+	u32 size;
+	struct mutex lock;
+	int status;
+};
+
+/*get data form firmware*/
+//#define RDA_COMBO_FROM_FIRMWARE
+
+#ifdef RDA_COMBO_FROM_FIRMWARE
+int rda_write_data_to_rf_from_firmware(struct i2c_client* client, char *data_name);
+#define rda_write_data_to_rf(CLIENT, DATA_NAME)\
+	rda_write_data_to_rf_from_firmware(CLIENT, #DATA_NAME)
+
+#else
+#define rda_write_data_to_rf(CLIENT, ARRAY_DATA)\
+	rda_i2c_write_data_to_rf(CLIENT, ARRAY_DATA, ARRAY_SIZE(ARRAY_DATA) )
+#endif
+
+#define RDA_BT_IOCTL_MAGIC 'u'
+
+/* bt module */
+#define RDA_BT_POWER_ON_IOCTL				   _IO(RDA_BT_IOCTL_MAGIC ,0x01)
+#define RDA_BT_RF_INIT_IOCTL				   _IO(RDA_BT_IOCTL_MAGIC ,0x02)
+#define RDA_BT_DC_CAL_IOCTL 				   _IO(RDA_BT_IOCTL_MAGIC ,0x03)
+#define RDA_BT_RF_SWITCH_IOCTL				   _IO(RDA_BT_IOCTL_MAGIC ,0x04)
+#define RDA_BT_POWER_OFF_IOCTL				   _IO(RDA_BT_IOCTL_MAGIC ,0x05)
+#define RDA_BT_EN_CLK						   _IO(RDA_BT_IOCTL_MAGIC ,0x06)
+#define RDA_BT_DC_DIG_RESET_IOCTL			   _IO(RDA_BT_IOCTL_MAGIC ,0x07)
+#define RDA_BT_GET_ADDRESS_IOCTL			   _IO(RDA_BT_IOCTL_MAGIC ,0x08)
+// add for pta
+#define RDA_BT_DC_CAL_IOCTL_FIX_5991_LNA_GAIN           _IO(RDA_BT_IOCTL_MAGIC ,0x26)
+// add for pta
+/* wifi module */
+#define RDA_WIFI_POWER_ON_IOCTL 			   _IO(RDA_BT_IOCTL_MAGIC ,0x10)
+#define RDA_WIFI_POWER_OFF_IOCTL			   _IO(RDA_BT_IOCTL_MAGIC ,0x11)
+#define RDA_WIFI_POWER_SET_TEST_MODE_IOCTL	   _IO(RDA_BT_IOCTL_MAGIC ,0x12)
+#define RDA_WIFI_POWER_CANCEL_TEST_MODE_IOCTL  _IO(RDA_BT_IOCTL_MAGIC ,0x13)
+#define RDA_WIFI_DEBUG_MODE_IOCTL			   _IO(RDA_BT_IOCTL_MAGIC ,0x14)
+#define RDA_WLAN_COMBO_VERSION			   	   _IO(RDA_BT_IOCTL_MAGIC ,0x15)
+#define RDA_COMBO_I2C_OPS    			   	   _IO(RDA_BT_IOCTL_MAGIC ,0x16)
+
+
+/* add for wifi role ( sta, softap, p2p )*/
+#define RDA_WIFI_STA_MODE_IOCTL                _IO(RDA_BT_IOCTL_MAGIC ,0x20)
+#define RDA_WIFI_SOFTAP_MODE_IOCTL             _IO(RDA_BT_IOCTL_MAGIC ,0x21)
+#define RDA_WIFI_P2P_MODE_IOCTL                _IO(RDA_BT_IOCTL_MAGIC ,0x22)
+
+//#define WLAN_USE_CRYSTAL // if use share crystal should close this
+#define WLAN_USE_DCDC  // if use LDO mode, should close this
+//#define WLAN_FOR_CTA		// if need pass CTA authenticate, should open this define
+#define CHINA_VERSION   // Low snr agc setting
+
+#define RDA_I2C_CHANNEL 	(0)
+#define RDA_WIFI_CORE_ADDR (0x13)
+#define RDA_WIFI_RF_ADDR (0x14) //correct add is 0x14
+#define RDA_BT_CORE_ADDR (0x15)
+#define RDA_BT_RF_ADDR (0x16)
+
+#define I2C_MASTER_ACK				(1<<0)
+#define I2C_MASTER_RD				(1<<4)
+#define I2C_MASTER_STO				(1<<8)
+#define I2C_MASTER_WR				(1<<12)
+#define I2C_MASTER_STA				(1<<16)
+
+/* If defined COMBO_WITH_26MHZ, use 26MHZ FREQ,
+  * else use 24MHZ FREQ.
+*/
+#define COMBO_WITH_26MHZ
+#define WLAN_VERSION_90_D (1)
+#define WLAN_VERSION_90_E (2)
+#define WLAN_VERSION_91   (3)
+#define WLAN_VERSION_91_E (4)
+#define WLAN_VERSION_91_F (5)
+#define WLAN_VERSION_91_G (6)
+
+
+#define CLOCK_WLAN (1 << 0)
+#define CLOCK_BT (1 << 1)
+#define CLOCK_FM (1 << 2)
+#define CLOCK_GPS (1 << 3)
+#define CLOCK_MASK_ALL (0x0f)
+
+#define I2C_DELAY_FLAG (0xFFFF)
+#define DELAY_MS(x) {I2C_DELAY_FLAG, x},
+#define RDA_WIFI_RF_I2C_DEVNAME "rda_wifi_rf_i2c"
+#define RDA_WIFI_CORE_I2C_DEVNAME "rda_wifi_core_i2c"
+#define RDA_BT_RF_I2C_DEVNAME "rda_bt_rf_i2c"
+#define RDA_BT_CORE_I2C_DEVNAME "rda_bt_core_i2c"
+
+extern struct i2c_client * rda_wifi_core_client;
+extern struct i2c_client * rda_wifi_rf_client;
+extern struct i2c_client * rda_bt_core_client;
+extern struct i2c_client * rda_bt_rf_client;
+extern struct completion rda_wifi_bt_comp;
+#ifdef RDA_COMBO_FROM_FIRMWARE
+extern atomic_t wifi_fw_status;
+extern atomic_t bt_fw_status;
+#endif
+
+int i2c_write_1_addr_2_data(struct i2c_client* client, const u8 addr, const u16 data);
+int i2c_read_1_addr_2_data(struct i2c_client* client, const u8 addr, u16* data);
+int rda_i2c_write_data_to_rf(struct i2c_client* client, const u16 (*data)[2], u32 count);
+void rda_release_firmware(void);
+
+void enable_26m_regulator(u8 mask);
+void disable_26m_regulator(u8 mask);
+void enable_32k_rtc(u8 mask);
+void disable_32k_rtc(u8 mask);
+void enable_26m_rtc(u8 mask);
+void disable_26m_rtc(u8 mask);
+
+void rda_combo_i2c_lock(void);
+void rda_combo_i2c_unlock(void);
+
+u32 rda_wlan_version(void);
+u8  check_test_mode(void);
+
+int rda_5990_wifi_power_off(void);
+int rda_5990_wifi_power_on(void);
+int rda_5990_bt_power_on(void);
+int rda_5990_bt_power_off(void);
+int rda_5990_fm_power_on(void);
+int rda_5990_fm_power_off(void);
+long rda_5990_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+int rda_5991_wifi_power_on(void);
+int rda_5991_wifi_power_off(void);
+int rda_5991_bt_power_on(void);
+int rda_5991_bt_power_off(void);
+int rda_5991_fm_power_on(void);
+int rda_5991_fm_power_off(void);
+long rda_5991_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+int rda_5991e_wifi_power_on(void);
+int rda_5991f_wifi_power_on(void);
+int rda_5991g_wifi_power_on(void);
+
+int rda_5991e_wifi_power_off(void);
+int rda_5991f_wifi_power_off(void);
+int rda_5991g_wifi_power_off(void);
+
+int rda_5991e_bt_power_on(void);
+int rda_5991f_bt_power_on(void);
+int rda_5991g_bt_power_on(void);
+
+int rda_5991e_bt_power_off(void);
+int rda_5991f_bt_power_off(void);
+int rda_5991g_bt_power_off(void);
+
+int rda_5991e_fm_power_on(void);
+int rda_5991f_fm_power_on(void);
+int rda_5991g_fm_power_on(void);
+
+int rda_5991e_fm_power_off(void);
+int rda_5991f_fm_power_off(void);
+int rda_5991g_fm_power_off(void);
+
+long rda_5991e_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+long rda_5991f_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+long rda_5991g_pw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+#endif
+
diff --git a/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo_power_main.c b/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo_power_main.c
new file mode 100644
index 000000000000..de9e0968d09d
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdacombodev/rda_combo_power_main.c
@@ -0,0 +1,1363 @@
+/* ----------------------------------------------------------------------- *
+ *
+ This file created by albert RDA Inc
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>		/* get the user-level API */
+#include <linux/bcd.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/nfs_fs.h>
+#include <linux/nfs_fs_sb.h>
+#include <linux/nfs_mount.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/tty.h>
+#include <linux/syscalls.h>
+#include <asm/termbits.h>
+#include <linux/serial.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <mach/iomap.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <mach/rda_clk_name.h>
+#include <mach/board.h>
+#include <linux/regulator/consumer.h>
+#include <mach/regulator.h>
+
+#include "tgt_ap_board_config.h"
+#include "tgt_ap_gpio_setting.h"
+#include "rda_combo.h"
+#include <linux/crc16.h>
+#include <linux/firmware.h>
+#include <linux/vmalloc.h>
+
+static struct mutex i2c_rw_lock;
+static struct rfkill *wlan_rfkill = NULL;
+static struct rfkill *bt_rfkill = NULL;
+static struct platform_device *platform_device;
+static unsigned short wlan_version = 0;
+static struct wake_lock rda_combo_wake_lock;
+static struct delayed_work rda_combo_sleep_worker;
+struct i2c_client *rda_wifi_core_client = NULL;
+struct i2c_client *rda_wifi_rf_client = NULL;
+struct i2c_client *rda_bt_core_client = NULL;
+struct i2c_client *rda_bt_rf_client = NULL;
+struct completion rda_wifi_bt_comp;
+struct regulator *combo_reg;
+
+static int bt_host_wake_irq;
+
+static u8 isBigEnded = 0;
+static u8 wifi_in_test_mode = 0;
+static u8 wifi_role_mode = 0;
+static u8 clock_mask_32k = 0;
+static u8 clock_mask_26m = 0;
+static u8 regulator_mask = 0;
+static struct clk *clk32k = NULL;
+static struct clk *clk26m = NULL;
+
+/*enable or disable 26m clock regulator */
+void enable_26m_regulator(u8 mask)
+{
+	int ret=0;
+	if (regulator_mask & CLOCK_MASK_ALL) {
+
+	} else {
+		ret = regulator_enable(combo_reg);
+	}
+	regulator_mask |= mask;
+
+}
+
+void disable_26m_regulator(u8 mask)
+{
+	if (regulator_mask & mask) {
+		regulator_mask &= ~mask;
+		if (regulator_mask & CLOCK_MASK_ALL) {
+
+		} else {
+			regulator_disable(combo_reg);
+		}
+	}
+}
+
+void enable_32k_rtc(u8 mask)
+{
+	if (clock_mask_32k & CLOCK_MASK_ALL) {
+
+	} else {
+		clk_prepare_enable(clk32k);
+	}
+	clock_mask_32k |= mask;
+}
+
+void disable_32k_rtc(u8 mask)
+{
+	if (clock_mask_32k & mask) {
+		clock_mask_32k &= ~mask;
+		if (clock_mask_32k & CLOCK_MASK_ALL) {
+
+		} else {
+			clk_disable_unprepare(clk32k);
+		}
+	}
+}
+
+void enable_26m_rtc(u8 mask)
+{
+	if (clock_mask_26m & CLOCK_MASK_ALL) {
+
+	} else {
+		clk_prepare_enable(clk26m);
+	}
+	clock_mask_26m |= mask;
+}
+
+void disable_26m_rtc(u8 mask)
+{
+	if (clock_mask_26m & mask) {
+		clock_mask_26m &= ~mask;
+		if (clock_mask_26m & CLOCK_MASK_ALL) {
+
+		} else {
+			clk_disable_unprepare(clk26m);
+		}
+	}
+}
+
+int i2c_write_1_addr_2_data(struct i2c_client *client, const u8 addr,
+				const u16 data)
+{
+	unsigned char DATA[3];
+	int ret = 0;
+	int retry = 3;
+
+	if (!isBigEnded) {
+		DATA[0] = addr;
+		DATA[1] = data >> 8;
+		DATA[2] = data >> 0;
+	} else {
+		DATA[0] = addr;
+		DATA[1] = data >> 0;
+		DATA[2] = data >> 8;
+	}
+
+	while (retry--) {
+		ret = i2c_master_send(client, (char *)DATA, 3);
+		if (ret >= 0) {
+			break;
+		}
+	}
+
+	if (ret < 0) {
+		printk(KERN_INFO
+			"***i2c_write_1_addr_2_data send:0x%X err:%d bigendia: %d \n",
+			addr, ret, isBigEnded);
+		return -1;
+	} else {
+		return 0;
+	}
+
+}
+
+int i2c_read_1_addr_2_data(struct i2c_client *client, const u8 addr, u16 * data)
+{
+	unsigned char DATA[2];
+	int ret = 0;
+	int retry = 3;
+
+	while (retry--) {
+		ret = i2c_master_send(client, (char *)&addr, 1);
+		if (ret >= 0) {
+			break;
+		}
+	}
+
+	if (ret < 0) {
+		printk(KERN_INFO "***i2c_read_1_addr_2_data send:0x%X err:%d\n",
+			addr, ret);
+		return -1;
+	}
+
+	retry = 3;
+	while (retry--) {
+		ret = i2c_master_recv(client, DATA, 2);
+		if (ret >= 0) {
+			break;
+		}
+	}
+
+	if (ret < 0) {
+		printk(KERN_INFO "***i2c_read_1_addr_2_data send:0x%X err:%d\n",
+			   addr, ret);
+		return -1;
+	}
+
+	if (!isBigEnded) {
+		*data = (DATA[0] << 8) | DATA[1];
+	} else {
+		*data = (DATA[1] << 8) | DATA[0];
+	}
+	return 0;
+}
+
+static void wlan_read_version_from_chip(void)
+{
+	int ret;
+	u16 project_id = 0, chip_version = 0;
+
+	if (wlan_version != 0 || !rda_wifi_rf_client)
+		return;
+
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0001);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x21, &chip_version);
+	if (ret)
+		goto err;
+
+	ret = i2c_read_1_addr_2_data(rda_wifi_rf_client, 0x20, &project_id);
+	if (ret)
+		goto err;
+
+	if (project_id == 0x5990) {
+		if (chip_version == 0x47)
+			wlan_version = WLAN_VERSION_90_D;
+		else if (chip_version == 0x44 || chip_version == 0x45)
+			wlan_version = WLAN_VERSION_90_E;
+	} else if (project_id == 0x5991) {
+		if (chip_version == 0x44)
+			wlan_version = WLAN_VERSION_91;
+		else if (chip_version == 0x45)
+			wlan_version = WLAN_VERSION_91_E;
+		else if (chip_version == 0x46)
+			wlan_version = WLAN_VERSION_91_F;
+		else if (chip_version == 0x47)
+			wlan_version = WLAN_VERSION_91_G;
+	}
+
+	if (wlan_version == 0)
+		printk("error, unsupported chip version! project_id:0x%x, chip_version:0x%x\n",
+			project_id, chip_version);
+	else
+		printk("read project_id:%x version:%x wlan_version:%x \n", project_id,
+			chip_version, wlan_version);
+err:
+	ret = i2c_write_1_addr_2_data(rda_wifi_rf_client, 0x3f, 0x0000);
+	return;
+
+}
+
+#ifdef RDA_COMBO_FROM_FIRMWARE
+atomic_t wifi_fw_status = ATOMIC_INIT(0);
+atomic_t bt_fw_status = ATOMIC_INIT(0);
+struct rda_firmware rda_combo_fw_entry = {
+	.status = 0,
+	.size = 0,
+	.num = 0,
+};
+
+static inline void rda_combo_firmware_lock(void)
+{
+	mutex_lock(&(rda_combo_fw_entry.lock));
+}
+static inline void rda_combo_firmware_unlock(void)
+{
+	mutex_unlock(&(rda_combo_fw_entry.lock));
+}
+static inline int rda_combo_get_firmware_status(void)
+{
+	return rda_combo_fw_entry.status;
+}
+static inline void rda_combo_set_firmware_status(int val)
+{
+	rda_combo_fw_entry.status = val;
+}
+void rda_release_firmware(void)
+{
+	if (atomic_read(&wifi_fw_status)==0 && atomic_read(&bt_fw_status)==0) {
+		rda_combo_firmware_lock();
+		if (rda_combo_get_firmware_status() == 1) {
+			vfree(rda_combo_fw_entry.data);
+			rda_combo_fw_entry.num = 0;
+			rda_combo_fw_entry.size = 0;
+			rda_combo_set_firmware_status(0);
+			printk("rda_combo: release firmware\n");
+		}
+		rda_combo_firmware_unlock();
+	}
+}
+static int check_firmware_data(const struct firmware *fw_entry)
+{
+	return crc16(0, fw_entry->data, fw_entry->size);
+}
+static struct rda_firmware_data_type* rda_find_data_from_firmware(
+		const u8 *fw, const char *data_name, int num_flag, u32 size_flag)
+{
+	struct rda_firmware_data_type * rda_combo_data_type;
+	const u8 *rda_combo_data;
+	u32 num = 0;
+	u32 size = 0;
+
+	rda_combo_data_type = (struct rda_firmware_data_type*)fw;
+
+	while (1) {
+		if (rda_combo_data_type == NULL) {
+			printk("rda_combo find data error, fw address error!\n");
+			return NULL;
+		}
+
+		num ++;
+		if (num > num_flag) {
+			printk("error: could not find data %s!\n",
+				data_name);
+			return NULL;
+		}
+
+		size += (sizeof(struct rda_firmware_data_type) +
+			rda_combo_data_type->size);
+		if (size > size_flag) {
+			printk("error: could not find data %s!\n",
+				data_name);
+			return NULL;
+		}
+
+		rda_combo_data =
+			(u8 *)(rda_combo_data_type + 1);
+
+		if (strcmp(rda_combo_data_type->data_name, data_name) == 0)
+			break;
+
+		rda_combo_data_type = (struct rda_firmware_data_type *)
+			(rda_combo_data + rda_combo_data_type->size);
+	}
+	if (crc16(0, rda_combo_data, rda_combo_data_type->size) !=
+				rda_combo_data_type->crc) {
+		printk("error: data %s crc error\n", data_name);
+			return NULL;
+	}
+	return rda_combo_data_type;
+
+}
+static int rda_firmware_copy_data(const struct firmware *fw_entry,
+				int chip_version)
+{
+	struct rda_device_firmware_head *rda_combo_firmware_head;
+	struct rda_firmware_data_type * rda_combo_data_type;
+	u32 num = 0;
+	u32 size = sizeof(struct rda_device_firmware_head);
+	int off_set = 0;
+
+	rda_combo_firmware_head = (struct rda_device_firmware_head *)(fw_entry->data);
+	if (strcmp(rda_combo_firmware_head->firmware_type,
+					RDA_COMBO_FIRMWARE_NAME) != 0) {
+		printk("rda_combo error: firmware data error\n");
+		return -1;
+	}
+	if (rda_combo_firmware_head->version != RDA_FIRMWARE_VERSION) {
+		printk("firmware data version error. version %d is needed\n",
+			RDA_FIRMWARE_VERSION);
+		return -1;
+	}
+
+	rda_combo_data_type =
+		(struct rda_firmware_data_type*)(rda_combo_firmware_head+1);
+	while (1) {
+		if (rda_combo_data_type == NULL) {
+			printk("rda_combo find data error, fw address error!\n");
+			return -1;
+		}
+
+		num++;
+		if (num > rda_combo_firmware_head->data_num)
+			break;
+
+		size += (sizeof(struct rda_firmware_data_type) +
+			rda_combo_data_type->size);
+		if (size > fw_entry->size) {
+			printk("rda_combo error, fw size error!\n");
+			return -1;
+		}
+
+		if (rda_combo_data_type->chip_version == chip_version ||
+			rda_combo_data_type->chip_version == -1) {
+			rda_combo_fw_entry.size +=
+				sizeof(struct rda_firmware_data_type) +
+				rda_combo_data_type->size;
+			rda_combo_fw_entry.num++;
+		}
+		rda_combo_data_type = (struct rda_firmware_data_type *)
+			((u8 *)(rda_combo_data_type + 1) +
+			rda_combo_data_type->size);
+	}
+
+	rda_combo_fw_entry.data = (const u8*)vmalloc(rda_combo_fw_entry.size);
+	if (rda_combo_fw_entry.data == NULL) {
+		printk("rda_combo:vmalloc faild!\n");
+		return -1;
+	}
+
+	num = 0;
+	size = 0;
+	rda_combo_data_type =
+		(struct rda_firmware_data_type*)(rda_combo_firmware_head+1);
+	while (1) {
+		if (rda_combo_data_type == NULL) {
+			printk("rda_combo find data error, fw address error!\n");
+			return -1;
+		}
+
+		num++;
+		if (num > rda_combo_firmware_head->data_num)
+			break;
+
+		size += (sizeof(struct rda_firmware_data_type) +
+			rda_combo_data_type->size);
+		if (size > fw_entry->size) {
+			printk("rda_combo error, fw size error!\n");
+			return -1;
+		}
+
+		if (rda_combo_data_type->chip_version == chip_version ||
+			rda_combo_data_type->chip_version == -1) {
+			memcpy((void *)(rda_combo_fw_entry.data+off_set),
+				(const void *)rda_combo_data_type,
+				rda_combo_data_type->size +
+				sizeof(struct rda_firmware_data_type));
+			off_set += rda_combo_data_type->size +
+				sizeof(struct rda_firmware_data_type);
+		}
+
+		rda_combo_data_type = (struct rda_firmware_data_type *)
+			((u8 *)(rda_combo_data_type + 1) +
+			rda_combo_data_type->size);
+	}
+
+	return 0;
+}
+
+static int rda_prepare_data_from_firmware(struct i2c_client* client)
+{
+	int ret;
+	u32 version = rda_wlan_version();
+	const struct firmware *fw_entry;
+	struct device * device = &(client->dev);
+	ret = request_firmware(&fw_entry,
+		RDA_COMBO_FIRMWARE_NAME,  device);
+	if (ret) {
+		printk("Request firmware: request firmware failed\n");
+		return ret;
+	}
+	if (check_firmware_data(fw_entry)) {
+		printk("firmware data crc check error\n");
+		ret = -1;
+		goto out;
+	}
+
+	switch (version) {
+	case WLAN_VERSION_90_D:
+	case WLAN_VERSION_90_E:
+		ret = rda_firmware_copy_data(fw_entry, WLAN_VERSION_90_D);
+		break;
+	case WLAN_VERSION_91:
+		ret = rda_firmware_copy_data(fw_entry, WLAN_VERSION_91);
+		break;
+	case WLAN_VERSION_91_E:
+		ret = rda_firmware_copy_data(fw_entry, WLAN_VERSION_91_E);
+		break;
+	case WLAN_VERSION_91_F:
+		ret = rda_firmware_copy_data(fw_entry, WLAN_VERSION_91_F);
+		break;
+	case WLAN_VERSION_91_G:
+		ret = rda_firmware_copy_data(fw_entry, WLAN_VERSION_91_G);
+		break;
+	default:
+		printk("rda_combo: error chip version!\n");
+		ret = -1;
+		goto out;
+	}
+	if (ret == 0)
+		printk("rda_combo: prepare data from firmware successfully!\n");
+	else {
+		printk("rda_combo: prepare data from firmware error!\n");
+		ret = -1;
+		goto out;
+	}
+out:
+	release_firmware(fw_entry);
+	return ret;
+
+}
+int rda_write_data_to_rf_from_firmware(struct i2c_client* client,
+						char *data_name)
+{
+	int ret = 0;
+	struct rda_firmware_data_type * rda_combo_data_type;
+	const u8 *rda_combo_data;
+
+	rda_combo_firmware_lock();
+	if (rda_combo_get_firmware_status() == 0) {
+		ret = rda_prepare_data_from_firmware(client);
+		if (ret < 0) {
+			printk("rda_comb error: prepare array_data error\n");
+			goto out;
+		}
+		rda_combo_set_firmware_status(1);
+	}
+
+	rda_combo_data_type = rda_find_data_from_firmware(
+		rda_combo_fw_entry.data, data_name,
+		rda_combo_fw_entry.num, rda_combo_fw_entry.size);
+	if (rda_combo_data_type == NULL) {
+		printk("rda_write_data_to_rf_from_firmware failed\n");
+		ret = -1;
+		goto out;
+	}
+
+	rda_combo_data = (const u8 *)(rda_combo_data_type+1);
+
+	ret = rda_i2c_write_data_to_rf(client,
+		(const u16 (*)[2])rda_combo_data, rda_combo_data_type->size / 4);
+
+out:
+	rda_combo_firmware_unlock();
+	return ret;
+}
+#endif
+
+int rda_i2c_write_data_to_rf(struct i2c_client *client, const u16(*data)[2],
+			 u32 count)
+{
+	int ret = 0;
+	u32 i = 0;
+
+	for (i = 0; i < count; i++) {
+		if (data[i][0] == I2C_DELAY_FLAG) {
+			msleep(data[i][1]);
+			continue;
+		}
+		ret = i2c_write_1_addr_2_data(client, data[i][0], data[i][1]);
+		if (ret < 0)
+			break;
+	}
+	return ret;
+}
+
+u32 rda_wlan_version(void)
+{
+	if(wlan_version == 0)
+		wlan_read_version_from_chip();
+	return wlan_version;
+}
+
+static int rda_wifi_rf_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int result = 0;
+
+	rda_wifi_rf_client = client;
+	printk("rda_wifi_rf_probe \n");
+	return result;
+}
+
+static int rda_wifi_rf_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int rda_wifi_rf_detect(struct i2c_client *client,
+				struct i2c_board_info *info)
+{
+	strcpy(info->type, RDA_WIFI_RF_I2C_DEVNAME);
+	return 0;
+}
+
+static const struct i2c_device_id wifi_rf_i2c_id[] ={
+	{RDA_WIFI_RF_I2C_DEVNAME, RDA_I2C_CHANNEL},
+	{}
+};
+
+static struct i2c_driver rda_wifi_rf_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = rda_wifi_rf_probe,
+	.remove = rda_wifi_rf_remove,
+	.detect = rda_wifi_rf_detect,
+	.driver.name = RDA_WIFI_RF_I2C_DEVNAME,
+	.id_table = wifi_rf_i2c_id,
+};
+
+static int rda_wifi_core_detect(struct i2c_client *client,
+				struct i2c_board_info *info)
+{
+	strcpy(info->type, RDA_WIFI_CORE_I2C_DEVNAME);
+	return 0;
+}
+
+static int rda_wifi_core_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int result = 0;
+
+	rda_wifi_core_client = client;
+	printk("rda_wifi_core_probe \n");
+	return result;
+}
+
+static int rda_wifi_core_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+int rda_wifi_power_off(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+		|| wlan_version == WLAN_VERSION_90_E)
+		return rda_5990_wifi_power_off();
+	else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_wifi_power_off();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_wifi_power_off();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_wifi_power_off();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_wifi_power_off();
+	return -1;
+}
+
+int rda_wifi_power_on(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+			|| wlan_version == WLAN_VERSION_90_E) {
+		return rda_5990_wifi_power_on();
+	} else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_wifi_power_on();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_wifi_power_on();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_wifi_power_on();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_wifi_power_on();
+	return -1;
+}
+
+static void rda_wifi_shutdown(struct i2c_client *client)
+{
+	printk("rda_wifi_shutdown \n");
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	if(atomic_read(&wifi_fw_status))
+#endif
+		rda_wifi_power_off();
+}
+
+static const struct i2c_device_id wifi_core_i2c_id[] = {
+	{RDA_WIFI_CORE_I2C_DEVNAME, RDA_I2C_CHANNEL},
+	{}
+};
+static struct i2c_driver rda_wifi_core_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = rda_wifi_core_probe,
+	.remove = rda_wifi_core_remove,
+	.detect = rda_wifi_core_detect,
+	.shutdown = rda_wifi_shutdown,
+	.driver.name = RDA_WIFI_CORE_I2C_DEVNAME,
+	.id_table = wifi_core_i2c_id,
+};
+
+static int rda_bt_rf_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	int result = 0;
+
+	rda_bt_rf_client = client;
+	printk("rda_bt_rf_probe \n");
+	return result;
+}
+
+static int rda_bt_rf_remove(struct i2c_client *client)
+{
+	rda_bt_rf_client = NULL;
+	return 0;
+}
+
+static int rda_bt_rf_detect(struct i2c_client *client,
+				struct i2c_board_info *info)
+{
+	strcpy(info->type, RDA_BT_RF_I2C_DEVNAME);
+	return 0;
+}
+
+static const struct i2c_device_id bt_rf_i2c_id[] = {
+	{RDA_BT_RF_I2C_DEVNAME, RDA_I2C_CHANNEL},
+	{}
+};
+static struct i2c_driver rda_bt_rf_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = rda_bt_rf_probe,
+	.remove = rda_bt_rf_remove,
+	.detect = rda_bt_rf_detect,
+	.driver.name = RDA_BT_RF_I2C_DEVNAME,
+	.id_table = bt_rf_i2c_id,
+};
+
+static int rda_bt_core_detect(struct i2c_client *client,
+				  struct i2c_board_info *info)
+{
+	strcpy(info->type, RDA_BT_CORE_I2C_DEVNAME);
+	return 0;
+}
+
+void rda_combo_set_wake_lock(void);
+
+#ifdef CONFIG_BLUEZ_SUPPORT
+extern void hci_bt_wakeup_host(void);
+#endif
+
+static irqreturn_t rda_bt_host_wake_eirq_handler(int irq, void *dev_id)
+{
+#ifdef CONFIG_BLUEZ_SUPPORT
+	hci_bt_wakeup_host();
+#endif
+	rda_combo_set_wake_lock();
+	return IRQ_HANDLED;
+}
+
+static int rda_bt_core_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int result = 0;
+	rda_bt_core_client = client;
+	printk("rda_bt_core_probe\n");
+	return result;
+}
+
+static int rda_bt_core_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id bt_core_i2c_id[] ={
+	{RDA_BT_CORE_I2C_DEVNAME, RDA_I2C_CHANNEL},
+	{}
+};
+
+static struct i2c_driver rda_bt_core_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = rda_bt_core_probe,
+	.remove = rda_bt_core_remove,
+	.detect = rda_bt_core_detect,
+	.driver.name = RDA_BT_CORE_I2C_DEVNAME,
+	.id_table = bt_core_i2c_id,
+};
+
+#ifdef CONFIG_BT_RANDADDR
+extern void bt_get_random_address(char *buf);
+#endif
+
+static int rda_combo_i2c_ops(unsigned long arg)
+{
+	int ret = 0, argc = 0;
+	u8 cmd[256], *argv[5], *pos, rw = 0, addr = 0, pageup = 0;
+	struct i2c_client * i2Client = NULL;
+	u16  data = 0;
+	void __user *argp = (void __user *)arg;
+
+	if(copy_from_user(cmd, argp, 256))
+		return -EFAULT;
+	else {
+		pos = cmd;
+		while (*pos != '\0') {
+			if (*pos == '\n') {
+				*pos = '\0';
+				break;
+			}
+			pos++;
+		}
+		argc = 0;
+		pos = cmd;
+		for (;;) {
+			while (*pos == ' ')
+				pos++;
+			if (*pos == '\0')
+				break;
+			argv[argc] = pos;
+			argc++;
+			if (argc == 5)
+				break;
+			if (*pos == '"') {
+				char *pos2 = strrchr(pos, '"');
+				if (pos2)
+					pos = pos2 + 1;
+			}
+			while (*pos != '\0' && *pos != ' ')
+				pos++;
+			if (*pos == ' ')
+				*pos++ = '\0';
+		}
+	}
+
+	if (!memcmp(argv[1], "bt", 2)) {
+		i2Client = rda_bt_rf_client;
+	} else
+		i2Client = rda_wifi_rf_client;
+
+	if (kstrtou8(argv[3], 0, &addr))
+		return -EINVAL;
+
+	if (*(argv[2]) == 'r') {
+		rw = 0;
+	} else {
+		rw = 1;
+		if (kstrtou16(argv[4], 0, &data))
+			return -EINVAL;
+	}
+
+	if (addr >= 0x80) {
+		i2c_write_1_addr_2_data(i2Client, 0x3F, 0x0001);
+		addr -= 0x80;
+		pageup = 1;
+	}
+
+	if (*(argv[2]) == 'r') {
+		int read_data = 0;
+		i2c_read_1_addr_2_data(i2Client, addr, &data);
+		read_data = (int)data;
+
+		if (copy_to_user(argp, &read_data, sizeof(int)))
+			ret = -EFAULT;
+	} else
+		i2c_write_1_addr_2_data(i2Client, addr, data);
+
+	if (pageup == 1)
+		i2c_write_1_addr_2_data(i2Client, 0x3F, 0x0000);
+
+	printk("wlan: %s %s %s %s :0x%x \n",
+		argv[0], argv[1], argv[2], argv[3], data);
+	return ret;
+}
+
+
+static long rda_combo_pw_ioctl(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	int ret = 0;
+	void __user *argp = (void __user *)arg;
+
+	switch (cmd) {
+	case RDA_WLAN_COMBO_VERSION:
+		{
+			u32 version = rda_wlan_version();
+			if (copy_to_user(argp, &version, sizeof(version)))
+				ret = -EFAULT;
+		}
+		break;
+	case RDA_WIFI_POWER_SET_TEST_MODE_IOCTL:
+		wifi_in_test_mode = 1;
+		printk("****set rda wifi in test mode \n");
+		break;
+	case RDA_WIFI_POWER_CANCEL_TEST_MODE_IOCTL:
+		wifi_in_test_mode = 0;
+		printk("****set rda wifi in normal mode \n");
+		break;
+	case RDA_WIFI_STA_MODE_IOCTL:
+		wifi_role_mode = 0;
+		printk("****set rda wifi in sta mode \n");
+		break;
+	case RDA_WIFI_SOFTAP_MODE_IOCTL:
+		wifi_role_mode = 1;
+		printk("****set rda wifi in softap mode \n");
+		break;
+	case RDA_WIFI_P2P_MODE_IOCTL:
+		wifi_role_mode |= 0xA0;
+		printk("****set rda wifi in p2p mode \n");
+		break;
+	case RDA_BT_GET_ADDRESS_IOCTL:
+		{
+			u8 bt_addr[6] = { 0 };
+#ifdef CONFIG_BT_RANDADDR
+			bt_get_random_address(bt_addr);
+#endif
+			printk(KERN_INFO
+				"rdabt address[0x%x]:[0x%x]:[0x%x]:[0x%x]:[0x%x]:[0x%x].\n",
+				bt_addr[0], bt_addr[1], bt_addr[2], bt_addr[3],
+				bt_addr[4], bt_addr[5]);
+
+			if (copy_to_user(argp, &bt_addr[0], sizeof(bt_addr))) {
+				ret = -EFAULT;
+			}
+		}
+		break;
+	case RDA_COMBO_I2C_OPS:
+		ret = rda_combo_i2c_ops(arg);
+		break;
+	default:
+		if (wlan_version == WLAN_VERSION_90_D
+			|| wlan_version == WLAN_VERSION_90_E) {
+			ret = rda_5990_pw_ioctl(file, cmd, arg);
+		} else if (wlan_version == WLAN_VERSION_91)
+			ret = rda_5991_pw_ioctl(file, cmd, arg);
+		else if (wlan_version == WLAN_VERSION_91_E)
+			ret = rda_5991e_pw_ioctl(file, cmd, arg);
+		else if (wlan_version == WLAN_VERSION_91_F)
+			ret = rda_5991f_pw_ioctl(file, cmd, arg);
+		else if (wlan_version == WLAN_VERSION_91_G)
+			ret = rda_5991g_pw_ioctl(file, cmd, arg);
+		else
+			ret = -1;
+		break;
+	}
+	return ret;
+}
+
+static int rda_combo_major;
+static struct class *rda_combo_class = NULL;
+struct device *rda_combo_device;
+static const struct file_operations rda_combo_operations = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = rda_combo_pw_ioctl,
+	.release = NULL
+};
+
+void rda_combo_sleep_worker_task(struct work_struct *work)
+{
+	printk("---rda_combo_sleep_worker_task end \n");
+	wake_unlock(&rda_combo_wake_lock);
+}
+
+void rda_combo_set_wake_lock(void)
+{
+	wake_lock(&rda_combo_wake_lock);
+	cancel_delayed_work(&rda_combo_sleep_worker);
+	schedule_delayed_work(&rda_combo_sleep_worker, 6 * HZ);
+}
+
+static struct platform_driver platform_driver = {
+	.driver = {
+		   .name = "rda_combo_rfkill_device",
+		   .owner = THIS_MODULE,
+		}
+};
+
+static int wlan_rfkill_set(void *data, bool blocked)
+{
+	printk("wlan_rfkill_set %d \n", blocked);
+	if (blocked) {
+		return rda_wifi_power_off();
+	} else {
+		return rda_wifi_power_on();
+	}
+}
+
+static int rda_bt_power_off(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+		|| wlan_version == WLAN_VERSION_90_E) {
+		return rda_5990_bt_power_off();
+	} else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_bt_power_off();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_bt_power_off();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_bt_power_off();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_bt_power_off();
+	return -1;
+}
+
+static int rda_bt_power_on(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+		|| wlan_version == WLAN_VERSION_90_E) {
+		return rda_5990_bt_power_on();
+	} else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_bt_power_on();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_bt_power_on();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_bt_power_on();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_bt_power_on();
+	return -1;
+}
+
+static const struct rfkill_ops wlan_rfkill_ops = {
+	.set_block = wlan_rfkill_set,
+};
+
+static int bt_rfkill_set(void *data, bool blocked)
+{
+	printk("bt_rfkill_set %d \n", blocked);
+	if (blocked) {
+		return rda_bt_power_off();
+	} else {
+		return rda_bt_power_on();
+	}
+}
+
+static const struct rfkill_ops bt_rfkill_ops = {
+	.set_block = bt_rfkill_set,
+};
+
+#ifdef _TGT_AP_HAVE_GPS
+static struct rfkill *gps_rfkill = NULL;
+static int rda_gps_power_off(int gpio, int value)
+{
+	int ret;
+	ret = gpio_request(gpio, "gps-on");
+	if (ret) {
+		printk("Fail to request gpio :%d\n", gpio);
+		return -1;
+	}
+	gpio_direction_output(gpio, value);
+	gpio_set_value(gpio, value);
+	disable_32k_rtc(CLOCK_GPS);
+	gpio_free(gpio);
+	printk("Disable GPS GPIO and 32K\n");
+	return ret;
+}
+
+static int rda_gps_power_on(int gpio, int value)
+{
+	int ret;
+	ret = gpio_request(gpio, "gps-on");
+	if (ret) {
+		printk("Fail to request gpio :%d\n", gpio);
+		return -1;
+	}
+	gpio_direction_output(gpio, value);
+	gpio_set_value(gpio, value);
+	enable_32k_rtc(CLOCK_GPS);
+	gpio_free(gpio);
+	printk("Enable GPS GPIO and 32K\n");
+	return ret;
+}
+
+static int gps_rfkill_set(void *data, bool blocked)
+{
+	printk("gps_rfkill_set %d \n", blocked);
+	if (blocked) {
+		rda_gps_power_off(_TGT_AP_GPIO_GPS_ENABLE, 0);
+	} else {
+		rda_gps_power_on(_TGT_AP_GPIO_GPS_ENABLE, 1);
+	}
+	return 0;
+}
+
+static const struct rfkill_ops gps_rfkill_ops = {
+	.set_block = gps_rfkill_set,
+};
+#endif
+int rda_combo_power_ctrl_init(void)
+{
+	int ret = 0;
+
+	printk("rda_combo_power_ctrl_init begin\n");
+	if (i2c_add_driver(&rda_wifi_core_driver)) {
+		printk("rda_wifi_core_driver failed!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	if (i2c_add_driver(&rda_wifi_rf_driver)) {
+		printk("rda_wifi_rf_driver failed!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	if (i2c_add_driver(&rda_bt_core_driver)) {
+		printk("rda_bt_core_driver failed!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	if (i2c_add_driver(&rda_bt_rf_driver)) {
+		printk("rda_bt_rf_driver failed!\n");
+		ret = -ENODEV;
+		return ret;
+	}
+#ifdef RDA_COMBO_FROM_FIRMWARE
+	mutex_init(&(rda_combo_fw_entry.lock));
+#endif
+	mutex_init(&i2c_rw_lock);
+	INIT_DELAYED_WORK(&rda_combo_sleep_worker,rda_combo_sleep_worker_task);
+	wake_lock_init(&rda_combo_wake_lock, WAKE_LOCK_SUSPEND,
+				"RDA_sleep_worker_wake_lock");
+	rda_combo_major =
+		register_chrdev(0, "rdacombo_power_ctrl", &rda_combo_operations);
+	if (rda_combo_major < 0) {
+		printk(KERN_INFO "register rdacombo_power_ctrl failed!!! \n");
+		ret = rda_combo_major;
+		goto fail;
+	}
+
+	rda_combo_class = class_create(THIS_MODULE, "rda_combo");
+	if (IS_ERR(rda_combo_class)) {
+		printk(KERN_INFO "create rda_combo_class failed!!! \n");
+		ret = PTR_ERR(rda_combo_class);
+		goto fail;
+	}
+
+	rda_combo_device= device_create(rda_combo_class, NULL, MKDEV(rda_combo_major, 0),
+			NULL, "rdacombo");
+	if (IS_ERR(rda_combo_device)) {
+		printk(KERN_INFO "create rda_combo_device failed!!! \n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	combo_reg = regulator_get(NULL, LDO_BT);
+	if (IS_ERR(combo_reg)) {
+		printk(KERN_INFO "could not find regulator devices\n");
+		ret = PTR_ERR(combo_reg);
+		goto fail;
+	}
+
+	{
+		unsigned char *temp = NULL;
+		unsigned short testData = 0xffee;
+		temp = (unsigned char *)&testData;
+		if (*temp == 0xee)
+			isBigEnded = 0;
+		else
+			isBigEnded = 1;
+	}
+
+	ret = platform_driver_register(&platform_driver);
+	if (ret)
+		goto fail;
+
+	platform_device = platform_device_alloc("rda_combo_rfkill_device", -1);
+	if (!platform_device) {
+		ret = -ENOMEM;
+	} else
+		ret = platform_device_add(platform_device);
+
+	if (ret)
+		goto fail_platform_device;
+
+
+	wlan_rfkill =
+		rfkill_alloc("rda_wlan_rk", &platform_device->dev, RFKILL_TYPE_WWAN,
+			 &wlan_rfkill_ops, NULL);
+	if (wlan_rfkill) {
+		rfkill_init_sw_state(wlan_rfkill, true);
+		ret = rfkill_register(wlan_rfkill);
+		if (ret < 0)
+			goto fail_rfkill_register;
+	} else
+		printk("rda_wlan_rk failed\n");
+
+	bt_rfkill =
+		rfkill_alloc("rda_bt_rk", &platform_device->dev,
+			RFKILL_TYPE_BLUETOOTH, &bt_rfkill_ops, NULL);
+	if (bt_rfkill) {
+		rfkill_init_sw_state(bt_rfkill, true);
+		ret = rfkill_register(bt_rfkill);
+		if (ret < 0)
+			goto fail_rfkill_register;
+	} else
+		printk("rda_bt_rk failed\n");
+
+#ifdef _TGT_AP_HAVE_GPS
+	gps_rfkill =
+		rfkill_alloc("rda_gps_rk", &platform_device->dev,
+			RFKILL_TYPE_GPS, &gps_rfkill_ops, NULL);
+	if (gps_rfkill) {
+		rfkill_init_sw_state(gps_rfkill, true);
+		ret = rfkill_register(gps_rfkill);
+		if (ret < 0)
+			goto fail_rfkill_register;
+	} else
+		printk("rda_gps_rk failed\n");
+#endif
+	ret = gpio_request(GPIO_BT_HOST_WAKE, "rda_bt_host_wake");
+	if (ret) {
+		/* this is not fatal */
+		printk("Fail to request GPIO for rda_bt_host_wake\n");
+		ret = 0;
+	} else {
+		bt_host_wake_irq = gpio_to_irq(GPIO_BT_HOST_WAKE);
+		if (bt_host_wake_irq < 0) {
+			ret = -1;
+			goto fail_platform_device;
+		}
+
+		ret = request_irq(bt_host_wake_irq,
+				rda_bt_host_wake_eirq_handler,
+				IRQF_TRIGGER_RISING | IRQF_NO_SUSPEND,
+				"rda_bt_host_wake_irq", NULL);
+		if (ret)
+			goto fail_platform_device;
+	}
+
+	clk32k = clk_get(NULL, RDA_CLK_OUT);
+	clk26m = clk_get(NULL, RDA_CLK_AUX);
+
+
+	wlan_read_version_from_chip();
+	if (wlan_version == 0) {
+		ret = -1;
+		goto fail_wland_veriosn;
+	}
+
+	init_completion(&rda_wifi_bt_comp);
+	complete(&rda_wifi_bt_comp);
+
+	printk("rda_combo_power_ctrl_init end\n");
+	return 0;
+
+fail_wland_veriosn:
+	disable_32k_rtc(CLOCK_MASK_ALL);
+	disable_26m_rtc(CLOCK_MASK_ALL);
+	clk_put(clk32k);
+	clk_put(clk26m);
+	free_irq(bt_host_wake_irq, NULL);
+fail_rfkill_register:
+fail_platform_device:
+	if (wlan_rfkill) {
+		rfkill_unregister(wlan_rfkill);
+		rfkill_destroy(wlan_rfkill);
+	}
+	if (bt_rfkill) {
+		rfkill_unregister(bt_rfkill);
+		rfkill_destroy(bt_rfkill);
+	}
+#ifdef _TGT_AP_HAVE_GPS
+	if (gps_rfkill) {
+		rfkill_unregister(gps_rfkill);
+		rfkill_destroy(gps_rfkill);
+	}
+#endif
+	if (platform_device)
+		platform_device_unregister(platform_device);
+	platform_driver_unregister(&platform_driver);
+
+fail:
+	if (!IS_ERR(combo_reg)) {
+		disable_26m_regulator(CLOCK_MASK_ALL);
+		regulator_put(combo_reg);
+	}
+	if (!IS_ERR(rda_combo_device))
+		device_destroy(rda_combo_class, MKDEV(rda_combo_major, 0));
+	if (rda_combo_class)
+		class_destroy(rda_combo_class);
+	if (rda_combo_major >= 0)
+		unregister_chrdev(rda_combo_major, "rdacombo_power_ctrl");
+	cancel_delayed_work_sync(&rda_combo_sleep_worker);
+	wake_lock_destroy(&rda_combo_wake_lock);
+	i2c_del_driver(&rda_bt_rf_driver);
+	i2c_del_driver(&rda_bt_core_driver);
+	i2c_del_driver(&rda_wifi_rf_driver);
+	i2c_del_driver(&rda_wifi_core_driver);
+	return ret;
+}
+
+void rda_combo_power_ctrl_exit(void)
+{
+	i2c_del_driver(&rda_wifi_core_driver);
+	i2c_del_driver(&rda_wifi_rf_driver);
+	i2c_del_driver(&rda_bt_core_driver);
+	i2c_del_driver(&rda_bt_rf_driver);
+	unregister_chrdev(rda_combo_major, "rdacombo_power_ctrl");
+	if (rda_combo_class)
+		class_destroy(rda_combo_class);
+
+	cancel_delayed_work_sync(&rda_combo_sleep_worker);
+	wake_lock_destroy(&rda_combo_wake_lock);
+	disable_32k_rtc(CLOCK_MASK_ALL);
+	disable_26m_rtc(CLOCK_MASK_ALL);
+	clk_put(clk32k);
+	clk_put(clk26m);
+	if (wlan_rfkill) {
+		rfkill_unregister(wlan_rfkill);
+		rfkill_destroy(wlan_rfkill);
+	}
+
+	if (bt_rfkill) {
+		rfkill_unregister(bt_rfkill);
+		rfkill_destroy(bt_rfkill);
+	}
+
+	free_irq(bt_host_wake_irq, NULL);
+
+	if (platform_device) {
+		platform_device_unregister(platform_device);
+		platform_driver_unregister(&platform_driver);
+	}
+
+	if (!IS_ERR(combo_reg)) {
+		disable_26m_regulator(CLOCK_MASK_ALL);
+			regulator_put(combo_reg);
+	}
+}
+
+u8 check_test_mode(void)
+{
+	return wifi_in_test_mode;
+}
+
+u8 check_role_mode(void)
+{
+	return wifi_role_mode;
+}
+
+void rda_combo_i2c_lock(void)
+{
+	mutex_lock(&i2c_rw_lock);
+}
+
+void rda_combo_i2c_unlock(void)
+{
+	mutex_unlock(&i2c_rw_lock);
+}
+
+int rda_fm_power_on(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+		|| wlan_version == WLAN_VERSION_90_E) {
+		return rda_5990_fm_power_on();
+	} else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_fm_power_on();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_fm_power_on();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_fm_power_on();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_fm_power_on();
+	return -1;
+}
+
+int rda_fm_power_off(void)
+{
+	if (wlan_version == WLAN_VERSION_90_D
+		|| wlan_version == WLAN_VERSION_90_E) {
+		return rda_5990_fm_power_off();
+	} else if (wlan_version == WLAN_VERSION_91)
+		return rda_5991_fm_power_off();
+	else if (wlan_version == WLAN_VERSION_91_E)
+		return rda_5991e_fm_power_off();
+	else if (wlan_version == WLAN_VERSION_91_F)
+		return rda_5991f_fm_power_off();
+	else if (wlan_version == WLAN_VERSION_91_G)
+		return rda_5991g_fm_power_off();
+	return -1;
+
+}
+
+EXPORT_SYMBOL(rda_wlan_version);
+EXPORT_SYMBOL(check_test_mode);
+EXPORT_SYMBOL(check_role_mode);
+EXPORT_SYMBOL(rda_combo_set_wake_lock);
+EXPORT_SYMBOL(rda_wifi_power_off);
+EXPORT_SYMBOL(rda_wifi_power_on);
+EXPORT_SYMBOL(rda_fm_power_on);
+EXPORT_SYMBOL(rda_fm_power_off);
+late_initcall(rda_combo_power_ctrl_init);
+module_exit(rda_combo_power_ctrl_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/Makefile b/drivers/net/wireless/rdaw80211/rdawlan/Makefile
new file mode 100644
index 000000000000..fcb1cff3d339
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/Makefile
@@ -0,0 +1,61 @@
+#
+# Makefile fragment for Rdamicro 802.11 Networking Device Driver
+#
+# Copyright (c) 2014 Rdamicro Corporation
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ccflags-y += \
+	-Idrivers/net/wireless/rdaw80211/rdawlan\
+	-Idrivers/net/wireless/rdaw80211/include
+
+ccflags-y += -D__CHECK_ENDIAN__
+
+obj-$(CONFIG_RDAWFMAC) += rdawfmac.o
+rdawfmac-objs += \
+		linux_osl.o \
+		wland_iw.o \
+		wland_p2p.o \
+		wland_dbg.o \
+		wland_d11.o \
+		wland_btcoex.o \
+		wland_nvram.o \
+		wland_utils.o \
+		wland_trap.o \
+		wland_bus.o \
+		wland_cmds.o \
+		wland_fwsmgr.o \
+		wland_wid.o \
+ 		wland_fweh.o \
+		wland_linux.o \
+		wland_cfg80211.o \
+		wland_linux_mon.o \
+		wland_android.o 	
+
+rdawfmac-$(CONFIG_RDAWFMAC_SDIO) += \
+ 		wland_sdio.o \
+ 		wland_sdmmc.o 
+rdawfmac-$(CONFIG_RDAWFMAC_USB) += \
+ 		wland_usb.o
+rdawfmac-$(CONFIG_RDAWFMAC_BT) += \
+ 		wland_bta.o 
+
+KDIR  := /lib/modules/$(shell uname -r)/build
+PWD   := $(shell pwd)
+
+default:
+	make -C $(KDIR) M=$(PWD) modules
+clean:
+	rm -rf *.*
+
+
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/linux_osl.c b/drivers/net/wireless/rdaw80211/rdawlan/linux_osl.c
new file mode 100644
index 000000000000..25b525189c03
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/linux_osl.c
@@ -0,0 +1,222 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define LINUX_PORT
+
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <wland_utils.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+
+#define OS_HANDLE_MAGIC		    0x1234ABCD	/* Magic # to recognize osh */
+
+struct osl_info *osl_attach(void *pdev, uint bustype, bool pkttag)
+{
+	struct osl_info *osh;
+
+	if (!(osh = kmalloc(sizeof(struct osl_info), GFP_ATOMIC)))
+		return osh;
+
+	ASSERT(osh);
+
+	memset(osh, '\0', sizeof(struct osl_info));
+
+	osh->magic = OS_HANDLE_MAGIC;
+
+	atomic_set(&osh->malloced, 0);
+
+	osh->failed = 0;
+	osh->pdev = pdev;
+	osh->pub.pkttag = pkttag;
+	osh->bustype = bustype;
+	osh->pub.mmbus = false;
+
+	spin_lock_init(&(osh->pktalloc_lock));
+
+	return osh;
+}
+
+void osl_detach(struct osl_info *osh)
+{
+	if (osh == NULL)
+		return;
+
+	ASSERT(osh->magic == OS_HANDLE_MAGIC);
+	kfree(osh);
+}
+
+static struct sk_buff *osl_alloc_skb(unsigned int len)
+{
+	return __dev_alloc_skb(len, GFP_ATOMIC);
+}
+
+/* Return a new packet. zero out pkttag */
+void *osl_pktget(struct osl_info *osh, uint len)
+{
+	struct sk_buff *skb;
+	ulong flags;
+
+	if ((skb = osl_alloc_skb(len))) {
+		skb_put(skb, len);
+		skb->priority = 0;
+
+		spin_lock_irqsave(&osh->pktalloc_lock, flags);
+		osh->pub.pktalloced++;
+		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
+	}
+
+	return ((void *) skb);
+}
+
+/* Free the driver packet. Free the tag if present */
+void osl_pktfree(struct osl_info *osh, void *p, bool send)
+{
+	struct sk_buff *skb, *nskb;
+	ulong flags;
+
+	skb = (struct sk_buff *) p;
+
+	if (send && osh->pub.tx_fn)
+		osh->pub.tx_fn(osh->pub.tx_ctx, p, 0);
+
+	/*
+	 * perversion: we use skb->next to chain multi-skb packets
+	 */
+	while (skb) {
+		nskb = skb->next;
+		skb->next = NULL;
+
+		if (skb->destructor)
+			/*
+			 * cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists
+			 */
+			dev_kfree_skb_any(skb);
+		else
+			/*
+			 * can free immediately (even in_irq()) if destructor
+			 * * does not exist
+			 */
+			dev_kfree_skb(skb);
+
+		spin_lock_irqsave(&osh->pktalloc_lock, flags);
+		osh->pub.pktalloced--;
+		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
+		skb = nskb;
+	}
+}
+
+void *osl_malloc(struct osl_info *osh, uint size)
+{
+	void *addr;
+
+	/*
+	 * only ASSERT if osh is defined
+	 */
+	if (osh)
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+
+	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+		if (osh)
+			osh->failed++;
+		return (NULL);
+	}
+	if (osh)
+		atomic_add(size, &osh->malloced);
+
+	return (addr);
+}
+
+void osl_free(struct osl_info *osh, void *addr, uint size)
+{
+	if (osh) {
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+		atomic_sub(size, &osh->malloced);
+	}
+	kfree(addr);
+}
+
+uint osl_malloced(struct osl_info *osh)
+{
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (atomic_read(&osh->malloced));
+}
+
+#if defined(BCMASSERT_LOG)
+void osl_assert(const char *exp, const char *file, int line)
+{
+	char tempbuf[256];
+	const char *basename;
+
+	basename = strrchr(file, '/');
+	/*
+	 * skip the '/'
+	 */
+	if (basename)
+		basename++;
+
+	if (!basename)
+		basename = file;
+
+	snprintf(tempbuf, 64, "\"%s\": file \"%s\", line %d\n", exp, basename,
+		line);
+
+	printk("%s", tempbuf);
+}
+#endif
+
+void osl_delay(uint usec)
+{
+	uint d;
+
+	while (usec > 0) {
+		d = MIN(usec, 1000);
+		udelay(d);
+		usec -= d;
+	}
+}
+
+void *osl_open_image(const char *filename, int open_mode, int mode)
+{
+	struct file *fp = filp_open(filename, open_mode, mode);
+
+	if (IS_ERR(fp))
+		fp = NULL;
+
+	return fp;
+}
+
+int osl_get_image_block(char *buf, int len, void *image)
+{
+	struct file *fp = (struct file *) image;
+	int rdlen;
+
+	if (!image)
+		return 0;
+
+	rdlen = kernel_read(fp, fp->f_pos, buf, len);
+	if (rdlen > 0)
+		fp->f_pos += rdlen;
+
+	return rdlen;
+}
+
+void osl_close_image(void *image)
+{
+	if (image)
+		filp_close((struct file *) image, NULL);
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_android.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_android.c
new file mode 100644
index 000000000000..194f741f796e
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_android.c
@@ -0,0 +1,1164 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <linux/rtnetlink.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+#include <net/netlink.h>
+#include <net/ieee80211_radiotap.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+#include <wland_android.h>
+
+/*
+ * Android private command strings, PLEASE define new private commands here
+ * so they can be updated easily in the future (if needed)
+ */
+
+#define CMD_START		        "START"
+#define CMD_STOP		        "STOP"
+#define	CMD_SCAN_ACTIVE		    "SCAN-ACTIVE"
+#define	CMD_SCAN_PASSIVE	    "SCAN-PASSIVE"
+#define CMD_RSSI		        "RSSI"
+#define CMD_LINKSPEED		    "LINKSPEED"
+#define CMD_RXFILTER_START	    "RXFILTER-START"
+#define CMD_RXFILTER_STOP	    "RXFILTER-STOP"
+#define CMD_RXFILTER_ADD	    "RXFILTER-ADD"
+#define CMD_RXFILTER_REMOVE	    "RXFILTER-REMOVE"
+#define CMD_BTCOEXSCAN_START	"BTCOEXSCAN-START"
+#define CMD_BTCOEXSCAN_STOP	    "BTCOEXSCAN-STOP"
+#define CMD_BTCOEXMODE		    "BTCOEXMODE"
+#define CMD_SETSUSPENDOPT	    "SETSUSPENDOPT"
+#define CMD_SETSUSPENDMODE      "SETSUSPENDMODE"
+#define CMD_P2P_DEV_ADDR	    "P2P_DEV_ADDR"
+#define CMD_SETFWPATH		    "SETFWPATH"
+#define CMD_SETBAND		        "SETBAND"
+#define CMD_GETBAND		        "GETBAND"
+#define CMD_COUNTRY		        "COUNTRY"
+#define CMD_P2P_SET_NOA		    "P2P_SET_NOA"
+#if !defined WL_ENABLE_P2P_IF
+#define CMD_P2P_GET_NOA		    "P2P_GET_NOA"
+#endif
+#define CMD_P2P_SD_OFFLOAD		"P2P_SD_"
+#define CMD_P2P_SET_PS		    "P2P_SET_PS"
+#define CMD_SET_AP_WPS_P2P_IE 	"SET_AP_WPS_P2P_IE"
+#define CMD_SETROAMMODE 	    "SETROAMMODE"
+
+/* CCX Private Commands */
+#ifdef PNO_SUPPORT
+#define CMD_PNOSSIDCLR_SET	    "PNOSSIDCLR"
+#define CMD_PNOSETUP_SET	    "PNOSETUP "
+#define CMD_PNOENABLE_SET	    "PNOFORCE"
+#define CMD_PNODEBUG_SET	    "PNODEBUG"
+
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			'1'
+#define PNO_TLV_SUBVERSION 		'2'
+#define PNO_TLV_RESERVED		'0'
+#define PNO_TLV_TYPE_SSID_IE	'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define PNO_TLV_FREQ_REPEAT		'R'
+#define PNO_TLV_FREQ_EXPO_MAX	'M'
+
+struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+};
+#endif /* PNO_SUPPORT */
+
+#define CMD_OKC_SET_PMK		    "SET_PMK"
+#define CMD_OKC_ENABLE		    "OKC_ENABLE"
+
+struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+};
+
+/*
+ * Local (static) function definitions
+ */
+static int wl_android_get_link_speed(struct net_device *net, char *command,
+	int total_len)
+{
+	int bytes_written = 0;
+
+#if 0
+	int link_speed;
+	int error = wldev_get_link_speed(net, &link_speed);
+
+	if (error)
+		return -1;
+
+	/*
+	 * Convert Kbps to Android Mbps
+	 */
+	link_speed = link_speed / 1000;
+	bytes_written =
+		snprintf(command, total_len, "LinkSpeed %d", link_speed);
+#endif
+	WLAND_DBG(DEFAULT, TRACE, "command result is %s\n", command);
+	return bytes_written;
+}
+
+static int wl_android_get_rssi(struct net_device *net, char *command,
+	int total_len)
+{
+	int bytes_written = 0;
+
+#if 0
+	struct wlc_ssid ssid = { 0 };
+	int rssi, error;
+
+	error = wldev_get_rssi(net, &rssi);
+	if (error)
+		return -1;
+#if defined(WLAND_RSSIOFFSET_SUPPORT)
+	rssi = wl_update_rssi_offset(rssi);
+#endif
+
+	error = wldev_get_ssid(net, &ssid);
+	if (error)
+		return -1;
+	if ((ssid.SSID_len == 0) || (ssid.SSID_len > DOT11_MAX_SSID_LEN)) {
+		WLAND_ERR("wldev_get_ssid failed\n");
+	} else {
+		memcpy(command, ssid.SSID, ssid.SSID_len);
+		bytes_written = ssid.SSID_len;
+	}
+	bytes_written +=
+		snprintf(&command[bytes_written], total_len, " rssi %d", rssi);
+#endif
+	WLAND_DBG(DEFAULT, TRACE, "command result is %s (%d)\n", command,
+		bytes_written);
+	return bytes_written;
+}
+
+static int wl_android_set_suspendopt(struct net_device *dev, char *command,
+	int total_len)
+{
+	int ret = 0;
+
+#if 0
+	int suspend_flag, ret_now;
+
+	suspend_flag = *(command + strlen(CMD_SETSUSPENDOPT) + 1) - '0';
+
+	if (suspend_flag)
+		suspend_flag = 1;
+	ret_now = net_os_set_suspend_disable(dev, suspend_flag);
+
+	if (ret_now != suspend_flag) {
+		if (!(ret = net_os_set_suspend(dev, ret_now, 1)))
+			WLAND_DBG(DEFAULT, TRACE, "Suspend Flag %d -> %d\n",
+				ret_now, suspend_flag);
+		else
+			WLAND_DBG(DEFAULT, TRACE, "failed %d\n", ret);
+	}
+#endif
+	WLAND_DBG(DEFAULT, TRACE, "command result is %s (%d)\n", command,
+		total_len);
+
+	return ret;
+}
+
+static int wl_android_set_suspendmode(struct net_device *dev, char *command,
+	int total_len)
+{
+	int ret = 0;
+
+#if 0
+#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(DHD_USE_EARLYSUSPEND)
+	int suspend_flag = *(command + strlen(CMD_SETSUSPENDMODE) + 1) - '0';
+
+	if (suspend_flag)
+		suspend_flag = 1;
+
+	if (!(ret = net_os_set_suspend(dev, suspend_flag, 0)))
+		WLAND_DBG(DEFAULT, TRACE, "Suspend Mode %d\n", suspend_flag);
+	else
+		WLAND_DBG(DEFAULT, TRACE, "failed %d\n", ret);
+#endif
+#endif
+	WLAND_DBG(DEFAULT, TRACE, "command result is %s (%d)\n", command,
+		total_len);
+
+	return ret;
+}
+
+static int wl_android_get_band(struct net_device *dev, char *command,
+	int total_len)
+{
+	int bytes_written = 0;
+
+#if 0
+	uint band;
+	int error = wldev_get_band(dev, &band);
+
+	if (error)
+		return -1;
+	bytes_written = snprintf(command, total_len, "Band %d", band);
+#endif
+	return bytes_written;
+}
+
+#if defined(PNO_SUPPORT)
+static int wl_android_set_pno_setup(struct net_device *dev, char *command,
+	int total_len)
+{
+	struct wlc_ssid ssids_local[MAX_PFN_LIST_COUNT];
+	int res = -1;
+	int nssid = 0;
+	struct cmd_tlv *cmd_tlv_temp;
+	char *str_ptr;
+	int tlv_size_left;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "command=%s, len=%d\n", command, total_len);
+
+	if (total_len < (strlen(CMD_PNOSETUP_SET) + sizeof(struct cmd_tlv))) {
+		WLAND_ERR("argument=%d less min size\n", total_len);
+		goto exit_proc;
+	}
+
+	str_ptr = command + strlen(CMD_PNOSETUP_SET);
+
+	tlv_size_left = total_len - strlen(CMD_PNOSETUP_SET);
+	cmd_tlv_temp = (struct cmd_tlv *) str_ptr;
+
+	memset(ssids_local, 0, sizeof(ssids_local));
+
+	if ((cmd_tlv_temp->prefix == PNO_TLV_PREFIX) &&
+		(cmd_tlv_temp->version == PNO_TLV_VERSION) &&
+		(cmd_tlv_temp->subver == PNO_TLV_SUBVERSION)) {
+		str_ptr += sizeof(struct cmd_tlv);
+		tlv_size_left -= sizeof(struct cmd_tlv);
+
+		if ((nssid = wl_iw_parse_ssid_list_tlv(&str_ptr, ssids_local,
+					MAX_PFN_LIST_COUNT,
+					&tlv_size_left)) <= 0) {
+			WLAND_ERR("SSID is not presented or corrupted ret=%d\n",
+				nssid);
+			goto exit_proc;
+		} else {
+			if ((str_ptr[0] != PNO_TLV_TYPE_TIME)
+				|| (tlv_size_left <= 1)) {
+				WLAND_ERR
+					("scan duration corrupted field size %d\n",
+					tlv_size_left);
+				goto exit_proc;
+			}
+			str_ptr++;
+			pno_time = simple_strtoul(str_ptr, &str_ptr, 16);
+
+			WLAND_DBG(DEFAULT, TRACE, "pno_time=%d\n", pno_time);
+
+			if (str_ptr[0] != 0) {
+				if ((str_ptr[0] != PNO_TLV_FREQ_REPEAT)) {
+					WLAND_ERR
+						("pno repeat : corrupted field\n");
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_repeat =
+					simple_strtoul(str_ptr, &str_ptr, 16);
+				WLAND_DBG(DEFAULT, TRACE,
+					"%s :got pno_repeat=%d\n", pno_repeat);
+				if (str_ptr[0] != PNO_TLV_FREQ_EXPO_MAX) {
+					WLAND_ERR
+						("FREQ_EXPO_MAX corrupted field size\n");
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_freq_expo_max =
+					simple_strtoul(str_ptr, &str_ptr, 16);
+				WLAND_DBG(DEFAULT, TRACE,
+					"%s: pno_freq_expo_max=%d\n",
+					pno_freq_expo_max);
+			}
+		}
+	} else {
+		WLAND_ERR("get wrong TLV command\n");
+		goto exit_proc;
+	}
+
+	res = dhd_dev_pno_set(dev, ssids_local, nssid, pno_time, pno_repeat,
+		pno_freq_expo_max);
+
+exit_proc:
+	return res;
+}
+#endif /* PNO_SUPPORT */
+
+static int wl_android_get_p2p_dev_addr(struct net_device *ndev, char *command,
+	int total_len)
+{
+	int bytes_written = 0;
+
+#if 0
+	int ret = wl_cfg80211_get_p2p_dev_addr(ndev,
+		(struct ether_addr *) command);
+
+	if (ret)
+		return 0;
+	bytes_written = sizeof(struct ether_addr);
+#endif
+	return bytes_written;
+}
+
+static int wl_android_set_pmk(struct net_device *dev, char *command,
+	int total_len)
+{
+#if 0
+	u8 pmk[33];
+	char smbuf[WLC_IOCTL_SMLEN];
+
+	memset(pmk, '\0', sizeof(pmk));
+	memcpy(pmk, command + strlen("SET_PMK "), 32);
+
+	return wldev_iovar_setbuf(dev, "okc_info_pmk", pmk, 32, smbuf,
+		sizeof(smbuf), NULL);
+#endif
+	return 0;
+}
+
+static int wl_android_okc_enable(struct net_device *dev, char *command,
+	int total_len)
+{
+#if 0
+	char okc_enable = command[strlen(CMD_OKC_ENABLE) + 1] - '0';
+
+	WLAND_DBG(DEFAULT, TRACE, "Failed to %s OKC.\n",
+		okc_enable ? "enable" : "disable");
+
+	return wldev_iovar_setint(dev, "okc_enable", okc_enable);
+#endif
+	return 0;
+}
+
+int wl_android_set_roam_mode(struct net_device *dev, char *command,
+	int total_len)
+{
+#if 0
+	int mode = 0;
+
+	if (sscanf(command, "%*s %d", &mode) != 1) {
+		WLAND_ERR("Failed to get Parameter\n", __FUNCTION__);
+		return -1;
+	}
+
+	return wldev_iovar_setint(dev, "roam_off", mode);
+#endif
+	return 0;
+}
+
+int wland_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+#define PRIVATE_COMMAND_MAX_LEN	8192
+	int ret = 0, bytes_written = 0;
+	char *command = NULL;
+	struct android_wifi_priv_cmd priv_cmd;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+#if 0
+	net_os_wake_lock(net);
+#endif
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (copy_from_user(&priv_cmd, ifr->ifr_data,
+			sizeof(struct android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	if (priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) {
+		WLAND_ERR("too long priavte command\n");
+		ret = -EINVAL;
+	}
+	command = memdup_user(priv_cmd.buf, priv_cmd.total_len);
+	if (IS_ERR(command)) {
+		WLAND_ERR("failed to allocate or write memory\n");
+		ret= PTR_ERR(command);
+		goto exit;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "Android private cmd \"%s\" on %s\n", command,
+		ifr->ifr_name);
+
+	if (strnicmp(command, CMD_START, strlen(CMD_START)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular Start command\n");
+#if 0
+		bytes_written = wl_android_wifi_on(net);
+#endif
+	} else if (strnicmp(command, CMD_SETFWPATH, strlen(CMD_SETFWPATH)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular Set_fwpath command\n");
+	} else if (strnicmp(command, CMD_STOP, strlen(CMD_STOP)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular Stop command\n");
+#if 0
+		bytes_written = wl_android_wifi_off(net);
+#endif
+	} else if (strnicmp(command, CMD_SCAN_ACTIVE,
+			strlen(CMD_SCAN_ACTIVE)) == 0) {
+		/*
+		 * TBD: SCAN-ACTIVE
+		 */
+		 WLAND_DBG(DEFAULT, INFO, "Received regular SCAN_ACTIVE command\n");
+	} else if (strnicmp(command, CMD_SCAN_PASSIVE,
+			strlen(CMD_SCAN_PASSIVE)) == 0) {
+		/*
+		 * TBD: SCAN-PASSIVE
+		 */
+		  WLAND_DBG(DEFAULT, INFO, "Received regular SCAN_PASSIVE command\n");
+	} else if (strnicmp(command, CMD_RSSI, strlen(CMD_RSSI)) == 0) {
+		bytes_written =
+			wl_android_get_rssi(net, command, priv_cmd.total_len);
+		WLAND_DBG(DEFAULT, INFO, "Received regular RSSI command\n");
+	} else if (strnicmp(command, CMD_LINKSPEED, strlen(CMD_LINKSPEED)) == 0) {
+		bytes_written =
+			wl_android_get_link_speed(net, command,
+			priv_cmd.total_len);
+		WLAND_DBG(DEFAULT, INFO, "Received regular LINKSPEED command\n");
+	}
+#ifdef PKT_FILTER_SUPPORT
+	else if (strnicmp(command, CMD_RXFILTER_START,
+			strlen(CMD_RXFILTER_START)) == 0) {
+		bytes_written = net_os_enable_packet_filter(net, 1);
+	} else if (strnicmp(command, CMD_RXFILTER_STOP,
+			strlen(CMD_RXFILTER_STOP)) == 0) {
+		bytes_written = net_os_enable_packet_filter(net, 0);
+	} else if (strnicmp(command, CMD_RXFILTER_ADD,
+			strlen(CMD_RXFILTER_ADD)) == 0) {
+		int filter_num =
+			*(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
+		bytes_written =
+			net_os_rxfilter_add_remove(net, true, filter_num);
+	} else if (strnicmp(command, CMD_RXFILTER_REMOVE,
+			strlen(CMD_RXFILTER_REMOVE)) == 0) {
+		int filter_num =
+			*(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
+		bytes_written =
+			net_os_rxfilter_add_remove(net, FALSE, filter_num);
+	}
+#endif /* PKT_FILTER_SUPPORT */
+	else if (strnicmp(command, CMD_BTCOEXSCAN_START,
+			strlen(CMD_BTCOEXSCAN_START)) == 0) {
+		/*
+		 * TBD: BTCOEXSCAN-START
+		 */
+		 WLAND_DBG(DEFAULT, INFO, "Received regular BTCOEXSCAN_START command\n");
+	} else if (strnicmp(command, CMD_BTCOEXSCAN_STOP,
+			strlen(CMD_BTCOEXSCAN_STOP)) == 0) {
+		/*
+		 * TBD: BTCOEXSCAN-STOP
+		 */
+		  WLAND_DBG(DEFAULT, INFO, "Received regular BTCOEXSCAN_STOP command\n");
+	} else if (strnicmp(command, CMD_BTCOEXMODE,
+			strlen(CMD_BTCOEXMODE)) == 0) {
+			WLAND_DBG(DEFAULT, INFO, "Received regular BTCOEXMODE command\n");
+#ifdef WLAND_CFG80211_SUPPORT
+#if 0
+		bytes_written = wl_cfg80211_set_btcoex_dhcp(net, command);
+#endif
+#else
+#ifdef PKT_FILTER_SUPPORT
+		uint mode = *(command + strlen(CMD_BTCOEXMODE) + 1) - '0';
+
+		if (mode == 1)
+			net_os_enable_packet_filter(net, 0);	/* DHCP starts */
+		else
+			net_os_enable_packet_filter(net, 1);	/* DHCP ends */
+#endif /* PKT_FILTER_SUPPORT */
+#endif /* WLAND_CFG80211_SUPPORT */
+	} else if (strnicmp(command, CMD_SETSUSPENDOPT,
+			strlen(CMD_SETSUSPENDOPT)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular SETSUSPENDOPT command\n");
+		bytes_written =
+			wl_android_set_suspendopt(net, command,
+			priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_SETSUSPENDMODE,
+			strlen(CMD_SETSUSPENDMODE)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular SETSUSPENDMODE command\n");
+		bytes_written =
+			wl_android_set_suspendmode(net, command,
+			priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_SETBAND, strlen(CMD_SETBAND)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular SETBAND command\n");
+#if 0
+		uint band = *(command + strlen(CMD_SETBAND) + 1) - '0';
+
+		bytes_written = wldev_set_band(net, band);
+#endif
+	} else if (strnicmp(command, CMD_GETBAND, strlen(CMD_GETBAND)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular GETBAND command\n");
+		bytes_written =
+			wl_android_get_band(net, command, priv_cmd.total_len);
+	}
+#ifdef WLAND_CFG80211_SUPPORT
+	/*
+	 * CUSTOMER_SET_COUNTRY feature is define for only GGSM model
+	 */
+	else if (strnicmp(command, CMD_COUNTRY, strlen(CMD_COUNTRY)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular COUNTRY command\n");
+#if 0
+		char *country_code = command + strlen(CMD_COUNTRY) + 1;
+
+		bytes_written = wldev_set_country(net, country_code);
+#endif
+	}
+#endif /* WLAND_CFG80211_SUPPORT */
+#if defined(PNO_SUPPORT)
+	else if (strnicmp(command, CMD_PNOSSIDCLR_SET,
+			strlen(CMD_PNOSSIDCLR_SET)) == 0) {
+		bytes_written = dhd_dev_pno_reset(net);
+	} else if (strnicmp(command, CMD_PNOSETUP_SET,
+			strlen(CMD_PNOSETUP_SET)) == 0) {
+		bytes_written =
+			wl_android_set_pno_setup(net, command,
+			priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_PNOENABLE_SET,
+			strlen(CMD_PNOENABLE_SET)) == 0) {
+		uint pfn_enabled =
+			*(command + strlen(CMD_PNOENABLE_SET) + 1) - '0';
+		bytes_written = dhd_dev_pno_enable(net, pfn_enabled);
+	}
+#endif /* PNO_SUPPORT */
+	else if (strnicmp(command, CMD_P2P_DEV_ADDR,
+			strlen(CMD_P2P_DEV_ADDR)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular P2P_DEV_ADDR command\n");
+		bytes_written =
+			wl_android_get_p2p_dev_addr(net, command,
+			priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_P2P_SET_NOA,
+			strlen(CMD_P2P_SET_NOA)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular P2P_SET_NOA command\n");
+#if 0
+		int skip = strlen(CMD_P2P_SET_NOA) + 1;
+
+		bytes_written =
+			wl_cfg80211_set_p2p_noa(net, command + skip,
+			priv_cmd.total_len - skip);
+#endif
+	} else if (strnicmp(command, CMD_P2P_GET_NOA,
+			strlen(CMD_P2P_GET_NOA)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular P2P_GET_NOA command\n");
+#if 0
+		bytes_written =
+			wl_cfg80211_get_p2p_noa(net, command,
+			priv_cmd.total_len);
+#endif
+	} else if (strnicmp(command, CMD_P2P_SET_PS,
+			strlen(CMD_P2P_SET_PS)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular P2P_SET_PS command\n");
+#if 0
+		int skip = strlen(CMD_P2P_SET_PS) + 1;
+
+		bytes_written =
+			wl_cfg80211_set_p2p_ps(net, command + skip,
+			priv_cmd.total_len - skip);
+#endif
+	}
+#ifdef WLAND_CFG80211_SUPPORT
+	else if (strnicmp(command, CMD_SET_AP_WPS_P2P_IE,
+			strlen(CMD_SET_AP_WPS_P2P_IE)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular SET_AP_WPS_P2P_IE command\n");
+#if 0
+		int skip = strlen(CMD_SET_AP_WPS_P2P_IE) + 3;
+
+		bytes_written =
+			wl_cfg80211_set_wps_p2p_ie(net, command + skip,
+			priv_cmd.total_len - skip, *(command + skip - 2) - '0');
+#endif
+	}
+#endif /* WLAND_CFG80211_SUPPORT */
+	else if (strnicmp(command, CMD_OKC_SET_PMK,
+			strlen(CMD_OKC_SET_PMK)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular OKC_SET_PMK command\n");
+		bytes_written =
+			wl_android_set_pmk(net, command, priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_OKC_ENABLE,
+			strlen(CMD_OKC_ENABLE)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular OKC_ENABLE command\n");
+		bytes_written =
+			wl_android_okc_enable(net, command, priv_cmd.total_len);
+	} else if (strnicmp(command, CMD_SETROAMMODE,
+			strlen(CMD_SETROAMMODE)) == 0) {
+		WLAND_DBG(DEFAULT, INFO, "Received regular SETROAMMODE command\n");
+		bytes_written =
+			wl_android_set_roam_mode(net, command,
+			priv_cmd.total_len);
+	} else {
+		WLAND_DBG(DEFAULT, DEBUG,
+			"Unknown PRIVATE command %s - ignored\n", command);
+		snprintf(command, 3, "OK");
+		bytes_written = strlen("OK");
+	}
+
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0))
+			command[0] = '\0';
+		if (bytes_written >= priv_cmd.total_len) {
+			WLAND_ERR("bytes_written = %d\n", bytes_written);
+			bytes_written = priv_cmd.total_len;
+		} else {
+			bytes_written++;
+		}
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+			WLAND_ERR("failed to copy data to user buffer\n");
+			ret = -EFAULT;
+		}
+	} else {
+		ret = bytes_written;
+	}
+
+exit:
+#if 0
+	net_os_wake_unlock(net);
+#endif
+	WLAND_DBG(DEFAULT, TRACE, "Done(\"%s\",on:%s,ret:%d)\n", command,
+		ifr->ifr_name, ret);
+
+	if (command)
+		kfree(command);
+
+	return ret;
+}
+
+#ifdef WLAND_RSSIAVG_SUPPORT
+void wl_free_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl)
+{
+	struct wland_rssi_cache *node, *cur, **rssi_head;
+	int i = 0;
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	node = *rssi_head;
+
+	while (node) {
+		WLAND_DBG(DEFAULT, TRACE, "Free %d with BSSID %pM\n", i,
+			node->BSSID);
+		cur = node;
+		node = cur->next;
+		kfree(cur);
+		i++;
+	}
+	*rssi_head = NULL;
+}
+
+void wl_delete_dirty_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl)
+{
+	struct wland_rssi_cache *node, *prev, **rssi_head;
+	int i = -1, tmp = 0;
+	int max = RSSICACHE_LEN;
+
+	max = min(max, RSSICACHE_LEN);
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	node = *rssi_head;
+	prev = node;
+
+	for (; node;) {
+		i++;
+		if (node->dirty > max) {
+			if (node == *rssi_head) {
+				tmp = 1;
+				*rssi_head = node->next;
+			} else {
+				tmp = 0;
+				prev->next = node->next;
+			}
+			WLAND_DBG(DEFAULT, TRACE, "Del %d with BSSID %pM\n", i,
+				node->BSSID);
+			kfree(node);
+			if (tmp == 1) {
+				node = *rssi_head;
+				prev = node;
+			} else {
+				node = prev->next;
+			}
+			continue;
+		}
+		prev = node;
+		node = node->next;
+	}
+}
+
+void wl_delete_disconnected_rssi_cache(struct wland_rssi_cache_ctrl
+	*rssi_cache_ctrl, u8 * bssid)
+{
+	struct wland_rssi_cache *node, *prev, **rssi_head;
+	int i = -1, tmp = 0;
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	node = *rssi_head;
+	prev = node;
+
+	for (; node;) {
+		i++;
+		if (!memcmp(node->BSSID, bssid, ETH_ALEN)) {
+			if (node == *rssi_head) {
+				tmp = 1;
+				*rssi_head = node->next;
+			} else {
+				tmp = 0;
+				prev->next = node->next;
+			}
+			WLAND_DBG(DEFAULT, TRACE, "Del %d with BSSID %pM\n", i,
+				node->BSSID);
+			kfree(node);
+			if (tmp == 1) {
+				node = *rssi_head;
+				prev = node;
+			} else {
+				node = prev->next;
+			}
+			continue;
+		}
+		prev = node;
+		node = node->next;
+	}
+}
+
+void wl_reset_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl)
+{
+	struct wland_rssi_cache *node, **rssi_head;
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	/*
+	 * reset dirty
+	 */
+	node = *rssi_head;
+	for (; node;) {
+		node->dirty += 1;
+		node = node->next;
+	}
+}
+
+int wl_update_connected_rssi_cache(struct net_device *ndev,
+	struct wland_rssi_cache_ctrl *rssi_cache_ctrl, s16 * rssi_avg)
+{
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_rssi_cache *node, *prev, *leaf, **rssi_head;
+	int j, k = 0, error = 0;
+	s16 rssi = 0;
+	u8 *bssid = profile->bssid;
+
+	if (!profile->valid_bssid) {
+		WLAND_ERR("Invalid BSSID:%pM\n", bssid);
+		return -1;
+	}
+	//get rssi default value rssi = wl_get_avg_rssi(rssi_cache_ctrl, bssid);
+
+	error = wland_dev_get_rssi(ndev, &rssi);
+	if (error) {
+		WLAND_ERR("Could not get rssi (%d)\n", error);
+		return error;
+	}
+	/*
+	 * update RSSI
+	 */
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	node = *rssi_head;
+	prev = NULL;
+
+	for (; node;) {
+		if (!memcmp(node->BSSID, bssid, ETH_ALEN)) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"Update %d with BSSID %pM, RSSI=%d\n", k, bssid,
+				rssi);
+			for (j = 0; j < RSSIAVG_LEN - 1; j++)
+				node->RSSI[j] = node->RSSI[j + 1];
+			node->RSSI[j] = rssi;
+			node->dirty = 0;
+			goto exit;
+		}
+		prev = node;
+		node = node->next;
+		k++;
+	}
+
+	leaf = kmalloc(sizeof(struct wland_rssi_cache), GFP_KERNEL);
+	if (!leaf) {
+		WLAND_ERR("Memory alloc failure %d\n",
+			sizeof(struct wland_rssi_cache));
+		return 0;
+	}
+	WLAND_DBG(DEFAULT, TRACE,
+		"Add %d with cached BSSID %pM, RSSI=%d in the leaf\n", k,
+		&bssid, rssi);
+
+	leaf->next = NULL;
+	leaf->dirty = 0;
+
+	memcpy(leaf->BSSID, bssid, ETH_ALEN);
+
+	for (j = 0; j < RSSIAVG_LEN; j++)
+		leaf->RSSI[j] = rssi;
+
+	if (!prev)
+		*rssi_head = leaf;
+	else
+		prev->next = leaf;
+
+exit:
+	*rssi_avg = wl_get_avg_rssi(rssi_cache_ctrl, bssid);
+
+	return error;
+}
+
+void wl_update_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl,
+	struct wland_bss_info_le *bss)
+{
+	struct wland_rssi_cache *node, *prev, *leaf, **rssi_head;
+	struct wland_bss_info_le *bi = NULL;
+	int j, k;
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+
+	/*
+	 * update RSSI
+	 */
+
+	bi = bss;
+	node = *rssi_head;
+	prev = NULL;
+	k = 0;
+	for (; node;) {
+		if (!memcmp(node->BSSID, bi->BSSID, ETH_ALEN)) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"Update %d with BSSID %pM, RSSI=%d, SSID \"%s\"\n",
+				k, bi->BSSID, bi->RSSI, bi->SSID);
+			for (j = 0; j < RSSIAVG_LEN - 1; j++)
+				node->RSSI[j] = node->RSSI[j + 1];
+			node->RSSI[j] = bi->RSSI;
+			node->dirty = 0;
+			break;
+		}
+		prev = node;
+
+		node = node->next;
+		k++;
+	}
+
+	if (node)
+		return;
+
+	leaf = kmalloc(sizeof(struct wland_rssi_cache), GFP_KERNEL);
+	if (!leaf) {
+		WLAND_ERR("Memory alloc failure %d\n",
+			sizeof(struct wland_rssi_cache));
+		return;
+	}
+	WLAND_DBG(DEFAULT, TRACE,
+		"Add %d with cached BSSID %pM, RSSI=%d, SSID \"%s\" in the leaf\n",
+		k, &bi->BSSID, bi->RSSI, bi->SSID);
+
+	leaf->next = NULL;
+	leaf->dirty = 0;
+
+	memcpy(leaf->BSSID, bi->BSSID, ETH_ALEN);
+
+	for (j = 0; j < RSSIAVG_LEN; j++)
+		leaf->RSSI[j] = bi->RSSI;
+
+	if (!prev)
+		*rssi_head = leaf;
+	else
+		prev->next = leaf;
+
+}
+
+s16 wl_get_avg_rssi(struct wland_rssi_cache_ctrl *rssi_cache_ctrl, void *addr)
+{
+	struct wland_rssi_cache *node, **rssi_head;
+	int j, rssi_sum;
+	s16 rssi = RSSI_MINVAL;
+
+	rssi_head = &rssi_cache_ctrl->m_cache_head;
+	/*
+	 * reset dirty
+	 */
+	node = *rssi_head;
+	for (; node;) {
+		if (!memcmp(node->BSSID, addr, ETH_ALEN)) {
+			rssi_sum = 0;
+			rssi = 0;
+			for (j = 0; j < RSSIAVG_LEN; j++)
+				rssi_sum += node->RSSI[RSSIAVG_LEN - j - 1];
+			rssi = rssi_sum / j;
+			break;
+		}
+		node = node->next;
+	}
+	rssi = MIN(rssi, RSSI_MAXVAL);
+
+	if (rssi == RSSI_MINVAL) {
+		WLAND_ERR("BSSID %pM does not in RSSI cache\n", addr);
+	}
+
+	return rssi;
+}
+#endif /* WLAND_RSSIAVG_SUPPORT */
+
+
+#ifdef WLAND_BSSCACHE_SUPPORT
+void wl_free_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl)
+{
+	struct wland_bss_cache *node, *cur, **bss_head;
+	int i = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	bss_head = &bss_cache_ctrl->m_cache_head;
+	node = *bss_head;
+
+	for (; node;) {
+		WLAND_DBG(DEFAULT, TRACE, "Free %d with BSSID %pM\n", i,
+			node->bss.BSSID);
+		cur = node;
+		node = cur->next;
+		if(cur->bss.ie)
+			kfree(cur->bss.ie);
+		kfree(cur);
+		i++;
+	}
+	*bss_head = NULL;
+}
+
+void wl_delete_dirty_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl)
+{
+	struct wland_bss_cache *node, *prev, **bss_head;
+	int i = -1, tmp = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+	bss_head = &bss_cache_ctrl->m_cache_head;
+	node = *bss_head;
+	prev = node;
+
+	for (; node;) {
+		i++;
+		if (node->dirty > BSSCACHE_LEN) {
+			if (node == *bss_head) {
+				tmp = 1;
+				*bss_head = node->next;
+			} else {
+				tmp = 0;
+				prev->next = node->next;
+			}
+			WLAND_DBG(DEFAULT, TRACE,
+				"Del %d with BSSID %pM, RSSI=%d, SSID \"%s\"\n",
+				i, node->bss.BSSID,
+				node->bss.RSSI,
+				node->bss.SSID);
+			if(node->bss.ie)
+				kfree(node->bss.ie);
+			kfree(node);
+			if (tmp == 1) {
+				node = *bss_head;
+				prev = node;
+			} else {
+				node = prev->next;
+			}
+			continue;
+		}
+		prev = node;
+		node = node->next;
+	}
+}
+
+void wl_delete_disconnected_bss_cache(struct wland_bss_cache_ctrl
+	*bss_cache_ctrl, u8 * bssid)
+{
+	struct wland_bss_cache *node, *prev, **bss_head;
+	int i = -1, tmp = 0;
+
+	bss_head = &bss_cache_ctrl->m_cache_head;
+	node = *bss_head;
+	prev = node;
+
+	for (; node;) {
+		i++;
+
+		if (!memcmp(node->bss.BSSID, bssid, ETH_ALEN)) {
+			if (node == *bss_head) {
+				tmp = 1;
+				*bss_head = node->next;
+			} else {
+				tmp = 0;
+				prev->next = node->next;
+			}
+			WLAND_DBG(DEFAULT, TRACE,
+				"Del %d with BSSID %pM, RSSI=%d, SSID \"%s\"\n",
+				i, node->bss.BSSID,
+				node->bss.RSSI,
+				node->bss.SSID);
+			kfree(node);
+			if (tmp == 1) {
+				node = *bss_head;
+				prev = node;
+			} else {
+				node = prev->next;
+			}
+			continue;
+		}
+		prev = node;
+		node = node->next;
+	}
+}
+
+void wl_reset_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl)
+{
+	struct wland_bss_cache *node, **bss_head;
+
+	bss_head = &bss_cache_ctrl->m_cache_head;
+	/*
+	 * reset dirty
+	 */
+	node = *bss_head;
+	for (; node;) {
+		node->dirty += 1;
+		node = node->next;
+	}
+}
+
+void wl_update_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl,
+	struct list_head *scan_result_list)
+{
+	struct wland_bss_cache *node, *prev, *leaf, **bss_head;
+	struct wland_bss_info_le *bi = NULL;
+	struct wland_cfg80211_info *cfg =
+		container_of(scan_result_list, struct wland_cfg80211_info, scan_result_list);
+	int k = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (list_empty(scan_result_list)) {
+		WLAND_ERR("ss_list->count ==0 \n");
+		return;
+	}
+
+	bss_head = &bss_cache_ctrl->m_cache_head;
+
+	list_for_each_entry(bi, scan_result_list, list) {
+		node = *bss_head;
+		prev = NULL;
+
+		for (; node;) {
+			if (!memcmp(node->bss.BSSID, bi->BSSID,
+					ETH_ALEN)) {
+				leaf = node;
+				if(leaf->bss.ie)
+					kfree(leaf->bss.ie);
+				memset(&leaf->bss, 0,
+					sizeof(struct wland_bss_info_le));
+				memcpy(&leaf->bss, bi,
+					sizeof(struct wland_bss_info_le));
+                                leaf->bss.ie = kmemdup(bi->ie, bi->ie_length,GFP_KERNEL);
+				if (!leaf->bss.ie) {
+					WLAND_ERR("Memory alloc failure %d\n", bi->ie_length);
+					return;
+				}
+				leaf->next = node->next;
+				leaf->dirty = 0;
+				leaf->version = cfg->scan_results.version;
+
+				WLAND_DBG(DEFAULT, TRACE,
+					"Update %d with BSSID %pM, RSSI=%d, SSID \"%s\", length=%d\n",
+					k, bi->BSSID, bi->RSSI, bi->SSID,
+					bi->length);
+				if (!prev)
+					*bss_head = leaf;
+				else
+					prev->next = leaf;
+				node = leaf;
+				prev = node;
+
+				k++;
+				break;
+			}
+			prev = node;
+			node = node->next;
+		}
+
+		if (node)
+			continue;
+
+		leaf = kmalloc(sizeof(struct wland_bss_cache), GFP_KERNEL);
+		if (!leaf) {
+			WLAND_ERR("Memory alloc failure %d\n", sizeof(struct wland_bss_cache));
+			return;
+		}
+
+		WLAND_DBG(DEFAULT, TRACE,
+			"Add %d with cached BSSID %pM, RSSI=%d, SSID \"%s\" in the leaf\n",
+			k, &bi->BSSID, bi->RSSI, bi->SSID);
+
+		memcpy(&leaf->bss, bi, sizeof(struct wland_bss_info_le));
+		leaf->bss.ie = kmalloc(bi->ie_length, GFP_KERNEL);
+		if (!(leaf->bss.ie)) {
+			WLAND_ERR("Memory alloc failure %d\n", bi->ie_length);
+			kfree(leaf);
+			return;
+		}
+		memcpy(leaf->bss.ie, bi->ie, bi->ie_length);
+
+		leaf->next = NULL;
+		leaf->dirty = 0;
+		leaf->version = cfg->scan_results.version;
+		k++;
+
+		if (!prev)
+			*bss_head = leaf;
+		else
+			prev->next = leaf;
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+}
+
+void wl_release_bss_cache_ctrl(struct wland_bss_cache_ctrl *bss_cache_ctrl)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	wl_free_bss_cache(bss_cache_ctrl);
+}
+
+#endif /* WLAND_BSSCACHE_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_android.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_android.h
new file mode 100644
index 000000000000..4322e6ee09bc
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_android.h
@@ -0,0 +1,76 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_ANDROID_H_
+#define _WLAND_ANDROID_H_
+
+#define RSSI_MAXVAL                 -2
+#define RSSI_MINVAL                 -200
+#define REPEATED_SCAN_RESULT_CNT	4
+
+#ifdef WLAND_RSSIAVG_SUPPORT
+#define RSSIAVG_LEN                 (4*REPEATED_SCAN_RESULT_CNT)
+#define RSSICACHE_LEN               (4*REPEATED_SCAN_RESULT_CNT)
+
+struct wland_rssi_cache {
+	struct wland_rssi_cache *next;
+	int dirty;
+	u8 BSSID[ETH_ALEN];
+	s16 RSSI[RSSIAVG_LEN];
+};
+
+struct wland_rssi_cache_ctrl {
+	struct wland_rssi_cache *m_cache_head;
+};
+
+void wl_free_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl);
+void wl_delete_dirty_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl);
+void wl_delete_disconnected_rssi_cache(struct wland_rssi_cache_ctrl
+	*rssi_cache_ctrl, u8 * bssid);
+void wl_reset_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl);
+void wl_update_rssi_cache(struct wland_rssi_cache_ctrl *rssi_cache_ctrl,
+	struct wland_bss_info_le *bss);
+int wl_update_connected_rssi_cache(struct net_device *net,
+	struct wland_rssi_cache_ctrl *rssi_cache_ctrl, s16 * rssi_avg);
+s16 wl_get_avg_rssi(struct wland_rssi_cache_ctrl *rssi_cache_ctrl, void *addr);
+#endif /* WLAND_RSSIAVG_SUPPORT */
+
+
+#ifdef WLAND_BSSCACHE_SUPPORT
+#define BSSCACHE_LEN	            (REPEATED_SCAN_RESULT_CNT)
+
+struct wland_bss_cache {
+	struct wland_bss_cache *next;
+	int dirty;
+	u32 version;
+	struct wland_bss_info_le bss;
+};
+struct wland_bss_cache_ctrl {
+	struct wland_bss_cache *m_cache_head;
+};
+
+void wl_free_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl);
+void wl_delete_dirty_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl);
+void wl_delete_disconnected_bss_cache(struct wland_bss_cache_ctrl
+	*bss_cache_ctrl, u8 * bssid);
+void wl_reset_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl);
+void wl_update_bss_cache(struct wland_bss_cache_ctrl *bss_cache_ctrl,
+	struct list_head *scan_results_list);
+void wl_release_bss_cache_ctrl(struct wland_bss_cache_ctrl *bss_cache_ctrl);
+#endif /* WLAND_BSSCACHE_SUPPORT */
+
+int wland_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+#endif /* _WLAND_ANDROID_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.c
new file mode 100644
index 000000000000..fd26dc1b336d
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.c
@@ -0,0 +1,363 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifdef WLAND_BT_3_0_SUPPORT
+#include <wland_bta.h>
+
+#ifdef SEND_HCI_CMD_VIA_IOCTL
+#define BTA_HCI_CMD_MAX_LEN     HCI_CMD_PREAMBLE_SIZE + HCI_CMD_DATA_SIZE
+
+/* Send HCI cmd via wl iovar HCI_cmd to the dongle. */
+int dhd_bta_docmd(wland_private * pub, void *cmd_buf, uint cmd_len)
+{
+	amp_hci_cmd_t *cmd = (amp_hci_cmd_t *) cmd_buf;
+	u8 buf[BTA_HCI_CMD_MAX_LEN + 16];
+	uint len = sizeof(buf);
+	struct wl_ioctl ioc;
+
+	if (cmd_len < HCI_CMD_PREAMBLE_SIZE)
+		return BCME_BADLEN;
+
+	if ((uint) cmd->plen + HCI_CMD_PREAMBLE_SIZE > cmd_len)
+		return BCME_BADLEN;
+
+	len = bcm_mkiovar("HCI_cmd", (char *) cmd,
+		(uint) cmd->plen + HCI_CMD_PREAMBLE_SIZE, (char *) buf, len);
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	ioc.cmd = WLC_SET_VAR;
+	ioc.buf = buf;
+	ioc.len = len;
+	ioc.set = true;
+
+	return dhd_wl_ioctl(pub, &ioc, ioc.buf, ioc.len);
+}
+#else /* !SEND_HCI_CMD_VIA_IOCTL */
+
+static void dhd_bta_flush_hcidata(wland_private * pub, u16 llh)
+{
+	int prec;
+	uint count = 0;
+	struct pktq *q = wland_bus_txq(pub->bus);
+
+	if (q == NULL)
+		return;
+
+	DHD_BTA(("dhd: flushing HCI ACL data for logical link %u...\n", llh));
+
+	dhd_os_sdlock_txq(pub);
+
+	/*
+	 * Walk through the txq and toss all HCI ACL data packets
+	 */
+	for (prec = q->num_prec - 1; prec >= 0; prec--) {
+		void *head_pkt = NULL;
+
+		while (pktq_ppeek(q, prec) != head_pkt) {
+			void *pkt = pktq_pdeq(q, prec);
+			int ifidx;
+
+			PKTPULL(pub->osh, pkt, dhd_bus_hdrlen(pub->bus));
+			wland_proto_hdrpull(pub, &ifidx, pkt);
+
+			if (PKTLEN(pub->osh, pkt) >= RFC1042_HDR_LEN) {
+				struct ether_header *eh =
+					(struct ether_header *)
+					PKTDATA(pub->osh, pkt);
+
+				if (ntoh16(eh->ether_type) < ETHER_TYPE_MIN) {
+					struct dot11_llc_snap_header *lsh =
+						(struct dot11_llc_snap_header *)
+						&eh[1];
+
+					if (memcmp(lsh, BT_SIG_SNAP_MPROT,
+							DOT11_LLC_SNAP_HDR_LEN -
+							2) == 0
+						&& ntoh16(lsh->type) ==
+						BTA_PROT_L2CAP) {
+						amp_hci_ACL_data_t *ACL_data =
+							(amp_hci_ACL_data_t *) &
+							lsh[1];
+						u16 handle =
+							ltoh16(ACL_data->
+							handle);
+
+						if (HCI_ACL_DATA_HANDLE(handle)
+							== llh) {
+							osl_pktfree(pub->osh,
+								pkt, true);
+							count++;
+							continue;
+						}
+					}
+				}
+			}
+
+			wland_proto_hdrpush(pub, ifidx, pkt);
+			PKTPUSH(pub->osh, pkt, dhd_bus_hdrlen(pub->bus));
+
+			if (head_pkt == NULL)
+				head_pkt = pkt;
+			pktq_penq(q, prec, pkt);
+		}
+	}
+
+	dhd_os_sdunlock_txq(pub);
+
+	WLAND_DBG(HCI, "dhd: flushed %u packet(s) for logical link %u...\n",
+		count, llh);
+}
+
+/* Handle HCI cmd locally.
+ * Return 0: continue to send the cmd across SDIO
+ *        < 0: stop, fail
+ *        > 0: stop, succuess
+ */
+static int _dhd_bta_docmd(wland_private * pub, amp_hci_cmd_t * cmd)
+{
+	int status = 0;
+
+	switch (ltoh16_ua((u8 *) & cmd->opcode)) {
+	case HCI_Enhanced_Flush:
+		{
+			eflush_cmd_parms_t *cmdparms =
+				(eflush_cmd_parms_t *) cmd->parms;
+			dhd_bta_flush_hcidata(pub, ltoh16_ua(cmdparms->llh));
+			break;
+		}
+	default:
+		break;
+	}
+
+	return status;
+}
+
+/* Send HCI cmd encapsulated in BT-SIG frame via data channel to the dongle. */
+int dhd_bta_docmd(wland_private * pub, void *cmd_buf, uint cmd_len)
+{
+	amp_hci_cmd_t *cmd = (amp_hci_cmd_t *) cmd_buf;
+	struct ether_header *eh;
+	struct dot11_llc_snap_header *lsh;
+	struct osl_info *osh = pub->osh;
+	uint len;
+	void *p;
+	int status;
+
+	if (cmd_len < HCI_CMD_PREAMBLE_SIZE) {
+		WLAND_ERR("dhd_bta_docmd: short command, cmd_len %u\n",
+			cmd_len);
+		return BCME_BADLEN;
+	}
+
+	if ((len = (uint) cmd->plen + HCI_CMD_PREAMBLE_SIZE) > cmd_len) {
+		WLAND_ERR
+			("dhd_bta_docmd: malformed command, len %u cmd_len %u\n",
+			len, cmd_len);
+		/*
+		 * return BCME_BADLEN;
+		 */
+	}
+
+	p = osl_pktget(osh, pub->hdrlen + RFC1042_HDR_LEN + len);
+	if (p == NULL) {
+		WLAND_ERR(("dhd_bta_docmd: out of memory\n"));
+		return BCME_NOMEM;
+	}
+
+	/*
+	 * intercept and handle the HCI cmd locally
+	 */
+	if ((status = _dhd_bta_docmd(pub, cmd)) > 0)
+		return 0;
+	else if (status < 0)
+		return status;
+
+	/*
+	 * copy in HCI cmd
+	 */
+	PKTPULL(osh, p, pub->hdrlen + RFC1042_HDR_LEN);
+
+	memcpy(PKTDATA(osh, p), cmd, len);
+
+	/*
+	 * copy in partial Ethernet header with BT-SIG LLC/SNAP header
+	 */
+	PKTPUSH(osh, p, RFC1042_HDR_LEN);
+	eh = (struct ether_header *) PKTDATA(osh, p);
+
+	memset(eh->ether_dhost, '\0', ETH_ALEN);
+
+	ETHER_SET_LOCALADDR(eh->ether_dhost);
+
+	memcpy(eh->ether_shost, &pub->mac, ETH_ALEN);
+
+	eh->ether_type = hton16(len + DOT11_LLC_SNAP_HDR_LEN);
+
+	lsh = (struct dot11_llc_snap_header *) &eh[1];
+
+	memcpy(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2);
+	lsh->type = 0;
+
+	return dhd_sendpkt(pub, 0, p);
+}
+#endif /* !SEND_HCI_CMD_VIA_IOCTL */
+
+/* Send HCI ACL data to dongle via data channel */
+int dhd_bta_tx_hcidata(wland_private * pub, void *data_buf, uint data_len)
+{
+	amp_hci_ACL_data_t *data = (amp_hci_ACL_data_t *) data_buf;
+	struct ether_header *eh;
+	struct dot11_llc_snap_header *lsh;
+	struct osl_info *osh = pub->osh;
+	uint len;
+	void *p;
+
+	if (data_len < HCI_ACL_DATA_PREAMBLE_SIZE) {
+		WLAND_ERR("dhd_bta_tx_hcidata: short data_buf, data_len %u\n",
+			data_len);
+		return BCME_BADLEN;
+	}
+
+	if ((len = (uint) ltoh16(data->dlen) + HCI_ACL_DATA_PREAMBLE_SIZE) >
+		data_len) {
+		WLAND_ERR
+			("dhd_bta_tx_hcidata: malformed hci data, len %u data_len %u\n",
+			len, data_len);
+		/*
+		 * return BCME_BADLEN;
+		 */
+	}
+
+	p = osl_pktget(osh, pub->hdrlen + RFC1042_HDR_LEN + len);
+	if (p == NULL) {
+		WLAND_ERR("dhd_bta_tx_hcidata: out of memory\n");
+		return BCME_NOMEM;
+	}
+
+	/*
+	 * copy in HCI ACL data header and HCI ACL data
+	 */
+	PKTPULL(osh, p, pub->hdrlen + RFC1042_HDR_LEN);
+
+	memcpy(PKTDATA(osh, p), data, len);
+
+	/*
+	 * copy in partial Ethernet header with BT-SIG LLC/SNAP header
+	 */
+	PKTPUSH(osh, p, RFC1042_HDR_LEN);
+	eh = (struct ether_header *) PKTDATA(osh, p);
+
+	memset(eh->ether_dhost, '\0', ETH_ALEN);
+	memcpy(eh->ether_shost, &pub->mac, ETH_ALEN);
+
+	eh->ether_type = hton16(len + DOT11_LLC_SNAP_HDR_LEN);
+	lsh = (struct dot11_llc_snap_header *) &eh[1];
+
+	memcpy(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2);
+
+	lsh->type = BTA_PROT_L2CAP;
+
+	return wland_sendpkt(pub, p);
+}
+
+/* txcomplete callback */
+void dhd_bta_tx_hcidata_complete(wland_private * dhdp, void *txp, bool success)
+{
+	u8 *pktdata = (u8 *) PKTDATA(dhdp->osh, txp);
+	amp_hci_ACL_data_t *ACL_data =
+		(amp_hci_ACL_data_t *) (pktdata + RFC1042_HDR_LEN);
+	u16 handle = ltoh16(ACL_data->handle);
+	u16 llh = HCI_ACL_DATA_HANDLE(handle);
+
+	wl_event_msg_t event;
+	u8 data[HCI_EVT_PREAMBLE_SIZE +
+		sizeof(num_completed_data_blocks_evt_parms_t)];
+	amp_hci_event_t *evt;
+	num_completed_data_blocks_evt_parms_t *parms;
+
+	u16 len =
+		HCI_EVT_PREAMBLE_SIZE +
+		sizeof(num_completed_data_blocks_evt_parms_t);
+
+	/*
+	 * update the event struct
+	 */
+	memset(&event, 0, sizeof(event));
+	event.version = hton16(BCM_EVENT_MSG_VERSION);
+	event.event_type = hton32(WLC_E_BTA_HCI_EVENT);
+	event.status = 0;
+	event.reason = 0;
+	event.auth_type = 0;
+	event.datalen = hton32(len);
+	event.flags = 0;
+
+	/*
+	 * generate Number of Completed Blocks event
+	 */
+	evt = (amp_hci_event_t *) data;
+	evt->ecode = HCI_Number_of_Completed_Data_Blocks;
+	evt->plen = sizeof(num_completed_data_blocks_evt_parms_t);
+
+	parms = (num_completed_data_blocks_evt_parms_t *) evt->parms;
+	htol16_ua_store(dhdp->maxdatablks, (u8 *) & parms->num_blocks);
+	parms->num_handles = 1;
+	htol16_ua_store(llh, (u8 *) & parms->completed[0].handle);
+	parms->completed[0].pkts = 1;
+	parms->completed[0].blocks = 1;
+
+	dhd_sendup_event_common(dhdp, &event, data);
+}
+
+/* event callback */
+void dhd_bta_doevt(wland_private * dhdp, void *data_buf, uint data_len)
+{
+	amp_hci_event_t *evt = (amp_hci_event_t *) data_buf;
+
+	switch (evt->ecode) {
+	case HCI_Command_Complete:
+		{
+			cmd_complete_parms_t *parms =
+				(cmd_complete_parms_t *) evt->parms;
+			switch (ltoh16_ua((u8 *) & parms->opcode)) {
+			case HCI_Read_Data_Block_Size:
+				{
+					read_data_block_size_evt_parms_t *parms2
+						=
+						(read_data_block_size_evt_parms_t
+						*) parms->parms;
+					dhdp->maxdatablks =
+						ltoh16_ua((u8 *) &
+						parms2->data_block_num);
+					break;
+				}
+			}
+			break;
+		}
+
+	case HCI_Flush_Occurred:
+		{
+			flush_occurred_evt_parms_t *evt_parms =
+				(flush_occurred_evt_parms_t *) evt->parms;
+			dhd_bta_flush_hcidata(dhdp,
+				ltoh16_ua((u8 *) & evt_parms->handle));
+			break;
+		}
+	default:
+		break;
+	}
+}
+#endif /* WLAND_BT_3_0_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.h
new file mode 100644
index 000000000000..439b0994c476
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_bta.h
@@ -0,0 +1,427 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifdef WLAND_BT_3_0_SUPPORT
+#ifndef _WLAND_BTA_H_
+#define _WLAND_BTA_H_
+
+struct wland_pub;
+
+/* AMP HCI CMD packet format */
+typedef PRE_PACKED struct amp_hci_cmd {
+	u16 opcode;
+	u8 plen;
+	u8 parms[1];
+} POST_PACKED amp_hci_cmd_t;
+
+#define HCI_CMD_PREAMBLE_SIZE		OFFSETOF(amp_hci_cmd_t, parms)
+#define HCI_CMD_DATA_SIZE		255
+
+/* AMP HCI CMD opcode layout */
+#define HCI_CMD_OPCODE(ogf, ocf)	            ((((ogf) & 0x3F) << 10) | ((ocf) & 0x03FF))
+#define HCI_CMD_OGF(opcode)		                ((u8)(((opcode) >> 10) & 0x3F))
+#define HCI_CMD_OCF(opcode)		                ((opcode) & 0x03FF)
+
+/* AMP HCI command opcodes */
+#define HCI_Read_Failed_Contact_Counter		    HCI_CMD_OPCODE(0x05, 0x0001)
+#define HCI_Reset_Failed_Contact_Counter	    HCI_CMD_OPCODE(0x05, 0x0002)
+#define HCI_Read_Link_Quality			        HCI_CMD_OPCODE(0x05, 0x0003)
+#define HCI_Read_Local_AMP_Info			        HCI_CMD_OPCODE(0x05, 0x0009)
+#define HCI_Read_Local_AMP_ASSOC		        HCI_CMD_OPCODE(0x05, 0x000A)
+#define HCI_Write_Remote_AMP_ASSOC		        HCI_CMD_OPCODE(0x05, 0x000B)
+#define HCI_Create_Physical_Link		        HCI_CMD_OPCODE(0x01, 0x0035)
+#define HCI_Accept_Physical_Link_Request	    HCI_CMD_OPCODE(0x01, 0x0036)
+#define HCI_Disconnect_Physical_Link		    HCI_CMD_OPCODE(0x01, 0x0037)
+#define HCI_Create_Logical_Link			        HCI_CMD_OPCODE(0x01, 0x0038)
+#define HCI_Accept_Logical_Link			        HCI_CMD_OPCODE(0x01, 0x0039)
+#define HCI_Disconnect_Logical_Link		        HCI_CMD_OPCODE(0x01, 0x003A)
+#define HCI_Logical_Link_Cancel			        HCI_CMD_OPCODE(0x01, 0x003B)
+#define HCI_Flow_Spec_Modify			        HCI_CMD_OPCODE(0x01, 0x003C)
+#define HCI_Write_Flow_Control_Mode		        HCI_CMD_OPCODE(0x01, 0x0067)
+#define HCI_Read_Best_Effort_Flush_Timeout	    HCI_CMD_OPCODE(0x01, 0x0069)
+#define HCI_Write_Best_Effort_Flush_Timeout	    HCI_CMD_OPCODE(0x01, 0x006A)
+#define HCI_Short_Range_Mode			        HCI_CMD_OPCODE(0x01, 0x006B)
+#define HCI_Reset				                HCI_CMD_OPCODE(0x03, 0x0003)
+#define HCI_Read_Connection_Accept_Timeout	    HCI_CMD_OPCODE(0x03, 0x0015)
+#define HCI_Write_Connection_Accept_Timeout	    HCI_CMD_OPCODE(0x03, 0x0016)
+#define HCI_Read_Link_Supervision_Timeout	    HCI_CMD_OPCODE(0x03, 0x0036)
+#define HCI_Write_Link_Supervision_Timeout	    HCI_CMD_OPCODE(0x03, 0x0037)
+#define HCI_Enhanced_Flush			            HCI_CMD_OPCODE(0x03, 0x005F)
+#define HCI_Read_Logical_Link_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0061)
+#define HCI_Write_Logical_Link_Accept_Timeout	HCI_CMD_OPCODE(0x03, 0x0062)
+#define HCI_Set_Event_Mask_Page_2		        HCI_CMD_OPCODE(0x03, 0x0063)
+#define HCI_Read_Location_Data_Command		    HCI_CMD_OPCODE(0x03, 0x0064)
+#define HCI_Write_Location_Data_Command		    HCI_CMD_OPCODE(0x03, 0x0065)
+#define HCI_Read_Local_Version_Info		        HCI_CMD_OPCODE(0x04, 0x0001)
+#define HCI_Read_Local_Supported_Commands	    HCI_CMD_OPCODE(0x04, 0x0002)
+#define HCI_Read_Buffer_Size			        HCI_CMD_OPCODE(0x04, 0x0005)
+#define HCI_Read_Data_Block_Size		        HCI_CMD_OPCODE(0x04, 0x000A)
+
+/* AMP HCI command parameters */
+struct read_local_cmd_parms {
+	u8 plh;
+	u8 offset[2];		/* length so far */
+	u8 max_remote[2];
+};
+
+struct write_remote_cmd_parms {
+	u8 plh;
+	u8 offset[2];
+	u8 len[2];
+	u8 frag[1];
+};
+
+struct phy_link_cmd_parms {
+	u8 plh;
+	u8 key_length;
+	u8 key_type;
+	u8 key[1];
+} phy_link_cmd_parms_t;
+
+struct dis_phy_link_cmd_parms {
+	u8 plh;
+	u8 reason;
+};
+
+struct log_link_cmd_parms {
+	u8 plh;
+	u8 txflow[16];
+	u8 rxflow[16];
+};
+
+struct ext_flow_spec {
+	u8 id;
+	u8 service_type;
+	u8 max_sdu[2];
+	u8 sdu_ia_time[4];
+	u8 access_latency[4];
+	u8 flush_timeout[4];
+};
+
+struct log_link_cancel_cmd_parms {
+	u8 plh;
+	u8 tx_fs_ID;
+};
+
+struct flow_spec_mod_cmd_parms {
+	u8 llh[2];
+	u8 txflow[16];
+	u8 rxflow[16];
+};
+
+struct plh_pad {
+	u8 plh;
+	u8 pad;
+};
+
+union hci_handle {
+	u16 bredr;
+	plh_pad_t amp;
+} hci_handle_t;
+
+struct ls_to_cmd_parms {
+	hci_handle_t handle;
+	u8 timeout[2];
+} ls_to_cmd_parms_t;
+
+struct befto_cmd_parms {
+	u8 llh[2];
+	u8 befto[4];
+};
+
+struct srm_cmd_parms {
+	u8 plh;
+	u8 srm;
+};
+
+struct ld_cmd_parms {
+	u8 ld_aware;
+	u8 ld[2];
+	u8 ld_opts;
+	u8 l_opts;
+};
+
+struct eflush_cmd_parms {
+	u8 llh[2];
+	u8 packet_type;
+};
+
+/* Generic AMP extended flow spec service types */
+#define EFS_SVCTYPE_NO_TRAFFIC		0
+#define EFS_SVCTYPE_BEST_EFFORT		1
+#define EFS_SVCTYPE_GUARANTEED		2
+
+/* AMP HCI event packet format */
+struct amp_hci_event {
+	u8 ecode;
+	u8 plen;
+	u8 parms[1];
+};
+
+#define HCI_EVT_PREAMBLE_SIZE			OFFSETOF(amp_hci_event_t, parms)
+
+/* AMP HCI event codes */
+#define HCI_Command_Complete			                    0x0E
+#define HCI_Command_Status			                        0x0F
+#define HCI_Flush_Occurred			                        0x11
+#define HCI_Enhanced_Flush_Complete		                    0x39
+#define HCI_Physical_Link_Complete		                    0x40
+#define HCI_Channel_Select			                        0x41
+#define HCI_Disconnect_Physical_Link_Complete	            0x42
+#define HCI_Logical_Link_Complete		                    0x45
+#define HCI_Disconnect_Logical_Link_Complete	            0x46
+#define HCI_Flow_Spec_Modify_Complete		                0x47
+#define HCI_Number_of_Completed_Data_Blocks	                0x48
+#define HCI_Short_Range_Mode_Change_Complete	            0x4C
+#define HCI_Status_Change_Event			                    0x4D
+#define HCI_Vendor_Specific			                        0xFF
+
+/* AMP HCI event mask bit positions */
+#define HCI_Physical_Link_Complete_Event_Mask			    0x0001
+#define HCI_Channel_Select_Event_Mask				        0x0002
+#define HCI_Disconnect_Physical_Link_Complete_Event_Mask	0x0004
+#define HCI_Logical_Link_Complete_Event_Mask			    0x0020
+#define HCI_Disconnect_Logical_Link_Complete_Event_Mask		0x0040
+#define HCI_Flow_Spec_Modify_Complete_Event_Mask		    0x0080
+#define HCI_Number_of_Completed_Data_Blocks_Event_Mask		0x0100
+#define HCI_Short_Range_Mode_Change_Complete_Event_Mask		0x1000
+#define HCI_Status_Change_Event_Mask				        0x2000
+#define HCI_All_Event_Mask					                0x31e7
+
+/* AMP HCI event parameters */
+struct cmd_status_parms {
+	u8 status;
+	u8 cmdpkts;
+	u16 opcode;
+} cmd_status_parms_t;
+
+struct cmd_complete_parms {
+	u8 cmdpkts;
+	u16 opcode;
+	u8 parms[1];
+} cmd_complete_parms_t;
+
+struct flush_occurred_evt_parms {
+	u16 handle;
+} flush_occurred_evt_parms_t;
+
+struct write_remote_evt_parms {
+	u8 status;
+	u8 plh;
+} write_remote_evt_parms_t;
+
+struct read_local_evt_parms {
+	u8 status;
+	u8 plh;
+	u16 len;
+	u8 frag[1];
+} read_local_evt_parms_t;
+
+struct read_local_info_evt_parms {
+	u8 status;
+	u8 AMP_status;
+	u32 bandwidth;
+	u32 gbandwidth;
+	u32 latency;
+	u32 PDU_size;
+	u8 ctrl_type;
+	u16 PAL_cap;
+	u16 AMP_ASSOC_len;
+	u32 max_flush_timeout;
+	u32 be_flush_timeout;
+} read_local_info_evt_parms_t;
+
+struct log_link_evt_parms {
+	u8 status;
+	u16 llh;
+	u8 plh;
+	u8 tx_fs_ID;
+} log_link_evt_parms_t;
+
+struct disc_log_link_evt_parms {
+	u8 status;
+	u16 llh;
+	u8 reason;
+} disc_log_link_evt_parms_t;
+
+struct log_link_cancel_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 tx_fs_ID;
+} log_link_cancel_evt_parms_t;
+
+struct flow_spec_mod_evt_parms {
+	u8 status;
+	u16 llh;
+} flow_spec_mod_evt_parms_t;
+
+struct phy_link_evt_parms {
+	u8 status;
+	u8 plh;
+} phy_link_evt_parms_t;
+
+struct dis_phy_link_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 reason;
+} dis_phy_link_evt_parms_t;
+
+struct read_ls_to_evt_parms {
+	u8 status;
+	hci_handle_t handle;
+	u16 timeout;
+} read_ls_to_evt_parms_t;
+
+struct read_lla_ca_to_evt_parms {
+	u8 status;
+	u16 timeout;
+} read_lla_ca_to_evt_parms_t;
+
+struct read_data_block_size_evt_parms {
+	u8 status;
+	u16 ACL_pkt_len;
+	u16 data_block_len;
+	u16 data_block_num;
+} read_data_block_size_evt_parms_t;
+
+struct data_blocks {
+	u16 handle;
+	u16 pkts;
+	u16 blocks;
+} data_blocks_t;
+
+struct num_completed_data_blocks_evt_parms {
+	u16 num_blocks;
+	u8 num_handles;
+	data_blocks_t completed[1];
+} num_completed_data_blocks_evt_parms_t;
+
+struct befto_evt_parms {
+	u8 status;
+	u32 befto;
+} befto_evt_parms_t;
+
+struct srm_evt_parms {
+	u8 status;
+	u8 plh;
+	u8 srm;
+} srm_evt_parms_t;
+
+struct contact_counter_evt_parms {
+	u8 status;
+	u8 llh[2];
+	u16 counter;
+} contact_counter_evt_parms_t;
+
+struct contact_counter_reset_evt_parms {
+	u8 status;
+	u8 llh[2];
+} contact_counter_reset_evt_parms_t;
+
+struct read_linkq_evt_parms {
+	u8 status;
+	hci_handle_t handle;
+	u8 link_quality;
+} read_linkq_evt_parms_t;
+
+struct ld_evt_parms {
+	u8 status;
+	u8 ld_aware;
+	u8 ld[2];
+	u8 ld_opts;
+	u8 l_opts;
+} ld_evt_parms_t;
+
+struct eflush_complete_evt_parms {
+	u16 handle;
+} eflush_complete_evt_parms_t;
+
+struct vendor_specific_evt_parms {
+	u8 len;
+	u8 parms[1];
+} vendor_specific_evt_parms_t;
+
+struct local_version_info_evt_parms {
+	u8 status;
+	u8 hci_version;
+	u16 hci_revision;
+	u8 pal_version;
+	u16 mfg_name;
+	u16 pal_subversion;
+} local_version_info_evt_parms_t;
+
+#define MAX_SUPPORTED_CMD_BYTE	64
+
+struct local_supported_cmd_evt_parms {
+	u8 status;
+	u8 cmd[MAX_SUPPORTED_CMD_BYTE];
+} local_supported_cmd_evt_parms_t;
+
+struct status_change_evt_parms {
+	u8 status;
+	u8 amp_status;
+} status_change_evt_parms_t;
+
+/* AMP HCI error codes */
+#define HCI_SUCCESS				            0x00
+#define HCI_ERR_ILLEGAL_COMMAND			    0x01
+#define HCI_ERR_NO_CONNECTION			    0x02
+#define HCI_ERR_MEMORY_FULL			        0x07
+#define HCI_ERR_CONNECTION_TIMEOUT		    0x08
+#define HCI_ERR_MAX_NUM_OF_CONNECTIONS		0x09
+#define HCI_ERR_CONNECTION_EXISTS		    0x0B
+#define HCI_ERR_CONNECTION_DISALLOWED		0x0C
+#define HCI_ERR_CONNECTION_ACCEPT_TIMEOUT	0x10
+#define HCI_ERR_UNSUPPORTED_VALUE		    0x11
+#define HCI_ERR_ILLEGAL_PARAMETER_FMT		0x12
+#define HCI_ERR_CONN_TERM_BY_LOCAL_HOST		0x16
+#define HCI_ERR_UNSPECIFIED			        0x1F
+#define HCI_ERR_UNIT_KEY_USED			    0x26
+#define HCI_ERR_QOS_REJECTED			    0x2D
+#define HCI_ERR_PARAM_OUT_OF_RANGE		    0x30
+#define HCI_ERR_NO_SUITABLE_CHANNEL		    0x39
+#define HCI_ERR_CHANNEL_MOVE			    0xFF
+
+#define HCI_ACL_DATA_BC_FLAGS		(0x0 << 14)
+#define HCI_ACL_DATA_PB_FLAGS		(0x3 << 12)
+
+#define HCI_ACL_DATA_HANDLE(handle)	((handle) & 0x0fff)
+#define HCI_ACL_DATA_FLAGS(handle)	((handle) >> 12)
+
+/* AMP Activity Report packet formats */
+struct amp_hci_activity_report {
+	u8 ScheduleKnown;
+	u8 NumReports;
+	u8 data[1];
+} amp_hci_activity_report_t;
+
+struct amp_hci_activity_report_triple {
+	u32 StartTime;
+	u32 Duration;
+	u32 Periodicity;
+} amp_hci_activity_report_triple_t;
+
+#define HCI_AR_SCHEDULE_KNOWN		0x01
+
+extern int dhd_bta_docmd(struct dhd_pub *pub, void *cmd_buf, uint cmd_len);
+extern void dhd_bta_doevt(struct dhd_pub *pub, void *data_buf, uint data_len);
+extern int dhd_bta_tx_hcidata(struct dhd_pub *pub, void *data_buf,
+	uint data_len);
+extern void dhd_bta_tx_hcidata_complete(struct dhd_pub *dhdp, void *txp,
+	bool success);
+
+#endif /* _WLAND_BTA_H_ */
+#endif /* WLAND_BT_3_0_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.c
new file mode 100644
index 000000000000..bcf6ac89b498
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.c
@@ -0,0 +1,535 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifdef WLAND_BTCOEX_SUPPORT
+
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <net/cfg80211.h>
+
+#include <wland_utils.h>
+#include <wland_defs.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_btcoex.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+/* T1 start SCO/eSCO priority suppression */
+#define BRCMF_BTCOEX_OPPR_WIN_TIME      2000
+
+/* BT registers values during DHCP */
+#define BRCMF_BT_DHCP_REG50             0x8022
+#define BRCMF_BT_DHCP_REG51             0
+#define BRCMF_BT_DHCP_REG64             0
+#define BRCMF_BT_DHCP_REG65             0
+#define BRCMF_BT_DHCP_REG71             0
+#define BRCMF_BT_DHCP_REG66             0x2710
+#define BRCMF_BT_DHCP_REG41             0x33
+#define BRCMF_BT_DHCP_REG68             0x190
+
+/* number of samples for SCO detection */
+#define BRCMF_BT_SCO_SAMPLES            12
+
+/**
+* enum wland_btcoex_state - BT coex DHCP state machine states
+* @WLAND_BT_DHCP_IDLE : DCHP is idle
+* @WLAND_BT_DHCP_START: DHCP started, wait before boosting wifi priority
+* @WLAND_BT_DHCP_OPPR_WIN: graceful DHCP opportunity ended,boost wifi priority
+* @WLAND_BT_DHCP_FLAG_FORCE_TIMEOUT: wifi priority boost end restore defaults
+*/
+enum wland_btcoex_state {
+	WLAND_BT_DHCP_IDLE,
+	WLAND_BT_DHCP_START,
+	WLAND_BT_DHCP_OPPR_WIN,
+	WLAND_BT_DHCP_FLAG_FORCE_TIMEOUT
+};
+
+/**
+ * struct wland_btcoex_info - BT coex related information
+ * @vif: interface for which request was done.
+ * @timer: timer for DHCP state machine
+ * @timeout: configured timeout.
+ * @timer_on:  DHCP timer active
+ * @dhcp_done: DHCP finished before T1/T2 timer expiration
+ * @bt_state: DHCP state machine state
+ * @work: DHCP state machine work
+ * @cfg: driver private data for cfg80211 interface
+ * @reg66: saved value of btc_params 66
+ * @reg41: saved value of btc_params 41
+ * @reg68: saved value of btc_params 68
+ * @saved_regs_part1: flag indicating regs 66,41,68	have been saved
+ * @reg51: saved value of btc_params 51
+ * @reg64: saved value of btc_params 64
+ * @reg65: saved value of btc_params 65
+ * @reg71: saved value of btc_params 71
+ * @saved_regs_part1: flag indicating regs 50,51,64,65,71 have been saved
+ */
+struct wland_btcoex_info {
+	struct wland_cfg80211_vif *vif;
+	struct timer_list timer;
+	u16 timeout;
+	bool timer_on;
+	bool dhcp_done;
+	enum wland_btcoex_state bt_state;
+	struct work_struct work;
+	struct wland_cfg80211_info *cfg;
+	u32 reg66;
+	u32 reg41;
+	u32 reg68;
+	bool saved_regs_part1;
+	u32 reg50;
+	u32 reg51;
+	u32 reg64;
+	u32 reg65;
+	u32 reg71;
+	bool saved_regs_part2;
+};
+
+/**
+ * wland_btcoex_params_write() - write btc_params firmware variable
+ * @ifp:  interface
+ * @addr: btc_params register number
+ * @data: data to write
+ */
+static s32 wland_btcoex_params_write(struct wland_if *ifp, u32 addr, u32 data)
+{
+	struct {
+		__le32 addr;
+		__le32 data;
+	} reg_write;
+
+	reg_write.addr = cpu_to_le32(addr);
+	reg_write.data = cpu_to_le32(data);
+
+	return wland_fil_iovar_data_set(ifp, "btc_params", &reg_write,
+		sizeof(reg_write));
+}
+
+/**
+ * wland_btcoex_params_read() - read btc_params firmware variable
+ * @ifp:  interface
+ * @addr: btc_params register number
+ * @data: read data
+ */
+static s32 wland_btcoex_params_read(struct wland_if *ifp, u32 addr, u32 * data)
+{
+	*data = addr;
+
+	return wland_fil_iovar_data_get(ifp, "btc_params", data);
+}
+
+/**
+ * wland_btcoex_boost_wifi() - control BT SCO/eSCO parameters
+ * @btci: BT coex info
+ * @trump_sco:
+ *	true  - set SCO/eSCO parameters for compatibility during DHCP window
+ *	false - restore saved parameter values
+ *
+ * Enhanced BT COEX settings for eSCO compatibility during DHCP window
+ */
+static void wland_btcoex_boost_wifi(struct wland_btcoex_info *btci,
+	bool trump_sco)
+{
+	struct wland_if *ifp = btci->cfg->pub->iflist[0];
+
+	if (trump_sco && !btci->saved_regs_part2) {
+		/*
+		 * this should reduce eSCO agressive retransmit w/o breaking it
+		 */
+
+		/*
+		 * save current
+		 */
+		WLAND_DBG(DEFAULT, TRACE,
+			"new SCO/eSCO coex algo {save & override}\n");
+
+		wland_btcoex_params_read(ifp, 50, &btci->reg50);
+		wland_btcoex_params_read(ifp, 51, &btci->reg51);
+		wland_btcoex_params_read(ifp, 64, &btci->reg64);
+		wland_btcoex_params_read(ifp, 65, &btci->reg65);
+		wland_btcoex_params_read(ifp, 71, &btci->reg71);
+
+		btci->saved_regs_part2 = true;
+		WLAND_DBG(DEFAULT, TRACE,
+			"saved bt_params[50,51,64,65,71]: 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+			btci->reg50, btci->reg51, btci->reg64, btci->reg65,
+			btci->reg71);
+
+		/*
+		 * pacify the eSco
+		 */
+		wland_btcoex_params_write(ifp, 50, BRCMF_BT_DHCP_REG50);
+		wland_btcoex_params_write(ifp, 51, BRCMF_BT_DHCP_REG51);
+		wland_btcoex_params_write(ifp, 64, BRCMF_BT_DHCP_REG64);
+		wland_btcoex_params_write(ifp, 65, BRCMF_BT_DHCP_REG65);
+		wland_btcoex_params_write(ifp, 71, BRCMF_BT_DHCP_REG71);
+	} else if (btci->saved_regs_part2) {
+		/*
+		 * restore previously saved bt params
+		 */
+		WLAND_DBG(DEFAULT, TRACE,
+			"Do new SCO/eSCO coex algo {restore}\n");
+		wland_btcoex_params_write(ifp, 50, btci->reg50);
+		wland_btcoex_params_write(ifp, 51, btci->reg51);
+		wland_btcoex_params_write(ifp, 64, btci->reg64);
+		wland_btcoex_params_write(ifp, 65, btci->reg65);
+		wland_btcoex_params_write(ifp, 71, btci->reg71);
+
+		WLAND_DBG(DEFAULT, TRACE,
+			"restored bt_params[50,51,64,65,71]: 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+			btci->reg50, btci->reg51, btci->reg64, btci->reg65,
+			btci->reg71);
+
+		btci->saved_regs_part2 = false;
+	} else {
+		WLAND_ERR("attempted to restore not saved BTCOEX params\n");
+	}
+}
+
+/**
+ * wland_btcoex_is_sco_active() - check if SCO/eSCO is active
+ * @ifp: interface
+ *
+ * return: true if SCO/eSCO session is active
+ */
+static bool wland_btcoex_is_sco_active(struct wland_if *ifp)
+{
+	bool res = false;
+	int sco_id_cnt = 0, ioc_res = 0, i;
+	u32 param27;
+
+	for (i = 0; i < BRCMF_BT_SCO_SAMPLES; i++) {
+		ioc_res = wland_btcoex_params_read(ifp, 27, &param27);
+
+		if (ioc_res < 0) {
+			WLAND_ERR("ioc read btc params error\n");
+			break;
+		}
+
+		WLAND_DBG(DEFAULT, TRACE, "sample[%d], btc_params 27:%x\n", i,
+			param27);
+
+		if ((param27 & 0x6) == 2) {	/* count both sco & esco  */
+			sco_id_cnt++;
+		}
+
+		if (sco_id_cnt > 2) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"sco/esco detected, pkt id_cnt:%d samples:%d\n",
+				sco_id_cnt, i);
+			res = true;
+			break;
+		}
+	}
+	WLAND_DBG(DEFAULT, TRACE, "exit: result=%d\n", res);
+	return res;
+}
+
+/*
+ * wland_btcoex_save_part1() - save first step parameters.
+ */
+static void wland_btcoex_save_part1(struct wland_btcoex_info *btci)
+{
+	struct wland_if *ifp = btci->vif->ifp;
+
+	if (!btci->saved_regs_part1) {
+		/*
+		 * Retrieve and save original reg value
+		 */
+		wland_btcoex_params_read(ifp, 66, &btci->reg66);
+		wland_btcoex_params_read(ifp, 41, &btci->reg41);
+		wland_btcoex_params_read(ifp, 68, &btci->reg68);
+		btci->saved_regs_part1 = true;
+		WLAND_DBG(DEFAULT, TRACE,
+			"saved btc_params regs (66,41,68) 0x%x 0x%x 0x%x\n",
+			btci->reg66, btci->reg41, btci->reg68);
+	}
+}
+
+/*
+ * wland_btcoex_restore_part1() - restore first step parameters.
+ */
+static void wland_btcoex_restore_part1(struct wland_btcoex_info *btci)
+{
+	struct wland_if *ifp;
+
+	if (btci->saved_regs_part1) {
+		btci->saved_regs_part1 = false;
+		ifp = btci->vif->ifp;
+		wland_btcoex_params_write(ifp, 66, btci->reg66);
+		wland_btcoex_params_write(ifp, 41, btci->reg41);
+		wland_btcoex_params_write(ifp, 68, btci->reg68);
+
+		WLAND_DBG(DEFAULT, TRACE,
+			"restored btc_params regs {66,41,68} 0x%x 0x%x 0x%x\n",
+			btci->reg66, btci->reg41, btci->reg68);
+	}
+}
+
+/**
+ * wland_btcoex_timerfunc() - BT coex timer callback
+ */
+static void wland_btcoex_timerfunc(ulong data)
+{
+	struct wland_btcoex_info *bt_local;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	bt_local = (struct wland_btcoex_info *) data;
+
+	bt_local->timer_on = false;
+
+	schedule_work(&bt_local->work);
+}
+
+/**
+ * wland_btcoex_handler() - BT coex state machine work handler
+ * @work: work
+ */
+static void wland_btcoex_handler(struct work_struct *work)
+{
+	struct wland_btcoex_info *btci =
+		container_of(work, struct wland_btcoex_info, work);
+
+	if (btci->timer_on) {
+		btci->timer_on = false;
+		if (timer_pending(&btci->timer)) {
+			WLAND_DBG(DEFAULT, TRACE, "Del timer btci->timer\n");
+			del_timer_sync(&btci->timer);
+		}
+	}
+
+	switch (btci->bt_state) {
+	case WLAND_BT_DHCP_START:
+		/*
+		 * DHCP started provide OPPORTUNITY window
+		 * to get DHCP address
+		 */
+		WLAND_DBG(DEFAULT, TRACE, "DHCP started\n");
+		btci->bt_state = WLAND_BT_DHCP_OPPR_WIN;
+		if (btci->timeout < BRCMF_BTCOEX_OPPR_WIN_TIME) {
+			mod_timer(&btci->timer, btci->timer.expires);
+		} else {
+			btci->timeout -= BRCMF_BTCOEX_OPPR_WIN_TIME;
+			mod_timer(&btci->timer, jiffies +
+				msecs_to_jiffies(BRCMF_BTCOEX_OPPR_WIN_TIME));
+		}
+		btci->timer_on = true;
+		break;
+
+	case WLAND_BT_DHCP_OPPR_WIN:
+		if (btci->dhcp_done) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"DHCP done before T1 expiration\n");
+			goto idle;
+		}
+
+		/*
+		 * DHCP is not over yet, start lowering BT priority
+		 */
+		WLAND_DBG(DEFAULT, TRACE, "DHCP T1:%d expired\n",
+			BRCMF_BTCOEX_OPPR_WIN_TIME);
+		wland_btcoex_boost_wifi(btci, true);
+
+		btci->bt_state = WLAND_BT_DHCP_FLAG_FORCE_TIMEOUT;
+		mod_timer(&btci->timer,
+			jiffies + msecs_to_jiffies(btci->timeout));
+		btci->timer_on = true;
+		break;
+
+	case WLAND_BT_DHCP_FLAG_FORCE_TIMEOUT:
+		if (btci->dhcp_done)
+			WLAND_DBG(DEFAULT, TRACE,
+				"DHCP done before T2 expiration\n");
+		else
+			WLAND_DBG(DEFAULT, TRACE, "DHCP T2:%d expired\n",
+				WLAND_BT_DHCP_FLAG_FORCE_TIMEOUT);
+
+		goto idle;
+
+	default:
+		WLAND_ERR("invalid state=%d !!!\n", btci->bt_state);
+		goto idle;
+	}
+
+	return;
+
+idle:
+	btci->bt_state = WLAND_BT_DHCP_IDLE;
+	btci->timer_on = false;
+	wland_btcoex_boost_wifi(btci, false);
+	cfg80211_crit_proto_stopped(&btci->vif->wdev, GFP_KERNEL);
+	wland_btcoex_restore_part1(btci);
+	btci->vif = NULL;
+}
+
+/**
+ * wland_btcoex_attach() - initialize BT coex data
+ * @cfg: driver private cfg80211 data
+ *
+ * return: 0 on success
+ */
+int wland_btcoex_attach(struct wland_cfg80211_info *cfg)
+{
+	struct wland_btcoex_info *btci;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	btci = kmalloc(sizeof(struct wland_btcoex_info), GFP_KERNEL);
+	if (!btci)
+		return -ENOMEM;
+
+	btci->bt_state = WLAND_BT_DHCP_IDLE;
+
+	/*
+	 * Set up timer for BT
+	 */
+	btci->timer_on = false;
+	btci->timeout = BRCMF_BTCOEX_OPPR_WIN_TIME;
+	init_timer(&btci->timer);
+	btci->timer.data = (ulong) btci;
+	btci->timer.function = wland_btcoex_timerfunc;
+	btci->cfg = cfg;
+	btci->saved_regs_part1 = false;
+	btci->saved_regs_part2 = false;
+
+	INIT_WORK(&btci->work, wland_btcoex_handler);
+
+	cfg->btcoex = btci;
+	return 0;
+}
+
+/**
+ * wland_btcoex_detach - clean BT coex data
+ * @cfg: driver private cfg80211 data
+ */
+void wland_btcoex_detach(struct wland_cfg80211_info *cfg)
+{
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	if (!cfg->btcoex)
+		return;
+
+	if (cfg->btcoex->timer_on) {
+		cfg->btcoex->timer_on = false;
+		if (timer_pending(&cfg->btcoex->timer)) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"del timer cfg->btcoex->timer\n");
+			del_timer_sync(&cfg->btcoex->timer);
+		}
+	}
+
+	cancel_work_sync(&cfg->btcoex->work);
+
+	wland_btcoex_boost_wifi(cfg->btcoex, false);
+	wland_btcoex_restore_part1(cfg->btcoex);
+
+	kfree(cfg->btcoex);
+	cfg->btcoex = NULL;
+}
+
+static void wland_btcoex_dhcp_start(struct wland_btcoex_info *btci)
+{
+	struct wland_if *ifp = btci->vif->ifp;
+
+	wland_btcoex_save_part1(btci);
+	/*
+	 * set new regs values
+	 */
+	wland_btcoex_params_write(ifp, 66, BRCMF_BT_DHCP_REG66);
+	wland_btcoex_params_write(ifp, 41, BRCMF_BT_DHCP_REG41);
+	wland_btcoex_params_write(ifp, 68, BRCMF_BT_DHCP_REG68);
+	btci->dhcp_done = false;
+	btci->bt_state = WLAND_BT_DHCP_START;
+	schedule_work(&btci->work);
+
+	WLAND_DBG(DEFAULT, TRACE, "enable BT DHCP Timer\n");
+}
+
+static void wland_btcoex_dhcp_end(struct wland_btcoex_info *btci)
+{
+	/*
+	 * Stop any bt timer because DHCP session is done
+	 */
+	btci->dhcp_done = true;
+
+	if (btci->timer_on) {
+		WLAND_DBG(DEFAULT, TRACE, "disable BT DHCP Timer\n");
+		btci->timer_on = false;
+		if (timer_pending(&btci->timer)) {
+			WLAND_DBG(DEFAULT, TRACE, "Del timer btci->timer\n");
+			del_timer_sync(&btci->timer);
+		}
+
+		/*
+		 * schedule worker if transition to IDLE is needed
+		 */
+		if (btci->bt_state != WLAND_BT_DHCP_IDLE) {
+			WLAND_DBG(DEFAULT, TRACE, "bt_state:%d\n",
+				btci->bt_state);
+			schedule_work(&btci->work);
+		}
+	} else {
+		/*
+		 * Restore original values
+		 */
+		wland_btcoex_restore_part1(btci);
+	}
+}
+
+/**
+ * wland_btcoex_set_mode - set BT coex mode
+ * @cfg: driver private cfg80211 data
+ * @mode: Wifi-Bluetooth coexistence mode
+ *
+ * return: 0 on success
+ */
+int wland_btcoex_set_mode(struct wland_cfg80211_vif *vif,
+	enum wland_btcoex_mode mode, u16 duration)
+{
+	struct wland_cfg80211_info *cfg = wiphy_priv(vif->wdev.wiphy);
+	struct wland_btcoex_info *btci = cfg->btcoex;
+	struct wland_if *ifp = cfg->pub->iflist[0];
+
+	switch (mode) {
+	case BTCOEX_DISABLED:
+		WLAND_DBG(DEFAULT, TRACE, "DHCP session starts\n");
+		if (btci->bt_state != WLAND_BT_DHCP_IDLE)
+			return -EBUSY;
+		/*
+		 * Start BT timer only for SCO connection
+		 */
+		if (wland_btcoex_is_sco_active(ifp)) {
+			btci->timeout = duration;
+			btci->vif = vif;
+			wland_btcoex_dhcp_start(btci);
+		}
+		break;
+
+	case BTCOEX_ENABLED:
+		WLAND_DBG(DEFAULT, TRACE, "DHCP session ends\n");
+		if (btci->bt_state != WLAND_BT_DHCP_IDLE && vif == btci->vif) {
+			wland_btcoex_dhcp_end(btci);
+		}
+		break;
+	default:
+		WLAND_DBG(DEFAULT, TRACE, "Unknown mode, ignored\n");
+	}
+	return 0;
+}
+
+#endif /* WLAND_BTCOEX_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.h
new file mode 100644
index 000000000000..b67dd0636000
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_btcoex.h
@@ -0,0 +1,32 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_BTCOEX_H_
+#define _WLAND_BTCOEX_H_
+
+#ifdef WLAND_BTCOEX_SUPPORT
+
+enum wland_btcoex_mode {
+	BTCOEX_DISABLED,
+	BTCOEX_ENABLED
+};
+
+int wland_btcoex_attach(struct wland_cfg80211_info *cfg);
+void wland_btcoex_detach(struct wland_cfg80211_info *cfg);
+int wland_btcoex_set_mode(struct wland_cfg80211_vif *vif,
+	enum wland_btcoex_mode mode, u16 duration);
+#endif /* WLAND_BTCOEX_SUPPORT */
+#endif /* WLAND_BTCOEX_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.c
new file mode 100644
index 000000000000..c0ef1e0ff326
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.c
@@ -0,0 +1,466 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/kthread.h>
+#include <linux/printk.h>
+#include <linux/export.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/scatterlist.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/vmalloc.h>
+#include <asm/unaligned.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+/* Accept MAC address of the form macaddr=0x08,0x00,0x20,0x30,0x40,0x50 */
+static int macaddr[6];
+module_param_array(macaddr, int, NULL, 0);
+MODULE_PARM_DESC(macaddr, "WLAN MAC address");
+
+void wland_txflowcontrol(struct device *dev, bool state)
+{
+	int i = 0;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_private *drvr = bus_if->drvr;
+
+	//struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_fws_info *fws = drvr->fws;
+
+	//struct wland_sdio     *bus     = sdiodev->bus;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+	if (state) {
+		fws->stats.bus_flow_block++;
+	}
+
+	for (i = 0; i < WLAND_MAX_IFS; i++) {
+		if (drvr->iflist[i]) {
+			if (state)
+				netif_stop_queue(drvr->iflist[i]->ndev);
+			else
+				netif_wake_queue(drvr->iflist[i]->ndev);
+		}
+	}
+}
+
+int wland_bus_start(struct device *dev)
+{
+	int ret = -EINVAL, i;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_private *drvr = bus_if->drvr;
+	struct wland_if *ifp = NULL;
+	u8 device_role = check_role_mode();
+
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_if *p2p_ifp = NULL;
+#endif /* WLAND_P2P_SUPPORT */
+
+#ifdef USE_MAC_FROM_RDA_NVRAM
+	u8 mac_addr[ETH_ALEN];
+#else
+	u8 mac_addr[ETH_ALEN] = { 0x59, 0x95, 0x4c, 0x33, 0x22, 0x11 };
+#endif /* USE_MAC_FROM_RDA_NVRAM */
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	if (!bus_if) {
+		WLAND_ERR("bus if empty!\n");
+		return -EINVAL;
+	}
+#if defined(USE_MAC_FROM_RDA_NVRAM)
+	ret = wlan_read_mac_from_nvram(mac_addr);
+	if (ret) {
+		WLAND_ERR("nvram:get a random ether address\n");
+		random_ether_addr(mac_addr);
+		if (ret == -EINVAL)
+			wlan_write_mac_to_nvram(mac_addr);
+	} else {
+		if (!is_valid_ether_addr(mac_addr)) {
+			mac_addr[0] &= 0xfe;	/* clear multicast bit */
+			mac_addr[0] |= 0x02;	/* set local assignment bit (IEEE802) */
+			WLAND_ERR("nvram:get an invalid ether addr\n");
+		}
+	}
+#else
+	for (i = 0; i < 6; i++) {
+		if (macaddr[i] != 0)
+			break;
+	}
+	if (i == 6) {
+		random_ether_addr(mac_addr);
+	} else {
+		for (i = 0; i < 6; i++) {
+			mac_addr[i] = macaddr[i] & 0xff;
+		}
+	}
+	mac_addr[0] &= 0xfe;	/* clear multicast bit */
+	mac_addr[0] |= 0x02;	/* set local assignment bit (IEEE802) */
+#endif
+	/*
+	 * add primary networking interface
+	 */
+	ifp = wland_add_if(drvr, 0, 0, "wlan%d", mac_addr);
+
+	if (IS_ERR(ifp)) {
+		WLAND_ERR("wland_add_if failed!\n");
+		return PTR_ERR(ifp);
+	}
+
+#ifdef WLAND_P2P_SUPPORT
+	temp_addr[0] |= 0x02;
+	temp_addr[4] ^= 0x80;
+
+	if (drvr->p2p_enable)
+		p2p_ifp = wland_add_if(drvr, 1, 0, "p2p%d", temp_addr);
+	else
+		p2p_ifp = NULL;
+
+	if (IS_ERR(p2p_ifp))
+		p2p_ifp = NULL;
+#endif /* WLAND_P2P_SUPPORT */
+
+	ret = wland_fws_init(drvr);
+	if (ret < 0)
+		goto out;
+
+	wland_fws_add_interface(ifp);
+
+#if defined(WLAND_CFG80211_SUPPORT)
+	drvr->config = cfg80211_attach(drvr, bus_if->dev);
+	if (!drvr->config) {
+		WLAND_ERR("cfg80211_attach failed\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+#elif defined(WLAND_WEXT_SUPPORT)
+	/* Attach and link in the iw */
+	if (iwext_attach(drvr, bus_if->dev) != 0) {
+		WLAND_ERR("iwext_attach failed\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+#endif /* WLAND_CFG80211_SUPPORT */
+
+	ret = netdev_attach(ifp);
+	if (ret < 0) {
+		WLAND_ERR("netdev attach,failed:%d\n", ret);
+		goto out;
+	}
+
+#ifdef WLAND_P2P_SUPPORT
+	if (drvr->p2p_enable && p2p_ifp) {
+		if (netdev_p2p_attach(p2p_ifp) < 0) {
+			WLAND_ERR("p2p attach failed: %d.\n", ret);
+			drvr->p2p_enable = false;
+			ret = -EBADE;
+			goto netdev_p2p_attach_fail;
+		}
+	}
+#endif /* WLAND_P2P_SUPPORT */
+
+	ret = wland_start_chip(ifp, device_role);
+	if (ret < 0) {
+		WLAND_ERR("failed to start up chip\n");
+		goto start_chip_fail;
+	}
+
+
+
+start_chip_fail:
+
+#ifdef WLAND_P2P_SUPPORT
+	if (ret<0 && p2p_ifp && p2p_ifp->ndev) {
+		WLAND_ERR("free_netdev p2p_ifp->ndev\n");
+		unregister_netdev(p2p_ifp->ndev);
+		drvr->iflist[1] = NULL;
+	}
+netdev_p2p_attach_fail:
+#endif /* WLAND_P2P_SUPPORT */
+
+	if (ret<0 && ifp && ifp->ndev) {
+		WLAND_ERR("unregister netdev.\n");
+		unregister_netdev(ifp->ndev);
+		drvr->iflist[0] = NULL;
+	}
+
+out:
+	if (ret < 0) {
+		bus_if->state = WLAND_BUS_DOWN;
+		if (drvr->config) {
+			WLAND_ERR("cfg80211_detach\n");
+			cfg80211_detach(drvr->config);
+		}
+
+		if (drvr->fws) {
+			WLAND_ERR("wland_fws_deinit\n");
+			wland_fws_del_interface(ifp);
+			wland_fws_deinit(drvr);
+		}
+
+
+		if (drvr->iflist[0]) {
+			free_netdev(drvr->iflist[0]->ndev);
+			drvr->iflist[0] = NULL;
+		}
+#ifdef WLAND_P2P_SUPPORT
+		if (drvr->iflist[1]) {
+			free_netdev(drvr->iflist[1]->ndev);
+			drvr->iflist[1] = NULL;
+		}
+#endif /* WLAND_P2P_SUPPORT */
+
+		wland_registration_sem_up(false);
+	} else {
+		/* notify insmod ko ok */
+		wland_registration_sem_up(true);
+	}
+
+	WLAND_DBG(BUS, TRACE, "Done.(ret=%d)\n", ret);
+	return ret;
+}
+
+void wland_rx_frames(struct device *dev, struct sk_buff *skb)
+{
+	s32 ifidx = 0;
+	struct wland_bus *bus_if;
+	struct wland_private *drvr;
+	struct wland_if *ifp;
+
+	/*
+	 * process and remove protocol-specific header
+	 */
+	int ret;
+
+	WLAND_DBG(BUS, TRACE, "Enter,%s,count:%u\n", dev_name(dev), skb->len);
+
+	/*
+	 * setup receive data
+	 */
+	bus_if = dev_get_drvdata(dev);
+	drvr = bus_if->drvr;
+	ret = wland_proto_hdrpull(drvr, &ifidx, skb);
+	ifp = drvr->iflist[ifidx];
+
+	if (ret || !ifp || !ifp->ndev) {
+		if ((ret != -ENODATA) && ifp)
+			ifp->stats.rx_errors++;
+		WLAND_ERR("RX error!\n");
+		wland_pkt_buf_free_skb(skb);
+	} else {
+		wland_netif_rx(ifp, skb);
+	}
+
+	WLAND_DBG(BUS, TRACE, "Done,%s: count:%u\n", dev_name(dev), skb->len);
+}
+
+void wland_txcomplete(struct device *dev, struct sk_buff *txp, bool success)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_private *drvr = bus_if->drvr;
+	struct wland_if *ifp;
+	struct ethhdr *eh;
+	s32 ifidx = 0;
+	u16 type;
+	int res;
+
+	WLAND_DBG(BUS, TRACE, "Enter,success:%d\n", success);
+
+	res = wland_proto_hdrpull(drvr, &ifidx, txp);
+	ifp = drvr->iflist[ifidx];
+	if (!ifp)
+		goto done;
+
+	if (res == 0) {
+		eh = (struct ethhdr *) (txp->data);
+		type = ntohs(eh->h_proto);
+
+		WLAND_DBG(BUS, TRACE, "type:%d\n", type);
+
+		if (type == ETH_P_PAE) {
+			atomic_dec(&ifp->pend_8021x_cnt);
+			if (waitqueue_active(&ifp->pend_8021x_wait))
+				wake_up(&ifp->pend_8021x_wait);
+		}
+	}
+	if (!success)
+		ifp->stats.tx_errors++;
+done:
+	wland_pkt_buf_free_skb(txp);
+
+	WLAND_DBG(BUS, TRACE, "Done\n");
+}
+
+int wland_bus_active(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	int ret = -1;
+
+	/*
+	 * Bring up the bus
+	 */
+	ret = wland_bus_init(bus_if);
+	if (ret < 0) {
+		WLAND_ERR("bus init failed %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+int wland_bus_attach(uint bus_hdrlen, struct device *dev)
+{
+	int ret = 0;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_private *drvr = NULL;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	/*
+	 * Allocate primary wland_info
+	 */
+	drvr = osl_malloc(bus_if->osh, sizeof(struct wland_private));
+	if (!drvr) {
+		WLAND_ERR("Drvr Malloc Failed!\n");
+		return -ENOMEM;
+	}
+
+	memset(drvr, '\0', sizeof(struct wland_private));
+
+	mutex_init(&drvr->proto_block);
+
+	/*
+	 * Link to bus module
+	 */
+	drvr->hdrlen = bus_hdrlen;
+	drvr->bus_if = bus_if;
+
+#ifdef WLAND_P2P_SUPPORT
+	drvr->p2p_enable = true;
+#endif /*WLAND_P2P_SUPPORT */
+
+	/*
+	 * setup chip sleep flag
+	 */
+#ifdef WLAND_POWER_MANAGER
+	drvr->sleep_flags = WLAND_SLEEP_ENABLE | WLAND_SLEEP_PREASSO;
+#endif /*WLAND_POWER_MANAGER */
+
+	bus_if->drvr = drvr;
+
+	/*
+	 * create device debugfs folder
+	 */
+	wland_debugfs_attach(drvr);
+
+	/*
+	 * Attach and link in the protocol
+	 */
+	ret = wland_proto_attach(drvr);
+	if (ret < 0) {
+		WLAND_ERR("proto_attach failed\n");
+		goto fail;
+	}
+
+	/*
+	 * attach firmware event handler
+	 */
+	wland_fweh_attach(drvr);
+
+	WLAND_DBG(BUS, TRACE, "Done\n");
+
+	return ret;
+
+fail:
+	wland_bus_detach(dev);
+
+	return ret;
+}
+
+void wland_bus_detach(struct device *dev)
+{
+	s32 i;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_private *drvr = bus_if->drvr;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	if (!dev) {
+		WLAND_ERR("Not Found Dev!\n");
+		return;
+	}
+
+	if (!drvr) {
+		WLAND_ERR("Not Found Private Val!\n");
+		return;
+	}
+
+	/*
+	 * stop firmware event handling
+	 */
+	wland_fweh_detach(drvr);
+
+	/*
+	 * make sure primary interface removed last
+	 */
+	for (i = WLAND_MAX_IFS - 1; i > -1; i--) {
+		if (drvr->iflist[i]) {
+			wland_fws_del_interface(drvr->iflist[i]);
+			wland_del_if(drvr, i);
+		}
+	}
+
+	/*
+	 * Stop the bus module
+	 */
+	if (drvr)
+		wland_bus_stop(drvr->bus_if);
+
+	if (drvr->prot)
+		wland_proto_detach(drvr);
+
+	wland_fws_deinit(drvr);
+
+	wland_debugfs_detach(drvr);
+
+	bus_if->drvr = NULL;
+
+	osl_free(bus_if->osh, drvr, sizeof(struct wland_private));
+
+	WLAND_DBG(BUS, TRACE, "Done\n");
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.h
new file mode 100644
index 000000000000..fc166025b4a6
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_bus.h
@@ -0,0 +1,153 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLAND_BUS_H_
+#define _WLAND_BUS_H_
+
+#define BUS_WAKE(bus) \
+	do { \
+		(bus)->idlecount = 0; \
+	} while (0)
+
+#define WAKE_TX_WORK(bus) \
+	do { \
+	    atomic_inc(&(bus)->tx_dpc_tskcnt); \
+		queue_work((bus)->wland_txwq, &(bus)->TxWork); \
+	} while (0)
+
+#define WAKE_RX_WORK(bus) \
+	do { \
+	    atomic_inc(&(bus)->rx_dpc_tskcnt); \
+		queue_work((bus)->wland_rxwq, &(bus)->RxWork); \
+	} while (0)
+
+/* The level of bus communication with the chip */
+enum wland_bus_state {
+	WLAND_BUS_DOWN,		/* Not ready for frame transfers    */
+	WLAND_BUS_LOAD,		/* Download access only (CPU reset)
+				 * But this state not used in RDA WIFI chip
+				 */
+	WLAND_BUS_DATA		/* Ready for frame transfers        */
+};
+
+/*
+ * struct wland_bus_ops - bus callback operations.
+ *
+ * @init    : prepare for communication with dongle.
+ * @stop    : clear pending frames, disable data flow.
+ * @txdata  : send a data frame to the dongle. When the data
+ *	has been transferred, the common driver must be
+ *	notified using wland_txcomplete(). The common
+ *	driver calls this function with interrupts disabled.
+ * @txctl   : transmit a control request message to dongle.
+ * @rxctl   : receive a control response message from dongle.
+ * @gettxq  : obtain a reference of bus transmit queue (optional).
+ *
+ * This structure provides an abstract interface towards the
+ * bus specific driver. For control messages to common driver
+ * will assure there is only one active transaction. Unless
+ * indicated otherwise these callbacks are mandatory.
+ */
+struct wland_bus_ops {
+	int (*init) (struct device * dev);
+	void (*stop) (struct device * dev);
+	int (*txdata) (struct device * dev, struct sk_buff * skb);
+	int (*txctl) (struct device * dev, u8 * msg, uint len);
+	int (*rxctl) (struct device * dev, u8 * msg, uint len);
+	struct pktq *(*gettxq) (struct device * dev);
+};
+
+/*
+ * struct wland_bus - interface structure between common and bus layer
+ *
+ * @bus_priv:   pointer to private bus device.
+ * @dev:        device pointer of bus device.
+ * @drvr:       public driver information.
+ * @state:      operational state of the bus interface.
+ * @dstats:     dongle-based statistical data.
+ * @chip:       device identifier of the dongle chip.
+ */
+struct wland_bus {
+	union {
+		struct wland_sdio_dev *sdio;
+		struct wland_usb_dev *usb;
+	} bus_priv;
+	struct device *dev;
+	struct osl_info *osh;	/* OSL handle */
+	struct wland_private *drvr;
+	struct wland_bus_ops *ops;
+	enum wland_bus_state state;
+	u32 chip;
+};
+
+/* callback wrappers:txrx data to sdio or usb device interface */
+static inline int wland_bus_init(struct wland_bus *bus)
+{
+	return bus->ops->init(bus->dev);
+}
+
+static inline void wland_bus_stop(struct wland_bus *bus)
+{
+	bus->ops->stop(bus->dev);
+}
+
+static inline int wland_bus_txdata(struct wland_bus *bus, struct sk_buff *skb)
+{
+	return bus->ops->txdata(bus->dev, skb);
+}
+
+static inline int wland_bus_txctl(struct wland_bus *bus, u8 * msg, uint len)
+{
+	return bus->ops->txctl(bus->dev, msg, len);
+}
+
+static inline int wland_bus_rxctl(struct wland_bus *bus, u8 * msg, uint len)
+{
+	return bus->ops->rxctl(bus->dev, msg, len);
+}
+
+static inline struct pktq *wland_bus_gettxq(struct wland_bus *bus)
+{
+	if (!bus->ops->gettxq)
+		return ERR_PTR(-ENOENT);
+
+	return bus->ops->gettxq(bus->dev);
+}
+
+/* Receive frame for delivery to OS.  Callee disposes of rxp. */
+extern void wland_rx_frames(struct device *dev, struct sk_buff *skb);
+
+/* Indication from bus module regarding presence/insertion of dongle. */
+extern int wland_bus_attach(uint bus_hdrlen, struct device *dev);
+
+/* Indication from bus module regarding removal/absence of dongle */
+extern void wland_bus_detach(struct device *dev);
+
+/* Indication from bus module to change flow-control state */
+extern void wland_txflowcontrol(struct device *dev, bool state);
+
+/* Notify the bus has transferred the tx packet to firmware */
+extern void wland_txcomplete(struct device *dev, struct sk_buff *txp,
+	bool success);
+
+/* Start Bus */
+extern int wland_bus_start(struct device *dev);
+
+/* Active Bus */
+extern int wland_bus_active(struct device *dev);
+
+#endif /* _WLAND_BUS_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.c
new file mode 100644
index 000000000000..51451a1299c6
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.c
@@ -0,0 +1,6698 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+#include <net/netlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_trap.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+#include <wland_android.h>
+
+#define CHAN2G(_channel, _freq, _flags) {	    \
+	.band			  = IEEE80211_BAND_2GHZ,    \
+	.center_freq	  = (_freq),			    \
+	.hw_value		  = (_channel),			    \
+	.flags			  = (_flags),			    \
+	.max_antenna_gain = 0,				        \
+	.max_power		  = 30,				        \
+}
+
+#ifdef WLAND_5GRF_SUPPORT
+#define CHAN5G(_channel, _flags) {				\
+	.band			  = IEEE80211_BAND_5GHZ,	\
+	.center_freq	  = 5000 + (5 * (_channel)),\
+	.hw_value		  = (_channel),			    \
+	.flags			  = (_flags),			    \
+	.max_antenna_gain = 0,				        \
+	.max_power		  = 30,				        \
+}
+#endif /* WLAND_5GRF_SUPPORT */
+
+#define RATE_TO_BASE100KBPS(rate)               (((rate) * 10) / 2)
+
+#define RATETAB_ENT(_rateid, _flags){            \
+	.bitrate      = RATE_TO_BASE100KBPS(_rateid),\
+	.hw_value     = (_rateid),                   \
+	.flags        = (_flags),                    \
+}
+
+static struct ieee80211_rate __wl_rates[] = {
+	RATETAB_ENT(WLAND_RATE_1M, 0),
+	RATETAB_ENT(WLAND_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLAND_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLAND_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(WLAND_RATE_6M, 0),
+	RATETAB_ENT(WLAND_RATE_9M, 0),
+	RATETAB_ENT(WLAND_RATE_12M, 0),
+	RATETAB_ENT(WLAND_RATE_18M, 0),
+	RATETAB_ENT(WLAND_RATE_24M, 0),
+	RATETAB_ENT(WLAND_RATE_36M, 0),
+	RATETAB_ENT(WLAND_RATE_48M, 0),
+	RATETAB_ENT(WLAND_RATE_54M, 0),
+};
+
+#define wl_a_rates		(__wl_rates + 4)
+#define wl_a_rates_size	8
+#define wl_g_rates		(__wl_rates + 0)
+#define wl_g_rates_size	12
+
+static struct ieee80211_channel __wl_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+#ifdef WLAND_5GRF_SUPPORT
+static struct ieee80211_channel __wl_5ghz_a_channels[] = {
+	CHAN5G(34, 0), CHAN5G(36, 0),
+	CHAN5G(38, 0), CHAN5G(40, 0),
+	CHAN5G(42, 0), CHAN5G(44, 0),
+	CHAN5G(46, 0), CHAN5G(48, 0),
+	CHAN5G(52, 0), CHAN5G(56, 0),
+	CHAN5G(60, 0), CHAN5G(64, 0),
+	CHAN5G(100, 0), CHAN5G(104, 0),
+	CHAN5G(108, 0), CHAN5G(112, 0),
+	CHAN5G(116, 0), CHAN5G(120, 0),
+	CHAN5G(124, 0), CHAN5G(128, 0),
+	CHAN5G(132, 0), CHAN5G(136, 0),
+	CHAN5G(140, 0), CHAN5G(149, 0),
+	CHAN5G(153, 0), CHAN5G(157, 0),
+	CHAN5G(161, 0), CHAN5G(165, 0),
+	CHAN5G(184, 0), CHAN5G(188, 0),
+	CHAN5G(192, 0), CHAN5G(196, 0),
+	CHAN5G(200, 0), CHAN5G(204, 0),
+	CHAN5G(208, 0), CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+#endif /* WLAND_5GRF_SUPPORT */
+
+static struct ieee80211_supported_band __wl_band_2ghz = {
+	.band = IEEE80211_BAND_2GHZ,
+	.channels = __wl_2ghz_channels,
+	.n_channels = ARRAY_SIZE(__wl_2ghz_channels),
+	.bitrates = wl_g_rates,
+	.n_bitrates = wl_g_rates_size,
+};
+
+#ifdef WLAND_5GRF_SUPPORT
+static struct ieee80211_supported_band __wl_band_5ghz_a = {
+	.band = IEEE80211_BAND_5GHZ,
+	.channels = __wl_5ghz_a_channels,
+	.n_channels = ARRAY_SIZE(__wl_5ghz_a_channels),
+	.bitrates = wl_a_rates,
+	.n_bitrates = wl_a_rates_size,
+};
+#endif /* WLAND_5GRF_SUPPORT */
+
+/* This is to override regulatory domains defined in cfg80211 module (reg.c)
+ * By default world regulatory domain defined in reg.c puts the flags
+ * NL80211_RRF_PASSIVE_SCAN and NL80211_RRF_NO_IBSS for 5GHz channels (for
+ * 36..48 and 149..165). With respect to these flags, wpa_supplicant doesn't
+ * start p2p operations on 5GHz channels. All the changes in world regulatory
+ * domain are to be done here.
+ */
+static const struct ieee80211_regdomain wland_regdom = {
+	.n_reg_rules = 4,
+	.alpha2 = "99",
+	.reg_rules = {
+			/*
+			 * IEEE 802.11b/g, channels 1..11
+			 */
+			REG_RULE(2412 - 10, 2472 + 10, 40, 6, 20, 0),
+			/*
+			 * If any
+			 */
+			/*
+			 * IEEE 802.11 channel 14 - Only JP enables this and for 802.11b only
+			 */
+			REG_RULE(2484 - 10, 2484 + 10, 20, 6, 20, 0),
+			/*
+			 * IEEE 802.11a, channel 36..64
+			 */
+			REG_RULE(5150 - 10, 5350 + 10, 40, 6, 20, 0),
+			/*
+			 * IEEE 802.11a, channel 100..165
+			 */
+		REG_RULE(5470 - 10, 5850 + 10, 40, 6, 20, 0),}
+};
+
+static const u32 __wl_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+#ifdef WLAND_WAPI_SUPPORT
+	WLAN_CIPHER_SUITE_SMS4
+#endif /*WLAND_WAPI_SUPPORT */
+};
+
+/* Vendor specific ie. id = 221, oui and type defines exact ie */
+struct wland_vs_tlv {
+	u8 id;
+	u8 len;
+	u8 oui[3];
+	u8 oui_type;
+};
+
+struct parsed_vndr_ie_info {
+	u8 *ie_ptr;
+	u32 ie_len;		/* total length including id & length field */
+	struct wland_vs_tlv vndrie;
+};
+
+struct parsed_vndr_ies {
+	u32 count;
+	struct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];
+};
+
+/* Quarter dBm units to mW
+ * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
+ * Table is offset so the last entry is largest mW value that fits in
+ * a u16.
+ */
+
+#define QDBM_OFFSET         153	/* Offset for first entry */
+#define QDBM_TABLE_LEN      40	/* Table size */
+
+/* Smallest mW value that will round up to the first table entry, QDBM_OFFSET.
+ * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
+ */
+#define QDBM_TABLE_LOW_BOUND 6493	/* Low bound */
+
+/* Largest mW value that will round down to the last table entry,
+ * QDBM_OFFSET + QDBM_TABLE_LEN-1.
+ * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) +
+ * mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
+ */
+#define QDBM_TABLE_HIGH_BOUND 64938	/* High bound */
+
+static const u16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+
+/* qdBm:	+0	+1	+2	+3	+4	+5	+6	+7 */
+
+/* 153: */ 6683, 7079, 7499, 7943, 8414, 8913, 9441, 10000,
+
+/* 161: */ 10593, 11220, 11885, 12589, 13335, 14125, 14962, 15849,
+
+/* 169: */ 16788, 17783, 18836, 19953, 21135, 22387, 23714, 25119,
+
+/* 177: */ 26607, 28184, 29854, 31623, 33497, 35481, 37584, 39811,
+
+/* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
+};
+
+#ifdef WLAND_RSSIAVG_SUPPORT
+static struct wland_rssi_cache_ctrl g_rssi_cache_ctrl;
+
+//static struct wland_rssi_cache_ctrl g_rssi2_cache_ctrl;
+#endif /* WLAND_RSSIAVG_SUPPORT */
+#ifdef WLAND_BSSCACHE_SUPPORT
+static struct wland_bss_cache_ctrl g_bss_cache_ctrl;
+#endif /* WLAND_BSSCACHE_SUPPORT */
+
+static u16 wland_qdbm_to_mw(u8 qdbm)
+{
+	uint factor = 1;
+	int idx = qdbm - QDBM_OFFSET;
+
+	if (idx >= QDBM_TABLE_LEN)
+		/*
+		 * clamp to max u16 mW value
+		 */
+		return 0xFFFF;
+
+	/*
+	 * scale the qdBm index up to the range of the table 0-40
+	 * * where an offset of 40 qdBm equals a factor of 10 mW.
+	 */
+	while (idx < 0) {
+		idx += 40;
+		factor *= 10;
+	}
+
+	/*
+	 * return the mW value scaled down to the correct factor of 10,
+	 * * adding in factor/2 to get proper rounding.
+	 */
+	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
+}
+
+static u8 wland_mw_to_qdbm(u16 mw)
+{
+	u8 qdbm;
+	int offset;
+	uint mw_uint = mw;
+	uint boundary;
+
+	/*
+	 * handle boundary case
+	 */
+	if (mw_uint <= 1)
+		return 0;
+
+	offset = QDBM_OFFSET;
+
+	/*
+	 * move mw into the range of the table
+	 */
+	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
+		mw_uint *= 10;
+		offset -= 40;
+	}
+
+	for (qdbm = 0; qdbm < QDBM_TABLE_LEN - 1; qdbm++) {
+		boundary =
+			nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm + 1] -
+			nqdBm_to_mW_map[qdbm]) / 2;
+		if (mw_uint < boundary)
+			break;
+	}
+
+	qdbm += (u8) offset;
+
+	return qdbm;
+}
+
+u16 channel_to_chanspec(struct wland_d11inf * d11inf,
+	struct ieee80211_channel * ch)
+{
+	struct wland_chan ch_inf;
+
+	ch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq);
+	ch_inf.bw = CHAN_BW_20;
+
+	d11inf->encchspec(&ch_inf);
+
+	return ch_inf.chspec;
+}
+
+static __always_inline void wland_delay(u32 ms)
+{
+	if (ms < 1000 / HZ) {
+		cond_resched();
+		mdelay(ms);
+	} else {
+		msleep(ms);
+	}
+}
+
+/* Traverse a string of 1-byte tag/1-byte length/variable-length value
+ * triples, returning a pointer to the substring whose first element matches tag
+ */
+struct wland_tlv *wland_parse_tlvs(void *buf, int buflen, uint key)
+{
+	struct wland_tlv *elt = (struct wland_tlv *) buf;
+	int totlen = buflen;
+
+	/*
+	 * find tagged parameter
+	 */
+	while (totlen >= TLV_HDR_LEN) {
+		int len = elt->len;
+
+		/*
+		 * validate remaining totlen
+		 */
+		if ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))
+			return elt;
+
+		elt = (struct wland_tlv *) ((u8 *) elt + (len + TLV_HDR_LEN));
+		totlen -= (len + TLV_HDR_LEN);
+	}
+
+	return NULL;
+}
+
+/* Is any of the tlvs the expected entry? If not update the tlvs buffer pointer/length. */
+static bool wland_tlv_has_ie(u8 * ie, u8 ** tlvs, u32 * tlvs_len, u8 * oui,
+	u32 oui_len, u8 type)
+{
+	/*
+	 * If the contents match the OUI and the type
+	 */
+	if (ie[TLV_LEN_OFF] >= oui_len + 1
+		&& !memcmp(&ie[TLV_BODY_OFF], oui, oui_len)
+		&& type == ie[TLV_BODY_OFF + oui_len]) {
+		return true;
+	}
+
+	if (tlvs == NULL)
+		return false;
+	/*
+	 * point to the next ie
+	 */
+	ie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;
+	/*
+	 * calculate the length of the rest of the buffer
+	 */
+	*tlvs_len -= (int) (ie - *tlvs);
+	/*
+	 * update the pointer to the start of the buffer
+	 */
+	*tlvs = ie;
+
+	return false;
+}
+
+static struct wland_vs_tlv *wland_find_wpaie(u8 * parse, u32 len)
+{
+	struct wland_tlv *ie;
+
+	while ((ie = wland_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {
+		if (wland_tlv_has_ie((u8 *) ie, &parse, &len, WPA_OUI,
+				TLV_OUI_LEN, WPA_OUI_TYPE))
+			return (struct wland_vs_tlv *) ie;
+	}
+	return NULL;
+}
+
+static struct wland_vs_tlv *wland_find_wpsie(u8 * parse, u32 len)
+{
+	struct wland_tlv *ie;
+
+	while ((ie = wland_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {
+		if (wland_tlv_has_ie((u8 *) ie, &parse, &len, WPA_OUI,
+				TLV_OUI_LEN, WPS_OUI_TYPE))
+			return (struct wland_vs_tlv *) ie;
+	}
+	return NULL;
+}
+
+static int send_key_to_chip(struct net_device *ndev, struct wland_wsec_key *key)
+{
+	int err;
+
+	wland_netdev_wait_pend8021x(ndev);
+
+	err = wland_fil_iovar_data_set(netdev_priv(ndev), "wsec_key", key,
+		sizeof(struct wland_wsec_key));
+	if (err)
+		WLAND_ERR("wsec_key error (%d)\n", err);
+
+	return err;
+}
+
+static bool check_vif_up(struct wland_cfg80211_vif *vif)
+{
+	if (!test_bit(VIF_STATUS_READY, &vif->sme_state)) {
+		WLAND_DBG(CFG80211, DEBUG,
+			"device is not ready : status (%lu)\n", vif->sme_state);
+		return false;
+	}
+
+	if (test_bit(VIF_STATUS_TESTING, &vif->sme_state)) {
+		WLAND_DBG(CFG80211, DEBUG,
+			"device is enter testing : status (%lu)\n",
+			vif->sme_state);
+		return false;
+	}
+
+	return true;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+static struct wireless_dev *cfg80211_add_virtual_iface(struct wiphy *wiphy,
+	const char *name,
+	enum nl80211_iftype type, u32 * flags, struct vif_params *params)
+{
+	struct wireless_dev *ndev = NULL;
+
+	WLAND_DBG(CFG80211, TRACE, "enter: %s, type %d\n", name, type);
+
+	if (!name) {
+		WLAND_ERR("name is NULL\n");
+		return ndev;
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		WLAND_ERR("Unsupported interface type\n");
+		return ndev;
+	case NL80211_IFTYPE_MONITOR:
+#ifdef WLAND_P2P_SUPPORT
+		WLAND_ERR("No more support monitor interface\n");
+		return ndev;
+#else /* WLAND_P2P_SUPPORT */
+		WLAND_ERR("No more support monitor interface\n");
+		return ndev;
+#endif /* WLAND_P2P_SUPPORT */
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return ndev;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	default:
+		return ndev;
+	}
+}
+
+#else
+struct net_device *cfg80211_add_virtual_iface(struct wiphy *wiphy,
+	char *name,
+	enum nl80211_iftype type, u32 * flags, struct vif_params *params)
+{
+
+	struct net_device *ndev = NULL;
+
+	WLAND_DBG(CFG80211, TRACE, "enter: %s, type %d\n", name, type);
+
+	if (!name) {
+		WLAND_ERR("name is NULL\n");
+		return ndev;
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		WLAND_ERR("Unsupported interface type\n");
+		return ndev;
+	case NL80211_IFTYPE_MONITOR:
+#ifdef WLAND_MONITOR_SUPPORT
+		wland_add_monitor(name, &ndev);
+		return ndev;
+#else
+		return ndev;
+#endif /*WLAND_MONITOR_SUPPORT */
+
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+#ifdef WLAND_P2P_SUPPORT
+		//return wland_p2p_add_vif(wiphy, name, type, flags, params);
+		return ndev;
+#else
+		return ndev;
+#endif /* WLAND_P2P_SUPPORT */
+	case NL80211_IFTYPE_UNSPECIFIED:
+	default:
+		return ndev;
+	}
+}
+
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+s32 wland_notify_escan_complete(struct wland_cfg80211_info * cfg,
+	struct wland_if * ifp, bool aborted, bool fw_abort)
+{
+	struct cfg80211_scan_request *scan_request;
+	struct wland_ssid_le ssid_le;
+	s32 err = 0;
+
+	memset(&ssid_le, 0, sizeof(ssid_le));
+
+	/*
+	 * clear scan request, because the FW abort can cause a second call
+	 */
+	/*
+	 * to this functon and might cause a double cfg80211_scan_done
+	 */
+	scan_request = cfg->scan_request;
+
+	cfg->scan_request = NULL;
+
+	if (timer_pending(&cfg->scan_timeout))
+		del_timer_sync(&cfg->scan_timeout);
+
+	if (fw_abort) {
+		/*
+		 * Do a scan abort to stop the driver's scan engine
+		 */
+		WLAND_DBG(CFG80211, TRACE, "ABORT scan in firmware\n");
+#if 0
+		/*
+		 * E-Scan (or anyother type) can be aborted by SCAN
+		 */
+		err = wland_start_scan_set(ifp, &ssid_le, false);
+		if (err < 0)
+			WLAND_ERR("Scan abort failed\n");
+#endif
+	}
+
+	/*
+	 * e-scan can be initiated by scheduled scan which takes precedence.
+	 */
+	if (cfg->sched_escan) {
+		WLAND_DBG(CFG80211, DEBUG, "scheduled scan completed\n");
+		cfg->sched_escan = false;
+		if (!aborted)
+			cfg80211_sched_scan_results(cfg_to_wiphy(cfg));
+	} else if (scan_request) {
+		WLAND_DBG(CFG80211, DEBUG, "ESCAN Completed scan: %s\n",
+			aborted ? "Aborted" : "Done");
+		cfg80211_scan_done(scan_request, aborted);
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Done(aborted:%d,fw_abort:%d)\n", aborted,
+		fw_abort);
+
+	return err;
+}
+
+static s32 cfg80211_del_virtual_iface(struct wiphy *wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *ndev
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	)
+{
+	struct wland_cfg80211_info *cfg = wiphy_priv(wiphy);
+
+#if   LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct net_device *ndev = wdev->netdev;
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wireless_dev *wdev = &(ifp->vif->wdev);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+	/*
+	 * vif event pending in firmware
+	 */
+	if (wland_cfg80211_vif_event_armed(cfg))
+		return -EBUSY;
+
+	if (ndev) {
+		if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)
+			&& cfg->scan_info.ifp == netdev_priv(ndev))
+			wland_notify_escan_complete(cfg, netdev_priv(ndev),
+				true, true);
+	}
+
+	switch (wdev->iftype) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_MESH_POINT:
+		return -EOPNOTSUPP;
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	case NL80211_IFTYPE_P2P_DEVICE:
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+#ifdef WLAND_P2P_SUPPORT
+		return wland_p2p_del_vif(wiphy, wdev);
+#else /* WLAND_P2P_SUPPORT */
+		return -EOPNOTSUPP;
+#endif /* WLAND_P2P_SUPPORT */
+	case NL80211_IFTYPE_UNSPECIFIED:
+	default:
+		return -EINVAL;
+	}
+	return -EOPNOTSUPP;
+}
+
+static s32 cfg80211_change_virtual_iface(struct wiphy *wiphy,
+	struct net_device *ndev,
+	enum nl80211_iftype type, u32 * flags, struct vif_params *params)
+{
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_cfg80211_info *cfg = wiphy_priv(wiphy);
+#endif /* WLAND_P2P_SUPPORT */
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_vif *vif = ifp->vif;
+	s32 infra = 0, ap = 0, err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter, type:%d\n", type);
+	switch (type) {
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		ap = 1;
+		WLAND_ERR("type (%d) : currently we do not support this type\n",
+			type);
+		break;
+		return -EOPNOTSUPP;
+	case NL80211_IFTYPE_ADHOC:
+		vif->mode = WL_MODE_IBSS;
+		infra = 0;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_STATION:
+		/*
+		 * Ignore change for p2p IF. Unclear why supplicant does this
+		 */
+		if ((vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ||
+			(vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)) {
+			WLAND_DBG(CFG80211, TRACE, "Ignoring cmd for p2p if\n");
+			/*
+			 * WAR: It is unexpected to get a change of VIF for P2P IF, but it happens.
+			 * * The request can not be handled but returning EPERM causes a crash. Returning 0
+			 * * without setting ieee80211_ptr->iftype causes trace (WARN_ON) but it works with wpa_supplicant
+			 */
+			return 0;
+		}
+		vif->mode = WL_MODE_BSS;
+		infra = 1;
+		break;
+
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_P2P_GO:
+		vif->mode = WL_MODE_AP;
+		ap = 1;
+		break;
+	default:
+		err = -EINVAL;
+		goto done;
+	}
+
+	WLAND_DBG(CFG80211, TRACE,
+		"Enter,ndev:%p,type:%d,ap:%d,infra:%d,vif->mode:%d\n", ndev,
+		type, ap, infra, vif->mode);
+
+	if (ap) {
+		if (type == NL80211_IFTYPE_P2P_GO) {
+			WLAND_DBG(CFG80211, TRACE, "IF Type = P2P GO\n");
+#ifdef WLAND_P2P_SUPPORT
+			err = wland_p2p_ifchange(cfg, FIL_P2P_IF_GO);
+#else /* WLAND_P2P_SUPPORT */
+			err = 0;
+#endif /* WLAND_P2P_SUPPORT */
+		}
+		if (!err) {
+			set_bit(VIF_STATUS_AP_CREATING, &vif->sme_state);
+			WLAND_DBG(CFG80211, TRACE, "IF Type = AP\n");
+		}
+	} else {
+		err = wland_fil_iovar_data_set(ifp, "set_infra", &infra,
+			sizeof(infra));
+		if (err < 0) {
+			WLAND_ERR("SET_INFRA error (%d)\n", err);
+			err = -EAGAIN;
+			goto done;
+		}
+		WLAND_DBG(CFG80211, TRACE, "IF Type = %s\n",
+			(vif->mode == WL_MODE_IBSS) ? "Adhoc" : "Infra");
+	}
+	ndev->ieee80211_ptr->iftype = type;
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 wland_run_escan(struct wland_cfg80211_info *cfg,
+	struct wland_if *ifp, struct cfg80211_scan_request *request, u16 action)
+{
+	struct wland_ssid_le ssid_le;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, DEBUG, "E-SCAN START(request->n_ssids:%d), Enter\n",
+		request->n_ssids);
+
+	memset(&ssid_le, 0, sizeof(ssid_le));
+
+	if (request->ssids && request->n_ssids) {
+		ssid_le.SSID_len = cpu_to_le32(request->ssids[0].ssid_len);
+
+		memcpy(ssid_le.SSID, request->ssids[0].ssid,
+			request->ssids[0].ssid_len);
+	}
+
+	/*
+	 * in our platform just only support one hid ssid
+	 */
+	err = wland_start_scan_set(ifp, &ssid_le, true);
+	if (err < 0)
+		WLAND_ERR("SCAN error (%d)\n", err);
+
+	/*
+	 * Arm scan timeout timer
+	 */
+	if(ifp->drvr->bus_if->chip == WLAND_VER_91_F)
+		mod_timer(&cfg->scan_timeout,
+			jiffies + msecs_to_jiffies(SCAN_TIMER_INTERVAL_MS_91F));
+	else
+		mod_timer(&cfg->scan_timeout,
+			jiffies + msecs_to_jiffies(SCAN_TIMER_INTERVAL_MS));
+
+	WLAND_DBG(CFG80211, TRACE, "E-SCAN START, Done\n");
+	return err;
+}
+
+static s32 wland_do_escan(struct wland_cfg80211_info *cfg, struct wiphy *wiphy,
+	struct wland_if *ifp, struct cfg80211_scan_request *request)
+{
+	struct escan_info *escan = &cfg->scan_info;
+
+	escan->ifp = ifp;
+	escan->wiphy = wiphy;
+	escan->escan_state = SCAN_STATE_SCANNING;
+
+	return escan->run(cfg, ifp, request, SCAN_ACTION_START);
+}
+
+static s32 cfg80211_scan(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	struct net_device *ndev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct cfg80211_scan_request *request)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wland_cfg80211_vif *vif =
+		container_of(request->wdev, struct wland_cfg80211_vif, wdev);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct wland_cfg80211_vif *vif =
+		((struct wland_if *) netdev_priv(ndev))->vif;
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct wland_if *ifp = vif->ifp;
+	struct cfg80211_ssid *ssids = NULL;
+	struct wland_cfg80211_scan_req *sr = &cfg->scan_req_int;
+	s32 err = 0, SSID_len;
+	bool escan_req;
+
+	if (!check_vif_up(vif))
+		return -EIO;
+
+	while (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)) {
+		WLAND_DBG(CFG80211, DEBUG,
+			"Scanning already: status (%lu)\n", cfg->scan_status);
+		msleep(100);
+	}
+	if (test_bit(SCAN_STATUS_ABORT, &cfg->scan_status)) {
+		WLAND_ERR("Scanning being aborted: status (%lu)\n",
+			cfg->scan_status);
+		return -EAGAIN;
+	}
+	if (test_bit(SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+		WLAND_ERR("Scanning suppressed: status (%lu)\n",
+			cfg->scan_status);
+		return -EAGAIN;
+	}
+	if (test_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state)) {
+		WLAND_ERR("In Connecting(status %lu), scan return.\n",
+			ifp->vif->sme_state);
+		return -EAGAIN;
+	}
+#ifdef WLAND_P2P_SUPPORT
+	/*
+	 * If scan req comes for p2p0, send it over primary I/F
+	 */
+	if (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)
+		vif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+#endif /* WLAND_P2P_SUPPORT */
+	escan_req = false;
+
+	if (request) {
+		/*
+		 * scan bss
+		 */
+		ssids = request->ssids;
+		escan_req = true;
+	} else {
+		/*
+		 * scan in ibss
+		 */
+		/*
+		 * we don't do escan in ibss
+		 */
+	}
+
+	WLAND_DBG(CFG80211, DEBUG,
+		"START scan bss:%d,ssids->ssid_len:%d,request->n_ssids:%d, ssids->ssid=%s\n",
+		escan_req, ssids->ssid_len, request->n_ssids, ssids->ssid);
+#ifdef WLAND_INIT_SCAN_SUPPORT
+	if (atomic_read(&cfg->init_scan) == 0) {
+		// init scan
+		atomic_set(&cfg->init_scan, 1);
+	} else if (atomic_read(&cfg->init_scan) == 1) {
+		// first scan from wpa_supplicant
+		atomic_set(&cfg->init_scan, 2);
+		WLAND_DBG(CFG80211, DEBUG, "first time scan report\n");
+		cfg->scan_request = request;
+		schedule_work(&cfg->scan_report_work);
+#ifdef WLAND_P2P_SUPPORT
+		if (wland_p2p_scan_finding_common_channel(cfg, NULL))
+			return 0;
+#endif /* WLAND_P2P_SUPPORT */
+		return 0;
+	} else {
+		cfg->scan_request = request;
+	}
+#else
+		cfg->scan_request = request;
+#endif
+	set_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+
+	if (escan_req) {
+		cfg->scan_info.run = wland_run_escan;
+#ifdef WLAND_P2P_SUPPORT
+		err = wland_p2p_scan_prep(wiphy, request, vif);
+		if (err < 0) {
+			clear_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+			if (timer_pending(&cfg->scan_timeout))
+				del_timer_sync(&cfg->scan_timeout);
+			cfg->scan_request = NULL;
+			return err;
+		}
+#endif /* WLAND_P2P_SUPPORT */
+	} else {
+		WLAND_DBG(CFG80211, TRACE, "ssid \"%s\", ssid_len (%d)\n",
+			ssids->ssid, ssids->ssid_len);
+
+		memset(&sr->ssid_le, 0, sizeof(sr->ssid_le));
+		SSID_len = min_t(u8, sizeof(sr->ssid_le.SSID), ssids->ssid_len);
+		sr->ssid_le.SSID_len = cpu_to_le32(0);
+
+		if (SSID_len) {
+			memcpy(sr->ssid_le.SSID, ssids->ssid, SSID_len);
+			sr->ssid_le.SSID_len = cpu_to_le32(SSID_len);
+		} else {
+			WLAND_DBG(CFG80211, TRACE, "Broadcast scan\n");
+		}
+	}
+
+	err = wland_do_escan(cfg, wiphy, vif->ifp, request);
+	if (err < 0){
+//		err = 0;
+		//goto scan_out;
+		clear_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+		if (timer_pending(&cfg->scan_timeout))
+			del_timer_sync(&cfg->scan_timeout);
+		cfg->scan_request = NULL;
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return 0;
+}
+
+static s32 cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct net_device *ndev = cfg_to_ndev(cfg);
+	struct wland_if *ifp = netdev_priv(ndev);
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD
+		&& (cfg->conf->rts_threshold != wiphy->rts_threshold)) {
+		cfg->conf->rts_threshold = wiphy->rts_threshold;
+		err = wland_fil_set_cmd_data(ifp, WID_RTS_THRESHOLD,
+			&cfg->conf->rts_threshold,
+			sizeof(cfg->conf->rts_threshold));
+		if (err < 0)
+			goto done;
+	}
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD
+		&& (cfg->conf->frag_threshold != wiphy->frag_threshold)) {
+		cfg->conf->frag_threshold = wiphy->frag_threshold;
+		err = wland_fil_set_cmd_data(ifp, WID_FRAG_THRESHOLD,
+			&cfg->conf->frag_threshold,
+			sizeof(cfg->conf->frag_threshold));
+		if (err < 0)
+			goto done;
+	}
+
+	if (changed & WIPHY_PARAM_RETRY_LONG
+		&& (cfg->conf->retry_long != wiphy->retry_long)) {
+		cfg->conf->retry_long = wiphy->retry_long;
+		err = wland_fil_set_cmd_data(ifp, WID_LONG_RETRY_LIMIT,
+			&cfg->conf->retry_long, sizeof(cfg->conf->retry_long));
+		if (err < 0)
+			goto done;
+	}
+
+	if (changed & WIPHY_PARAM_RETRY_SHORT
+		&& (cfg->conf->retry_short != wiphy->retry_short)) {
+		cfg->conf->retry_short = wiphy->retry_short;
+		err = wland_fil_set_cmd_data(ifp, WID_SHORT_RETRY_LIMIT,
+			&cfg->conf->retry_short,
+			sizeof(cfg->conf->retry_short));
+		if (err < 0)
+			goto done;
+	}
+
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return err;
+}
+
+static void wland_link_down(struct wland_cfg80211_vif *vif)
+{
+	s32 err = 0;
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);
+	struct wland_scb_val_le scbval;
+	struct wland_cfg80211_profile *profile = ndev_to_prof(cfg->conn_info.ndev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (test_bit(VIF_STATUS_CONNECTED, &vif->sme_state)) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Call WLC_DISASSOC to stop excess roaming\n ");
+
+		memset(&scbval, '\0', sizeof(scbval));
+		memcpy(&scbval.ea, &profile->bssid, ETH_ALEN);
+		err = wland_disconnect_bss(vif->ifp, &scbval);
+		if (!err) {
+			WLAND_ERR("DISASSOC from AP success!\n");
+			cfg80211_disconnected(vif->wdev.netdev, 0, NULL, 0,
+				GFP_KERNEL);
+		}
+
+		clear_bit(VIF_STATUS_CONNECTED, &vif->sme_state);
+	}
+	clear_bit(VIF_STATUS_CONNECTING, &vif->sme_state);
+	clear_bit(SCAN_STATUS_SUPPRESS, &cfg->scan_status);
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	wland_btcoex_set_mode(vif, BTCOEX_ENABLED, 0);
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+}
+
+static s32 cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_ibss_params *params)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_join_params join_params;
+	size_t join_params_size = 0;
+	s32 err = 0, wsec = 0, bcnprd;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	if (params->ssid) {
+		WLAND_DBG(CFG80211, TRACE, "SSID: %s\n", params->ssid);
+	} else {
+		WLAND_DBG(CFG80211, TRACE, "SSID: NULL, Not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	set_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+
+	if (params->bssid)
+		WLAND_DBG(CFG80211, TRACE, "BSSID: %pM\n", params->bssid);
+	else
+		WLAND_DBG(CFG80211, TRACE, "No BSSID specified\n");
+
+#if     LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	if (params->chandef.chan)
+		WLAND_DBG(CFG80211, TRACE, "channel: %d\n",
+			params->chandef.chan->center_freq);
+	else
+		WLAND_DBG(CFG80211, TRACE, "no channel specified\n");
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+	if (params->channel_fixed)
+		WLAND_DBG(CFG80211, TRACE, "fixed channel required\n");
+	else
+		WLAND_DBG(CFG80211, TRACE, "no fixed channel required\n");
+
+	if (params->ie && params->ie_len)
+		WLAND_DBG(CFG80211, TRACE, "ie len: %d\n", params->ie_len);
+	else
+		WLAND_DBG(CFG80211, TRACE, "no ie specified\n");
+
+	if (params->beacon_interval)
+		WLAND_DBG(CFG80211, TRACE, "beacon interval: %d\n",
+			params->beacon_interval);
+	else
+		WLAND_DBG(CFG80211, TRACE, "no beacon interval specified\n");
+
+	if (params->basic_rates)
+		WLAND_DBG(CFG80211, TRACE, "basic rates: %08X\n",
+			params->basic_rates);
+	else
+		WLAND_DBG(CFG80211, TRACE, "no basic rates specified\n");
+
+	if (params->privacy)
+		WLAND_DBG(CFG80211, TRACE, "privacy required\n");
+	else
+		WLAND_DBG(CFG80211, TRACE, "no privacy required\n");
+
+	/*
+	 * Configure Privacy for starter
+	 */
+	if (params->privacy)
+		wsec |= WEP_ENABLED;
+
+	err = wland_fil_iovar_data_set(ifp, "wsec", &wsec, sizeof(wsec));
+	if (err) {
+		WLAND_ERR("wsec failed (%d)\n", err);
+		goto done;
+	}
+
+	/*
+	 * Configure Beacon Interval for starter
+	 */
+	if (params->beacon_interval)
+		bcnprd = params->beacon_interval;
+	else
+		bcnprd = 100;
+
+	err = wland_fil_iovar_data_set(ifp, "set_bcnprd", &bcnprd,
+		sizeof(bcnprd));
+	if (err < 0) {
+		WLAND_ERR("WLC_SET_BCNPRD failed (%d)\n", err);
+		goto done;
+	}
+
+	/*
+	 * Configure required join parameter
+	 */
+	memset(&join_params, 0, sizeof(struct wland_join_params));
+
+	/*
+	 * SSID
+	 */
+	profile->ssid.SSID_len = min_t(u32, params->ssid_len, 32);
+
+	memcpy(profile->ssid.SSID, params->ssid, profile->ssid.SSID_len);
+	memcpy(join_params.ssid_le.SSID, params->ssid, profile->ssid.SSID_len);
+
+	join_params.ssid_le.SSID_len = cpu_to_le32(profile->ssid.SSID_len);
+	join_params_size = sizeof(join_params.ssid_le);
+
+	/*
+	 * BSSID
+	 */
+	if (params->bssid) {
+		memcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);
+		join_params_size =
+			sizeof(join_params.ssid_le) +
+			(sizeof(struct wland_assoc_params_le) - sizeof(u16));
+		memcpy(profile->bssid, params->bssid, ETH_ALEN);
+	} else {
+		memset(join_params.params_le.bssid, 0xFF, ETH_ALEN);
+		memset(profile->bssid, 0, ETH_ALEN);
+	}
+
+#if     LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	/*
+	 * Channel
+	 */
+	if (params->chandef.chan) {
+		u32 target_channel;
+
+		cfg->channel =
+			ieee80211_frequency_to_channel(params->chandef.
+			chan->center_freq);
+
+		if (params->channel_fixed) {
+			/*
+			 * adding chanspec
+			 */
+			u16 chanspec = channel_to_chanspec(&cfg->d11inf,
+				params->chandef.chan);
+
+			join_params.params_le.chanspec_list[0] =
+				cpu_to_le16(chanspec);
+			join_params.params_le.chanspec_num = cpu_to_le32(1);
+			join_params_size += sizeof(join_params.params_le);
+		}
+
+		/*
+		 * set channel for starter
+		 */
+		target_channel = cfg->channel;
+		err = wland_fil_iovar_data_set(ifp, "set_channel",
+			&target_channel, sizeof(target_channel));
+		if (err < 0) {
+			WLAND_ERR("WLC_SET_CHANNEL failed (%d)\n", err);
+			goto done;
+		}
+	} else {
+		cfg->channel = 0;
+	}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	cfg->ibss_starter = false;
+
+	err = wland_fil_iovar_data_set(ifp, "set_ssid", &join_params,
+		join_params_size);
+	if (err < 0) {
+		WLAND_ERR("WLC_SET_SSID failed (%d)\n", err);
+		goto done;
+	}
+
+done:
+	if (err)
+		clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return err;
+}
+
+static s32 cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	wland_link_down(ifp->vif);
+
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+
+	return 0;
+}
+
+static s32 wland_wakeup_connect_worker(struct wland_cfg80211_connect_info
+	*conn_info);
+static s32 cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_connect_params *sme)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_cfg80211_connect_info *conn_info = &cfg->conn_info;
+	struct ieee80211_channel *chan = sme->channel;
+	u16 chanspec;
+	s32 err = 0;
+	u8 *pcgroup_encrypt_val = NULL, *pccipher_group = NULL, *pcwpa_version =
+		NULL;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	if (!sme->ssid) {
+		WLAND_ERR("Invalid ssid\n");
+		return -EOPNOTSUPP;
+	}
+
+	while (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)) {
+		WLAND_DBG(CFG80211, DEBUG,
+			"Scanning : status (%lu)\n", cfg->scan_status);
+		msleep(200);
+	}
+
+	if (cfg->in_disconnecting) {
+		cfg->in_waiting = true;
+		wait_for_completion_timeout(&cfg->disconnecting_wait,
+			msecs_to_jiffies(2 * 1000));
+	}
+	cfg->in_waiting = false;
+
+	memset(profile, '\0', sizeof(struct wland_cfg80211_profile));
+	memcpy(profile->bssid, sme->bssid, ETH_ALEN);
+	profile->valid_bssid = true;
+
+	WLAND_DBG(CFG80211, TRACE,
+		"sme->ssid:%s, sme->bssid:%pM, sme->channel:%d\n", sme->ssid,
+		sme->bssid,
+		ieee80211_frequency_to_channel(sme->channel->center_freq));
+	WLAND_DBG(CFG80211, TRACE,
+		"sme->auth_type:%d, sme->ie_len:%d, sme->key_len:%d\n",
+		sme->auth_type, sme->ie_len, sme->key_len);
+	WLAND_DBG(CFG80211, TRACE, "############# begin connect......\n");
+	set_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+
+	if (timer_pending(&conn_info->connect_restorework_timeout)) {
+		del_timer_sync(&conn_info->connect_restorework_timeout);
+		WLAND_DBG(CFG80211, TRACE, "###### delete connect restorework timer\n");
+	}
+
+#ifdef WLAND_P2P_SUPPORT
+	if (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif) {
+		struct wland_tlv *rsn_ie;
+		struct wland_vs_tlv *wpa_ie;
+		void *ie;
+		u32 ie_len;
+
+		WLAND_DBG(CFG80211, TRACE,
+			"A normal (non P2P) connection request setup\n");
+		/*
+		 * A normal (non P2P) connection request setup.
+		 */
+		ie = NULL;
+		ie_len = 0;
+		/*
+		 * find the WPA_IE
+		 */
+		wpa_ie = wland_find_wpaie((u8 *) sme->ie, sme->ie_len);
+		if (wpa_ie) {
+			ie = wpa_ie;
+			ie_len = wpa_ie->len + TLV_HDR_LEN;
+		} else {
+			/*
+			 * find the RSN_IE
+			 */
+			rsn_ie = wland_parse_tlvs((u8 *) sme->ie, sme->ie_len,
+				WLAN_EID_RSN);
+			if (rsn_ie) {
+				ie = rsn_ie;
+				ie_len = rsn_ie->len + TLV_HDR_LEN;
+			}
+		}
+		wland_fil_iovar_data_set(ifp, "wpaie", ie, ie_len);
+	}
+#endif /* WLAND_P2P_SUPPORT */
+
+	err = wland_fil_set_mgmt_ie(ifp, sme->ie, sme->ie_len);
+	if (err < 0) {
+		WLAND_ERR("Set Assoc REQ IE Failed\n");
+		goto done;
+	}
+
+	if (chan) {
+		cfg->channel =
+			ieee80211_frequency_to_channel(chan->center_freq);
+		chanspec = channel_to_chanspec(&cfg->d11inf, chan);
+	} else {
+		cfg->channel = 0;
+		chanspec = 0;
+	}
+
+	WLAND_DBG(CFG80211, TRACE,
+		"channel:%d, center_req:%d, chanspec:0x%04x\n", cfg->channel,
+		chan->center_freq, chanspec);
+
+	/*
+	 * 1.set wpa version
+	 */
+	profile->sec.wpa_versions = sme->crypto.wpa_versions;
+	/*
+	 * 2.set auth type
+	 */
+	profile->sec.auth_type = sme->auth_type;
+
+	WLAND_DBG(CFG80211, TRACE,
+		"setting wpa_version to 0x%0x, auth_type to 0x%0x.\n",
+		profile->sec.wpa_versions, profile->sec.auth_type);
+
+	/*
+	 * 3.set cipher
+	 */
+	profile->sec.cipher_pairwise = sme->crypto.ciphers_pairwise[0];
+	profile->sec.cipher_group = sme->crypto.cipher_group;
+
+	/*
+	 * In case of privacy, but no security and WPS then simulate setting AES. WPS-2.0 allows no security
+	 */
+	if (wland_find_wpsie(sme->ie, sme->ie_len) && sme->privacy)
+		WLAND_DBG(CFG80211, DEBUG, "privacy 0x%0x\n", sme->privacy);
+
+	WLAND_DBG(CFG80211, TRACE,
+		"setting cipher(cipher_pairwise:0x%0x, cipher_group:0x%x)\n",
+		profile->sec.cipher_pairwise, profile->sec.cipher_group);
+
+	/*
+	 * 4.set key_mgmt
+	 */
+	profile->sec.wpa_auth = sme->crypto.akm_suites[0];
+
+	WLAND_DBG(CFG80211, TRACE,
+		"setting key_mgm(n_akm_suites:0x%0x, wpa_auth:0x%x)\n",
+		sme->crypto.n_akm_suites, profile->sec.wpa_auth);
+
+	profile->sec.security = NO_ENCRYPT;
+	profile->sec.firmware_autype = OPEN_SYSTEM;
+
+	if ((sme->crypto.n_ciphers_pairwise)
+		&& (profile->sec.cipher_pairwise != NO_ENCRYPT)) {
+		/*
+		 * To determine the u8security value, first we check the group cipher suite then {in case of WPA or WPA2}
+		 * we will add to it the pairwise cipher suite(s)
+		 */
+		if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
+			if (profile->sec.cipher_pairwise ==
+				WLAN_CIPHER_SUITE_TKIP) {
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA2 | TKIP;
+				pcgroup_encrypt_val = "WPA2_TKIP";
+				pccipher_group = "TKIP";
+			} else if (profile->sec.cipher_pairwise == WLAN_CIPHER_SUITE_CCMP)	//TODO: mostafa: here we assume that any other encryption type is AES
+			{
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA2 | AES;
+				pcgroup_encrypt_val = "WPA2_AES";
+				pccipher_group = "AES";
+			} else if (profile->sec.cipher_pairwise ==
+				WLAN_CIPHER_SUITE_AES_CMAC) {
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA2 | AES;
+				pcgroup_encrypt_val = "WPA2_AES";
+				pccipher_group = "AES";
+			}
+			pcwpa_version = "WPA_VERSION_2";
+		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) {
+			if (profile->sec.cipher_pairwise ==
+				WLAN_CIPHER_SUITE_TKIP) {
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA | TKIP;
+				pcgroup_encrypt_val = "WPA_TKIP";
+				pccipher_group = "TKIP";
+			} else if (profile->sec.cipher_pairwise == WLAN_CIPHER_SUITE_CCMP)	//TODO: mostafa: here we assume that any other encryption type is AES
+			{
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA | AES;
+				pcgroup_encrypt_val = "WPA_AES";
+				pccipher_group = "AES";
+			} else if (profile->sec.cipher_pairwise ==
+				WLAN_CIPHER_SUITE_AES_CMAC) {
+				profile->sec.security =
+					ENCRYPT_ENABLED | WPA | AES;
+				pcgroup_encrypt_val = "WPA_AES";
+				pccipher_group = "AES";
+			}
+			pcwpa_version = "WPA_VERSION_1";
+		} else {
+			pcwpa_version = "Default";
+			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) {
+				profile->sec.security = ENCRYPT_ENABLED | WEP;
+				pcgroup_encrypt_val = "WEP40";
+				pccipher_group = "WLAN_CIPHER_SUITE_WEP40";
+			} else if (sme->crypto.cipher_group ==
+				WLAN_CIPHER_SUITE_WEP104) {
+				profile->sec.security =
+					ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
+				pcgroup_encrypt_val = "WEP104";
+				pccipher_group = "WLAN_CIPHER_SUITE_WEP104";
+			} else {
+				WLAND_ERR("Not supported cipher\n");
+				err = -ENOTSUPP;
+				goto done;
+			}
+
+			/*
+			 * 5.process wep key
+			 */
+			profile->wepkey_idx = sme->key_idx;
+			profile->wepkeys[sme->key_idx].len = (u32) sme->key_len;
+			profile->wepkeys[sme->key_idx].index =
+				(u32) sme->key_idx;
+
+			if (profile->wepkeys[sme->key_idx].len >
+				sizeof(profile->wepkeys[sme->key_idx].data)) {
+				WLAND_ERR("Too long key length (%u)\n",
+					profile->wepkeys[sme->key_idx].len);
+				err = -EINVAL;
+				goto done;
+			}
+
+			memcpy(profile->wepkeys[sme->key_idx].data, sme->key,
+				profile->wepkeys[sme->key_idx].len);
+
+			profile->wepkeys[sme->key_idx].flags = WL_PRIMARY_KEY;
+
+			switch (profile->sec.cipher_pairwise) {
+			case WLAN_CIPHER_SUITE_WEP40:
+				profile->wepkeys[sme->key_idx].algo =
+					CRYPTO_ALGO_WEP1;
+				break;
+			case WLAN_CIPHER_SUITE_WEP104:
+				profile->wepkeys[sme->key_idx].algo =
+					CRYPTO_ALGO_WEP128;
+				break;
+			default:
+				WLAND_ERR("Invalid algorithm (%d)\n",
+					sme->crypto.ciphers_pairwise[0]);
+				err = -EINVAL;
+				goto done;
+			}
+
+			/*
+			 * Set the new key/index
+			 */
+			WLAND_DBG(CFG80211, DEBUG,
+				"key length (%d),key index (%d),algo (%d),key \"%s\"\n",
+				profile->wepkeys[sme->key_idx].len,
+				profile->wepkeys[sme->key_idx].index,
+				profile->wepkeys[sme->key_idx].algo,
+				profile->wepkeys[sme->key_idx].data);
+
+			err = wland_fil_set_cmd_data(ifp, WID_KEY_ID,
+				&profile->wepkeys[sme->key_idx].index,
+				sizeof(u8));
+
+			if (err < 0) {
+				WLAND_ERR("WID_KEY_ID failed (%d)\n", err);
+				goto done;
+			}
+
+			err = wland_add_wep_key_bss_sta(ifp, (u8 *) sme->key,
+				(u8) sme->key_len, (u8) sme->key_idx);
+			if (err < 0) {
+				WLAND_ERR("add_wep_key failed (%d)\n", err);
+				goto done;
+			}
+		}
+	}
+
+	switch (sme->auth_type) {
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		profile->sec.firmware_autype = OPEN_SYSTEM;
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		profile->sec.firmware_autype = SHARED_KEY;
+		break;
+	default:
+		WLAND_DBG(CFG80211, DEBUG, "Automatic Authentation type = %d\n",
+			sme->auth_type);
+		break;
+	}
+
+	WLAND_DBG(CFG80211, TRACE,
+		"Group encryption value:%s, Cipher Group:%s, WPA version:%s\n",
+		pcgroup_encrypt_val, pccipher_group, pcwpa_version);
+
+	profile->ssid.SSID_len =
+		min_t(u32, (u32) sizeof(profile->ssid.SSID),
+		(u32) sme->ssid_len);
+
+	memcpy(&profile->ssid.SSID, sme->ssid, profile->ssid.SSID_len);
+
+	if (profile->ssid.SSID_len < IEEE80211_MAX_SSID_LEN)
+		profile->ssid.SSID[profile->ssid.SSID_len] = 0;
+
+	WLAND_DBG(CFG80211, TRACE,
+		"imode:0x%x, authtype:%d, bssid:%pM, SSID:\"%s\", len (%d)\n",
+		profile->sec.security, profile->sec.firmware_autype,
+		profile->bssid, profile->ssid.SSID, profile->ssid.SSID_len);
+
+	wland_wakeup_connect_worker(conn_info);
+	mod_timer(&conn_info->timer, jiffies + msecs_to_jiffies(CONNECT_TIMER_INTERVAL_MS));
+	WLAND_DBG(CFG80211, TRACE, "###### Set connect timer!\n");
+	conn_info->timer_on = true;
+	conn_info->retry_times = 0;
+
+done:
+	if (err < 0) {
+		WLAND_ERR
+			("Connect error(%d) and clear VIF_STATUS_CONNECTING.\n",
+			err);
+		clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+		if (timer_pending(&conn_info->timer)) {
+			del_timer_sync(&conn_info->timer);
+			WLAND_DBG(CFG80211, TRACE,
+				"###### delete conn_info->timer\n");
+		}
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,
+	u16 reason_code)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_scb_val_le scbval;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(Reason code:%d)\n", reason_code);
+
+	if (!check_vif_up(ifp->vif)) {
+		WLAND_ERR("check_vif_up(ifp->vif) fail and go out.\n");
+		return -EIO;
+	}
+
+	while (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)) {
+		WLAND_DBG(CFG80211, DEBUG,
+			"Scanning: status (%lu)\n", cfg->scan_status);
+		msleep(100);
+	}
+
+	cancel_work_sync(&conn_info->work);
+	if (timer_pending(&conn_info->timer)) {
+		del_timer_sync(&conn_info->timer);
+		msleep(2000);
+		WLAND_DBG(CFG80211, DEBUG, "###### delete conn_info->timer\n");
+	}
+	clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+
+	if (timer_pending(&conn_info->connect_restorework_timeout)) {
+		del_timer_sync(&conn_info->connect_restorework_timeout);
+		WLAND_DBG(CFG80211, DEBUG, "###### delete connect restoreworktimer\n");
+	}
+
+	cfg->in_disconnecting = true;
+	memcpy(&scbval.ea, &profile->bssid, ETH_ALEN);
+
+	scbval.val = (u8) (reason_code);
+
+	err = wland_disconnect_bss(ifp, &scbval);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+static s32 cfg80211_set_tx_power(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	enum nl80211_tx_power_setting type, s32 mbm)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct net_device *ndev = cfg_to_ndev(cfg);
+	struct wland_if *ifp = netdev_priv(ndev);
+	u16 txpwrmw;
+	s32 err = 0, disable = 0;
+
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	s32 dbm = MBM_TO_DBM(mbm);
+#else
+	s32 dbm = mbm;
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	switch (type) {
+	case NL80211_TX_POWER_AUTOMATIC:
+		break;
+	case NL80211_TX_POWER_LIMITED:
+	case NL80211_TX_POWER_FIXED:
+		if (dbm < 0) {
+			WLAND_ERR("TX_POWER_FIXED - dbm is negative\n");
+			err = -EINVAL;
+			goto done;
+		}
+		break;
+	default:
+		err = -EINVAL;
+		goto done;
+	}
+	/*
+	 * Make sure radio is off or on as far as software is concerned
+	 */
+	disable = RADIO_SW_DISABLE << 16;
+
+#if 0
+	err = wland_fil_iovar_data_set(ifp, "set_radio", &disable,
+		sizeof(disable));
+	if (err < 0)
+		WLAND_ERR("SET_RADIO error (%d)\n", err);
+#endif
+
+	if (dbm > 0xFFFF)
+		txpwrmw = 0xFFFF;
+	else
+		txpwrmw = (u16) dbm;
+
+	cfg->conf->tx_power = dbm;
+
+	dbm = wland_mw_to_qdbm(txpwrmw);
+
+	err = wland_fil_iovar_data_set(ifp, "qtxpower", &dbm, sizeof(dbm));
+
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done(qtxpower:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_get_tx_power(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#endif				/* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	s32 * dbm)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(cfg_to_ndev(cfg));
+	u8 result;
+	s32 err = 0, txpwrdbm = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter.\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	err = wland_fil_iovar_data_get(ifp, "qtxpower", &txpwrdbm, sizeof(s32));
+	if (err < 0) {
+		WLAND_ERR("error (%d)\n", err);
+		goto done;
+	}
+
+	result = (u8) (txpwrdbm & ~TXPWR_OVERRIDE);
+	*dbm = (s32) wland_qdbm_to_mw(result);
+
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done(dbm:%d)\n", *dbm);
+	return err;
+}
+
+static s32 cfg80211_config_default_key(struct wiphy *wiphy,
+	struct net_device *ndev, u8 key_idx, bool unicast, bool multicast)
+{
+	u32 index, wsec;
+	s32 err = 0;
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(CFG80211, TRACE, "key index (%d), Enter\n", key_idx);
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	err = wland_fil_iovar_data_get(ifp, "wsec", &wsec, sizeof(u32));
+	if (err < 0) {
+		WLAND_ERR("WLC_GET_WSEC error (%d)\n", err);
+		goto done;
+	}
+
+	if (wsec & WEP_ENABLED) {
+		/*
+		 * Just select a new current key
+		 */
+		index = key_idx;
+		err = wland_fil_iovar_data_set(ifp, "set_key_primary", &index,
+			sizeof(u32));
+		if (err < 0)
+			WLAND_ERR("error (%d)\n", err);
+	}
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return err;
+}
+
+static s32 wland_add_ptkey(struct wiphy *wiphy, struct net_device *ndev,
+	u8 key_idx, const u8 * mac_addr, struct key_params *params)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_ptkey ptkey;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter key_idx=%d, params->key_len=%d, params->cipher=0x%x\n", key_idx, params->key_len, params->cipher);
+
+	memset(&ptkey, 0, sizeof(ptkey));
+	if (!is_multicast_ether_addr(mac_addr))
+		memcpy(ptkey.ea, mac_addr, ETH_ALEN);
+
+	/*
+	 * check for key index change
+	 */
+	if (params->key_len > 0) {
+		if (params->key_len > WLAN_MAX_KEY_LEN) {
+			WLAND_ERR("Invalid key length (%d)\n", params->key_len);
+			return -EINVAL;
+		}
+
+		WLAND_DBG(CFG80211, TRACE, "Setting the key index %d\n",
+			key_idx);
+		ptkey.keyLen = params->key_len;
+		memcpy(ptkey.key, params->key, 16);
+
+		if(params->key_len > 16) {
+			WLAND_DBG(CFG80211, TRACE, "params->key_len > 16\n");
+			memcpy(ptkey.key + 16, params->key + 24, 8);
+			memcpy(ptkey.key + 24, params->key + 16, 8);
+		}
+		err = wland_fil_set_cmd_data(ifp, WID_ADD_PTK, &ptkey,
+			MIN(sizeof(ptkey), params->key_len+ETH_ALEN+1));
+		if (err < 0) {
+			WLAND_ERR("Set WID_ADD_PTK error (%d)\n", err);
+			return err;
+		}
+
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done.\n");
+	return err;
+}
+
+static s32 wland_add_rx_gtkey(struct wiphy *wiphy, struct net_device *ndev,
+	u8 key_idx, struct key_params *params)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_rx_gtkey gtkey;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter key_idx=%d, params->key_len=%d, params->cipher=0x%x\n", key_idx, params->key_len, params->cipher);
+
+	memset(&gtkey, 0, sizeof(gtkey));
+	memcpy(gtkey.ea, profile->bssid, ETH_ALEN);
+	memcpy(gtkey.keyRSC, params->seq, params->seq_len);
+	gtkey.keyIdx = key_idx;
+	gtkey.keyLen = params->key_len;
+	memcpy(gtkey.key, params->key, 16);
+	if (params->key_len > 16) {
+		WLAND_DBG(CFG80211, TRACE, "params->key_len > 16\n");
+		memcpy(gtkey.key + 16, params->key + 24, 8);
+		memcpy(gtkey.key + 24, params->key + 16, 8);
+	}
+	err = wland_fil_set_cmd_data(ifp, WID_ADD_RX_GTK, &gtkey,
+		MIN(sizeof(gtkey), params->key_len+ETH_ALEN+10));
+	if (err < 0) {
+		WLAND_ERR("Set WID_ADD_RX_GTK error (%d)\n", err);
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Done.\n");
+	return err;
+}
+
+#ifdef STRUCT_REF
+
+/**
+ * struct key_params - key information
+ *
+ * Information about a key
+ *
+ * @key: key material
+ * @key_len: length of key material
+ * @cipher: cipher suite selector
+ * @seq: sequence counter (IV/PN) for TKIP and CCMP keys, only used
+ *	with the get_key() callback, must be in little endian,
+ *	length given by @seq_len.
+ * @seq_len: length of @seq.
+ */
+struct key_params {
+	u8 *key;
+	u8 *seq;
+	int key_len;
+	int seq_len;
+	u32 cipher;
+};
+#endif /* STRUCT_REF */
+
+static s32 cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
+	u8 key_idx, bool pairwise, const u8 * mac_addr,
+	struct key_params *params)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	s32 err = 0;
+
+#if 0
+	struct wland_wsec_key key;
+	s32 val, wsec;
+	u8 keybuf[8] = { 0 };
+#endif
+	WLAND_DBG(CFG80211, DEBUG, "key index (%d),Enter\n", key_idx);
+	WLAND_DBG(CFG80211, DEBUG,
+		"Add Key(%s):\n"
+		"Pairwise: %u\n"
+		"KeyIndex: %u\n"
+		"Cipher  : %02X-%02X-%02X-%02X\n"
+		"KeyLen  : %u\n"
+		"SeqLen  : %u\n",
+		mac_addr ? "ptkey":"gtkey",
+		(unsigned int) pairwise, (unsigned int) key_idx,
+		(params->cipher >> 24) & 0xFF,
+		(params->cipher >> 16) & 0xFF,
+		(params->cipher >> 8) & 0xFF,
+		params->cipher & 0xFF, params->key_len, params->seq_len);
+
+	if (mac_addr)
+		WLAND_DUMP(TX_CTRL, mac_addr, 6, "MAddr:\n");
+
+	if (params->key_len)
+		WLAND_DUMP(TX_CTRL, params->key, params->key_len, "Key:\n");
+
+	if (params->seq_len)
+		WLAND_DUMP(TX_CTRL, params->seq, params->seq_len, "Seq:\n");
+
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	if (mac_addr)
+		return wland_add_ptkey(wiphy, ndev, key_idx, mac_addr, params);
+	else
+		return wland_add_rx_gtkey(wiphy, ndev, key_idx, params);
+
+#if 0
+	memset(&key, 0, sizeof(key));
+
+	key.len = (u32) params->key_len;
+	key.index = (u32) key_idx;
+
+	switch (params->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		key.algo = CRYPTO_ALGO_WEP1;
+		val = WEP_ENABLED;
+		WLAND_DBG(CFG80211, DEBUG, "WLAN_CIPHER_SUITE_WEP40\n");
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		key.algo = CRYPTO_ALGO_WEP128;
+		val = WEP_ENABLED;
+		WLAND_DBG(CFG80211, DEBUG, "WLAN_CIPHER_SUITE_WEP104\n");
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		if (ifp->vif->mode != WL_MODE_AP) {
+			WLAND_DBG(CFG80211, TRACE, "Swapping RX/TX MIC key\n");
+			memcpy(keybuf, &key.data[24], sizeof(keybuf));
+			memcpy(&key.data[24], &key.data[16], sizeof(keybuf));
+			memcpy(&key.data[16], keybuf, sizeof(keybuf));
+		}
+		key.algo = CRYPTO_ALGO_TKIP;
+		val = TKIP_ENABLED;
+		WLAND_DBG(CFG80211, DEBUG, "WLAN_CIPHER_SUITE_TKIP\n");
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		key.algo = CRYPTO_ALGO_AES_CCM;
+		val = AES_ENABLED;
+		WLAND_DBG(CFG80211, DEBUG, "WLAN_CIPHER_SUITE_AES_CMAC\n");
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		key.algo = CRYPTO_ALGO_AES_CCM;
+		val = AES_ENABLED;
+		WLAND_DBG(CFG80211, DEBUG, "WLAN_CIPHER_SUITE_CCMP\n");
+		break;
+#ifdef WLAND_WAPI_SUPPORT
+	case WLAN_CIPHER_SUITE_SMS4:
+		key.algo = CRYPTO_ALGO_SMS4;
+		val = SMS4_ENABLED;
+		WLAND_DBG(CFG80211, TRACE,
+			"et key to WLAN_CIPHER_SUITE_SMS4\n");
+		break;
+#endif /*WLAND_WAPI_SUPPORT */
+	default:
+		WLAND_ERR("Invalid cipher (0x%x)\n", params->cipher);
+		err = -EINVAL;
+		goto done;
+	}
+
+	if (mac_addr) {
+		WLAND_DBG(CFG80211, DEBUG, "mac_addr not empty, Done\n");
+
+		/*
+		 * Instead of bcast for ea address for default wep keys,driver needs it to be Null
+		 */
+		if (!is_multicast_ether_addr(mac_addr))
+			memcpy((char *) &key.ea, (void *) mac_addr, ETH_ALEN);
+
+		/*
+		 * check for key index change
+		 */
+		if (key.len == 0) {
+			/*
+			 * key delete
+			 */
+			err = send_key_to_chip(ndev, &key);
+			if (err)
+				WLAND_ERR("key delete error (%d)\n", err);
+		} else {
+			if (key.len > sizeof(key.data)) {
+				WLAND_ERR("Invalid key length (%d)\n", key.len);
+				return -EINVAL;
+			}
+
+			WLAND_DBG(CFG80211, DEBUG, "Setting the key index %d\n",
+				key.index);
+			memcpy(key.data, params->key, key.len);
+
+			if ((ifp->vif->mode != WL_MODE_AP)
+				&& (params->cipher == WLAN_CIPHER_SUITE_TKIP)) {
+				WLAND_DBG(CFG80211, DEBUG,
+					"Swapping RX/TX MIC key\n");
+				memcpy(keybuf, &key.data[24], sizeof(keybuf));
+				memcpy(&key.data[24], &key.data[16],
+					sizeof(keybuf));
+				memcpy(&key.data[16], keybuf, sizeof(keybuf));
+			}
+
+			/*
+			 * if IW_ENCODE_EXT_RX_SEQ_VALID set
+			 */
+			if (params->seq && params->seq_len == 6) {
+				/*
+				 * rx iv
+				 */
+				u8 *ivptr;
+
+				ivptr = (u8 *) params->seq;
+				key.rxiv.hi =
+					(ivptr[5] << 24) | (ivptr[4] << 16) |
+					(ivptr[3] << 8) | ivptr[2];
+				key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
+				key.iv_initialized = true;
+			}
+
+			err = send_key_to_chip(ndev, &key);
+			if (err)
+				WLAND_ERR("wsec_key error (%d)\n", err);
+		}
+		return err;
+	}
+
+	if (key.len > sizeof(key.data)) {
+		WLAND_ERR("Too long key length (%u)\n", key.len);
+		err = -EINVAL;
+		goto done;
+	}
+	memcpy(key.data, params->key, key.len);
+
+	key.flags = WL_PRIMARY_KEY;
+
+	err = send_key_to_chip(ndev, &key);
+	if (err)
+		goto done;
+
+	err = wland_fil_iovar_data_get(ifp, "wsec", &wsec, sizeof(wsec));
+	if (err < 0) {
+		WLAND_ERR("get wsec error (%d)\n", err);
+		goto done;
+	}
+	wsec |= val;
+	err = wland_fil_iovar_data_set(ifp, "wsec", &wsec, sizeof(wsec));
+	if (err < 0) {
+		WLAND_ERR("set wsec error (%d)\n", err);
+		goto done;
+	}
+
+done:
+#endif
+	WLAND_DBG(CFG80211, DEBUG, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
+	u8 key_idx, bool pairwise, const u8 * mac_addr)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_wsec_key key;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	return err;
+
+	if (key_idx >= DOT11_MAX_DEFAULT_KEYS) {
+		/*
+		 * we ignore this key index in this case
+		 */
+		WLAND_ERR("invalid key index (%d)\n", key_idx);
+		return -EINVAL;
+	}
+
+	memset(&key, 0, sizeof(key));
+
+	key.index = (u32) key_idx;
+	key.flags = WL_PRIMARY_KEY;
+	key.algo = CRYPTO_ALGO_OFF;
+
+	WLAND_DBG(CFG80211, TRACE, "key index (%d)\n", key_idx);
+
+	/*
+	 * Set the new key/index
+	 */
+	err = send_key_to_chip(ndev, &key);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,
+	u8 key_idx, bool pairwise, const u8 * mac_addr, void *cookie,
+	void (*callback) (void *cookie, struct key_params * params))
+{
+	struct key_params params;
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_cfg80211_security *sec;
+	s32 wsec, err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "key index (%d),Enter\n", key_idx);
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	memset(&params, 0, sizeof(params));
+
+	err = wland_fil_iovar_data_get(ifp, "wsec", &wsec, sizeof(wsec));
+	if (err) {
+		WLAND_ERR("WLC_GET_WSEC error (%d)\n", err);
+		/*
+		 * Ignore this error, may happen during DISASSOC
+		 */
+		err = -EAGAIN;
+		goto done;
+	}
+
+	if (wsec & WEP_ENABLED) {
+		sec = &profile->sec;
+		if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {
+			params.cipher = WLAN_CIPHER_SUITE_WEP40;
+			WLAND_DBG(CFG80211, TRACE, "WLAN_CIPHER_SUITE_WEP40\n");
+		} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {
+			params.cipher = WLAN_CIPHER_SUITE_WEP104;
+			WLAND_DBG(CFG80211, TRACE,
+				"WLAN_CIPHER_SUITE_WEP104\n");
+		}
+	} else if (wsec & TKIP_ENABLED) {
+		params.cipher = WLAN_CIPHER_SUITE_TKIP;
+		WLAND_DBG(CFG80211, TRACE, "WLAN_CIPHER_SUITE_TKIP\n");
+	} else if (wsec & AES_ENABLED) {
+		params.cipher = WLAN_CIPHER_SUITE_AES_CMAC;
+		WLAND_DBG(CFG80211, TRACE, "WLAN_CIPHER_SUITE_AES_CMAC\n");
+	}
+#ifdef WLAND_WAPI_SUPPORT
+	else if (wsec & SMS4_ENABLED) {
+		params.cipher = WLAN_CIPHER_SUITE_SMS4;
+		WLAND_DBG(CFG80211, TRACE, "WLAN_CIPHER_SUITE_SMS4\n");
+	}
+#endif /* WLAND_WAPI_SUPPORT */
+	else {
+		WLAND_ERR("Invalid algo (0x%x)\n", wsec);
+		err = -EINVAL;
+		goto done;
+	}
+	callback(cookie, &params);
+
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return err;
+}
+
+static s32 cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
+	struct net_device *ndev, u8 key_idx)
+{
+	WLAND_DBG(CFG80211, TRACE, "Not supported\n");
+
+	return -EOPNOTSUPP;
+}
+
+static s32 cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,
+	u8 * mac, struct station_info *sinfo)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_scb_val_le scb_val;
+	s32 rate, err = 0;
+	u8 *bssid = profile->bssid;
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter, MAC %pM\n", mac);
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	if (ifp->vif->mode == WL_MODE_AP) {
+		struct wland_sta_info_le *sta_info_le;
+		sta_info_le =
+			kmalloc(sizeof(struct wland_sta_info_le), GFP_ATOMIC);
+		if (!sta_info_le) {
+			WLAND_ERR("kmalloc sta_info_le failed\n");
+			return -1;
+		}
+
+		memcpy(sta_info_le, mac, ETH_ALEN);
+
+		err = wland_fil_iovar_data_get(ifp, "sta_info", sta_info_le,
+			sizeof(struct wland_sta_info_le));
+		if (err < 0) {
+			WLAND_ERR("GET STA INFO failed, %d\n", err);
+			kfree(sta_info_le);
+			goto done;
+		}
+
+		sinfo->filled = STATION_INFO_INACTIVE_TIME;
+
+		sinfo->inactive_time = le32_to_cpu(sta_info_le->idle) * 1000;
+
+		if (le32_to_cpu(sta_info_le->flags) & WLAND_STA_ASSOC) {
+			sinfo->filled |= STATION_INFO_CONNECTED_TIME;
+			sinfo->connected_time = le32_to_cpu(sta_info_le->in);
+		}
+		WLAND_DBG(CFG80211, TRACE,
+			"STA idle time : %d ms, connected time :%d sec\n",
+			sinfo->inactive_time, sinfo->connected_time);
+		kfree(sta_info_le);
+	} else if (ifp->vif->mode == WL_MODE_BSS) {
+		if (!test_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state)) {
+			WLAND_ERR
+				("Network is not connected and go out(sme_state=%x)\n",
+				(u32) ifp->vif->sme_state);
+			goto done;
+		}
+		if (memcmp(mac, bssid, ETH_ALEN)) {
+			WLAND_ERR
+				("Wrong Mac address cfg_mac-%pM wl_bssid-%pM\n",
+				mac, bssid);
+			goto done;
+		}
+
+		/*
+		 * Report the current tx rate
+		 */
+		err = wland_fil_iovar_data_get(ifp, "get_rate", &rate,
+			sizeof(rate));
+		if (err < 0) {
+			WLAND_ERR("Could not get rate (%d)\n", err);
+			goto done;
+		} else {
+			rate = 108;
+			sinfo->filled |= STATION_INFO_TX_BITRATE;
+			sinfo->txrate.legacy = rate * 5;
+			WLAND_DBG(CFG80211, TRACE, "Rate %d Mbps\n", rate / 2);
+		}
+		if (test_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state)) {
+			memset(&scb_val, 0, sizeof(scb_val));
+#if defined(WLAND_RSSIAVG_SUPPORT)
+			err = wl_update_connected_rssi_cache(ndev,
+				&g_rssi_cache_ctrl, &scb_val.val);
+			if (err) {
+				WLAND_ERR("Could not get rssi (%d)\n", err);
+				goto done;
+			}
+			wl_delete_dirty_rssi_cache(&g_rssi_cache_ctrl);
+			wl_reset_rssi_cache(&g_rssi_cache_ctrl);
+#else
+			err = wland_dev_get_rssi(ndev, &scb_val.val);
+#endif
+			if (err < 0) {
+				WLAND_ERR("Could not get rssi (%d)\n", err);
+				goto done;
+			} else {
+				sinfo->filled |= STATION_INFO_SIGNAL;
+				sinfo->signal = scb_val.val;
+				WLAND_DBG(CFG80211, TRACE, "RSSI %d dBm\n",
+					sinfo->signal);
+			}
+		}
+	} else {
+		err = -EPERM;
+	}
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return err;
+}
+
+static s32 cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
+	bool enabled, s32 timeout)
+{
+	s32 pm, err = 0;
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(enabled:%d,timeout:%d).\n", enabled,
+		timeout);
+	/*
+	 * Powersave enable/disable request is coming from the cfg80211 even before the interface is up.
+	 * In that scenario, driver will be storing the power save preference in cfg struct to apply this
+	 * to FW later while initializing the dongle
+	 */
+	cfg->pwr_save = enabled;
+
+	if (!check_vif_up(ifp->vif)) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Device is not ready, storing the value in cfg_info struct\n");
+		goto done;
+	}
+
+	pm = enabled ? MIN_FAST_PS : NO_POWERSAVE;
+
+	/*
+	 * Do not enable the power save after assoc if it is a p2p interface
+	 */
+	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Do not enable power save for P2P clients\n");
+		pm = NO_POWERSAVE;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "power save %s\n",
+		(pm ? "enabled" : "disabled"));
+#if 0
+	err = wland_fil_set_cmd_data(ifp, WID_POWER_MANAGEMENT, &pm,
+		sizeof(u8));
+	if (err < 0)
+		WLAND_ERR("error (%d)\n", err);
+#endif
+done:
+	WLAND_DBG(CFG80211, TRACE, "Done(ret:%d).\n", err);
+	return err;
+}
+
+static struct wland_bss_info_le *wland_alloc_bss(
+	struct wland_cfg80211_info *cfg, struct wland_bss_info_le *old)
+{
+	struct wland_bss_info_le *bss;
+
+	WLAND_DBG(CFG80211, TRACE, "allocating bss\n");
+
+        bss = kmemdup(old, sizeof(struct wland_bss_info_le), GFP_KERNEL);
+	if (!bss)
+		return ERR_PTR(-ENOMEM);
+
+	list_add_tail(&bss->list, &cfg->scan_result_list);
+	cfg->scan_results.count ++;
+
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return bss;
+}
+
+static void wland_free_bss(struct wland_cfg80211_info *cfg,
+	struct wland_bss_info_le *bss)
+{
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	list_del(&bss->list);
+	if(cfg->scan_results.count == 0)
+		WLAND_ERR("bss count error\n");
+	cfg->scan_results.count --;
+
+	if(bss->ie)
+		kfree(bss->ie);
+	kfree(bss);
+
+}
+
+static s32 wland_inform_single_bss(struct wland_cfg80211_info *cfg,
+	struct wland_bss_info_le *bi)
+{
+	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+	struct ieee80211_channel *notify_channel;
+	struct cfg80211_bss *bss;
+	struct ieee80211_supported_band *band =
+		wiphy->bands[IEEE80211_BAND_2GHZ];
+	struct wland_chan ch;
+	s32 notify_signal;
+	u16 channel;
+	u32 freq;
+	u8 *notify_ie;
+
+	struct wland_cfg80211_profile *profile = ndev_to_prof(cfg->conn_info.ndev);
+
+	if (bi->length > WLAND_BSS_INFO_MAX) {
+		WLAND_ERR("Bss info is larger than buffer. Discarding\n");
+		return 0;
+	}
+
+	if (!bi->ctl_ch) {
+		ch.chspec = bi->chanspec;
+		cfg->d11inf.decchspec(&ch);
+		bi->ctl_ch = ch.chnum;
+	}
+	channel = bi->ctl_ch;
+
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+#ifdef WLAND_5GRF_SUPPORT
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif /* WLAND_5GRF_SUPPORT */
+
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+	notify_ie = bi->ie;
+	if ((profile->valid_bssid == true)		//only to BSS of current connection, we use average RSSI in scan_result
+		&& !memcmp(profile->bssid, bi->BSSID, ETH_ALEN))
+		notify_signal = wl_get_avg_rssi(&g_rssi_cache_ctrl, bi->BSSID) * 100;
+	else
+		notify_signal = bi->RSSI * 100;
+
+	WLAND_DBG(CFG80211, TRACE,
+		"ssid:%s,Bssid:%pM,Channel:%d(%d),Capability:%X,Beacon interval:%d,Signal:%d\n",
+		bi->SSID, bi->BSSID, channel, freq, bi->capability,
+		bi->beacon_period, notify_signal);
+
+	bss = cfg80211_inform_bss(wiphy,
+		notify_channel,
+		(const u8 *) bi->BSSID,
+		0,
+		bi->capability,
+		bi->beacon_period,
+		notify_ie, (size_t) bi->ie_length, notify_signal, GFP_KERNEL);
+
+	if (!bss)
+		return -ENOMEM;
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	cfg80211_put_bss(wiphy, bss);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	cfg80211_put_bss(bss);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+	return 0;
+}
+
+static s32 wland_inform_bss(struct wland_cfg80211_info *cfg)
+{
+	struct wland_bss_info_le *bss = NULL;	/* must be initialized */
+	struct wland_bss_info_le *bss_temp = NULL;
+	s32 err = 0;
+
+#if defined(WLAND_BSSCACHE_SUPPORT)
+	int i;
+	struct wland_bss_cache *node;
+#endif
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	mutex_lock(&cfg->scan_result_lock);
+
+#if defined(WLAND_BSSCACHE_SUPPORT)
+	wl_update_bss_cache(&g_bss_cache_ctrl, &cfg->scan_result_list);
+	wl_delete_dirty_bss_cache(&g_bss_cache_ctrl);
+	wl_reset_bss_cache(&g_bss_cache_ctrl);
+#endif
+
+#if defined(WLAND_RSSIAVG_SUPPORT)
+#if defined(WLAND_BSSCACHE_SUPPORT)
+	node = g_bss_cache_ctrl.m_cache_head;
+	for (; node;) {
+		wl_update_rssi_cache(&g_rssi_cache_ctrl, &node->bss);
+		node = node->next;
+	}
+#else
+	list_for_each_entry(bss, cfg->scan_result_list, list)
+		wl_update_rssi_cache(&g_rssi_cache_ctrl, bss);
+#endif
+
+	wl_delete_dirty_rssi_cache(&g_rssi_cache_ctrl);
+	wl_reset_rssi_cache(&g_rssi_cache_ctrl);
+#endif
+
+#if defined(WLAND_BSSCACHE_SUPPORT)
+#if 0
+	if (p2p_disconnected > 0) {
+		// terence 20130703: Fix for wrong group_capab (timing issue)
+		wl_delete_disconnected_bss_cache(&g_bss_cache_ctrl,
+			(u8 *) & p2p_disconnected_bssid);
+#if defined(WLAND_RSSIAVG_SUPPORT)
+		wl_delete_disconnected_rssi_cache(&g_rssi_cache_ctrl,
+			(u8 *) & p2p_disconnected_bssid);
+#endif
+	}
+#endif
+	WLAND_DBG(CFG80211, TRACE, "Inform cached AP list\n");
+	node = g_bss_cache_ctrl.m_cache_head;
+	for (i = 0; node; i++) {
+		if (node->dirty > 1) {
+			// just inform dirty bss
+			bss = &node->bss;
+			err = wland_inform_single_bss(cfg, bss);
+		}
+		node = node->next;
+	}
+	bss = NULL;
+#endif
+
+	WLAND_DBG(CFG80211, TRACE, "scanned AP count (%d)\n", cfg->scan_results.count);
+	list_for_each_entry_safe(bss, bss_temp, &cfg->scan_result_list, list) {
+		err = wland_inform_single_bss(cfg, bss);
+		if (err < 0) {
+			WLAND_ERR
+				("wland_inform_single_bss ERROR!  (err=%d)\n",
+				err);
+			break;
+		}
+		if(time_before(bss->time,
+			jiffies - msecs_to_jiffies(SCAN_TIMER2_INTERVAL_MS))) {
+			WLAND_DBG(CFG80211, DEBUG,
+				"del bss:%s.(timeout for %d msecond)\n",
+				bss->SSID, SCAN_TIMER2_INTERVAL_MS);
+			wland_free_bss(cfg, bss);
+			continue;
+		}
+	}
+	WLAND_DBG(CFG80211, TRACE, "Report scanned AP list Done.\n");
+
+#if 0
+	if (p2p_disconnected > 0) {
+		// terence 20130703: Fix for wrong group_capab (timing issue)
+		p2p_disconnected++;
+		if (p2p_disconnected >= REPEATED_SCAN_RESULT_CNT + 1)
+			p2p_disconnected = 0;
+	}
+#endif
+	mutex_unlock(&cfg->scan_result_lock);
+
+	return err;
+}
+
+static s32 wland_inform_ibss(struct wland_cfg80211_info *cfg,
+	struct net_device *ndev, const u8 * bssid)
+{
+	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+	struct ieee80211_channel *notify_channel;
+	struct wland_bss_info_le *bi = NULL;
+	struct ieee80211_supported_band *band;
+	struct cfg80211_bss *bss;
+	struct wland_chan ch;
+	u8 *buf = NULL;
+	s32 err = 0;
+	u32 freq;
+	u8 *notify_ie;
+	s32 notify_signal;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	buf = kzalloc(WLAND_BSS_INFO_MAX, GFP_KERNEL);
+	if (buf == NULL) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	*(__le32 *) buf = cpu_to_le32(WLAND_BSS_INFO_MAX);
+
+	err = wland_fil_iovar_data_get(netdev_priv(ndev), "get_bss_info", buf,
+		WLAND_BSS_INFO_MAX);
+	if (err < 0) {
+		WLAND_ERR("WLC_GET_BSS_INFO failed: %d\n", err);
+		goto CleanUp;
+	}
+
+	bi = (struct wland_bss_info_le *) (buf + 4);
+
+	ch.chspec = le16_to_cpu(bi->chanspec);
+	cfg->d11inf.decchspec(&ch);
+
+	band = wiphy->bands[IEEE80211_BAND_2GHZ];
+#ifdef WLAND_5GRF_SUPPORT
+	if (ch.band == CHAN_BAND_5G)
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif /* WLAND_5GRF_SUPPORT */
+
+	freq = ieee80211_channel_to_frequency(ch.chnum, band->band);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+	notify_ie = bi->ie;
+	notify_signal = bi->RSSI * 100;
+
+	WLAND_DBG(CFG80211, TRACE, "channel: %d(%d)\n", ch.chnum, freq);
+	WLAND_DBG(CFG80211, TRACE, "capability: %X\n", bi->capability);
+	WLAND_DBG(CFG80211, TRACE, "beacon interval: %d\n", bi->beacon_period);
+	WLAND_DBG(CFG80211, TRACE, "signal: %d\n", notify_signal);
+
+	bss = cfg80211_inform_bss(wiphy,
+		notify_channel,
+		bssid,
+		0,
+		bi->capability,
+		bi->beacon_period,
+		notify_ie, (size_t) bi->ie_length, notify_signal, GFP_KERNEL);
+
+	if (!bss) {
+		err = -ENOMEM;
+		goto CleanUp;
+	}
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	cfg80211_put_bss(wiphy, bss);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	cfg80211_put_bss(bss);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+CleanUp:
+	kfree(buf);
+out:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+
+	return err;
+}
+
+void wland_abort_scanning(struct wland_cfg80211_info *cfg)
+{
+	struct escan_info *escan = &cfg->scan_info;
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+
+	if (timer_pending(&cfg->scan_timeout)) {
+		WLAND_DBG(CFG80211, TRACE, "del timer scan_timerout\n");
+		del_timer_sync(&cfg->scan_timeout);
+	}
+
+	cancel_work_sync(&cfg->scan_report_work);
+
+	set_bit(SCAN_STATUS_ABORT, &cfg->scan_status);
+
+	if (cfg->scan_request) {
+		escan->escan_state = SCAN_STATE_IDLE;
+		wland_notify_escan_complete(cfg, escan->ifp, true, true);
+	}
+
+	clear_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+	clear_bit(SCAN_STATUS_ABORT, &cfg->scan_status);
+
+	WLAND_DBG(CFG80211, DEBUG, "Done\n");
+}
+
+static void cfg80211_scan_report_worker(struct work_struct *work)
+{
+	struct wland_cfg80211_info *cfg =
+		container_of(work, struct wland_cfg80211_info,
+		scan_report_work);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	wland_notify_escan_complete(cfg, cfg->scan_info.ifp, false, true);
+}
+
+static void wland_scan_timeout(ulong data)
+{
+	struct wland_cfg80211_info *cfg = (struct wland_cfg80211_info *) data;
+	struct wland_event_msg event;
+
+	memset(&event, '\0', sizeof(struct wland_event_msg));
+
+	event.event_code = WLAND_E_ESCAN_RESULT;
+	event.status = STATUS_TIMEOUT;
+
+	firmweh_push_event(cfg->pub, &event, NULL);
+	if (cfg->scan_request) {
+		WLAND_DBG(CFG80211, DEBUG, "timer expired, schedule_work scan_report_work\n");
+		schedule_work(&cfg->scan_report_work);
+#ifdef WLAND_P2P_SUPPORT
+		if (wland_p2p_scan_finding_common_channel(cfg, NULL))
+			return 0;
+#endif /* WLAND_P2P_SUPPORT */
+	}
+}
+
+static s32 wland_wakeup_connect_worker(struct wland_cfg80211_connect_info
+	*conn_info)
+{
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+	WLAND_DBG(CFG80211, DEBUG, "wake up connect\n");
+	queue_work(conn_info->connect_wq, &conn_info->work);
+	WLAND_DBG(CFG80211, DEBUG, "Done.\n");
+	return 0;
+}
+
+static void wland_connect_timer(unsigned long data)
+{
+	struct wland_cfg80211_connect_info *conn_info =
+		(struct wland_cfg80211_connect_info *) data;
+	struct wland_cfg80211_info *cfg =
+		container_of(conn_info, struct wland_cfg80211_info, conn_info);
+	struct net_device *ndev = cfg_to_ndev(cfg);
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+	if (test_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state)) {
+		WLAND_DBG(CFG80211, ERROR, "VIF_STATUS_CONNECTED\n");
+		return ;
+	}
+
+	if (conn_info) {
+		conn_info->timer_on = false;
+		conn_info->retry_times++;
+
+		if (conn_info->retry_times < CONNECT_RETRY_TIMES_MAX) {
+			WLAND_DBG(CFG80211, TRACE,
+				"conn_info->timer expired and mod another timer! retry_times=%d\n",
+				conn_info->retry_times);
+			wland_wakeup_connect_worker(conn_info);
+			mod_timer(&conn_info->timer,
+				jiffies + msecs_to_jiffies(CONNECT_TIMER_INTERVAL_MS));
+			conn_info->timer_on = true;
+		} else {
+			WLAND_DBG(CFG80211, INFO,
+				"conn_info->timer expired reached max times %d!! leave connecting\n",
+				conn_info->retry_times);
+			test_and_clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+		}
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done.\n");
+}
+
+static void wland_cfg80211_connect_worker(struct work_struct *work)
+{
+	struct wland_cfg80211_connect_info *conn_info =
+		container_of(work, struct wland_cfg80211_connect_info, work);
+	//struct wland_cfg80211_info *cfg = (struct wland_cfg80211_info *)conn_info->data;
+	int err = -1;
+
+	struct wland_if *ifp = netdev_priv(conn_info->ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(conn_info->ndev);
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter conn_ctrl->timer_on=%d\n",
+		conn_info->timer_on);
+
+	WLAND_DBG(CFG80211, DEBUG, "Really do start join AP!\n");
+
+	//try to connect WEP_AP with shared_key or open_system
+	if (profile->sec.security & (WEP | WEP_EXTENDED)) {
+		if (profile->sec.firmware_autype == OPEN_SYSTEM)
+			profile->sec.firmware_autype = SHARED_KEY;
+		else
+			profile->sec.firmware_autype = OPEN_SYSTEM;
+	}
+
+	err = wland_start_join(ifp, profile);
+	if (err)
+		WLAND_ERR("wland_start_join failed (%d)\n", err);
+
+	WLAND_DBG(CFG80211, DEBUG, "Done.\n");
+}
+
+static void wland_connect_restorework_timeout(ulong data)
+{
+	struct wland_cfg80211_connect_info *conn_info =
+		(struct wland_cfg80211_connect_info *) data;
+
+	WLAND_DBG(CFG80211, TRACE, "restorework timer expired\n");
+	schedule_work(&conn_info->connect_restorework_timeout_work);
+}
+
+static void cfg80211_connect_restorework_timeout_worker(struct work_struct *work)
+{
+	struct wland_cfg80211_connect_info *conn_info =
+		container_of(work, struct wland_cfg80211_connect_info,
+		connect_restorework_timeout_work);
+	struct wland_if *ifp = netdev_priv(conn_info->ndev);
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+	if (timer_pending(&conn_info->connect_restorework_timeout)) {
+		del_timer_sync(&conn_info->connect_restorework_timeout);
+		WLAND_DBG(CFG80211, TRACE, "###### delete connect restoreworktimer\n");
+	}
+
+	wland_assoc_power_save(ifp->drvr);
+	//restore tx rate
+	wland_set_txrate(ifp, 0);
+
+	WLAND_DBG(CFG80211, TRACE, "Done.\n");
+}
+
+static s32 wland_init_connect_info(struct wland_cfg80211_info *cfg)
+{
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+	int err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	conn_info->ndev = cfg_to_ndev(cfg);
+	init_timer(&conn_info->timer);
+	conn_info->timer.data = (unsigned long) conn_info;
+	conn_info->timer.function = wland_connect_timer;
+	conn_info->timer_on = false;
+	INIT_WORK(&conn_info->work, wland_cfg80211_connect_worker);
+
+	init_timer(&conn_info->connect_restorework_timeout);
+	conn_info->connect_restorework_timeout.data = (unsigned long) conn_info;
+	conn_info->connect_restorework_timeout.function =
+		wland_connect_restorework_timeout;
+	INIT_WORK(&conn_info->connect_restorework_timeout_work,
+		cfg80211_connect_restorework_timeout_worker);
+
+	conn_info->data = cfg;
+
+	conn_info->connect_wq = create_singlethread_workqueue("connect_wq");
+	if (!conn_info->connect_wq) {
+		WLAND_ERR("insufficient memory to create txworkqueue.\n");
+		err = -1;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Exit\n");
+	return err;
+}
+
+static s32 wland_deinit_connect_info(struct wland_cfg80211_info *cfg)
+{
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+	int err = 0;
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+
+	if (timer_pending(&conn_info->timer)) {
+		del_timer_sync(&conn_info->timer);
+		WLAND_DBG(CFG80211, TRACE, "###### delete conn_info->timer\n");
+	}
+	if (timer_pending(&conn_info->connect_restorework_timeout)) {
+		del_timer_sync(&conn_info->connect_restorework_timeout);
+		WLAND_DBG(CFG80211, TRACE, "###### delete conn_info->connect_restorework_timeout\n");
+	}
+	cancel_work_sync(&conn_info->work);
+	if (conn_info->connect_wq)
+		destroy_workqueue(conn_info->connect_wq);
+
+	WLAND_DBG(CFG80211, DEBUG, "Exit\n");
+	return err;
+}
+
+static bool compare_update_same_bss(struct wland_cfg80211_info *cfg,
+	struct wland_bss_info_le *bss, struct wland_bss_info_le *new_bss)
+{
+	struct list_head *p_next, *p_prev;
+#ifdef WLAND_TBD_SUPPORT
+	struct wland_chan ch_bss, ch_bss_info_le;
+	ch_bss.chspec = bss->chanspec;
+	cfg->d11inf.decchspec(&ch_bss);
+	ch_bss_info_le.chspec = new_bss->chanspec;
+	cfg->d11inf.decchspec(&ch_bss_info_le);
+
+	/*
+	 * A network is only a duplicate if the channel, BSSID, and ESSID
+	 * * all match.  We treat all <hidden> with the same BSSID and channel
+	 * * as one network
+	 */
+	if (!compare_ether_addr(bss->BSSID, new_bss->BSSID) &&
+		ch_bss.band == ch_bss_info_le.band &&
+		new_bss->SSID_len == bss->SSID_len &&
+		!memcmp(new_bss->SSID, bss->SSID, new_bss->SSID_len))
+#else /*WLAND_TBD_SUPPORT */
+	if (((bss->ctl_ch == new_bss->ctl_ch) &&
+			!compare_ether_addr(bss->BSSID, new_bss->BSSID) &&
+			new_bss->SSID_len == bss->SSID_len &&
+			!memcmp(bss->SSID, new_bss->SSID, new_bss->SSID_len)))
+#endif /*WLAND_TBD_SUPPORT */
+	{
+		//If the network in list, then update it.
+		/*
+		 * preserve max RSSI if the measurements are both on-channel or both off-channel
+		 */
+		if(bss->ie)
+			kfree(bss->ie);
+
+		p_next = bss->list.next;
+		p_prev= bss->list.prev;
+		memcpy(bss, new_bss, sizeof(struct wland_bss_info_le));
+		bss->list.next = p_next;
+		bss->list.prev= p_prev;
+
+		return true;
+	}
+	return false;
+}
+
+void ParseNetworkInfo(struct wland_bss_info_le *bi, u8 * pu8MsgBuffer)
+{
+	u8 u8MsgType = 0, u8MsgID = 0, u8index = 0;
+	u16 u16MsgLen = 0, u16WidID = 0, u16WidLen = 0, u16MsaLen;
+	u8 *pu8WidVal, *pbuf;
+
+	u8MsgType = pu8MsgBuffer[0];
+
+	/*
+	 * Check whether the received message type is 'N'
+	 */
+	if (('N' != u8MsgType) || (!bi)) {
+		WLAND_ERR("Received Message format incorrect.\n");
+		return;
+	}
+
+	/*
+	 * Extract message ID
+	 */
+	u8MsgID = pu8MsgBuffer[1];
+
+	/*
+	 * Extract message Length
+	 */
+	u16MsgLen = MAKE_WORD16(pu8MsgBuffer[2], pu8MsgBuffer[3]);
+
+	/*
+	 * Extract WID ID
+	 */
+	u16WidID = MAKE_WORD16(pu8MsgBuffer[4], pu8MsgBuffer[5]);
+
+	/*
+	 * Extract WID Length
+	 */
+	u16WidLen = MAKE_WORD16(pu8MsgBuffer[6], pu8MsgBuffer[7]);
+
+	WLAND_DBG(CFG80211, TRACE,
+		"u8MsgID:%d, u16MsgLen:%d, u16WidID:0x%04x, u16WidLen:%d\n",
+		u8MsgID, u16MsgLen, u16WidID, u16WidLen);
+
+	/*
+	 * first byte rssi
+	 */
+#ifdef WLAND_RSSIOFFSET_SUPPORT
+	if(pu8MsgBuffer[8] < WLAND_RSSI_MAXVAL_FOR_OFFSET)
+		bi->RSSI = (signed char)(pu8MsgBuffer[8] + WLAND_RSSI_OFFSET);
+	else
+		bi->RSSI = (signed char)(pu8MsgBuffer[8]);
+#else
+	bi->RSSI = (signed char)(pu8MsgBuffer[8]);
+#endif
+	/*
+	 * Assign a pointer to the WID value
+	 */
+	pu8WidVal = &pu8MsgBuffer[9];
+
+	u16MsaLen = u16WidLen - 1;
+
+	/*
+	 * Get the cap_info
+	 */
+	bi->capability = get_cap_info(pu8WidVal);
+
+	/*
+	 * Get SSID
+	 */
+	get_ssid(pu8WidVal, bi->SSID, &(bi->SSID_len));
+
+	/*
+	 * Get BSSID
+	 */
+	get_BSSID(pu8WidVal, bi->BSSID);
+
+	/*
+	 * Get the current channel
+	 */
+	bi->ctl_ch = get_current_channel(pu8WidVal, (u16MsaLen + FCS_LEN));
+
+	pbuf = get_data_rate(pu8WidVal, (u16MsaLen + FCS_LEN),
+		WLAN_EID_SUPP_RATES, &u8index);
+	if (pbuf) {
+		bi->rateset.count = min_t(u8, MAX_RATES, u8index);
+		memcpy(bi->rateset.rates, pbuf, bi->rateset.count);
+	}
+
+	/*
+	 * Get beacon period
+	 */
+	u8index = (MAC_HDR_LEN + TIME_STAMP_LEN);
+
+	bi->beacon_period = get_beacon_period(pu8WidVal + u8index);
+
+	u8index += BEACON_INTERVAL_LEN + CAP_INFO_LEN;
+
+	/*
+	 * Get DTIM Period
+	 */
+	pbuf = get_tim_elm(pu8WidVal, (u16MsaLen + FCS_LEN), u8index);
+	if (pbuf) {
+		bi->dtim_period = pbuf[3];
+	}
+
+	pbuf = get_data_rate(pu8WidVal, (u16MsaLen + FCS_LEN),
+		WLAN_EID_EXT_SUPP_RATES, &u8index);
+	if (pbuf) {
+		if ((u8index + bi->rateset.count) < (MAX_RATES + 2)) {
+			memcpy(&bi->rateset.rates[bi->rateset.count + 1], pbuf,
+				u8index);
+			bi->rateset.count += u8index;
+		} else {
+			memcpy(&bi->rateset.rates[bi->rateset.count + 1], pbuf,
+				(MAX_RATES + 1 - bi->rateset.count));
+			bi->rateset.count = MAX_RATES + 1;
+		}
+	}
+
+	bi->ie_length = (u16MsaLen - (MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN + CAP_INFO_LEN));
+	bi->length = sizeof(struct wland_bss_info_le);
+	bi->ie = kmalloc(bi->ie_length, GFP_KERNEL);
+	if (!(bi->ie)) {
+		WLAND_ERR("failed to allocate memory\n");
+		return;
+	}
+	memcpy(bi->ie, &pu8WidVal[MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN + CAP_INFO_LEN], bi->ie_length);
+
+	WLAND_DBG(CFG80211, TRACE,
+		"bi->SSID(%s), bi->ie_length:%d, bi->ie:%p, bi->length:%d\n",
+		bi->SSID, bi->ie_length, bi->ie, bi->length);
+
+}
+
+static s32 notify_escan_handler(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_bss_info_le *bss = NULL;
+	struct wland_bss_info_le bss_info_le;
+	struct wland_bss_info_le *new_bss;
+	s32 err = 0;
+
+	if (!check_vif_up(ifp->vif)) {
+		WLAND_DBG(CFG80211, ERROR, "Device is not ready\n");
+		goto exit;
+	}
+
+	if (e->status == STATUS_SUCCESS) {
+		if (!data) {
+			WLAND_ERR("Invalid escan result (NULL pointer)\n");
+			goto exit;
+		}
+		memset(&bss_info_le, '\0', sizeof(struct wland_bss_info_le));
+		ParseNetworkInfo(&bss_info_le, (u8 *) data);
+		if (bss_info_le.ctl_ch == 0) {
+			WLAND_ERR("failed to get bss channel number\n");
+			goto exit;
+		}
+
+		/*
+		 * Skip channel-14
+		 */
+#ifdef SKIP_REPORT_CHANNEL_14
+		if (bss_info_le.ctl_ch == 14) {
+			WLAND_DBG(CFG80211, DEBUG, "Skip Report Channel 14 \n");
+			memset(&bss_info_le, '\0',
+				sizeof(struct wland_bss_info_le));
+			goto exit;
+		}
+#endif /*SKIP_REPORT_CHANNEL_14 */
+#ifdef WLAND_P2P_SUPPORT
+		if (wland_p2p_scan_finding_common_channel(cfg, bss_info_le))
+			goto exit;
+#endif /* WLAND_P2P_SUPPORT */
+
+		if (!(cfg_to_wiphy(cfg)->interface_modes &
+				BIT(NL80211_IFTYPE_ADHOC))) {
+			if (bss_info_le.capability & CAPABILITY_IBSS) {
+				WLAND_DBG(CFG80211, DEBUG,
+					"Ignoring IBSS result(SSID: %s).\n",
+					bss_info_le.SSID);
+				goto exit;
+			}
+		}
+		WLAND_DBG(CFG80211, DEBUG,
+			"Get BSS(BSSID:%pM, RSSI:%d, SSID:\"%s\")\n",
+			bss_info_le.BSSID, bss_info_le.RSSI, bss_info_le.SSID);
+
+		mutex_lock(&cfg->scan_result_lock);
+		list_for_each_entry(bss, &cfg->scan_result_list, list) {
+			if (compare_update_same_bss(cfg, bss, &bss_info_le)) {
+				bss->time = jiffies;
+				mutex_unlock(&cfg->scan_result_lock);
+				goto exit;
+			}
+		}
+
+		WLAND_DBG(CFG80211, DEBUG,
+			"list->count:%u, NewBSS(BSSID:%pM, RSSI:%d, SSID:\"%s\")\n",
+			cfg->scan_results.count, bss_info_le.BSSID,
+			bss_info_le.RSSI, bss_info_le.SSID);
+
+		bss_info_le.time = jiffies;
+
+		/*
+		 * store bss header to buf
+		 */
+		new_bss = wland_alloc_bss(cfg, &bss_info_le);
+		if (IS_ERR(new_bss)) {
+			WLAND_ERR("wland_alloc_bss error\n");
+			err = PTR_ERR(new_bss);
+		}
+		mutex_unlock(&cfg->scan_result_lock);
+
+	} else {
+		WLAND_DBG(CFG80211, TRACE,
+			"Scan Done(timeout or other reason)\n");
+
+		cfg->scan_info.escan_state = SCAN_STATE_IDLE;
+
+		if (cfg->scan_request)
+			wland_inform_bss(cfg);
+		else
+			WLAND_DBG(CFG80211, DEBUG,
+				"Ignored scan complete result 0x%x\n", e->status);
+
+		if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)) {
+			clear_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+		}
+	}
+
+exit:
+	return err;
+}
+
+static s32 cfg80211_resume(struct wiphy *wiphy)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+
+	if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status))
+		WLAND_DBG(CFG80211, TRACE, "scanning......\n");
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	return 0;
+}
+
+static s32 cfg80211_suspend(struct wiphy *wiphy
+	, struct cfg80211_wowlan *wow
+	)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct net_device *ndev = cfg_to_ndev(cfg);
+	struct wland_cfg80211_vif *vif = ndev_to_vif(ndev);
+
+	/*
+	 * if the primary net_device is not READY there is nothing we can do but pray resume goes smoothly.
+	 */
+	if (!check_vif_up(vif))
+		goto exit;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	list_for_each_entry(vif, &cfg->vif_list, list) {
+		if (!test_bit(VIF_STATUS_READY, &vif->sme_state))
+			continue;
+		/*
+		 * While going to suspend if associated with AP disassociate
+		 * from AP to save power while system is in suspended state
+		 */
+		//wland_link_down(vif);
+
+		/*
+		 * Make sure WPA_Supplicant receives all the event
+		 * * generated due to DISASSOC call to the fw to keep
+		 * * the state fw and WPA_Supplicant state consistent
+		 */
+		wland_delay(200);
+	}
+	/*
+	 * end any scanning
+	 */ if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status))
+		wland_abort_scanning(cfg);
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	/*
+	 * clear any scanning activity
+	 */
+	cfg->scan_status = 0;
+	return 0;
+}
+
+static __used s32 wland_update_pmklist(struct net_device *ndev,
+	struct wland_cfg80211_pmk_list *pmk_list, s32 err)
+{
+	int i, j;
+	int pmkid_len = le32_to_cpu(pmk_list->pmkids.npmkid);
+
+	WLAND_DBG(CFG80211, TRACE, "No of elements %d\n", pmkid_len);
+
+	for (i = 0; i < pmkid_len; i++) {
+		WLAND_DBG(CFG80211, TRACE, "PMKID[%d]: %pM =\n", i,
+			&pmk_list->pmkids.pmkid[i].BSSID);
+
+		for (j = 0; j < WLAN_PMKID_LEN; j++)
+			WLAND_DBG(CFG80211, TRACE, "%02x\n",
+				pmk_list->pmkids.pmkid[i].PMKID[j]);
+	}
+	if (!err)
+		wland_fil_iovar_data_set(netdev_priv(ndev), "pmkid_info",
+			(char *) pmk_list, sizeof(*pmk_list));
+
+	return err;
+}
+
+static s32 cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_pmksa *pmksa)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct pmkid_list *pmkids = &cfg->pmk_list->pmkids;
+	s32 err = 0;
+	int i, pmkid_len;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	pmkid_len = le32_to_cpu(pmkids->npmkid);
+
+	for (i = 0; i < pmkid_len; i++) {
+		if (!memcmp(pmksa->bssid, pmkids->pmkid[i].BSSID, ETH_ALEN))
+			break;
+	}
+	if (i < MAXPMKID) {
+		memcpy(pmkids->pmkid[i].BSSID, pmksa->bssid, ETH_ALEN);
+		memcpy(pmkids->pmkid[i].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+
+		if (i == pmkid_len) {
+			pmkid_len++;
+			pmkids->npmkid = cpu_to_le32(pmkid_len);
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",
+		pmkids->pmkid[pmkid_len].BSSID);
+
+	for (i = 0; i < WLAN_PMKID_LEN; i++)
+		WLAND_DBG(CFG80211, TRACE, "%02x\n",
+			pmkids->pmkid[pmkid_len].PMKID[i]);
+
+	err = wland_update_pmklist(ndev, cfg->pmk_list, err);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_pmksa *pmksa)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct pmkid_list pmkid;
+	s32 err = 0;
+	int i, pmkid_len;
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	memcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETH_ALEN);
+	memcpy(&pmkid.pmkid[0].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+
+	WLAND_DBG(CFG80211, TRACE,
+		"del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
+		&pmkid.pmkid[0].BSSID);
+
+	for (i = 0; i < WLAN_PMKID_LEN; i++)
+		WLAND_DBG(CFG80211, TRACE, "%02x\n", pmkid.pmkid[0].PMKID[i]);
+
+	pmkid_len = le32_to_cpu(cfg->pmk_list->pmkids.npmkid);
+
+	for (i = 0; i < pmkid_len; i++)
+		if (!memcmp(pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].BSSID,
+				ETH_ALEN))
+			break;
+
+	if ((pmkid_len > 0) && (i < pmkid_len)) {
+		memset(&cfg->pmk_list->pmkids.pmkid[i], 0,
+			sizeof(struct pmkid));
+
+		for (; i < (pmkid_len - 1); i++) {
+			memcpy(&cfg->pmk_list->pmkids.pmkid[i].BSSID,
+				&cfg->pmk_list->pmkids.pmkid[i + 1].BSSID,
+				ETH_ALEN);
+			memcpy(&cfg->pmk_list->pmkids.pmkid[i].PMKID,
+				&cfg->pmk_list->pmkids.pmkid[i + 1].PMKID,
+				WLAN_PMKID_LEN);
+		}
+		cfg->pmk_list->pmkids.npmkid = cpu_to_le32(pmkid_len - 1);
+	} else {
+		err = -EINVAL;
+	}
+
+	err = wland_update_pmklist(ndev, cfg->pmk_list, err);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+static s32 cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(ndev);
+	s32 err = 0;
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	memset(cfg->pmk_list, 0, sizeof(struct wland_cfg80211_pmk_list));
+
+	err = wland_update_pmklist(ndev, cfg->pmk_list, err);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+/*
+ * PFN result doesn't have all the info which are
+ * required by the supplicant
+ * (For e.g IEs) Do a target Escan so that sched scan results are reported
+ * via wl_inform_single_bss in the required format. Escan does require the
+ * scan request in the form of cfg80211_scan_request. For timebeing, create
+ * cfg80211_scan_request one out of the received PNO event.
+ */
+ static s32 notify_sched_scan_results(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_pno_net_info_le *netinfo, *netinfo_start;
+	struct cfg80211_scan_request *request = NULL;
+	struct cfg80211_ssid *ssid = NULL;
+	struct ieee80211_channel *channel = NULL;
+	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+	struct wland_pno_scanresults_le *pfn_result =
+		(struct wland_pno_scanresults_le *) data;
+	s32 err = 0, channel_req = 0, band = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	/*
+	 * PFN event is limited to fit 512 bytes so we may get multiple NET_FOUND events. For now place a warning here.
+	 */
+	WARN_ON(pfn_result->status != WLAND_PNO_SCAN_COMPLETE);
+
+	WLAND_DBG(CFG80211, TRACE, "PFN NET FOUND event. count: %d\n",
+		pfn_result->count);
+
+	if (pfn_result->count > 0) {
+		int i;
+
+		request = kzalloc(sizeof(*request), GFP_KERNEL);
+		ssid = kcalloc(pfn_result->count, sizeof(*ssid), GFP_KERNEL);
+		channel =
+			kcalloc(pfn_result->count, sizeof(*channel),
+			GFP_KERNEL);
+		if (!request || !ssid || !channel) {
+			err = -ENOMEM;
+			goto out_err;
+		}
+
+		request->wiphy = wiphy;
+
+		data += sizeof(struct wland_pno_scanresults_le);
+		netinfo_start = (struct wland_pno_net_info_le *) data;
+
+		for (i = 0; i < pfn_result->count; i++) {
+			netinfo = &netinfo_start[i];
+			if (!netinfo) {
+				WLAND_ERR("Invalid netinfo ptr. index: %d\n",
+					i);
+				err = -EINVAL;
+				goto out_err;
+			}
+
+			WLAND_DBG(CFG80211, TRACE, "SSID:%s Channel:%d\n",
+				netinfo->SSID, netinfo->channel);
+			memcpy(ssid[i].ssid, netinfo->SSID, netinfo->SSID_len);
+			ssid[i].ssid_len = netinfo->SSID_len;
+			request->n_ssids++;
+
+			channel_req = netinfo->channel;
+			if (channel_req <= CH_MAX_2G_CHANNEL)
+				band = NL80211_BAND_2GHZ;
+			else
+				band = NL80211_BAND_5GHZ;
+			channel[i].center_freq =
+				ieee80211_channel_to_frequency(channel_req,
+				band);
+			channel[i].band = band;
+			channel[i].flags |= IEEE80211_CHAN_NO_HT40;
+
+			request->channels[i] = &channel[i];
+			request->n_channels++;
+		}
+
+		/*
+		 * assign parsed ssid array
+		 */
+		if (request->n_ssids)
+			request->ssids = &ssid[0];
+
+		if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status))
+			/*
+			 * Abort any on-going scan
+			 */
+			wland_abort_scanning(cfg);
+
+		set_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+
+		err = wland_do_escan(cfg, wiphy, ifp, request);
+		if (err < 0) {
+			clear_bit(SCAN_STATUS_BUSY, &cfg->scan_status);
+			goto out_err;
+		}
+		cfg->sched_escan = true;
+		cfg->scan_request = request;
+	} else {
+		WLAND_ERR("false PNO Event. (pfn_count == 0)\n");
+		goto out_err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+
+	kfree(ssid);
+	kfree(channel);
+	kfree(request);
+	return 0;
+
+out_err:
+	kfree(ssid);
+	kfree(channel);
+	kfree(request);
+	cfg80211_sched_scan_stopped(wiphy);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(error)\n");
+	return err;
+}
+
+static int cfg80211_sched_scan_start(struct wiphy *wiphy,
+	struct net_device *ndev, struct cfg80211_sched_scan_request *request)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_info *cfg = wiphy_priv(wiphy);
+	struct wland_pno_net_param_le pfn;
+	int i, enable = 1, ret = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter n_match_sets:%d n_ssids:%d\n",
+		request->n_match_sets, request->n_ssids);
+
+	if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status)) {
+		WLAND_ERR("Scanning already: status (%lu)\n", cfg->scan_status);
+		return -EAGAIN;
+	}
+
+	if (test_bit(SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+		WLAND_ERR("Scanning suppressed: status (%lu)\n",
+			cfg->scan_status);
+		return -EAGAIN;
+	}
+
+	if (!request->n_ssids || !request->n_match_sets) {
+		WLAND_ERR("Invalid sched scan req!! n_ssids:%d\n",
+			request->n_ssids);
+		return -EINVAL;
+	}
+
+	if (request->n_ssids > 0) {
+		for (i = 0; i < request->n_ssids; i++) {
+			/*
+			 * Active scan req for ssids
+			 */
+			WLAND_DBG(CFG80211, TRACE,
+				">>> Active scan req for ssid (%s)\n",
+				request->ssids[i].ssid);
+			/*
+			 * match_set ssids is a supert set of n_ssid list,so we need not add these set seperately.
+			 */
+		}
+	}
+
+	if (request->n_match_sets > 0) {
+		/*
+		 * configure pno
+		 */
+		struct wland_pno_param_le pfn_param;
+
+		memset(&pfn_param, 0, sizeof(pfn_param));
+
+		pfn_param.version = cpu_to_le32(WLAND_PNO_VERSION);
+
+		/*
+		 * set extra pno params
+		 */
+		pfn_param.flags =
+			cpu_to_le16(1 << WLAND_PNO_ENABLE_ADAPTSCAN_BIT);
+		pfn_param.repeat = WLAND_PNO_REPEAT;
+		pfn_param.exp = WLAND_PNO_FREQ_EXPO_MAX;
+
+		/*
+		 * set up pno scan fr
+		 */
+		pfn_param.scan_freq = cpu_to_le32(WLAND_PNO_TIME);
+
+		ret = wland_fil_iovar_data_set(netdev_priv(ndev), "pfn_set",
+			&pfn_param, sizeof(pfn_param));
+		if (ret < 0) {
+			WLAND_ERR("PNO setup failed!! ret=%d\n", ret);
+			return -EINVAL;
+		}
+
+		/*
+		 * configure each match set
+		 */
+		for (i = 0; i < request->n_match_sets; i++) {
+			struct cfg80211_ssid *ssid =
+				&request->match_sets[i].ssid;
+			u32 ssid_len = ssid->ssid_len;
+
+			if (!ssid_len) {
+				WLAND_ERR("skip broadcast ssid\n");
+				continue;
+			}
+			pfn.auth = cpu_to_le32(AUTH_OPEN);
+			pfn.wpa_auth = cpu_to_le32(WLAND_PNO_WPA_AUTH_ANY);
+			pfn.wsec = cpu_to_le32(0);
+			pfn.infra = cpu_to_le32(1);
+			pfn.flags = cpu_to_le32(1 << WLAND_PNO_HIDDEN_BIT);
+			pfn.ssid.SSID_len = cpu_to_le32(ssid_len);
+
+			memcpy(pfn.ssid.SSID, ssid->ssid, ssid_len);
+
+			ret = wland_fil_iovar_data_set(ifp, "pfn_add", &pfn,
+				sizeof(pfn));
+
+			WLAND_DBG(CFG80211, TRACE,
+				">>> PNO filter %s for ssid (%s)\n",
+				ret == 0 ? "set" : "failed", ssid->ssid);
+		}
+
+		ret = wland_fil_iovar_data_set(ifp, "pfn", &enable, sizeof(u8));
+
+		/*
+		 * Enable the PNO
+		 */
+		if (ret < 0) {
+			WLAND_ERR("PNO enable failed!! ret=%d\n", ret);
+			ret = -EINVAL;
+		}
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int cfg80211_sched_scan_stop(struct wiphy *wiphy,
+	struct net_device *ndev)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+
+	WLAND_DBG(CFG80211, TRACE, "enter\n");
+
+	if (cfg->sched_escan)
+		wland_notify_escan_complete(cfg, netdev_priv(ndev), true, true);
+
+	return 0;
+}
+
+static bool wland_valid_wpa_oui(u8 * oui, bool is_rsn_ie)
+{
+	if (is_rsn_ie)
+		return (memcmp(oui, RSN_OUI, TLV_OUI_LEN) == 0);
+
+	return (memcmp(oui, WPA_OUI, TLV_OUI_LEN) == 0);
+}
+
+static s32 wland_configure_wpaie(struct net_device *ndev,
+	struct wland_vs_tlv *wpa_ie, bool is_rsn_ie)
+{
+	//struct wland_if               *ifp     = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	u16 count, rsn_cap;
+	s32 err = 0, len = 0;
+	u32 i, wsec = 0, pval = 0, gval = 0, wpa_auth =
+		0, offset, wme_bss_disable, auth = OPEN_SYSTEM;
+	u8 *data;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (wpa_ie == NULL)
+		goto exit;
+
+	len = wpa_ie->len + TLV_HDR_LEN;
+	data = (u8 *) wpa_ie;
+	offset = TLV_HDR_LEN;
+
+	if (!is_rsn_ie)
+		offset += VS_IE_FIXED_HDR_LEN;
+	else
+		offset += WPA_IE_VERSION_LEN;
+
+	/*
+	 * check for multicast cipher suite
+	 */
+	if (offset + WPA_IE_MIN_OUI_LEN > len) {
+		err = -EINVAL;
+		WLAND_ERR("no multicast cipher suite\n");
+		goto exit;
+	}
+
+	if (!wland_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+		err = -EINVAL;
+		WLAND_ERR("ivalid OUI\n");
+		goto exit;
+	}
+	offset += TLV_OUI_LEN;
+
+	/*
+	 * pick up multicast cipher
+	 */
+	switch (data[offset]) {
+	case WPA_CIPHER_NONE:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_NONE\n");
+		gval = 0;
+		break;
+	case WPA_CIPHER_WEP_40:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_WEP_40\n");
+	case WPA_CIPHER_WEP_104:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_WEP_104\n");
+		gval = WEP_ENABLED;
+		break;
+	case WPA_CIPHER_TKIP:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_TKIP\n");
+		gval = TKIP_ENABLED;
+		break;
+	case WPA_CIPHER_AES_CCM:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_AES_CCM\n");
+		gval = AES_ENABLED;
+		break;
+#ifdef WLAND_WAPI_SUPPORT
+	case WAPI_CIPHER_SMS4:
+		WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_NONE\n");
+		gval = SMS4_ENABLED;
+		break;
+#endif /*WLAND_WAPI_SUPPORT */
+	default:
+		err = -EINVAL;
+		WLAND_ERR("Invalid multi cast cipher info\n");
+		goto exit;
+	}
+
+	offset++;
+	/*
+	 * walk thru unicast cipher list and pick up what we recognize
+	 */
+	count = data[offset] + (data[offset + 1] << 8);
+	offset += WPA_IE_SUITE_COUNT_LEN;
+	/*
+	 * Check for unicast suite(s)
+	 */
+	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+		err = -EINVAL;
+		WLAND_ERR("no unicast cipher suite\n");
+		goto exit;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (!wland_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+			err = -EINVAL;
+			WLAND_ERR("ivalid OUI\n");
+			goto exit;
+		}
+		offset += TLV_OUI_LEN;
+		switch (data[offset]) {
+		case WPA_CIPHER_NONE:
+			WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_NONE\n");
+			break;
+		case WPA_CIPHER_WEP_40:
+			WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_WEP_40\n");
+		case WPA_CIPHER_WEP_104:
+			WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_WEP_104\n");
+			pval |= WEP_ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_TKIP\n");
+			pval |= TKIP_ENABLED;
+			break;
+		case WPA_CIPHER_AES_CCM:
+			WLAND_DBG(CFG80211, TRACE, "WPA_CIPHER_AES_CCM\n");
+			pval |= AES_ENABLED;
+			break;
+#ifdef WLAND_WAPI_SUPPORT
+		case WAPI_CIPHER_SMS4:
+			WLAND_DBG(CFG80211, TRACE, "WAPI_CIPHER_SMS4\n");
+			pval |= SMS4_ENABLED;
+			break;
+#endif /*WLAND_WAPI_SUPPORT */
+		default:
+			WLAND_ERR("Ivalid unicast security info\n");
+		}
+		offset++;
+	}
+	/*
+	 * walk thru auth management suite list and pick up what we recognize
+	 */
+	count = data[offset] + (data[offset + 1] << 8);
+	offset += WPA_IE_SUITE_COUNT_LEN;
+
+	/*
+	 * Check for auth key management suite(s)
+	 */
+	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+		err = -EINVAL;
+		WLAND_ERR("no auth key mgmt suite\n");
+		goto exit;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (!wland_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+			err = -EINVAL;
+			WLAND_ERR("ivalid OUI\n");
+			goto exit;
+		}
+		offset += TLV_OUI_LEN;
+		switch (data[offset]) {
+		case RSN_AKM_NONE:
+			WLAND_DBG(CFG80211, TRACE, "RSN_AKM_NONE\n");
+			wpa_auth |= WPA_AUTH_NONE;
+			break;
+		case RSN_AKM_UNSPECIFIED:
+			WLAND_DBG(CFG80211, TRACE, "RSN_AKM_UNSPECIFIED\n");
+			is_rsn_ie ? (wpa_auth |=
+				WPA2_AUTH_UNSPECIFIED) : (wpa_auth |=
+				WPA_AUTH_UNSPECIFIED);
+			break;
+		case RSN_AKM_PSK:
+			WLAND_DBG(CFG80211, TRACE, "RSN_AKM_PSK\n");
+			is_rsn_ie ? (wpa_auth |= WPA2_AUTH_PSK) : (wpa_auth |=
+				WPA_AUTH_PSK);
+			break;
+		default:
+			WLAND_ERR("Ivalid key mgmt info\n");
+		}
+		offset++;
+	}
+
+	if (is_rsn_ie) {
+		wme_bss_disable = 1;
+		if ((offset + RSN_CAP_LEN) <= len) {
+			rsn_cap = data[offset] + (data[offset + 1] << 8);
+			profile->rsn_cap = (rsn_cap >> 2) & 0x03;
+			WLAND_DBG(CFG80211, DEBUG, "profile->rsn_cap: 0x%02x\n",
+				profile->rsn_cap);
+			if (rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK)
+				wme_bss_disable = 0;
+		}
+#if 0
+		/*
+		 * set wme_bss_disable to sync RSN Capabilities
+		 */
+		err = wland_fil_iovar_data_set(ifp, "wme_bss_disable",
+			&wme_bss_disable, sizeof(wme_bss_disable));
+		if (err < 0) {
+			WLAND_ERR("wme_bss_disable error %d\n", err);
+			goto exit;
+		}
+#endif
+	}
+	/*
+	 * FOR WPS , set SES_OW_ENABLED
+	 */
+	wsec = (pval | gval | SES_OW_ENABLED);
+
+	//profile->sec.firmware_autype= auth;
+	//profile->sec.wpa_auth       = wpa_auth;
+	//profile->sec.auth_type      = wsec;
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Done(auth:%d,wpa_auth:%d,wsec:%d,err:%d)\n",
+		auth, wpa_auth, wsec, err);
+	return err;
+}
+
+static s32 wland_parse_vndr_ies(const u8 * vndr_ie_buf, u32 vndr_ie_len,
+	struct parsed_vndr_ies *vndr_ies)
+{
+	s32 err = 0, remaining_len;
+	struct wland_vs_tlv *vndrie;
+	struct wland_tlv *ie;
+	struct parsed_vndr_ie_info *parsed_info;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	remaining_len = (s32) vndr_ie_len;
+
+	memset(vndr_ies, 0, sizeof(*vndr_ies));
+
+	ie = (struct wland_tlv *) vndr_ie_buf;
+
+	while (ie) {
+		if (ie->id != WLAN_EID_VENDOR_SPECIFIC)
+			goto next;
+		vndrie = (struct wland_vs_tlv *) ie;
+		/*
+		 * len should be bigger than OUI length + one
+		 */
+		if (vndrie->len < (VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1)) {
+			WLAND_ERR("invalid vndr ie. length is too small %d\n",
+				vndrie->len);
+			goto next;
+		}
+
+		/*
+		 * if wpa or wme ie, do not add ie
+		 */
+		if (!memcmp(vndrie->oui, (u8 *) WPA_OUI, TLV_OUI_LEN) &&
+			((vndrie->oui_type == WPA_OUI_TYPE)
+				|| (vndrie->oui_type == WME_OUI_TYPE))) {
+			WLAND_DBG(CFG80211, TRACE,
+				"Found WPA/WME oui. Do not add it\n");
+			goto next;
+		}
+
+		parsed_info = &vndr_ies->ie_info[vndr_ies->count];
+
+		/*
+		 * save vndr ie information
+		 */
+		parsed_info->ie_ptr = (char *) vndrie;
+		parsed_info->ie_len = vndrie->len + TLV_HDR_LEN;
+
+		memcpy(&parsed_info->vndrie, vndrie, sizeof(*vndrie));
+
+		vndr_ies->count++;
+
+		WLAND_DBG(CFG80211, TRACE,
+			"** OUI %02x %02x %02x, type 0x%02x\n",
+			parsed_info->vndrie.oui[0], parsed_info->vndrie.oui[1],
+			parsed_info->vndrie.oui[2],
+			parsed_info->vndrie.oui_type);
+
+		if (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)
+			break;
+next:
+		remaining_len -= (ie->len + TLV_HDR_LEN);
+
+		if (remaining_len <= TLV_HDR_LEN)
+			ie = NULL;
+		else
+			ie = (struct wland_tlv *) (((u8 *) ie) + ie->len +
+				TLV_HDR_LEN);
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+
+	return err;
+}
+
+static u32 wland_vndr_ie(u8 * iebuf, s32 pktflag, u8 * ie_ptr, u32 ie_len,
+	s8 * add_del_cmd)
+{
+	__le32 iecount_le;
+	__le32 pktflag_le;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	strncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);
+	iebuf[VNDR_IE_CMD_LEN - 1] = '\0';
+
+	iecount_le = cpu_to_le32(1);
+
+	memcpy(&iebuf[VNDR_IE_COUNT_OFFSET], &iecount_le, sizeof(iecount_le));
+
+	pktflag_le = cpu_to_le32(pktflag);
+
+	memcpy(&iebuf[VNDR_IE_PKTFLAG_OFFSET], &pktflag_le, sizeof(pktflag_le));
+
+	memcpy(&iebuf[VNDR_IE_VSIE_OFFSET], ie_ptr, ie_len);
+
+	return ie_len + VNDR_IE_HDR_SIZE;
+}
+
+s32 wland_vif_set_mgmt_ie(struct wland_cfg80211_vif * vif, s32 pktflag,
+	const u8 * vndr_ie_buf, u32 vndr_ie_len)
+{
+	struct parsed_vndr_ies old_vndr_ies;
+	struct parsed_vndr_ies new_vndr_ies;
+	struct parsed_vndr_ie_info *vndrie_info;
+	struct wland_if *ifp;
+	struct vif_saved_ie *saved_ie;
+	s32 err = 0, i;
+	u8 *iovar_ie_buf;
+	u8 *curr_ie_buf;
+	u8 *mgmt_ie_buf = NULL;
+	int mgmt_ie_buf_len, remained_buf_len;
+	u32 *mgmt_ie_len;
+	u32 del_add_ie_buf_len = 0, total_ie_buf_len = 0, parsed_ie_buf_len = 0;
+	u8 *ptr;
+
+	if (!vif)
+		return -ENODEV;
+
+	ifp = vif->ifp;
+	saved_ie = &vif->saved_ie;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(bssidx:%d,pktflag:0x%02X)\n",
+		ifp->bssidx, pktflag);
+
+	iovar_ie_buf = kzalloc(WLAND_EXTRA_BUF_MAX, GFP_KERNEL);
+	if (!iovar_ie_buf)
+		return -ENOMEM;
+	curr_ie_buf = iovar_ie_buf;
+
+	switch (pktflag) {
+	case WLAND_VNDR_IE_PRBREQ_FLAG:
+		mgmt_ie_buf = saved_ie->probe_req_ie;
+		mgmt_ie_len = &saved_ie->probe_req_ie_len;
+		mgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);
+		break;
+	case WLAND_VNDR_IE_PRBRSP_FLAG:
+		mgmt_ie_buf = saved_ie->probe_res_ie;
+		mgmt_ie_len = &saved_ie->probe_res_ie_len;
+		mgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);
+		break;
+	case WLAND_VNDR_IE_BEACON_FLAG:
+		mgmt_ie_buf = saved_ie->beacon_ie;
+		mgmt_ie_len = &saved_ie->beacon_ie_len;
+		mgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);
+		break;
+	case WLAND_VNDR_IE_ASSOCREQ_FLAG:
+		mgmt_ie_buf = saved_ie->assoc_req_ie;
+		mgmt_ie_len = &saved_ie->assoc_req_ie_len;
+		mgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);
+		break;
+	default:
+		err = -EPERM;
+		WLAND_ERR("not suitable type\n");
+		goto exit;
+	}
+
+	if (vndr_ie_len > mgmt_ie_buf_len) {
+		err = -ENOMEM;
+		WLAND_ERR("extra IE size too big\n");
+		goto exit;
+	}
+
+	/*
+	 * parse and save new vndr_ie in curr_ie_buff before comparing it
+	 */
+	if (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {
+		ptr = curr_ie_buf;
+		wland_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);
+
+		for (i = 0; i < new_vndr_ies.count; i++) {
+			vndrie_info = &new_vndr_ies.ie_info[i];
+			memcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,
+				vndrie_info->ie_len);
+			parsed_ie_buf_len += vndrie_info->ie_len;
+		}
+	}
+
+	if (mgmt_ie_buf && *mgmt_ie_len) {
+		if (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len)
+			&& (memcmp(mgmt_ie_buf, curr_ie_buf,
+					parsed_ie_buf_len) == 0)) {
+			WLAND_DBG(CFG80211, TRACE,
+				"Previous mgmt IE equals to current IE\n");
+			goto exit;
+		}
+
+		/*
+		 * parse old vndr_ie
+		 */
+		wland_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);
+
+		/*
+		 * make a command to delete old ie
+		 */
+		for (i = 0; i < old_vndr_ies.count; i++) {
+			vndrie_info = &old_vndr_ies.ie_info[i];
+
+			WLAND_DBG(CFG80211, TRACE,
+				"DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\n",
+				vndrie_info->vndrie.id, vndrie_info->vndrie.len,
+				vndrie_info->vndrie.oui[0],
+				vndrie_info->vndrie.oui[1],
+				vndrie_info->vndrie.oui[2]);
+
+			del_add_ie_buf_len =
+				wland_vndr_ie(curr_ie_buf, pktflag,
+				vndrie_info->ie_ptr, vndrie_info->ie_len,
+				"del");
+			curr_ie_buf += del_add_ie_buf_len;
+			total_ie_buf_len += del_add_ie_buf_len;
+		}
+	}
+
+	*mgmt_ie_len = 0;
+
+	/*
+	 * Add if there is any extra IE
+	 */
+	if (mgmt_ie_buf && parsed_ie_buf_len) {
+		ptr = mgmt_ie_buf;
+
+		remained_buf_len = mgmt_ie_buf_len;
+
+		/*
+		 * make a command to add new ie
+		 */
+		for (i = 0; i < new_vndr_ies.count; i++) {
+			vndrie_info = &new_vndr_ies.ie_info[i];
+
+			/*
+			 * verify remained buf size before copy data
+			 */
+			if (remained_buf_len <
+				(vndrie_info->vndrie.len +
+					VNDR_IE_VSIE_OFFSET)) {
+				WLAND_ERR
+					("no space in mgmt_ie_buf: len left %d",
+					remained_buf_len);
+				break;
+			}
+			remained_buf_len -=
+				(vndrie_info->ie_len + VNDR_IE_VSIE_OFFSET);
+
+			WLAND_DBG(CFG80211, TRACE,
+				"ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\n",
+				vndrie_info->vndrie.id, vndrie_info->vndrie.len,
+				vndrie_info->vndrie.oui[0],
+				vndrie_info->vndrie.oui[1],
+				vndrie_info->vndrie.oui[2]);
+
+			del_add_ie_buf_len =
+				wland_vndr_ie(curr_ie_buf, pktflag,
+				vndrie_info->ie_ptr, vndrie_info->ie_len,
+				"add");
+
+			/*
+			 * save the parsed IE in wl struct
+			 */
+			memcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,
+				vndrie_info->ie_len);
+			*mgmt_ie_len += vndrie_info->ie_len;
+
+			curr_ie_buf += del_add_ie_buf_len;
+			total_ie_buf_len += del_add_ie_buf_len;
+		}
+	}
+
+	if (total_ie_buf_len) {
+		err = wland_fil_iovar_data_set(ifp, "vndr_ie", iovar_ie_buf,
+			total_ie_buf_len);
+		if (err < 0)
+			WLAND_ERR("vndr ie set error : %d\n", err);
+	}
+
+exit:
+	kfree(iovar_ie_buf);
+	return err;
+}
+
+s32 wland_vif_clear_mgmt_ies(struct wland_cfg80211_vif * vif)
+{
+	s32 i, pktflags[] = {
+		WLAND_VNDR_IE_PRBREQ_FLAG,
+		WLAND_VNDR_IE_PRBRSP_FLAG, WLAND_VNDR_IE_BEACON_FLAG
+	};
+
+	for (i = 0; i < ARRAY_SIZE(pktflags); i++) {
+		wland_vif_set_mgmt_ie(vif, pktflags[i], NULL, 0);
+	}
+
+	memset(&vif->saved_ie, 0, sizeof(vif->saved_ie));
+	return 0;
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+static s32 cfg80211_modify_beacon(struct wiphy *wiphy, struct net_device *ndev,
+	struct beacon_parameters *info)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_tlv *ssid_ie;
+	struct wland_ssid_le ssid_le;
+	struct wland_tlv *rsn_ie;
+	struct wland_vs_tlv *wpa_ie;
+	struct wland_join_params join_params;
+	enum nl80211_iftype dev_role;
+	struct wland_fil_bss_enable_le bss_enable;
+	s32 ie_offset, err = -EPERM;
+
+	dev_role = ifp->vif->wdev.iftype;
+
+	memset(&ssid_le, 0, sizeof(ssid_le));
+
+	WLAND_DBG(CFG80211, TRACE,
+		"interval:(%d),dtim_period:(%d),head_len:(%d),tail_len:(%d)\n",
+		info->interval, info->dtim_period, info->head_len,
+		info->tail_len);
+
+	//WLAND_DUMP(CFG80211, info->head, 128, "beacon_parameters,len:%Zu\n", (info->tail - info->head));
+
+	/*
+	 * find the SSID
+	 */
+	ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
+	ssid_ie =
+		wland_parse_tlvs((u8 *) & info->head[ie_offset],
+		info->head_len - ie_offset, WLAN_EID_SSID);
+	if (!ssid_ie)
+		return -EINVAL;
+
+	memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);
+	ssid_le.SSID_len = cpu_to_le32(ssid_ie->len);
+
+	WLAND_DBG(CFG80211, TRACE, "SSID is (%s) in Head\n", ssid_le.SSID);
+
+	/*
+	 * find the RSN_IE
+	 */
+	rsn_ie = wland_parse_tlvs((u8 *) info->tail, info->tail_len,
+		WLAN_EID_RSN);
+
+	/*
+	 * find the WPA_IE
+	 */
+	wpa_ie = wland_find_wpaie((u8 *) info->tail, info->tail_len);
+
+	if ((wpa_ie != NULL || rsn_ie != NULL)) {
+		WLAND_DBG(CFG80211, TRACE, "WPA(2) IE is found\n");
+
+		if (wpa_ie != NULL) {
+			/*
+			 * WPA IE
+			 */
+			err = wland_configure_wpaie(ndev, wpa_ie, false);
+			if (err < 0)
+				goto exit;
+		} else {
+			/*
+			 * RSN IE
+			 */
+			err = wland_configure_wpaie(ndev,
+				(struct wland_vs_tlv *) rsn_ie, true);
+			if (err < 0)
+				goto exit;
+		}
+	} else {
+		WLAND_DBG(CFG80211, TRACE, "No WPA(2) IEs found\n");
+	}
+
+	/*
+	 * Set BI and DTIM period
+	 */
+	if (info->interval) {
+		err = wland_fil_set_cmd_data(ifp, WID_BEACON_INTERVAL,
+			&info->interval, sizeof(info->interval));
+		if (err < 0) {
+			WLAND_ERR("Beacon Interval Set Error, %d\n", err);
+			goto exit;
+		}
+	}
+	if (info->dtim_period) {
+		err = wland_fil_set_cmd_data(ifp, WID_DTIM_PERIOD,
+			&info->dtim_period, sizeof(info->dtim_period));
+		if (err < 0) {
+			WLAND_ERR("DTIM Interval Set Error, %d\n", err);
+			goto exit;
+		}
+	}
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "ADD/SET beacon done(err:%d)\n", err);
+
+	return err;
+}
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+
+#ifdef STRUCT_REF
+
+/**
+ * struct cfg80211_beacon_data - beacon data
+ * @head: head portion of beacon (before TIM IE)
+ *     or %NULL if not changed
+ * @tail: tail portion of beacon (after TIM IE)
+ *     or %NULL if not changed
+ * @head_len: length of @head
+ * @tail_len: length of @tail
+ * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL
+ * @beacon_ies_len: length of beacon_ies in octets
+ * @proberesp_ies: extra information element(s) to add into Probe Response
+ *	frames or %NULL
+ * @proberesp_ies_len: length of proberesp_ies in octets
+ * @assocresp_ies: extra information element(s) to add into (Re)Association
+ *	Response frames or %NULL
+ * @assocresp_ies_len: length of assocresp_ies in octets
+ * @probe_resp_len: length of probe response template (@probe_resp)
+ * @probe_resp: probe response template (AP mode only)
+ */
+struct cfg80211_beacon_data {
+	const u8 *head, *tail;
+	const u8 *beacon_ies;
+	const u8 *proberesp_ies;
+	const u8 *assocresp_ies;
+	const u8 *probe_resp;
+
+	size_t head_len, tail_len;
+	size_t beacon_ies_len;
+	size_t proberesp_ies_len;
+	size_t assocresp_ies_len;
+	size_t probe_resp_len;
+};
+
+/**
+ * struct cfg80211_crypto_settings - Crypto settings
+ * @wpa_versions: indicates which, if any, WPA versions are enabled
+ *	(from enum nl80211_wpa_versions)
+ * @cipher_group: group key cipher suite (or 0 if unset)
+ * @n_ciphers_pairwise: number of AP supported unicast ciphers
+ * @ciphers_pairwise: unicast key cipher suites
+ * @n_akm_suites: number of AKM suites
+ * @akm_suites: AKM suites
+ * @control_port: Whether user space controls IEEE 802.1X port, i.e.,
+ *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
+ *	required to assume that the port is unauthorized until authorized by
+ *	user space. Otherwise, port is marked authorized by default.
+ * @control_port_ethertype: the control port protocol that should be
+ *	allowed through even on unauthorized ports
+ * @control_port_no_encrypt: TRUE to prevent encryption of control port
+ *	protocol frames.
+ */
+struct cfg80211_crypto_settings {
+	u32 wpa_versions;
+	u32 cipher_group;
+	int n_ciphers_pairwise;
+	u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
+	int n_akm_suites;
+	u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
+	bool control_port;
+	__be16 control_port_ethertype;
+	bool control_port_no_encrypt;
+};
+
+/**
+ * enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID
+ * @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in
+ *	Beacon frames)
+ * @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element
+ *	in Beacon frames
+ * @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID
+ *	element in Beacon frames but zero out each byte in the SSID
+ */
+enum nl80211_hidden_ssid {
+	NL80211_HIDDEN_SSID_NOT_IN_USE,
+	NL80211_HIDDEN_SSID_ZERO_LEN,
+	NL80211_HIDDEN_SSID_ZERO_CONTENTS
+};
+
+/**
+ * enum nl80211_auth_type - AuthenticationType
+ *
+ * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
+ * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
+ * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
+ * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
+ * @__NL80211_AUTHTYPE_NUM: internal
+ * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
+ * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
+ *	trying multiple times); this is invalid in netlink -- leave out
+ *	the attribute for this on CONNECT commands.
+ */
+enum nl80211_auth_type {
+	NL80211_AUTHTYPE_OPEN_SYSTEM,
+	NL80211_AUTHTYPE_SHARED_KEY,
+	NL80211_AUTHTYPE_FT,
+	NL80211_AUTHTYPE_NETWORK_EAP,
+
+	/*
+	 * keep last
+	 */
+	__NL80211_AUTHTYPE_NUM,
+	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
+	NL80211_AUTHTYPE_AUTOMATIC
+};
+
+/**
+ * struct cfg80211_ap_settings - AP configuration
+ *
+ * Used to configure an AP interface.
+ *
+ * @beacon: beacon data
+ * @beacon_interval: beacon interval
+ * @dtim_period: DTIM period
+ * @ssid: SSID to be used in the BSS (note: may be %NULL if not provided from
+ *	user space)
+ * @ssid_len: length of @ssid
+ * @hidden_ssid: whether to hide the SSID in Beacon/Probe Response frames
+ * @crypto: crypto settings
+ * @privacy: the BSS uses privacy
+ * @auth_type: Authentication type (algorithm)
+ * @inactivity_timeout: time in seconds to determine station's inactivity.
+ */
+struct cfg80211_ap_settings {
+	struct cfg80211_beacon_data beacon;
+
+	int beacon_interval, dtim_period;
+	const u8 *ssid;
+	size_t ssid_len;
+	enum nl80211_hidden_ssid hidden_ssid;
+	struct cfg80211_crypto_settings crypto;
+	bool privacy;
+	enum nl80211_auth_type auth_type;
+	int inactivity_timeout;
+};
+#endif /* STRUCT_REF */
+
+s32 cfg80211_parse_ap_settings(struct net_device *ndev,
+	struct cfg80211_ap_settings *settings)
+{
+	s32 err = 0;
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+	profile->sec.security = NO_ENCRYPT;
+	profile->sec.firmware_autype = ANY;
+
+	if (settings->crypto.cipher_group != NO_ENCRYPT) {
+		int i;
+
+		WLAND_DBG(CFG80211, DEBUG, "ENCRYPT\n");
+
+		profile->sec.security = ENCRYPT_ENABLED;
+
+		/*
+		 * To determine the u8security value, first we check the group cipher suite then {in case of WPA or WPA2}
+		 * we will add to it the pairwise cipher suite(s)
+		 */
+		if (settings->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
+			WLAND_DBG(CFG80211, DEBUG, "WPA_VERSION_2\n");
+			profile->sec.firmware_autype = OPEN_SYSTEM;
+			profile->sec.security |= WPA2;
+		} else if (settings->
+			crypto.wpa_versions & NL80211_WPA_VERSION_1) {
+			WLAND_DBG(CFG80211, DEBUG, "WPA_VERSION_1\n");
+
+			profile->sec.firmware_autype = OPEN_SYSTEM;
+			profile->sec.security |= WPA;
+		} else {
+			profile->sec.firmware_autype = SHARED_KEY;
+			WLAND_DBG(CFG80211, DEBUG, "Default\n");
+			goto done;
+		}
+
+		for (i = 0; i < settings->crypto.n_ciphers_pairwise; i++) {
+			if (settings->crypto.ciphers_pairwise[i] ==
+				WLAN_CIPHER_SUITE_TKIP) {
+				profile->sec.security |= TKIP;
+				WLAND_DBG(CFG80211, DEBUG, "TKIP\n");
+			} else if (settings->crypto.ciphers_pairwise[i] ==
+				WLAN_CIPHER_SUITE_CCMP) {
+				profile->sec.security |= AES;
+				WLAND_DBG(CFG80211, DEBUG, "AES\n");
+			}
+		}
+	} else {
+		WLAND_DBG(CFG80211, DEBUG, "NO_ENCRYPT\n");
+		profile->sec.firmware_autype = OPEN_SYSTEM;
+	}
+
+done:
+	WLAND_DBG(CFG80211, DEBUG, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+static s32 cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_ap_settings *settings)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_tlv *ssid_ie;
+	struct wland_tlv *rsn_ie;
+	struct wland_vs_tlv *wpa_ie;
+	enum nl80211_iftype dev_role;
+	s32 ie_offset, err = -EPERM;
+
+	WLAND_DBG(CFG80211, DEBUG, "ssid=%s(%zu), "
+		"auth_type=%d, "
+		"inactivity_timeout=%d, "
+		"beacon_interval=%d, "
+		"dtim_period=%d, "
+		"hidden_ssid=%d, "
+		"auth_type=%d "
+		"crypto->wpa_versions=%d\n",
+		settings->ssid,
+		settings->ssid_len,
+		settings->auth_type,
+		settings->inactivity_timeout,
+		settings->beacon_interval,
+		settings->dtim_period,
+		settings->hidden_ssid,
+		settings->auth_type, settings->crypto.wpa_versions);
+
+	/*
+	 * Show AP settings
+	 */
+	WLAND_DBG(CFG80211, DEBUG,
+		"\n"
+		"BeaconIEs  (%p) BeaconIEsLen  (%u)\n"
+		"ProbeRspIEs(%p) ProbeRspIEsLen(%u)\n"
+		"AssocRspIEs(%p) AssocRspIEs   (%u)\n"
+		"ProbeResp  (%p) ProbeResp     (%u)\n"
+		"Head       (%p) HeadLen       (%u)\n"
+		"Tail       (%p) TailLen       (%u)\n"
+		"BeaconInterval: %dTU\n"
+		"DTIM Period   : %d\n"
+		"SSID          : '%s' Len(%uB)\n"
+		"Hidden SSID   : %u\n"
+		"Crypto:\n"
+		"  wpa_versions = %u\n"
+		"  cipher_group = %02X-%02X-%02X-%02X\n"
+		"  n_ciphers_pairwise = %d %02X-%02X-%02X-%02X\n"
+		"  n_akm_suites = %d %02X-%02X-%02X-%02X\n"
+		"Privacy       : %u\n"
+		"Auth Type     : %u\n"
+		"InactiveTime  : %d\n",
+		settings->beacon.beacon_ies, settings->beacon.beacon_ies_len,
+		settings->beacon.proberesp_ies,
+		settings->beacon.proberesp_ies_len,
+		settings->beacon.assocresp_ies,
+		settings->beacon.assocresp_ies_len, settings->beacon.probe_resp,
+		settings->beacon.probe_resp_len, settings->beacon.head,
+		settings->beacon.head_len, settings->beacon.tail,
+		settings->beacon.tail_len, settings->beacon_interval,
+		settings->dtim_period, (const char *) settings->ssid,
+		settings->ssid_len, settings->hidden_ssid,
+		settings->crypto.wpa_versions,
+		(settings->crypto.cipher_group >> 24) & 0xFF,
+		(settings->crypto.cipher_group >> 16) & 0xFF,
+		(settings->crypto.cipher_group >> 8) & 0xFF,
+		settings->crypto.cipher_group & 0xFF,
+		settings->crypto.n_ciphers_pairwise,
+		(settings->crypto.ciphers_pairwise[0] >> 24) & 0xFF,
+		(settings->crypto.ciphers_pairwise[0] >> 16) & 0xFF,
+		(settings->crypto.ciphers_pairwise[0] >> 8) & 0xFF,
+		settings->crypto.ciphers_pairwise[0] & 0xFF,
+		settings->crypto.n_akm_suites,
+		(settings->crypto.akm_suites[0] >> 24) & 0xFF,
+		(settings->crypto.akm_suites[0] >> 16) & 0xFF,
+		(settings->crypto.akm_suites[0] >> 8) & 0xFF,
+		settings->crypto.akm_suites[0] & 0xFF, settings->privacy,
+		settings->auth_type, settings->inactivity_timeout);
+
+	if (settings->beacon.beacon_ies && settings->beacon.beacon_ies_len) {
+		WLAND_DUMP(RX_NETEVENT,
+			settings->beacon.beacon_ies,
+			settings->beacon.beacon_ies_len,
+			"Beacon IEs(len %u):\n",
+			settings->beacon.beacon_ies_len);
+	}
+
+	if (settings->beacon.proberesp_ies
+		&& settings->beacon.proberesp_ies_len) {
+		WLAND_DUMP(RX_NETEVENT, settings->beacon.proberesp_ies,
+			settings->beacon.proberesp_ies_len,
+			"Probe Response IEs(len %u):\n",
+			settings->beacon.proberesp_ies_len);
+	}
+
+	if (settings->beacon.assocresp_ies
+		&& settings->beacon.assocresp_ies_len) {
+		WLAND_DUMP(RX_NETEVENT, settings->beacon.assocresp_ies,
+			settings->beacon.assocresp_ies_len,
+			"Associate Response IEs(len %u):\n",
+			settings->beacon.assocresp_ies_len);
+	}
+
+	if (settings->beacon.probe_resp && settings->beacon.probe_resp_len) {
+		WLAND_DUMP(RX_NETEVENT,
+			settings->beacon.probe_resp,
+			settings->beacon.probe_resp_len,
+			"Probe Response (len %u):\n",
+			settings->beacon.probe_resp_len);
+	}
+
+	if (settings->beacon.head && settings->beacon.head_len) {
+		WLAND_DUMP(RX_NETEVENT,
+			settings->beacon.head, settings->beacon.head_len,
+			"Head (len %u):\n", settings->beacon.head_len);
+	}
+
+	if (settings->beacon.tail && settings->beacon.tail_len) {
+		WLAND_DUMP(RX_NETEVENT,
+			settings->beacon.tail, settings->beacon.tail_len,
+			"Tail (len %u):\n", settings->beacon.tail_len);
+	}
+
+	dev_role = ifp->vif->wdev.iftype;
+
+	memset(&profile->ssid, '\0', sizeof(struct wland_ssid));
+
+	//SSID and SSID_len
+	if (settings->ssid == NULL || settings->ssid_len == 0) {
+		ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
+		ssid_ie =
+			wland_parse_tlvs((u8 *) & settings->
+			beacon.head[ie_offset],
+			settings->beacon.head_len - ie_offset, WLAN_EID_SSID);
+		if (!ssid_ie)
+			return -EINVAL;
+
+		memcpy(profile->ssid.SSID, ssid_ie->data, ssid_ie->len);
+		profile->ssid.SSID_len = ssid_ie->len;
+
+	} else {
+		memcpy(profile->ssid.SSID, settings->ssid, settings->ssid_len);
+		profile->ssid.SSID_len = settings->ssid_len;
+	}
+
+	//beacon_interval and dtim_period
+	/*
+	 * store beacon interval and dtim period
+	 */
+	profile->beacon = settings->beacon_interval;
+	profile->dtim = settings->dtim_period;
+
+	WLAND_DBG(CFG80211, TRACE, "SSID is (%s,SSIDLEN:%d) in Head\n",
+		profile->ssid.SSID, profile->ssid.SSID_len);
+
+	/*
+	 * find the RSN_IE
+	 */
+	rsn_ie = wland_parse_tlvs((u8 *) settings->beacon.tail,
+		settings->beacon.tail_len, WLAN_EID_RSN);
+
+	/*
+	 * find the WPA_IE
+	 */
+	wpa_ie = wland_find_wpaie((u8 *) settings->beacon.tail,
+		settings->beacon.tail_len);
+
+	if ((wpa_ie != NULL || rsn_ie != NULL)) {
+		WLAND_DBG(CFG80211, TRACE, "WPA(2) IE is found\n");
+
+		if (wpa_ie != NULL) {
+			/*
+			 * WPA IE
+			 */
+			WLAND_DBG(CFG80211, TRACE, "WPA IE\n");
+			err = wland_configure_wpaie(ndev, wpa_ie, false);
+			if (err < 0)
+				goto exit;
+		} else {
+			/*
+			 * RSN IE
+			 */
+			WLAND_DBG(CFG80211, TRACE, "RSN IE\n");
+			err = wland_configure_wpaie(ndev,
+				(struct wland_vs_tlv *) rsn_ie, true);
+			if (err < 0)
+				goto exit;
+		}
+	} else {
+		WLAND_DBG(CFG80211, TRACE, "No WPA(2) IEs found\n");
+	}
+#if 0
+	/*
+	 * Set Beacon IEs to FW
+	 */
+	err = wland_vif_set_mgmt_ie(ifp->vif, WLAND_VNDR_IE_BEACON_FLAG,
+		settings->beacon.tail, settings->beacon.tail_len);
+	if (err) {
+		WLAND_ERR("Set Beacon IE Failed\n");
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Applied Vndr IEs for Beacon\n");
+
+	/*
+	 * Set Probe Response IEs to FW
+	 */
+	err = wland_vif_set_mgmt_ie(ifp->vif, WLAND_VNDR_IE_PRBRSP_FLAG,
+		settings->beacon.proberesp_ies,
+		settings->beacon.proberesp_ies_len);
+	if (err)
+		WLAND_ERR("Set Probe Resp IE Failed\n");
+	else
+		WLAND_DBG(CFG80211, TRACE, "Applied Vndr IEs for Probe Resp\n");
+#endif
+
+	if (cfg80211_parse_ap_settings(ndev, settings)) {
+		WLAND_ERR("cfg80211_parse_ap_settings error!\n");
+		goto exit;
+	}
+
+	if (dev_role == NL80211_IFTYPE_AP) {
+		err = wland_start_ap_set(ifp, profile, false);
+
+		WLAND_DBG(CFG80211, TRACE, "AP mode configuration complete\n");
+	} else {
+		err = wland_start_ap_set(ifp, profile, true);
+
+		WLAND_DBG(CFG80211, TRACE, "GO mode configuration complete\n");
+	}
+
+	clear_bit(VIF_STATUS_AP_CREATING, &ifp->vif->sme_state);
+	set_bit(VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+static int cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {
+		struct wland_join_params join_params;
+
+		/*
+		 * Due to most likely deauths outstanding we sleep first to make sure they get processed by fw.
+		 */
+		memset(&join_params, 0, sizeof(join_params));
+
+		err = wland_fil_iovar_data_set(ifp, "set_ssid", &join_params,
+			sizeof(join_params));
+		if (err < 0)
+			WLAND_ERR("SET SSID error:%d\n", err);
+	} else {
+		struct wland_fil_bss_enable_le bss_enable;
+
+		bss_enable.bsscfg_idx = cpu_to_le32(ifp->bssidx);
+		bss_enable.enable = cpu_to_le32(0);
+
+		err = wland_fil_iovar_data_set(ifp, "bss", &bss_enable,
+			sizeof(bss_enable));
+		if (err < 0)
+			WLAND_ERR("bss_enable config failed:%d\n", err);
+	}
+
+	set_bit(VIF_STATUS_AP_CREATING, &ifp->vif->sme_state);
+	clear_bit(VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_beacon_data *info)
+{
+	s32 err = 0;
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	/*
+	 * Set Beacon IEs to FW
+	 */
+	err = wland_vif_set_mgmt_ie(ifp->vif, WLAND_VNDR_IE_BEACON_FLAG,
+		info->tail, info->tail_len);
+	if (err) {
+		WLAND_ERR("Set Beacon IE Failed\n");
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Applied Vndr IEs for Beacon\n");
+
+	/*
+	 * Set Probe Response IEs to FW
+	 */
+	err = wland_vif_set_mgmt_ie(ifp->vif, WLAND_VNDR_IE_PRBRSP_FLAG,
+		info->proberesp_ies, info->proberesp_ies_len);
+	if (err)
+		WLAND_ERR("Set Probe Resp IE Failed\n");
+	else
+		WLAND_DBG(CFG80211, TRACE, "Applied Vndr IEs for Probe Resp\n");
+
+	return err;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+static int cfg80211_del_station(struct wiphy *wiphy, struct net_device *ndev,
+	u8 * mac)
+{
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+#endif /* WLAND_P2P_SUPPORT */
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_scb_val_le scbval;
+	s32 err = 0;
+
+	if (!mac) {
+		WLAND_ERR("mac addr is NULL ignore it\n");
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(%pM)\n", mac);
+
+#ifdef WLAND_P2P_SUPPORT
+	if (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)
+		ifp = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;
+#endif /* WLAND_P2P_SUPPORT */
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	memcpy(&scbval.ea, mac, ETH_ALEN);
+
+	scbval.val = cpu_to_le32(WLAN_REASON_DEAUTH_LEAVING);
+
+	err = wland_fil_iovar_data_set(ifp, "scb_default_for_reason", &scbval,
+		sizeof(scbval));
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+
+static void cfg80211_mgmt_frame_register(struct wiphy *wiphy,
+#if  LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *dev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	u16 frame_type, bool reg)
+{
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct wland_cfg80211_vif *vif = ndev_to_vif(dev);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	u16 mgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;
+
+	WLAND_DBG(CFG80211, TRACE,
+		"(frame_type: 0x%04x,reg:%x,mgmt_type:0x%x),Enter\n",
+		frame_type, reg, mgmt_type);
+
+	if (reg)
+		vif->mgmt_rx_reg |= BIT(mgmt_type);
+	else
+		vif->mgmt_rx_reg &= ~BIT(mgmt_type);
+}
+
+static s32 cfg80211_change_bss(struct wiphy *wiphy, struct net_device *dev,
+	struct bss_parameters *params)
+{
+	WLAND_DBG(CFG80211, DEBUG,
+		"Enter, change_bss cts:%x,preamble:%x,short_slot_time:%x.\n",
+		params->use_cts_prot, params->use_short_preamble,
+		params->use_short_slot_time);
+
+	return 0;
+}
+
+static s32 cfg80211_mgmt_tx(struct wiphy *wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *ndev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct ieee80211_channel *channel, bool offchan,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	enum nl80211_channel_type channel_type, bool channel_type_vaild,
+#endif
+	unsigned int wait, const u8 * buf, size_t len,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	bool no_cck,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	bool dont_wait_for_ack,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0) */
+	u64 * cookie)
+{
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+#endif /* WLAND_P2P_SUPPORT */
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	struct wland_fil_action_frame_le *action_frame;
+	struct wland_fil_af_params_le *af_params;
+	bool ack;
+	s32 chan_nr, err = 0, ie_offset, ie_len;
+	u32 freq;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct wland_cfg80211_vif *vif = ndev_to_vif(ndev);;
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	*cookie = 0;
+
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		WLAND_ERR("Driver only allows MGMT packet type\n");
+		return -EPERM;
+	}
+
+	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		/*
+		 * Right now the only reason to get a probe response
+		 * is for p2p listen response or for p2p GO from
+		 * wpa_supplicant. Unfortunately the probe is send
+		 * on primary ndev, while dongle wants it on the p2p
+		 * vif. Since this is only reason for a probe
+		 * response to be sent, the vif is taken from cfg.
+		 * If ever desired to send proberesp for non p2p
+		 * response then data should be checked for
+		 * "DIRECT-". Note in future supplicant will take
+		 * dedicated p2p wdev to do this and then this 'hack'
+		 * is not needed anymore.
+		 */
+		ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
+		ie_len = len - ie_offset;
+
+#ifdef WLAND_P2P_SUPPORT
+		if (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)
+			vif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+#endif /* WLAND_P2P_SUPPORT */
+		err = wland_vif_set_mgmt_ie(vif, WLAND_VNDR_IE_PRBRSP_FLAG,
+			&buf[ie_offset], ie_len);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		cfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,
+			GFP_KERNEL);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, true,
+			GFP_KERNEL);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	} else if (ieee80211_is_action(mgmt->frame_control)) {
+		af_params = kzalloc(sizeof(*af_params), GFP_KERNEL);
+		if (af_params == NULL) {
+			WLAND_ERR("unable to allocate frame\n");
+			err = -ENOMEM;
+			goto exit;
+		}
+		action_frame = &af_params->action_frame;
+		/*
+		 * Add the packet Id
+		 */
+		action_frame->packet_id = cpu_to_le32(*cookie);
+		/*
+		 * Add BSSID
+		 */
+		memcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);
+		memcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);
+		/*
+		 * Add the length exepted for 802.11 header
+		 */
+		action_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);
+		/*
+		 * Add the channel. Use the one specified as parameter if any or
+		 * * the current one (got from the firmware) otherwise
+		 */
+		if (channel)
+			freq = channel->center_freq;
+		else
+			wland_fil_iovar_data_get(vif->ifp, "get_channel", &freq,
+				sizeof(freq));
+
+		chan_nr = ieee80211_frequency_to_channel(freq);
+		af_params->channel = cpu_to_le32(chan_nr);
+
+		memcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],
+			le16_to_cpu(action_frame->len));
+
+		WLAND_DBG(CFG80211, TRACE,
+			"Action frame, cookie=%lld, len=%d, freq=%d\n", *cookie,
+			le16_to_cpu(action_frame->len), freq);
+
+#ifdef WLAND_P2P_SUPPORT
+		ack = wland_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),
+			af_params);
+#else /* WLAND_P2P_SUPPORT */
+		ack = false;
+#endif /* WLAND_P2P_SUPPORT */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		cfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,
+			GFP_KERNEL);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, ack,
+			GFP_KERNEL);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		kfree(af_params);
+	} else {
+		WLAND_DBG(CFG80211, TRACE, "Unhandled, fc=%04x\n",
+			mgmt->frame_control);
+		//WLAND_DUMP(CFG80211, buf, len, "payload, len=%Zu\n", len);
+	}
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+#if 0
+static s32 cfg80211_remain_on_channel(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *dev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct ieee80211_channel *channel, unsigned int duration, u64 * cookie)
+{
+	WLAND_DBG(CFG80211, TRACE, "Enter p2p remain_on_channel\n");
+
+#ifdef WLAND_P2P_SUPPORT
+	return cfg80211_p2p_remain_on_channel(wiphy, dev, channel, channel_type,
+		duration, cookie);
+#else /*WLAND_P2P_SUPPORT */
+	return -EOPNOTSUPP;
+#endif /*WLAND_P2P_SUPPORT */
+}
+#endif
+static s32 cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *dev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	u64 cookie)
+{
+	s32 err = 0;
+
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_cfg80211_vif *vif =
+		cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+#else /* WLAND_P2P_SUPPORT */
+	struct wland_cfg80211_vif *vif = NULL;
+#endif /* WLAND_P2P_SUPPORT */
+
+	WLAND_DBG(CFG80211, TRACE, "Enter p2p listen cancel\n");
+
+	if (vif == NULL) {
+		WLAND_ERR("No p2p device available for probe response\n");
+		err = -ENODEV;
+		goto exit;
+	}
+#ifdef WLAND_P2P_SUPPORT
+	wland_p2p_cancel_remain_on_channel(vif->ifp);
+#endif /*WLAND_P2P_SUPPORT */
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Enter p2p listen cancel(err:%d)\n", err);
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+static int cfg80211_crit_proto_start(struct wiphy *wiphy,
+	struct wireless_dev *wdev, enum nl80211_crit_proto_id proto,
+	u16 duration)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	/*
+	 * only DHCP support for now
+	 */
+	if (proto != NL80211_CRIT_PROTO_DHCP)
+		return -EINVAL;
+
+	/*
+	 * suppress and abort scanning
+	 */
+	set_bit(SCAN_STATUS_SUPPRESS, &cfg->scan_status);
+
+	wland_abort_scanning(cfg);
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	return wland_btcoex_set_mode(vif, BTCOEX_DISABLED, duration);
+#else /* WLAND_BTCOEX_SUPPORT */
+	return 0;
+#endif /* WLAND_BTCOEX_SUPPORT */
+}
+
+static void cfg80211_crit_proto_stop(struct wiphy *wiphy,
+	struct wireless_dev *wdev)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	wland_btcoex_set_mode(vif, BTCOEX_ENABLED, 0);
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+	clear_bit(SCAN_STATUS_SUPPRESS, &cfg->scan_status);
+} static int cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *ndev,
+	u8 * peer, enum nl80211_tdls_operation oper)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_tdls_iovar_le info;
+	int ret = 0;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	switch (oper) {
+	case NL80211_TDLS_DISCOVERY_REQ:
+		ret = TDLS_MANUAL_EP_DISCOVERY;
+		break;
+	case NL80211_TDLS_SETUP:
+		ret = TDLS_MANUAL_EP_CREATE;
+		break;
+	case NL80211_TDLS_TEARDOWN:
+		ret = TDLS_MANUAL_EP_DELETE;
+		break;
+	default:
+		WLAND_ERR("unsupported operation: %d\n", oper);
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	if (ret < 0)
+		return ret;
+
+	memset(&info, 0, sizeof(info));
+
+	info.mode = (u8) ret;
+
+	if (peer)
+		memcpy(info.ea, peer, ETH_ALEN);
+
+	ret = wland_fil_iovar_data_set(ifp, "tdls_endpoint", &info,
+		sizeof(info));
+
+	WLAND_DBG(CFG80211, TRACE, "Done(ret:%d)\n", ret);
+
+	return ret;
+}
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+static s32 cfg80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+	struct wireless_dev *wdev, u64 cookie)
+{
+	/*
+	 * CFG80211 checks for tx_cancel_wait callback when ATTR_DURATION is passed with CMD_FRAME.
+	 * * This callback is supposed to cancel the OFFCHANNEL Wait.
+	 * * Since we are already taking care of that with the tx_mgmt logic, do nothing here.
+	 */
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	return 0;
+}
+#else
+static s32 cfg80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+	struct net_device *ndev, u64 cookie)
+{
+	/*
+	 * CFG80211 checks for tx_cancel_wait callback when ATTR_DURATION is passed with CMD_FRAME.
+	 * * This callback is supposed to cancel the OFFCHANNEL Wait.
+	 * * Since we are already taking care of that with the tx_mgmt logic, do nothing here.
+	 */
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	return 0;
+}
+#endif
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+#if 0
+static s32 cfg80211_set_channel(struct wiphy *wiphy,
+	struct net_device *dev,
+	struct ieee80211_channel *chan, enum nl80211_channel_type channel_type)
+{
+	struct wland_if *ifp = netdev_priv(dev);
+
+	s32 err = -EOPNOTSUPP, _chan;
+
+	if (!check_vif_up(ifp->vif))
+		return -EIO;
+
+	_chan = ieee80211_frequency_to_channel(chan->center_freq);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(chan:%d)\n", _chan);
+
+#ifdef WLAND_5GRF_SUPPORT
+	if (chan->band == IEEE80211_BAND_5GHZ) {
+		WLAND_DBG(CFG80211, TRACE, "(BAND_5GHZ---->chan:%d),Enter\n",
+			_chan);
+	}
+#endif /* WLAND_5GRF_SUPPORT */
+	if (chan->band == IEEE80211_BAND_2GHZ) {
+		WLAND_DBG(CFG80211, TRACE, "(BAND_2.4GHZ---->chan:%d),Enter\n",
+			_chan);
+	}
+
+	err = wland_fil_set_cmd_data(ifp, WID_CURRENT_CHANNEL, &_chan,
+		sizeof(_chan));
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+#endif
+
+/*
+*  @brief 	    cfg80211_set_cqm_rssi_config
+*  @details 	Configure connection quality monitor RSSI threshold.
+*  @param[in]   struct wiphy *wiphy:
+*  @param[in]	struct net_device *dev:
+*  @param[in]  	s32 rssi_thold:
+*  @param[in]	u32 rssi_hyst:
+*  @return 	int : Return 0 on Success
+*/
+static s32 cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
+	struct net_device *dev, s32 rssi_thold, u32 rssi_hyst)
+{
+	WLAND_DBG(CFG80211, TRACE, "Setting CQM RSSI Function\n");
+	return 0;
+}
+
+static struct cfg80211_ops wl_cfg80211_ops = {
+	.add_virtual_intf = cfg80211_add_virtual_iface,
+	.del_virtual_intf = cfg80211_del_virtual_iface,
+	.change_virtual_intf = cfg80211_change_virtual_iface,
+	.scan =	cfg80211_scan,
+	.set_wiphy_params = cfg80211_set_wiphy_params,
+	.join_ibss = cfg80211_join_ibss,
+	.leave_ibss = cfg80211_leave_ibss,
+	.get_station = cfg80211_get_station,
+	.set_tx_power = cfg80211_set_tx_power,
+	.get_tx_power = cfg80211_get_tx_power,
+	.add_key = cfg80211_add_key,
+	.del_key = cfg80211_del_key,
+	.get_key = cfg80211_get_key,
+	.set_default_key = cfg80211_config_default_key,
+	.set_default_mgmt_key =	cfg80211_config_default_mgmt_key,
+	.set_power_mgmt = cfg80211_set_power_mgmt,
+	.connect = cfg80211_connect,
+	.disconnect = cfg80211_disconnect,
+	.suspend = cfg80211_suspend,
+	.resume = cfg80211_resume,
+	.set_pmksa = cfg80211_set_pmksa,
+	.del_pmksa = cfg80211_del_pmksa,
+	.flush_pmksa = cfg80211_flush_pmksa,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+	.set_beacon = cfg80211_modify_beacon,
+	.add_beacon = cfg80211_modify_beacon,
+	.del_beacon = cfg80211_modify_beacon,
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+	.start_ap = cfg80211_start_ap,
+	.stop_ap = cfg80211_stop_ap,
+	.change_beacon = cfg80211_change_beacon,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	.del_station = cfg80211_del_station,
+	.mgmt_tx_cancel_wait = cfg80211_mgmt_tx_cancel_wait,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+	.sched_scan_start = cfg80211_sched_scan_start,
+	.sched_scan_stop = cfg80211_sched_scan_stop,
+	.mgmt_frame_register = cfg80211_mgmt_frame_register,
+	.change_bss = cfg80211_change_bss,
+	.mgmt_tx = cfg80211_mgmt_tx,
+#if 0
+	.set_channel = cfg80211_set_channel,
+	.remain_on_channel = cfg80211_remain_on_channel,
+#endif
+	.cancel_remain_on_channel = cfg80211_cancel_remain_on_channel,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#ifdef WLAND_P2P_SUPPORT
+	.start_p2p_device = cfg80211_p2p_start_device,
+	.stop_p2p_device = cfg80211_p2p_stop_device,
+#endif /* WLAND_P2P_SUPPORT */
+	.crit_proto_start = cfg80211_crit_proto_start,
+	.crit_proto_stop = cfg80211_crit_proto_stop,
+	.tdls_oper = cfg80211_tdls_oper,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	.set_cqm_rssi_config = cfg80211_set_cqm_rssi_config,
+};
+
+static s32 nl80211_iftype_to_mode(enum nl80211_iftype type)
+{
+	switch (type) {
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_MESH_POINT:
+		return -ENOTSUPP;
+	case NL80211_IFTYPE_ADHOC:
+		return WL_MODE_IBSS;
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return WL_MODE_BSS;
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		return WL_MODE_AP;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+#ifdef WLAND_TBD_SUPPORT
+static const struct ieee80211_iface_limit wland_iface_limits[] = {
+	{
+		.max = 2,.types = BIT(NL80211_IFTYPE_STATION) |
+		BIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP)
+	},
+	{
+		.max = 1,.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+		BIT(NL80211_IFTYPE_P2P_GO)
+	},
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	{
+		.max = 1,.types = BIT(NL80211_IFTYPE_P2P_DEVICE)
+	}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+};
+
+static const struct ieee80211_iface_combination wland_iface_combos[] = {
+	{
+		.max_interfaces =
+			WLAND_IFACE_MAX_CNT,.num_different_channels =
+			2,.n_limits =
+			ARRAY_SIZE(wland_iface_limits),.limits =
+			wland_iface_limits}
+};
+#endif /* WLAND_TBD_SUPPORT */
+
+/* There isn't a lot of sense in it, but you can transmit anything you like */
+static const struct ieee80211_txrx_stypes
+	cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_ADHOC] = {
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ACTION >> 4)
+		},[NL80211_IFTYPE_STATION] = {
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+		},[NL80211_IFTYPE_AP] = {
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4)
+		},[NL80211_IFTYPE_AP_VLAN] = {
+			/*
+			 * copy AP
+			 */
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4)
+		},[NL80211_IFTYPE_P2P_CLIENT] = {
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+		},[NL80211_IFTYPE_P2P_GO] = {
+			.tx = 0xFFFF,.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4)
+		}
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+void cfg80211_reg_notifier(struct wiphy *wiphy,
+	struct regulatory_request *request)
+{
+	struct wland_cfg80211_info *cfg =
+		(struct wland_cfg80211_info *) wiphy_priv(wiphy);
+	struct wland_country cspec = { {
+		0}, 0, {
+		0}
+	};
+
+	if (!request || !cfg) {
+		WLAND_ERR("Invalid arg\n");
+		return;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "ccode: %c%c Initiator: %d\n",
+		request->alpha2[0], request->alpha2[1], request->initiator);
+
+	/*
+	 * We support only REGDOM_SET_BY_USER as of now
+	 */
+	if (request->initiator != NL80211_REGDOM_SET_BY_USER) {
+		WLAND_ERR("reg_notifier for intiator:%d not supported \n",
+			request->initiator);
+		return;
+	}
+
+	if (request->alpha2[0] == '0' && request->alpha2[1] == '0') {
+		/*
+		 * world domain
+		 */
+		WLAND_ERR("World domain. Setting XY/4 \n");
+		strncpy(cspec.country_abbrev, "XY", strlen("XY"));
+		cspec.rev = 4;
+	} else {
+		memcpy(cspec.country_abbrev, request->alpha2, 2);
+		cspec.country_abbrev[3] = '\0';
+		cspec.rev = -1;	/* Unspecified */
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "set country '%s/%d' done\n",
+		cspec.country_abbrev, cspec.rev);
+	return;
+}
+#else
+int cfg80211_reg_notifier(struct wiphy *wiphy,
+	struct regulatory_request *request)
+{
+	struct wland_cfg80211_info *cfg =
+		(struct wland_cfg80211_info *) wiphy_priv(wiphy);
+	struct wland_country cspec = { {
+		0}, 0, {
+		0}
+	};
+	int err = 0;
+
+	if (!request || !cfg) {
+		WLAND_ERR("Invalid arg\n");
+		return err;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "ccode: %c%c Initiator: %d\n",
+		request->alpha2[0], request->alpha2[1], request->initiator);
+
+	/*
+	 * We support only REGDOM_SET_BY_USER as of now
+	 */
+	if (request->initiator != NL80211_REGDOM_SET_BY_USER) {
+		WLAND_ERR("reg_notifier for intiator:%d not supported \n",
+			request->initiator);
+		return err;
+	}
+
+	if (request->alpha2[0] == '0' && request->alpha2[1] == '0') {
+		/*
+		 * world domain
+		 */
+		WLAND_ERR("World domain. Setting XY/4 \n");
+		strncpy(cspec.country_abbrev, "XY", strlen("XY"));
+		cspec.rev = 4;
+	} else {
+		memcpy(cspec.country_abbrev, request->alpha2, 2);
+		cspec.country_abbrev[3] = '\0';
+		cspec.rev = -1;	/* Unspecified */
+	}
+
+#if 0
+	if ((ret = wldev_iovar_setbuf(cfg->wdev->netdev, "country",
+				(char *) &cspec, sizeof(cspec), cfg->ioctl_buf,
+				WLC_IOCTL_SMLEN, NULL)) < 0) {
+		WLAND_ERR("set country Failed :%d\n", ret);
+		goto exit;
+	}
+
+	if ((ret = wland_update_wiphybands(cfg, false)) < 0)
+		WLAND_ERR("wland_update_wiphybands failed\n");
+exit:
+#endif
+	WLAND_DBG(CFG80211, TRACE, "set country '%s/%d' done\n",
+		cspec.country_abbrev, cspec.rev);
+	return err;
+}
+#endif
+
+static struct wiphy *wland_setup_wiphy(struct device *phydev)
+{
+	s32 err = 0;
+	struct wiphy *wiphy = NULL;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter.\n sizeof_priv = %d\n",
+		sizeof(struct wland_cfg80211_info));
+	wiphy = wiphy_new(&wl_cfg80211_ops, sizeof(struct wland_cfg80211_info));
+	if (!wiphy) {
+		WLAND_ERR("Could not allocate wiphy device\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	set_wiphy_dev(wiphy, phydev);
+
+	//maximum number of SSIDs the device can scan for in any given scan
+	wiphy->max_scan_ssids = SCAN_NUM_MAX;
+
+	//maximum length of user-controlled IEs device can add to probe request frames transmitted
+	//during a scan, must not include fixed IEs like supported rates
+	wiphy->max_scan_ie_len = SCAN_IE_LEN_MAX;
+
+	//maximum number of PMKIDs supported by device
+	wiphy->max_num_pmkids = MAXPMKID;
+
+#ifdef WLAND_SCHED_SCAN_SUPPORT
+	/*
+	 * scheduled scan settings
+	 */
+	wiphy->max_sched_scan_ssids = WLAND_PNO_MAX_PFN_COUNT;
+	wiphy->max_match_sets = WLAND_PNO_MAX_PFN_COUNT;
+	wiphy->max_sched_scan_ie_len = SCAN_IE_LEN_MAX;
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif /* WLAND_SCHED_SCAN_SUPPORT */
+
+	//bitmask of interfaces types valid for this wiphy, must be set by driver
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)
+#ifdef WLAND_MONITOR_SUPPORT
+		| BIT(NL80211_IFTYPE_MONITOR)
+#endif /* WLAND_MONITOR_SUPPORT */
+		| BIT(NL80211_IFTYPE_AP)
+#ifdef WLAND_TBD_SUPPORT
+		| BIT(NL80211_IFTYPE_ADHOC)
+#endif /* WLAND_TBD_SUPPORT */
+#ifdef WLAND_P2P_SUPPORT
+		| BIT(NL80211_IFTYPE_P2P_CLIENT)
+		| BIT(NL80211_IFTYPE_P2P_GO)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		| BIT(NL80211_IFTYPE_P2P_DEVICE)
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+#endif /* WLAND_P2P_SUPPORT */
+		;
+#ifdef WLAND_TBD_SUPPORT
+	//Valid interface combinations array, should not list single interface types.
+	wiphy->iface_combinations = wland_iface_combos;
+	wiphy->n_iface_combinations = ARRAY_SIZE(wland_iface_combos);
+#endif /* WLAND_TBD_SUPPORT */
+
+	//information about bands/channels supported by this device
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
+
+	/*
+	 * signal type reported in &struct cfg80211_bss.
+	 * *@CFG80211_SIGNAL_TYPE_NONE: no signal strength information available
+	 * *@CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
+	 * *@CFG80211_SIGNAL_TYPE_UNSPEC: signal strength, increasing from 0 through 100
+	 */
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+
+	//supported cipher suites
+	wiphy->cipher_suites = __wl_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);
+
+	//Maximum time a remain-on-channel operation may request, if implemented.
+	wiphy->max_remain_on_channel_duration = 5000;
+
+	//bitmasks of frame subtypes that can be subscribed to or transmitted through nl80211,
+	//points to an array indexed by interface type
+	wiphy->mgmt_stypes = cfg80211_default_mgmt_stypes;
+
+	/*
+	 * initial flags
+	 */
+	//if set to true, powersave will be enabled.
+#ifdef WLAND_POWER_MANAGER
+	wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#else /*WLAND_POWER_MANAGER */
+	wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#endif /*WLAND_POWER_MANAGER */
+
+	/*
+	 *@WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this wiphy at all
+	 *@WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station on a VLAN interface)
+	 *@WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station
+	 */
+	wiphy->flags |= WIPHY_FLAG_NETNS_OK | WIPHY_FLAG_4ADDR_AP |
+		WIPHY_FLAG_4ADDR_STATION;
+	/*
+	 * If driver advertises FW_ROAM, the supplicant wouldn't
+	 * * send the BSSID & Freq in the connect command allowing the
+	 * * the driver to choose the AP to connect to. But unless we
+	 * * support ROAM_CACHE in firware this will delay the ASSOC as
+	 * * as the FW need to do a full scan before attempting to connect
+	 * * So that feature will just increase assoc. The better approach
+	 * * to let Supplicant to provide channel info and FW letter may roam
+	 * * if needed so DON'T advertise that featur eto Supplicant.
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	/*
+	 * wiphy->flags                       |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
+	 */
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+
+	//@WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.
+	//@WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	wiphy->flags |=
+		WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL | WIPHY_FLAG_OFFCHAN_TX;
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0) */
+
+	//@WIPHY_FLAG_HAVE_AP_SME: Device integrates AP SME.
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	/*
+	 * From 3.4 kernel ownards AP_SME flag can be advertised to remove the patch from supplicant
+	 */
+	wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+
+	//@WIPHY_FLAG_CUSTOM_REGULATORY: tell us the driver for this device
+	//has its own custom regulatory domain and cannot identify the
+	//ISO /IEC 3166 alpha2 it belongs to. When this is enabled
+	//we will disregard the first regulatory hint (when the initiator is %REGDOM_SET_BY_CORE).
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+
+	WLAND_DBG(CFG80211, TRACE, "Registering custom regulatory.\n");
+
+	/*
+	 *the driver's regulatory notification callback,
+	 *note that if your driver uses wiphy_apply_custom_regulatory()
+	 *the reg_nodifier's request can be passed as NULL
+	 */
+	wiphy->reg_notifier = cfg80211_reg_notifier;
+
+	wiphy_apply_custom_regulatory(wiphy, &wland_regdom);
+
+	err = wiphy_register(wiphy);
+	if (unlikely(err < 0)) {
+		WLAND_ERR("Could not register wiphy device (%d)\n", err);
+		wiphy_free(wiphy);
+		return ERR_PTR(err);
+	}
+	return wiphy;
+}
+
+struct wland_cfg80211_vif *wland_alloc_vif(struct wland_cfg80211_info *cfg,
+	enum nl80211_iftype type, bool pm_block)
+{
+	struct wland_cfg80211_vif *vif;
+
+	if (cfg->vif_cnt == WLAND_IFACE_MAX_CNT) {
+		WLAND_ERR("vif_cnt(%d)\n", cfg->vif_cnt);
+		return ERR_PTR(-ENOSPC);
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "allocating virtual interface (size=%zu)\n",
+		sizeof(*vif));
+
+	vif = kzalloc(sizeof(struct wland_cfg80211_vif), GFP_KERNEL);
+	if (!vif)
+		return ERR_PTR(-ENOMEM);
+
+	memset(vif, 0, sizeof(struct wland_cfg80211_vif));
+
+	vif->wdev.wiphy = cfg->wiphy;
+	vif->wdev.iftype = type;
+
+	vif->mode = nl80211_iftype_to_mode(type);
+	vif->pm_block = pm_block;
+	vif->roam_off = -1;
+
+	list_add_tail(&vif->list, &cfg->vif_list);
+	cfg->vif_cnt++;
+	return vif;
+}
+
+void wland_free_vif(struct wland_cfg80211_info *cfg,
+	struct wland_cfg80211_vif *vif)
+{
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	list_del(&vif->list);
+	cfg->vif_cnt--;
+
+	kfree(vif);
+
+	if (!cfg->vif_cnt) {
+		wiphy_unregister(cfg->wiphy);
+		wiphy_free(cfg->wiphy);
+	}
+}
+
+static bool wland_is_nonetwork(struct wland_cfg80211_info *cfg,
+	const struct wland_event_msg *e)
+{
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (e->status == STATUS_NO_NETWORKS) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Processing Link no network found\n");
+		return true;
+	}
+
+	if (e->status != STATUS_SUCCESS) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Processing connecting & no network found\n");
+		return true;
+	}
+
+	return false;
+}
+
+static s32 wland_get_assoc_ies(struct wland_cfg80211_info *cfg,
+	struct wland_if *ifp)
+{
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+	u8 req_len, resp_len;
+	s32 err = 0;
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+
+	if (conn_info->req_ie)
+		kfree(conn_info->req_ie);
+	conn_info->req_ie = NULL;
+	conn_info->req_ie_len = 0;
+	if (conn_info->resp_ie)
+		kfree(conn_info->resp_ie);
+	conn_info->resp_ie = NULL;
+	conn_info->resp_ie_len = 0;
+
+	err = wland_fil_get_cmd_data(ifp, WID_ASSOC_REQ_INFO, cfg->extra_buf,
+		WLAND_ASSOC_INFO_MAX);
+	if (err < 0) {
+		WLAND_ERR("could not get assoc info:%d\n", err);
+		return err;
+	}
+
+	req_len = cfg->extra_buf[0];
+
+	if (req_len) {
+		//WLAND_DUMP(CFG80211, cfg->extra_buf, (req_len + 1), "assocreq,len:%Zu\n", req_len);
+		conn_info->req_ie_len = req_len;
+		conn_info->req_ie =
+			kmemdup(&cfg->extra_buf[1], conn_info->req_ie_len,
+			GFP_KERNEL);
+	} else {
+		conn_info->req_ie_len = 0;
+		conn_info->req_ie = NULL;
+	}
+
+	err = wland_fil_get_cmd_data(ifp, WID_ASSOC_RES_INFO, cfg->extra_buf,
+		WLAND_ASSOC_INFO_MAX);
+	if (err < 0) {
+		WLAND_ERR("could not get assoc resp:%d\n", err);
+		return err;
+	}
+
+	resp_len = cfg->extra_buf[0];
+	if (resp_len) {
+		//WLAND_DUMP(CFG80211, cfg->extra_buf, (resp_len + 1), "assocres,len:%Zu\n", resp_len);
+		conn_info->resp_ie_len = resp_len;
+		conn_info->resp_ie =
+			kmemdup(&cfg->extra_buf[1], conn_info->resp_ie_len,
+			GFP_KERNEL);
+	} else {
+		conn_info->resp_ie_len = 0;
+		conn_info->resp_ie = NULL;
+	}
+
+	WLAND_DBG(CFG80211, DEBUG, "Done(req len:%d,resp len:%d)\n",
+		conn_info->req_ie_len, conn_info->resp_ie_len);
+
+	return err;
+}
+
+static s32 wland_bss_roaming_done(struct wland_cfg80211_info *cfg,
+	struct net_device *ndev, const struct wland_event_msg *e)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+	struct ieee80211_channel *notify_channel = NULL;
+	struct ieee80211_supported_band *band =
+		wiphy->bands[IEEE80211_BAND_2GHZ];
+	struct wland_bss_info_le *bi;
+	struct wland_chan ch;
+	u32 freq;
+	s32 err = 0;
+	u8 *buf;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	wland_get_assoc_ies(cfg, ifp);
+
+	buf = kzalloc(WLAND_BSS_INFO_MAX, GFP_KERNEL);
+	if (buf == NULL) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/*
+	 * data sent to dongle has to be little endian
+	 */
+	*(__le32 *) buf = cpu_to_le32(WLAND_BSS_INFO_MAX);
+
+	err = wland_fil_iovar_data_get(ifp, "get_bss_info", buf,
+		WLAND_BSS_INFO_MAX);
+	if (err < 0)
+		goto done;
+
+	bi = (struct wland_bss_info_le *) (buf + 4);
+	ch.chspec = le16_to_cpu(bi->chanspec);
+	cfg->d11inf.decchspec(&ch);
+
+	if (ch.band == CHAN_BAND_2G)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+#ifdef WLAND_5GRF_SUPPORT
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif /*WLAND_5GRF_SUPPORT */
+
+	freq = ieee80211_channel_to_frequency(ch.chnum, band->band);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+
+done:
+	kfree(buf);
+out:
+	cfg80211_roamed(ndev,
+		notify_channel,
+		(u8 *) profile->bssid,
+		conn_info->req_ie,
+		conn_info->req_ie_len,
+		conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+	set_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state);
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 wland_bss_connect_done(struct wland_cfg80211_info *cfg,
+	struct net_device *ndev, const struct wland_event_msg *e,
+	bool completed)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	struct wland_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+
+	WLAND_DBG(CFG80211, DEBUG, "Enter(completed:%d)\n", completed);
+	if (test_and_clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state)) {
+		if (completed) {
+			//wland_get_assoc_ies(cfg, ifp);
+			WLAND_DBG(CFG80211, TRACE,
+				"########## connected and clear VIF_STATUS_CONNECTING\n");
+			set_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state);
+			wland_set_phy_timeout(ifp->drvr, profile->sec.cipher_pairwise);
+		}
+
+		cfg80211_connect_result(ndev,
+			(u8 *) profile->bssid,
+			conn_info->req_ie,
+			conn_info->req_ie_len,
+			conn_info->resp_ie,
+			conn_info->resp_ie_len,
+			completed ? WLAN_STATUS_SUCCESS :
+			WLAN_STATUS_AUTH_TIMEOUT, GFP_KERNEL);
+		WLAND_DBG(CFG80211, INFO,
+			"Report connect result - connection %s\n",
+			completed ? "succeeded" : "failed");
+	}
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return 0;
+}
+
+static s32 notify_connect_status(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_cfg80211_connect_info *conn_info = &cfg->conn_info;
+	struct net_device *ndev = ifp->ndev;
+	struct wland_cfg80211_profile *profile = ndev_to_prof(ndev);
+	s32 err = 0;
+	u16 eventLen = 0;
+	u8 *pU8Buffer = (u8 *) data;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(ifp->vif->mode:%d)\n",
+		ifp->vif->mode);
+
+	if (!check_vif_up(ifp->vif)) {
+		WLAND_ERR("Vif Not SetUp(event:%d,reason:%d)\n", e->event_code,
+			e->reason);
+		err = -EINVAL;
+		return err;
+	}
+
+	cancel_work_sync(&conn_info->work);
+	if (timer_pending(&conn_info->timer)) {
+		del_timer_sync(&conn_info->timer);
+		WLAND_DBG(CFG80211, TRACE, "###### delete conn_info->timer\n");
+	}
+
+	if (ifp->vif->mode == WL_MODE_AP) {
+		static int generation;
+		struct station_info sinfo;
+
+		WLAND_DBG(CFG80211, TRACE, "SoftAp,event_code:%d\n",
+			e->event_code);
+
+		if (ndev != cfg_to_ndev(cfg)) {
+			WLAND_DBG(CFG80211, TRACE, "AP mode link down\n");
+			complete(&cfg->vif_disabled);
+			goto fail;
+		}
+
+		if ((e->event_code == WLAND_E_CONNECT_IND)
+			&& (e->action == EVENT_ASSOC_IND
+				|| e->action == EVENT_REASSOC_IND)
+			&& (e->status == STATUS_SUCCESS)) {
+			/*
+			 * Extract network event length
+			 */
+			eventLen = MAKE_WORD16(pU8Buffer[2], pU8Buffer[3]);
+
+			WLAND_DBG(CFG80211, DEBUG,
+				"WLAND_E_CONNECT_IND, e->addr=%pM\n", e->addr);
+			WLAND_DUMP(RX_NETEVENT, pU8Buffer, eventLen + 4,
+				"Event len:%Zu\n", eventLen);
+			memset(&sinfo, 0, sizeof(sinfo));
+			sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
+			if (!pU8Buffer) {
+				WLAND_ERR
+					("No IEs present in ASSOC/REASSOC_IND");
+				err = -EINVAL;
+				goto fail;
+			}
+			sinfo.assoc_req_ies = pU8Buffer + 6 + 24 + 2 + 2;
+			sinfo.assoc_req_ies_len = eventLen - 24 - 2 - 2 - 4;
+			generation++;
+			sinfo.generation = generation;
+			cfg80211_new_sta(ndev, e->addr, &sinfo, GFP_KERNEL);
+		} else if ((e->event_code == WLAND_E_DISCONNECT_IND)
+			&& (e->action == EVENT_DISASSOC_IND)) {
+			WLAND_DBG(CFG80211, DEBUG,
+				"WLAND_E_DISCONNECT_IND, e->addr=%pM\n",
+				e->addr);
+			cfg80211_del_sta(ndev, e->addr, GFP_KERNEL);
+		}
+	} else if ((e->event_code == WLAND_E_CONNECT_IND)
+		&& (e->status == STATUS_SUCCESS)) {
+		WLAND_DBG(CFG80211, DEBUG, "Linkup\n");
+
+		/*
+		 * start restore work timer
+		 */
+		mod_timer(&conn_info->connect_restorework_timeout,
+			jiffies + msecs_to_jiffies(CONNECT_RESTOREWORK_TIMER_MS));
+		WLAND_DBG(CFG80211, TRACE, "###### Set restore work timer(%d s)!\n",
+			CONNECT_RESTOREWORK_TIMER_MS);
+
+		if (ifp->vif->mode == WL_MODE_IBSS) {
+			memcpy(profile->bssid, e->addr, ETH_ALEN);
+			wland_inform_ibss(cfg, ndev, e->addr);
+			cfg80211_ibss_joined(ndev, e->addr, GFP_KERNEL);
+			clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+			set_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state);
+		} else {
+			WLAND_DBG(CFG80211, INFO,
+				"connected. wland_bss_connect_done\n");
+			if (!netif_carrier_ok(ndev)) {
+				netif_carrier_on(ndev);
+				WLAND_DBG(CFG80211, TRACE,
+					"netif_carrier_on(ndev)\n");
+			}
+			if (netif_queue_stopped(ndev)) {
+				netif_wake_queue(ndev);
+				WLAND_DBG(CFG80211, TRACE,
+					"netif_wake_queue(ndev)\n");
+			}
+			wland_bss_connect_done(cfg, ndev, e, true);
+		}
+	} else if (e->event_code == WLAND_E_DISCONNECT_IND) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Linkdown ifp->vif->mode=%d, sme_state=%x\n",
+			ifp->vif->mode, (u32) ifp->vif->sme_state);
+
+		if (timer_pending(&conn_info->connect_restorework_timeout)) {
+			del_timer_sync(&conn_info->connect_restorework_timeout);
+			WLAND_DBG(CFG80211, TRACE, "###### delete connect restorework timer\n");
+		}
+
+		if (ifp->vif->mode != WL_MODE_IBSS) {
+			if (!netif_queue_stopped(ndev)) {
+				netif_stop_queue(ndev);
+				WLAND_DBG(CFG80211, TRACE,
+					"netif_stop_queue(ndev)\n");
+			}
+			if (netif_carrier_ok(ndev)) {
+				netif_carrier_off(ndev);
+				WLAND_DBG(CFG80211, TRACE,
+					"netif_carrier_off(ndev)\n");
+			}
+			wland_bss_connect_done(cfg, ndev, e, false);
+
+			if (test_and_clear_bit(VIF_STATUS_CONNECTED,
+					&ifp->vif->sme_state)) {
+				cfg80211_disconnected(ndev, 0, NULL, 0,
+					GFP_KERNEL);
+				WLAND_DBG(CFG80211, INFO, "cfg80211_disconnected\n");
+			}
+		}
+
+		wland_link_down(ifp->vif);
+
+		memset(profile, '\0', sizeof(struct wland_cfg80211_profile));
+		if (cfg->in_disconnecting) {
+			if (cfg->in_waiting) {
+				complete(&cfg->disconnecting_wait);
+			}
+			cfg->in_disconnecting = false;
+		}
+
+		if (ndev != cfg_to_ndev(cfg))
+			complete(&cfg->vif_disabled);
+	} else if (wland_is_nonetwork(cfg, e)) {
+		if (ifp->vif->mode != WL_MODE_IBSS)
+			clear_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state);
+		else
+			wland_bss_connect_done(cfg, ndev, e, false);
+	}
+
+fail:
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 notify_roaming_status(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (e->event_code == WLAND_E_ROAM && e->status == STATUS_SUCCESS) {
+		if (test_bit(VIF_STATUS_CONNECTED, &ifp->vif->sme_state))
+			wland_bss_roaming_done(cfg, ifp->ndev, e);
+		else
+			wland_bss_connect_done(cfg, ifp->ndev, e, true);
+	}
+
+	return 0;
+}
+
+static s32 notify_vif_event(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_cfg80211_vif_event *event = &cfg->vif_event;
+	struct wland_cfg80211_vif *vif = event->vif;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter: action %u ifidx %u bsscfg %u\n",
+		e->action, e->ifidx, e->bsscfgidx);
+
+	mutex_lock(&event->vif_event_lock);
+	event->action = e->action;
+
+	switch (e->action) {
+	case WLAND_E_IF_ADD:
+		/*
+		 * waiting process may have timed out
+		 */
+		if (!cfg->vif_event.vif) {
+			mutex_unlock(&event->vif_event_lock);
+			return -EBADF;
+		}
+
+		ifp->vif = vif;
+
+		vif->ifp = ifp;
+		if (ifp->ndev) {
+			vif->wdev.netdev = ifp->ndev;
+			ifp->ndev->ieee80211_ptr = &vif->wdev;
+
+			SET_NETDEV_DEV(ifp->ndev, wiphy_dev(cfg->wiphy));
+		}
+		mutex_unlock(&event->vif_event_lock);
+		wake_up(&event->vif_wq);
+		return 0;
+
+	case WLAND_E_IF_DEL:
+		mutex_unlock(&event->vif_event_lock);
+		/*
+		 * event may not be upon user request
+		 */
+		if (wland_cfg80211_vif_event_armed(cfg))
+			wake_up(&event->vif_wq);
+		return 0;
+
+	case WLAND_E_IF_CHANGE:
+		mutex_unlock(&event->vif_event_lock);
+		wake_up(&event->vif_wq);
+		return 0;
+
+	default:
+		mutex_unlock(&event->vif_event_lock);
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static void wland_register_event_handlers(struct wland_cfg80211_info *cfg)
+{
+	firmweh_register(cfg->pub, WLAND_E_ESCAN_RESULT, notify_escan_handler);
+	firmweh_register(cfg->pub, WLAND_E_DISCONNECT_IND,
+		notify_connect_status);
+	firmweh_register(cfg->pub, WLAND_E_CONNECT_IND, notify_connect_status);
+
+	firmweh_register(cfg->pub, WLAND_E_ROAM, notify_roaming_status);
+	firmweh_register(cfg->pub, WLAND_E_PFN_NET_FOUND,
+		notify_sched_scan_results);
+
+	firmweh_register(cfg->pub, WLAND_E_IF_ADD, notify_vif_event);
+	firmweh_register(cfg->pub, WLAND_E_IF_DEL, notify_vif_event);
+	firmweh_register(cfg->pub, WLAND_E_IF_CHANGE, notify_vif_event);
+#ifdef WLAND_P2P_SUPPORT
+	firmweh_register(cfg->pub, WLAND_E_P2P_PROBEREQ_MSG,
+		notify_p2p_rx_mgmt_probereq);
+	firmweh_register(cfg->pub, WLAND_E_P2P_DISC_LISTEN_COMPLETE,
+		notify_p2p_listen_complete);
+	firmweh_register(cfg->pub, WLAND_E_ACTION_FRAME_RX,
+		notify_p2p_action_frame_rx);
+	firmweh_register(cfg->pub, WLAND_E_ACT_FRAME_COMPLETE,
+		notify_p2p_action_tx_complete);
+	firmweh_register(cfg->pub, WLAND_E_ACT_FRAME_OFF_CHAN_COMPLETE,
+		notify_p2p_action_tx_complete);
+#endif /* WLAND_P2P_SUPPORT */
+}
+
+static void wland_deinit_priv_mem(struct wland_cfg80211_info *cfg)
+{
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+
+	if (cfg->conf)
+		kfree(cfg->conf);
+	cfg->conf = NULL;
+
+	if (cfg->extra_buf)
+		kfree(cfg->extra_buf);
+	cfg->extra_buf = NULL;
+
+	if (cfg->pmk_list)
+		kfree(cfg->pmk_list);
+	cfg->pmk_list = NULL;
+
+	WLAND_DBG(CFG80211, DEBUG, "Done\n");
+}
+
+static s32 wland_init_priv_mem(struct wland_cfg80211_info *cfg)
+{
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	cfg->conf = NULL;
+	cfg->extra_buf = NULL;
+	cfg->pmk_list = NULL;
+
+	cfg->conf = kzalloc(sizeof(struct wland_cfg80211_conf), GFP_KERNEL);
+	if (!cfg->conf)
+		goto init_priv_mem_out;
+
+	cfg->extra_buf = kzalloc(WLAND_EXTRA_BUF_MAX, GFP_KERNEL);
+	if (!cfg->extra_buf)
+		goto init_priv_mem_out;
+
+	cfg->pmk_list =
+		kzalloc(sizeof(struct wland_cfg80211_pmk_list), GFP_KERNEL);
+	if (!cfg->pmk_list)
+		goto init_priv_mem_out;
+
+	WLAND_DBG(CFG80211, TRACE, "Success Done\n");
+	return 0;
+
+init_priv_mem_out:wland_deinit_priv_mem(cfg);
+
+	WLAND_DBG(CFG80211, TRACE, "Failed Done\n");
+	return -ENOMEM;
+}
+
+static s32 wland_dongle_roam(struct wland_if *ifp, u32 roamvar, u32 bcn_timeout)
+{
+	s32 err = 0;
+	__le32 roamtrigger[2];
+	__le32 roam_delta[2];
+
+	/*
+	 * Setup timeout if Beacons are lost and roam is off to report link down
+	 */
+	if (roamvar) {
+		err = wland_fil_iovar_data_set(ifp, "bcn_timeout", &bcn_timeout,
+			sizeof(bcn_timeout));
+		if (err < 0) {
+			WLAND_ERR("bcn_timeout error (%d)\n", err);
+			goto dongle_rom_out;
+		}
+	}
+
+	/*
+	 * Enable/Disable built-in roaming to allow supplicant to take care of roaming
+	 */
+	WLAND_DBG(CFG80211, TRACE, "Internal Roaming = %s\n",
+		roamvar ? "Off" : "On");
+
+	err = wland_fil_iovar_data_set(ifp, "roam_off", &roamvar,
+		sizeof(roamvar));
+	if (err < 0) {
+		WLAND_ERR("roam_off error (%d)\n", err);
+		goto dongle_rom_out;
+	}
+
+	roamtrigger[0] = cpu_to_le32(ROAM_TRIGGER_LEVEL);
+	roamtrigger[1] = cpu_to_le32(WLAND_BAND_ALL);
+	err = wland_fil_iovar_data_set(ifp, "roam_trigger", roamtrigger,
+		sizeof(roamtrigger));
+	if (err < 0) {
+		WLAND_ERR("WLC_SET_ROAM_TRIGGER error (%d)\n", err);
+		goto dongle_rom_out;
+	}
+
+	roam_delta[0] = cpu_to_le32(ROAM_DELTA);
+	roam_delta[1] = cpu_to_le32(WLAND_BAND_ALL);
+	err = wland_fil_iovar_data_set(ifp, "roam_delta", roam_delta,
+		sizeof(roam_delta));
+	if (err < 0) {
+		WLAND_ERR("WLC_SET_ROAM_DELTA error (%d)\n", err);
+		goto dongle_rom_out;
+	}
+
+dongle_rom_out:
+	return err;
+}
+
+static s32 wland_construct_reginfo(struct wland_cfg80211_info *cfg, u32 bw_cap)
+{
+	struct wland_if *ifp = netdev_priv(cfg_to_ndev(cfg));
+	struct ieee80211_channel *band_chan_arr;
+	struct wland_chanspec_list *list;
+	struct wland_chan ch;
+	u8 *pbuf;
+	s32 err;
+	u32 i, j, total, channel, index, ht40_flag, array_size;
+	enum ieee80211_band band;
+	u32 *n_cnt;
+	bool ht40_allowed, update;
+
+	return 0;
+
+	pbuf = kzalloc(WLAND_DCMD_MEDLEN, GFP_KERNEL);
+	if (pbuf == NULL)
+		return -ENOMEM;
+
+	list = (struct wland_chanspec_list *) pbuf;
+	err = wland_fil_iovar_data_get(ifp, "chanspecs", pbuf,
+		WLAND_DCMD_MEDLEN);
+	if (err < 0) {
+		WLAND_ERR("get chanspecs error (%d)\n", err);
+		goto exit;
+	}
+
+	__wl_band_2ghz.n_channels = 0;
+
+#ifdef WLAND_5GRF_SUPPORT
+	__wl_band_5ghz_a.n_channels = 0;
+#endif /* WLAND_5GRF_SUPPORT */
+	total = le32_to_cpu(list->count);
+
+	for (i = 0; i < total; i++) {
+		ch.chspec = (u16) le32_to_cpu(list->element[i]);
+		cfg->d11inf.decchspec(&ch);
+
+		if (ch.band == CHAN_BAND_2G) {
+			band_chan_arr = __wl_2ghz_channels;
+			array_size = ARRAY_SIZE(__wl_2ghz_channels);
+			n_cnt = &__wl_band_2ghz.n_channels;
+			band = IEEE80211_BAND_2GHZ;
+			ht40_allowed = (bw_cap == WLC_N_BW_40ALL);
+		}
+#ifdef WLAND_5GRF_SUPPORT
+		else if (ch.band == CHAN_BAND_5G) {
+			band_chan_arr = __wl_5ghz_a_channels;
+			array_size = ARRAY_SIZE(__wl_5ghz_a_channels);
+			n_cnt = &__wl_band_5ghz_a.n_channels;
+			band = IEEE80211_BAND_5GHZ;
+			ht40_allowed = !(bw_cap == WLC_N_BW_20ALL);
+		}
+#endif /* WLAND_5GRF_SUPPORT */
+		else {
+			WLAND_ERR("Invalid channel Sepc. 0x%x.\n", ch.chspec);
+			continue;
+		}
+
+		if (!ht40_allowed && ch.bw == CHAN_BW_40)
+			continue;
+
+		update = false;
+
+		for (j = 0; (j < *n_cnt && (*n_cnt < array_size)); j++) {
+			if (band_chan_arr[j].hw_value == ch.chnum) {
+				update = true;
+				break;
+			}
+		}
+
+		if (update)
+			index = j;
+		else
+			index = *n_cnt;
+
+		if (index < array_size) {
+			band_chan_arr[index].center_freq =
+				ieee80211_channel_to_frequency(ch.chnum, band);
+			band_chan_arr[index].hw_value = ch.chnum;
+
+			if (ch.bw == CHAN_BW_40 && ht40_allowed) {
+				/*
+				 * assuming the order is HT20, HT40 Upper, HT40 lower from chanspecs
+				 */
+				ht40_flag =
+					band_chan_arr[index].flags &
+					IEEE80211_CHAN_NO_HT40;
+				if (ch.sb == WLAND_CHAN_SB_U) {
+					if (ht40_flag == IEEE80211_CHAN_NO_HT40)
+						band_chan_arr[index].flags &=
+							~IEEE80211_CHAN_NO_HT40;
+					band_chan_arr[index].flags |=
+						IEEE80211_CHAN_NO_HT40PLUS;
+				} else {
+					/*
+					 * It should be one of IEEE80211_CHAN_NO_HT40 or IEEE80211_CHAN_NO_HT40PLUS
+					 */
+					band_chan_arr[index].flags &=
+						~IEEE80211_CHAN_NO_HT40;
+					if (ht40_flag == IEEE80211_CHAN_NO_HT40)
+						band_chan_arr[index].flags |=
+							IEEE80211_CHAN_NO_HT40MINUS;
+				}
+			} else {
+				band_chan_arr[index].flags =
+					IEEE80211_CHAN_NO_HT40;
+				ch.bw = CHAN_BW_20;
+				cfg->d11inf.encchspec(&ch);
+				channel = ch.chspec;
+				err = wland_fil_iovar_data_get(ifp,
+					"per_chan_info", &channel,
+					sizeof(channel));
+				if (!err) {
+					if (channel & WL_CHAN_RADAR)
+						band_chan_arr[index].flags |=
+							(IEEE80211_CHAN_RADAR |
+							IEEE80211_CHAN_NO_IBSS);
+					if (channel & WL_CHAN_PASSIVE)
+						band_chan_arr[index].flags |=
+							IEEE80211_CHAN_PASSIVE_SCAN;
+				}
+			}
+			if (!update)
+				(*n_cnt)++;
+		}
+	}
+exit:
+	kfree(pbuf);
+	return err;
+}
+
+static s32 wland_update_wiphybands(struct wland_cfg80211_info *cfg, bool notify)
+{
+	struct wland_if *ifp = netdev_priv(cfg_to_ndev(cfg));
+	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+	struct ieee80211_supported_band *bands[IEEE80211_NUM_BANDS];
+	s32 phy_list, err, i, index;
+	u32 band_list[3], nmode, nband, bw_cap = 0;
+	s8 phy;
+
+	err = wland_fil_iovar_data_get(ifp, "get_phylist", &phy_list,
+		sizeof(phy_list));
+	if (err < 0) {
+		WLAND_ERR("WLAND_C_GET_PHYLIST error (%d)\n", err);
+		return err;
+	}
+
+	phy = ((char *) &phy_list)[0];
+
+	WLAND_DBG(CFG80211, TRACE, "GET_PHYLIST reported: %c phy\n", phy);
+
+	err = wland_fil_iovar_data_get(ifp, "nmode", &nmode, sizeof(nmode));
+	if (err < 0) {
+		WLAND_ERR("nmode error (%d)\n", err);
+	} else {
+		err = wland_fil_iovar_data_get(ifp, "mimo_bw_cap", &bw_cap,
+			sizeof(bw_cap));
+		/*
+		 * set default value
+		 */
+		bw_cap = 0, nmode = 1;
+		band_list[0] = 0x01;
+		band_list[1] = 0x02;
+		band_list[2] = 0x00;
+		if (err < 0)
+			WLAND_ERR("mimo_bw_cap error (%d)\n", err);
+	}
+	WLAND_DBG(CFG80211, TRACE, "nmode=%d, mimo_bw_cap=%d\n", nmode, bw_cap);
+
+	err = wland_construct_reginfo(cfg, bw_cap);
+	if (err < 0) {
+		WLAND_ERR("construct reginfo failed (%d)\n", err);
+		return err;
+	}
+
+	nband = band_list[0];
+	memset(bands, 0, sizeof(bands));
+
+	for (i = 1; i <= nband && i < ARRAY_SIZE(band_list); i++) {
+		index = -1;
+#ifdef WLAND_5GRF_SUPPORT
+		if ((band_list[i] == WLC_BAND_5G)
+			&& (__wl_band_5ghz_a.n_channels > 0)) {
+			index = IEEE80211_BAND_5GHZ;
+			bands[index] = &__wl_band_5ghz_a;
+
+			if ((bw_cap == WLC_N_BW_40ALL)
+				|| (bw_cap == WLC_N_BW_20IN2G_40IN5G))
+				bands[index]->ht_cap.cap |=
+					IEEE80211_HT_CAP_SGI_40;
+		}
+#endif /*WLAND_5GRF_SUPPORT */
+		if ((band_list[i] == WLC_BAND_2G)
+			&& (__wl_band_2ghz.n_channels > 0)) {
+			index = IEEE80211_BAND_2GHZ;
+			bands[index] = &__wl_band_2ghz;
+
+			if (bw_cap == WLC_N_BW_40ALL)
+				bands[index]->ht_cap.cap |=
+					IEEE80211_HT_CAP_SGI_40;
+		}
+
+		WLAND_DBG(CFG80211, TRACE, "index:%d,nmode:%d\n", index, nmode);
+
+		/*
+		 * setup 802.11n
+		 */
+		if ((index >= 0) && nmode) {
+			bands[index]->ht_cap.ht_supported = true;
+			bands[index]->ht_cap.cap |=
+				(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+			bands[index]->ht_cap.mcs.rx_mask[0] = 0xFF;
+			bands[index]->ht_cap.ampdu_factor =
+				IEEE80211_HT_MAX_AMPDU_8K;
+			bands[index]->ht_cap.ampdu_density =
+				IEEE80211_HT_MPDU_DENSITY_NONE;
+#ifdef WLAND_TBD_SUPPORT
+			bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;
+			bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;
+			bands[index]->ht_cap.ht_supported = true;
+			bands[index]->ht_cap.ampdu_factor =
+				IEEE80211_HT_MAX_AMPDU_64K;
+			bands[index]->ht_cap.ampdu_density =
+				IEEE80211_HT_MPDU_DENSITY_16;
+			/*
+			 * An HT shall support all EQM rates for one spatial stream
+			 */
+			bands[index]->ht_cap.mcs.rx_mask[0] = 0xFF;
+#endif /*WLAND_TBD_SUPPORT */
+		}
+	}
+
+	wiphy->bands[IEEE80211_BAND_2GHZ] = bands[IEEE80211_BAND_2GHZ];
+#ifdef WLAND_5GRF_SUPPORT
+	wiphy->bands[IEEE80211_BAND_5GHZ] = bands[IEEE80211_BAND_5GHZ];
+#endif /*WLAND_5GRF_SUPPORT */
+	if (notify)
+		wiphy_apply_custom_regulatory(wiphy, &wland_regdom);
+
+	return err;
+}
+
+#ifdef WLAND_INIT_SCAN_SUPPORT
+static inline void wland_init_scan(struct wland_cfg80211_info *cfg,
+	struct net_device * ndev, struct wireless_dev *wdev)
+{
+	//init scan
+	struct cfg80211_scan_request request;
+	struct cfg80211_ssid ssids;
+	memset(&request, 0, sizeof(request));
+#if   LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	request.wdev = wdev;
+#endif
+	request.n_ssids = 1;
+
+	ssids.ssid_len = 0;
+	request.ssids = &ssids;
+
+	//request.n_channels = 14;
+	//request.n_ssids = 1;
+	//request.ssids = NULL;
+
+	cfg80211_scan(cfg->wiphy,
+#if    LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	ndev,
+#endif/*LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0) */
+	&request);
+}
+#endif
+
+s32 wland_cfg80211_up(struct net_device * ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_info *cfg = ndev_to_cfg(ndev);
+	struct wireless_dev *wdev = ndev->ieee80211_ptr;
+	s32 power_mode, err = 0;
+
+	mutex_lock(&cfg->usr_sync);
+
+	set_bit(VIF_STATUS_READY, &ifp->vif->sme_state);
+
+	if (cfg->dongle_up) {
+		WLAND_ERR("dongle up\n");
+		goto up_exit;
+	}
+
+	power_mode = cfg->pwr_save ? MIN_FAST_PS : NO_POWERSAVE;
+
+	WLAND_DBG(CFG80211, TRACE, "power save set to %s\n",
+		(power_mode ? "enabled" : "disabled"));
+
+	err = wland_dongle_roam(ifp, (cfg->roam_on ? 0 : 1),
+		WLAND_BEACON_TIMEOUT);
+	if (err < 0)
+		goto up_exit;
+
+	err = cfg80211_change_virtual_iface(wdev->wiphy, ndev, wdev->iftype,
+		NULL, NULL);
+	if (err < 0)
+		goto up_exit;
+
+	/*
+	 * according chip cap to update wiphybands
+	 */
+	err = wland_update_wiphybands(cfg, true);
+	if (err)
+		goto up_exit;
+
+	cfg->dongle_up = true;
+#ifdef WLAND_INIT_SCAN_SUPPORT
+	wland_init_scan(cfg, ndev, wdev);
+#endif
+up_exit:
+	mutex_unlock(&cfg->usr_sync);
+
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+s32 wland_cfg80211_down(struct net_device * ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_info *cfg = ndev_to_cfg(ndev);
+	s32 err = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (!cfg || !ifp) {
+		WLAND_ERR("Invalid Parameter\n");
+		goto fail;
+	}
+
+	/*
+	 * While going down, if associated with AP disassociate from AP to save power
+	 */
+	mutex_lock(&cfg->usr_sync);
+	if (check_vif_up(ifp->vif)) {
+		wland_link_down(ifp->vif);
+
+		/*
+		 * Make sure WPA_Supplicant receives all the event generated due to DISASSOC
+		 * call to the fw to keep the state fw and WPA_Supplicant state consistent
+		 */
+		//wland_delay(200);
+	}
+	wland_abort_scanning(cfg);
+	clear_bit(VIF_STATUS_READY, &ifp->vif->sme_state);
+	mutex_unlock(&cfg->usr_sync);
+
+fail:
+	WLAND_DBG(CFG80211, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+bool wland_vif_get_state_all(struct wland_cfg80211_info * cfg, ulong state)
+{
+	struct wland_cfg80211_vif *vif;
+	u8 result = 0;
+
+	list_for_each_entry(vif, &cfg->vif_list, list) {
+		if (test_bit(state, &vif->sme_state))
+			result++;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "vif state(result:%d)\n", result);
+
+	return result;
+}
+
+static inline bool vif_event_equals(struct wland_cfg80211_vif_event *event,
+	u8 action)
+{
+	u8 evt_action;
+
+	mutex_lock(&event->vif_event_lock);
+	evt_action = event->action;
+	mutex_unlock(&event->vif_event_lock);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(evt_action:%d)\n", evt_action);
+
+	return evt_action == action;
+}
+
+void wland_cfg80211_arm_vif_event(struct wland_cfg80211_info *cfg,
+	struct wland_cfg80211_vif *vif)
+{
+	struct wland_cfg80211_vif_event *event = &cfg->vif_event;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	mutex_lock(&event->vif_event_lock);
+	event->vif = vif;
+	event->action = 0;
+	mutex_unlock(&event->vif_event_lock);
+}
+
+bool wland_cfg80211_vif_event_armed(struct wland_cfg80211_info *cfg)
+{
+	struct wland_cfg80211_vif_event *event = &cfg->vif_event;
+	bool armed;
+
+	mutex_lock(&event->vif_event_lock);
+	armed = event->vif != NULL;
+	mutex_unlock(&event->vif_event_lock);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(armed:%d)\n", armed);
+
+	return armed;
+}
+
+int wland_cfg80211_wait_vif_event_timeout(struct wland_cfg80211_info *cfg,
+	u8 action, ulong timeout)
+{
+	struct wland_cfg80211_vif_event *event = &cfg->vif_event;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	return wait_event_timeout(event->vif_wq, vif_event_equals(event,
+			action), timeout);
+}
+
+/* attach to cfg80211 mode */
+struct wland_cfg80211_info *cfg80211_attach(struct wland_private *drvr,
+	struct device *busdev)
+{
+	struct net_device *ndev = drvr->iflist[0]->ndev;
+	struct wland_cfg80211_info *cfg;
+	struct wiphy *wiphy;
+	struct wland_cfg80211_vif *vif;
+	struct wland_if *ifp = netdev_priv(ndev);
+	s32 err = 0;
+
+	if (!ndev) {
+		WLAND_ERR("ndev is invalid\n");
+		return NULL;
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Enter,ifp:%p,drvr->iflist[0]:%p.\n", ifp,
+		drvr->iflist[0]);
+
+	wiphy = wland_setup_wiphy(busdev);
+	if (IS_ERR(wiphy)) {
+		WLAND_ERR("setup wiphy failed!\n");
+		return NULL;
+	}
+
+	/*
+	 * setup cfg structure
+	 */
+	cfg = wiphy_priv(wiphy);
+	cfg->wiphy = wiphy;
+	cfg->pub = drvr;
+
+	init_waitqueue_head(&cfg->vif_event.vif_wq);
+
+	mutex_init(&cfg->vif_event.vif_event_lock);
+
+	INIT_LIST_HEAD(&cfg->vif_list);
+
+	vif = wland_alloc_vif(cfg, NL80211_IFTYPE_STATION, false);
+	if (IS_ERR(vif)) {
+		wiphy_free(wiphy);
+		WLAND_ERR("vif malloc failed\n");
+		return NULL;
+	}
+
+	vif->ifp = ifp;
+	vif->wdev.netdev = ndev;
+	ndev->ieee80211_ptr = &vif->wdev;
+
+	SET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));
+
+	cfg->scan_request = NULL;
+	cfg->pwr_save = true;
+	cfg->roam_on = true;	/* roam on & off switch. we enable roam per default */
+	cfg->active_scan = true;	/* we do active scan for specific scan per default */
+	cfg->dongle_up = false;	/* chip is not up yet */
+
+	mutex_init(&cfg->usr_sync);
+
+#ifdef WLAND_INIT_SCAN_SUPPORT
+	atomic_set(&cfg->init_scan, 0);
+#endif
+	mutex_init(&cfg->scan_result_lock);
+	INIT_LIST_HEAD(&cfg->scan_result_list);
+	cfg->scan_results.version = SCAN_VERSION_NUM;
+	cfg->scan_results.count = 0;
+
+	err = wland_init_priv_mem(cfg);
+	if (err < 0) {
+		WLAND_ERR("Failed to init iwm_priv (%d)\n", err);
+		goto cfg80211_attach_out;
+	}
+
+	/*
+	 * register event cb when received from chip
+	 */
+	wland_register_event_handlers(cfg);
+
+	/*
+	 * init escan
+	 */
+	cfg->scan_info.escan_state = SCAN_STATE_IDLE;
+
+	/*
+	 * Init scan_timeout timer
+	 */
+	init_timer(&cfg->scan_timeout);
+	cfg->scan_timeout.data = (ulong) cfg;
+	cfg->scan_timeout.function = wland_scan_timeout;
+
+	INIT_WORK(&cfg->scan_report_work, cfg80211_scan_report_worker);
+
+	err = wland_init_connect_info(cfg);
+	if (err < 0) {
+		WLAND_ERR("Failed to init connect_info (err=%d)\n", err);
+		goto cfg80211_attach_out;
+	}
+
+	/*
+	 * init config
+	 */
+	if (cfg->conf)
+		memset(cfg->conf, 0, sizeof(struct wland_cfg80211_conf));
+
+	init_completion(&cfg->vif_disabled);
+	cfg->in_disconnecting = false;
+	cfg->in_waiting = false;
+	init_completion(&cfg->disconnecting_wait);
+
+	ifp->vif = vif;
+
+#ifdef WLAND_P2P_SUPPORT
+	err = cfg80211_p2p_attach(cfg);
+	if (err < 0) {
+		WLAND_ERR("P2P initilisation failed (%d)\n", err);
+		goto cfg80211_p2p_attach_out;
+	}
+#endif /* WLAND_P2P_SUPPORT */
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	err = wland_btcoex_attach(cfg);
+	if (err < 0) {
+		WLAND_ERR("BT-coex initialisation failed (%d)\n", err);
+#ifdef WLAND_P2P_SUPPORT
+		cfg80211_p2p_detach(&cfg->p2p);
+#endif /* WLAND_P2P_SUPPORT */
+		goto cfg80211_p2p_attach_out;
+	}
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+	cfg->d11inf.io_type = WLAND_D11N_IOTYPE;
+
+	wland_d11_attach(&cfg->d11inf);
+
+#ifdef WLAND_MONITOR_SUPPORT
+	wland_monitor_init(drvr);
+#endif /*WLAND_MONITOR_SUPPORT */
+	WLAND_DBG(CFG80211, TRACE, "Success Done\n");
+
+	return cfg;
+
+#ifdef WLAND_P2P_SUPPORT
+cfg80211_p2p_attach_out:
+	cfg->dongle_up = false;	/* dongle down */
+	wland_deinit_connect_info(cfg);
+	wland_abort_scanning(cfg);
+	wland_deinit_priv_mem(cfg);
+#endif /* WLAND_P2P_SUPPORT */
+
+cfg80211_attach_out:
+	wland_free_vif(cfg, vif);
+	WLAND_DBG(CFG80211, TRACE, "Failed Done\n");
+	return NULL;
+}
+
+/* dettach from annother mode */
+void cfg80211_detach(struct wland_cfg80211_info *cfg)
+{
+	struct wland_cfg80211_vif *vif;
+	struct wland_cfg80211_vif *tmp;
+	struct wland_bss_info_le *bss;
+	struct wland_bss_info_le *bss_tmp;
+	WLAND_DBG(CFG80211, DEBUG, "Enter\n");
+
+	if (!cfg || IS_ERR(cfg)) {
+		WLAND_ERR("cfg is NULL or IS_ERR!\n");
+		return;
+	}
+
+	cfg->dongle_up = false;	/* dongle down */
+
+	wland_deinit_connect_info(cfg);
+	wland_abort_scanning(cfg);
+	wland_deinit_priv_mem(cfg);
+
+#ifdef WLAND_BTCOEX_SUPPORT
+	wland_btcoex_detach(cfg);
+#endif /* WLAND_BTCOEX_SUPPORT */
+
+#ifdef WLAND_MONITOR_SUPPORT
+	wland_monitor_deinit();
+#endif /*WLAND_MONITOR_SUPPORT */
+#if defined(WLAND_RSSIAVG_SUPPORT)
+	wl_free_rssi_cache(&g_rssi_cache_ctrl);
+#endif
+#if defined(WLAND_BSSCACHE_SUPPORT)
+	wl_release_bss_cache_ctrl(&g_bss_cache_ctrl);
+#endif
+	list_for_each_entry_safe(bss, bss_tmp, &cfg->scan_result_list, list)
+		wland_free_bss(cfg, bss);
+
+	list_for_each_entry_safe(vif, tmp, &cfg->vif_list, list) {
+		wland_free_vif(cfg, vif);
+	}
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.h
new file mode 100644
index 000000000000..1d7f802bda87
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_cfg80211.h
@@ -0,0 +1,554 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLAND_CFG80211_H_
+#define _WLAND_CFG80211_H_
+
+/* for wland_d11inf */
+#include "wland_d11.h"
+#include "wland_defs.h"
+
+/* pmkid */
+#define	MAXPMKID		                16
+
+/* roam relations variables */
+#define ROAM_TRIGGER_LEVEL		        -75
+#define ROAM_DELTA			            20
+
+/* scan parameters */
+#define SCAN_IE_LEN_MAX		            2048
+#define SCAN_NUM_MAX			        10
+
+#define ESCAN_AP_NUM_MAX				70
+
+/* avoid access the wrong store cache eare */
+#define SCAN_VERSION_NUM                0x5995
+
+#define SCAN_TIMER_INTERVAL_MS		(2000)	/* E-Scan timeout */
+#define SCAN_TIMER_INTERVAL_MS_91F	(2000)	/* E-Scan timeout */
+#define SCAN_TIMER2_INTERVAL_MS	        (25*1000)
+
+/* scan action state */
+#define SCAN_ACTION_START		        1
+#define SCAN_ACTION_CONTINUE	        2
+#define SCAN_ACTION_ABORT		        3
+
+#define CONNECT_TIMER_INTERVAL_MS	    2000	/* connect timeout */
+#define CONNECT_RETRY_TIMES_MAX		5	/* CONNECT_TIMER_INTERVAL_MS*CONNECT_RETRY_TIMES_MAX should be no more than 10s */
+#define CONNECT_RESTOREWORK_TIMER_MS	6*1000
+
+#define IE_MAX_LEN			            512
+
+/* IE TLV processing */
+#define TLV_LEN_OFF			            1	/* length offset */
+#define TLV_HDR_LEN			            2	/* header length */
+#define TLV_BODY_OFF			        2	/* body offset   */
+#define TLV_OUI_LEN			            3	/* oui id length */
+
+#define WLAND_TLV_INFO_MAX			    1024
+#define WLAND_BSS_INFO_MAX			    1024
+#define WLAND_ASSOC_INFO_MAX		    512	/* assoc related fil max buf */
+#define WLAND_EXTRA_BUF_MAX		        1024
+#define WLAND_BEACON_TIMEOUT		    3
+
+/* 802.11 Mgmt Packet flags */
+#define WLAND_VNDR_IE_BEACON_FLAG	    0x01
+#define WLAND_VNDR_IE_PRBRSP_FLAG	    0x02
+#define WLAND_VNDR_IE_ASSOCRSP_FLAG	    0x04
+#define WLAND_VNDR_IE_AUTHRSP_FLAG	    0x08
+#define WLAND_VNDR_IE_PRBREQ_FLAG	    0x10
+#define WLAND_VNDR_IE_ASSOCREQ_FLAG	    0x20
+
+/* vendor IE in IW advertisement protocol ID field */
+#define WLAND_VNDR_IE_IWAPID_FLAG	    0x40
+
+/* allow custom IE id */
+#define WLAND_VNDR_IE_CUSTOM_FLAG	    0x100
+
+/* P2P Action Frames flags (spec ordered) */
+#define WLAND_VNDR_IE_GONREQ_FLAG       0x001000
+#define WLAND_VNDR_IE_GONRSP_FLAG       0x002000
+#define WLAND_VNDR_IE_GONCFM_FLAG       0x004000
+#define WLAND_VNDR_IE_INVREQ_FLAG       0x008000
+#define WLAND_VNDR_IE_INVRSP_FLAG       0x010000
+#define WLAND_VNDR_IE_DISREQ_FLAG       0x020000
+#define WLAND_VNDR_IE_DISRSP_FLAG       0x040000
+#define WLAND_VNDR_IE_PRDREQ_FLAG       0x080000
+#define WLAND_VNDR_IE_PRDRSP_FLAG       0x100000
+
+#define WLAND_VNDR_IE_P2PAF_SHIFT	    12
+
+#define WLAND_PNO_VERSION		        2
+#define WLAND_PNO_TIME			        30
+#define WLAND_PNO_REPEAT		        4
+#define WLAND_PNO_FREQ_EXPO_MAX		    3
+#define WLAND_PNO_MAX_PFN_COUNT		    16
+#define WLAND_PNO_ENABLE_ADAPTSCAN_BIT	6
+#define WLAND_PNO_HIDDEN_BIT		    2
+#define WLAND_PNO_WPA_AUTH_ANY		    0xFFFFFFFF
+#define WLAND_PNO_SCAN_COMPLETE		    1
+#define WLAND_PNO_SCAN_INCOMPLETE	    0
+
+#define WLAND_IFACE_MAX_CNT		        3
+
+#define VS_IE_FIXED_HDR_LEN		        6
+#define WPA_IE_VERSION_LEN		        2
+#define WPA_IE_MIN_OUI_LEN		        4
+
+#define VNDR_IE_CMD_LEN			        4	/* length of the set command string :"add", "del" (+ NUL) */
+#define VNDR_IE_COUNT_OFFSET		    4
+#define VNDR_IE_PKTFLAG_OFFSET		    8
+#define VNDR_IE_VSIE_OFFSET		        12
+#define VNDR_IE_HDR_SIZE		        12
+#define VNDR_IE_PARSE_LIMIT		        5
+
+/*
+ * enum wland_scan_status - scan engine status
+ *
+ * @SCAN_STATUS_BUSY    : scanning in progress on dongle.
+ * @SCAN_STATUS_ABORT   : scan being aborted on dongle.
+ * @SCAN_STATUS_SUPPRESS: scanning is suppressed in driver.
+ */
+enum wland_scan_status {
+	SCAN_STATUS_BUSY,
+	SCAN_STATUS_ABORT,
+	SCAN_STATUS_SUPPRESS,
+};
+
+/*
+ * enum wland_vif_status - bit indices for vif status.
+ *
+ * @VIF_STATUS_READY        : ready for operation.
+ * @VIF_STATUS_CONNECTING   : connect/join in progress.
+ * @VIF_STATUS_CONNECTED    : connected/joined succesfully.
+ * @VIF_STATUS_DISCONNECTING: disconnect/disable in progress.
+ * @VIF_STATUS_AP_CREATING  : interface configured for AP operation.
+ * @VIF_STATUS_AP_CREATED   : AP operation started.
+ * @VIF_STATUS_TESTING      : chip enter test mode.
+ */
+enum wland_vif_status {
+	VIF_STATUS_READY,
+	VIF_STATUS_CONNECTING,
+	VIF_STATUS_CONNECTED,
+	VIF_STATUS_DISCONNECTING,
+	VIF_STATUS_AP_CREATING,
+	VIF_STATUS_AP_CREATED,
+	VIF_STATUS_TESTING,
+};
+
+/*
+ * enum wland_mode - driver mode of virtual interface.
+ *
+ * @WL_MODE_BSS : connects to BSS.
+ * @WL_MODE_IBSS: operate as ad-hoc.
+ * @WL_MODE_AP  : operate as access-point.
+ */
+enum wland_mode {
+	WL_MODE_BSS,
+	WL_MODE_IBSS,
+	WL_MODE_AP
+};
+
+/* dongle configuration */
+struct wland_cfg80211_conf {
+	u32 frag_threshold;
+	u32 rts_threshold;
+	u32 retry_short;
+	u32 retry_long;
+	s32 tx_power;
+	struct ieee80211_channel channel;
+};
+
+struct pmkid {
+	u8 BSSID[ETH_ALEN];
+	u8 PMKID[WLAN_PMKID_LEN];
+};
+
+struct pmkid_list {
+	__le32 npmkid;
+	struct pmkid pmkid[1];
+};
+
+/* basic structure of scan request */
+struct wland_cfg80211_scan_req {
+	struct wland_ssid_le ssid_le;
+};
+
+/*
+ * struct vif_saved_ie - holds saved IEs for a virtual interface.
+ *
+ * @probe_req_ie    : IE info for probe request.
+ * @probe_res_ie    : IE info for probe response.
+ * @beacon_ie       : IE info for beacon frame.
+ * @probe_req_ie_len: IE info length for probe request.
+ * @probe_res_ie_len: IE info length for probe response.
+ * @beacon_ie_len   : IE info length for beacon frame.
+ */
+struct vif_saved_ie {
+	u8 probe_req_ie[IE_MAX_LEN];
+	u8 probe_res_ie[IE_MAX_LEN];
+	u8 beacon_ie[IE_MAX_LEN];
+	u8 assoc_req_ie[IE_MAX_LEN];
+	u32 probe_req_ie_len;
+	u32 probe_res_ie_len;
+	u32 beacon_ie_len;
+	u32 assoc_req_ie_len;
+};
+
+/*
+ * struct wland_cfg80211_vif - virtual interface specific information.
+ *
+ * @ifp         : lower layer interface pointer
+ * @wdev        : wireless device.
+ * @profile     : profile information.
+ * @mode        : operating mode.
+ * @roam_off    : roaming state.
+ * @sme_state   : SME state using enum wland_vif_status bits.
+ * @pm_block    : power-management blocked.
+ * @list        : linked list.
+ * @mgmt_rx_reg : registered rx mgmt frame types.
+ */
+struct wland_cfg80211_vif {
+	struct wland_if *ifp;
+	struct wireless_dev wdev;
+	struct wland_cfg80211_profile profile;
+	s32 mode;
+	s32 roam_off;
+	ulong sme_state;
+	bool pm_block;
+	struct vif_saved_ie saved_ie;
+	struct list_head list;
+	u16 mgmt_rx_reg;
+};
+
+/* association inform */
+struct wland_cfg80211_connect_info {
+	u8 *req_ie;
+	s32 req_ie_len;
+	u8 *resp_ie;
+	s32 resp_ie_len;
+
+	//connect control context
+	struct net_device *ndev;
+	struct timer_list timer;
+	struct timer_list connect_restorework_timeout;
+	u8 retry_times;
+	bool timer_on;
+	struct work_struct work;
+	struct workqueue_struct *connect_wq;
+	struct work_struct connect_restorework_timeout_work;
+
+	void *data;
+};
+
+/* wpa2 pmk list */
+struct wland_cfg80211_pmk_list {
+	struct pmkid_list pmkids;
+	struct pmkid foo[MAXPMKID - 1];
+};
+
+/* dongle scan state */
+enum wland_scan_state {
+	SCAN_STATE_IDLE,
+	SCAN_STATE_SCANNING
+};
+
+/* dongle escan controller */
+struct escan_info {
+	u32 escan_state;
+	struct wiphy *wiphy;
+	struct wland_if *ifp;
+	 s32(*run) (struct wland_cfg80211_info * cfg, struct wland_if * ifp,
+		struct cfg80211_scan_request * request, u16 action);
+};
+
+/*
+ * struct wland_pno_param_le - PNO scan configuration parameters
+ *
+ * @version     : PNO parameters version.
+ * @scan_freq   : scan frequency.
+ * @lost_network_timeout: #sec. to declare discovered network as lost.
+ * @flags       : Bit field to control features of PFN such as sort criteria auto enable switch and background scan.
+ * @rssi_margin : Margin to avoid jitter for choosing a PFN based on RSSI sort criteria.
+ * @bestn       : number of best networks in each scan.
+ * @mscan       : number of scans recorded.
+ * @repeat      : minimum number of scan intervals before scan frequency changes in adaptive scan.
+ * @exp         : exponent of 2 for maximum scan interval.
+ * @slow_freq   : slow scan period.
+ */
+struct wland_pno_param_le {
+	__le32 version;
+	__le32 scan_freq;
+	__le32 lost_network_timeout;
+	__le16 flags;
+	__le16 rssi_margin;
+	u8 bestn;
+	u8 mscan;
+	u8 repeat;
+	u8 exp;
+	__le32 slow_freq;
+};
+
+/*
+ * struct wland_pno_net_param_le - scan parameters per preferred network.
+ *
+ * @ssid    : ssid name and its length.
+ * @flags   : bit2: hidden.
+ * @infra   : BSS vs IBSS.
+ * @auth    : Open vs Closed.
+ * @wpa_auth: WPA type.
+ * @wsec    : wsec value.
+ */
+struct wland_pno_net_param_le {
+	struct wland_ssid_le ssid;
+	__le32 flags;
+	__le32 infra;
+	__le32 auth;
+	__le32 wpa_auth;
+	__le32 wsec;
+};
+
+/*
+ * struct wland_pno_net_info_le - information per found network.
+ *
+ * @bssid       : BSS network identifier.
+ * @channel     : channel number only.
+ * @SSID_len    : length of ssid.
+ * @SSID        : ssid characters.
+ * @RSSI        : receive signal strength (in dBm).
+ * @timestamp   : age in seconds.
+ */
+struct wland_pno_net_info_le {
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	u8 SSID_len;
+	u8 SSID[32];
+	__le16 RSSI;
+	__le16 timestamp;
+};
+
+/*
+ * struct wland_pno_scanresults_le - result returned in PNO NET FOUND event.
+ *
+ * @version : PNO version identifier.
+ * @status  : indicates completion status of PNO scan.
+ * @count   : amount of wland_pno_net_info_le entries appended.
+ */
+struct wland_pno_scanresults_le {
+	__le32 version;
+	__le32 status;
+	__le32 count;
+};
+
+/*
+ * struct wland_cfg80211_vif_event - virtual interface event information.
+ *
+ * @vif_wq          : waitqueue awaiting interface event from firmware.
+ * @vif_event_lock  : protects other members in this structure.
+ * @vif_complete    : completion for net attach.
+ * @action          : either add, change, or delete.
+ * @vif             : virtual interface object related to the event.
+ */
+struct wland_cfg80211_vif_event {
+	wait_queue_head_t vif_wq;
+	struct mutex vif_event_lock;
+	u8 action;
+	struct wland_cfg80211_vif *vif;
+};
+
+/*
+ * struct wland_cfg80211_info - dongle private data of cfg80211 interface
+ *
+ * @wiphy       : wiphy object for cfg80211 interface.
+ * @conf        : dongle configuration.
+ * @p2p         : peer-to-peer specific information.
+ * @btcoex      : Bluetooth coexistence information.
+ * @scan_request: cfg80211 scan request object.
+ * @usr_sync    : mainly for dongle up/down synchronization.
+ * @bss_list    : bss_list holding scanned ap information.
+ * @scan_req_int: internal scan request object.
+ * @ie          : information element object for internal purpose.
+ * @conn_info   : association info.
+ * @pmk_list    : wpa2 pmk list.
+ * @scan_status : scan activity on the dongle.
+ * @pub         : common driver information.
+ * @channel     : current channel.
+ * @active_scan : current scan mode.
+ * @sched_escan : e-scan for scheduled scan support running.
+ * @ibss_starter: indicates this sta is ibss starter.
+ * @pwr_save    : indicate whether dongle to support power save mode.
+ * @dongle_up   : indicate whether dongle up or not.
+ * @roam_on     : on/off switch for dongle self-roaming.
+ * @scan_tried  : indicates if first scan attempted.
+ * @extra_buf   : mainly to grab assoc information.
+ * @scan_buf    : scan information for escan or iscan.
+ * @scan_info   : escan information.
+ * @scan_timeout       : Timer for catch scan timeout.
+ * @scan_report_work  : scan report worker.
+ * @vif_list    : linked list of vif instances.
+ * @vif_cnt     : number of vif instances.
+ * @vif_event   : vif event signalling.
+ */
+struct wland_cfg80211_info {
+	struct wiphy *wiphy;
+	struct wland_cfg80211_conf *conf;
+	struct wland_cfg80211_pmk_list *pmk_list;
+	struct wland_private *pub;
+#ifdef WLAND_BTCOEX_SUPPORT
+	struct wland_btcoex_info *btcoex;
+#endif				/* WLAND_BTCOEX_SUPPORT */
+	struct cfg80211_scan_request *scan_request;
+	struct wland_cfg80211_connect_info conn_info;
+	struct wland_cfg80211_scan_req scan_req_int;
+#ifdef WLAND_P2P_SUPPORT
+	struct wland_p2p_info p2p;
+#endif				/* WLAND_P2P_SUPPORT */
+	ulong scan_status;
+	u32 channel;
+	bool active_scan;
+	bool sched_escan;
+	bool ibss_starter;
+	bool pwr_save;
+	bool dongle_up;
+	bool roam_on;
+	bool scan_tried;
+	u8 *extra_buf;
+	struct escan_info scan_info;
+	struct timer_list scan_timeout;
+	struct work_struct scan_report_work;
+	struct list_head vif_list;
+	u8 vif_cnt;
+	struct wland_cfg80211_vif_event vif_event;
+	struct completion vif_disabled;
+	struct mutex usr_sync;
+	struct wland_d11inf d11inf;
+	bool in_disconnecting;
+	bool in_waiting;
+	struct completion disconnecting_wait;
+#ifdef WLAND_INIT_SCAN_SUPPORT
+	atomic_t init_scan;
+#endif
+	struct wland_scan_results scan_results;
+	struct mutex scan_result_lock;
+	struct list_head scan_result_list;
+};
+
+/*
+ * struct wland_tlv - tag_ID/length/value_buffer tuple.
+ *
+ * @id  : tag identifier.
+ * @len : number of bytes in value buffer.
+ * @data: value buffer.
+ */
+struct wland_tlv {
+	u8 id;
+	u8 len;
+	u8 data[1];
+};
+
+static inline struct wiphy *cfg_to_wiphy(struct wland_cfg80211_info *cfg)
+{
+	return cfg->wiphy;
+}
+
+static inline struct wland_cfg80211_info *wiphy_to_cfg(struct wiphy *w)
+{
+	return (struct wland_cfg80211_info *) (wiphy_priv(w));
+}
+
+static inline struct wland_cfg80211_info *wdev_to_cfg(struct wireless_dev *wd)
+{
+	return (struct wland_cfg80211_info *) (wdev_priv(wd));
+}
+
+static inline struct net_device *cfg_to_ndev(struct wland_cfg80211_info *cfg)
+{
+	struct wland_cfg80211_vif *vif =
+		list_first_entry(&cfg->vif_list, struct wland_cfg80211_vif,
+		list);
+
+	return vif->wdev.netdev;
+}
+
+static inline struct wland_cfg80211_info *ndev_to_cfg(struct net_device *ndev)
+{
+	return wdev_to_cfg(ndev->ieee80211_ptr);
+}
+
+static inline struct wland_cfg80211_profile *ndev_to_prof(struct net_device *nd)
+{
+	struct wland_if *ifp = netdev_priv(nd);
+
+	return &ifp->vif->profile;
+}
+
+static inline struct wland_cfg80211_vif *ndev_to_vif(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	return ifp->vif;
+}
+
+static inline struct wland_cfg80211_connect_info *cfg_to_conn(struct
+	wland_cfg80211_info *cfg)
+{
+	return &cfg->conn_info;
+}
+
+/* cfg802.11 attach/detach interface function */
+extern struct wland_cfg80211_info *cfg80211_attach(struct wland_private *drvr,
+	struct device *busdev);
+extern void cfg80211_detach(struct wland_cfg80211_info *cfg);
+
+/* process cfg802.11 up/down */
+extern s32 wland_cfg80211_up(struct net_device *ndev);
+extern s32 wland_cfg80211_down(struct net_device *ndev);
+
+/* cfg802.11 vif manager interface function */
+extern struct wland_cfg80211_vif *wland_alloc_vif(struct wland_cfg80211_info
+	*cfg, enum nl80211_iftype type, bool pm_block);
+extern void wland_free_vif(struct wland_cfg80211_info *cfg,
+	struct wland_cfg80211_vif *vif);
+
+extern struct wland_tlv *wland_parse_tlvs(void *buf, int buflen, uint key);
+extern u16 channel_to_chanspec(struct wland_d11inf *d11inf,
+	struct ieee80211_channel *ch);
+
+extern void wland_cfg80211_arm_vif_event(struct wland_cfg80211_info *cfg,
+	struct wland_cfg80211_vif *vif);
+extern bool wland_cfg80211_vif_event_armed(struct wland_cfg80211_info *cfg);
+extern int wland_cfg80211_wait_vif_event_timeout(struct wland_cfg80211_info
+	*cfg, u8 action, ulong timeout);
+extern s32 wland_notify_escan_complete(struct wland_cfg80211_info *cfg,
+	struct wland_if *ifp, bool aborted, bool fw_abort);
+extern void wland_abort_scanning(struct wland_cfg80211_info *cfg);
+
+extern bool wland_vif_get_state_all(struct wland_cfg80211_info *cfg,
+	ulong state);
+extern s32 wland_vif_clear_mgmt_ies(struct wland_cfg80211_vif *vif);
+extern s32 wland_vif_set_mgmt_ie(struct wland_cfg80211_vif *vif, s32 pktflag,
+	const u8 * vndr_ie_buf, u32 vndr_ie_len);
+
+#ifdef WLAND_MONITOR_SUPPORT
+
+/* Monitor interface */
+extern int wland_monitor_init(void *pub);
+extern int wland_monitor_deinit(void);
+extern int wland_add_monitor(char *name, struct net_device **new_ndev);
+extern int wland_del_monitor(struct net_device *ndev);
+#endif /*WLAND_MONITOR_SUPPORT */
+#endif /* _WLAND_CFG80211_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_cmds.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_cmds.c
new file mode 100644
index 000000000000..4f6477795600
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_cmds.c
@@ -0,0 +1,1736 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+/* Max valid buffer size that can be sent to the dongle */
+#define CDC_MAX_MSG_SIZE	                (ETH_FRAME_LEN+ETH_FCS_LEN)
+
+/* retries to retrieve matching dcmd response */
+#define RETRIES                             2
+
+#define wl_getrssi_err_max                  3
+
+static int wl_getrssi_err_counter = 0;
+
+static int wland_wid_hdrpush(struct wland_private *drvr, u16 wid, bool rw,
+	u8 * val, u16 val_len)
+{
+	enum wid_type type = wland_get_wid_type(wid);
+	u16 size = wland_get_wid_size(type, val_len);
+	u16 wid_msg_len = FMW_HEADER_LEN, wid_pkt_len = 0;
+	struct wland_proto *prot = drvr->prot;
+	u8 *wid_msg = prot->buf;
+
+	if (drvr->bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus is down. we have nothing to do.\n");
+		return -EINVAL;
+	}
+
+	prot->cmd = wid;
+	prot->offset = 0;
+	prot->rsplen = 0;
+
+	/*
+	 * Fill MsgID
+	 */
+	prot->msg.wid_msg_id = wland_get_seqidx(drvr);
+
+	if (rw) {
+		prot->msg.wid_msg_type = WLAND_WID_MSG_WRITE;
+
+		wid_msg[0] = (u8) wid;
+		wid_msg[1] = (u8) (wid >> 8);
+		if(type == WID_BIN){
+			wid_msg[2] = size & 0xff;
+			wid_msg[3] = (size & 0xff00) >> 8;
+			memcpy(&wid_msg[4], val, size);
+			wid_msg_len           += (size + 4);
+			wid_msg               += (size + 4);
+			wid_msg_len           += 1;
+		}else{
+			wid_msg[2]             = (u8)(size);
+			memcpy(&wid_msg[3], val, size);
+			wid_msg_len           += (size + 3);
+			wid_msg               += (size + 3);
+		}
+	} else {
+		prot->msg.wid_msg_type = WLAND_WID_MSG_QUERY;
+
+		wid_msg[0] = (u8) wid;
+		wid_msg[1] = (u8) (wid >> 8);
+		wid_msg_len += 2;
+		wid_msg += 2;
+	}
+
+	wid_pkt_len = wid_msg_len + WID_HEADER_LEN;
+
+	prot->msg.wid_msg_length = cpu_to_le16(wid_msg_len);
+	prot->msg.wid_pkg_length =
+		cpu_to_le16((wid_pkt_len & CDC_DCMD_LEN_MASK) |
+		(PKT_TYPE_CFG_REQ << CDC_DCMD_LEN_SHIFT));
+
+	WLAND_DBG(DCMD, TRACE,
+		"Done(wid:0x%x,type:%d,size:%d,wid_msg_len:%d,wid_pkt_len:%d)\n",
+		wid, type, size, wid_msg_len, wid_pkt_len);
+
+	return (wid_msg_len - FMW_HEADER_LEN);
+}
+
+static int wland_wid_hdrpull(struct wland_private *drvr, u8 * val, u16 val_len)
+{
+	int ret = -EBADE;
+	u8 flag = 0;
+	struct wland_proto *prot = drvr->prot;
+	u8 *wid = prot->buf;
+	enum wid_type      type        = WID_UNKNOW;
+
+	if ((drvr->bus_if->state != WLAND_BUS_DATA)
+		|| (val_len < FMWID_HEADER_LEN)) {
+		WLAND_ERR("invalid. we have nothing to do.\n");
+		return -EINVAL;
+	}
+
+	prot->rsplen = 0;
+	prot->offset = 0;
+	prot->msg.wid_pkg_length = cpu_to_le16(prot->msg.wid_pkg_length);
+	prot->msg.wid_msg_length = cpu_to_le16(prot->msg.wid_msg_length);
+
+	flag = (prot->msg.
+		wid_pkg_length & ~CDC_DCMD_LEN_MASK) >> CDC_DCMD_LEN_SHIFT;
+
+	if (PKT_TYPE_CFG_RSP == flag) {
+		u16 rsp = (u16) (wid[0] | (wid[1] << 8));
+		type        = wland_get_wid_type(rsp);
+
+		if (WLAND_WID_MSG_RESP == prot->msg.wid_msg_type) {
+			if (rsp == WID_STATUS) {
+				ret = (wid[3] != STATUS_SUCCESS) ? -EINVAL : 0;
+			} else {
+				ret = 0;
+				if(type == WID_BIN){
+					prot->rsplen = wid[2] | wid[3] << 8;
+				}else{
+					prot->rsplen = wid[2];
+				}
+				prot->offset =
+					FMWID_HEADER_LEN - FMW_HEADER_LEN;
+			}
+		}
+
+		WLAND_DBG(EVENT, TRACE,
+			"cfgrsp_len:0x%x,cmd:0x%x,rsp:0x%x,rsplen:0x%x,status:0x%x,prot->rsplen:%d,prot->offset:%d\n",
+			val_len, prot->cmd, rsp, wid[2], wid[3], prot->rsplen,
+			prot->offset);
+	} else if (PKT_TYPE_IND == flag) {
+		WLAND_DBG(EVENT, TRACE, "data indication val_len:%d\n",
+			val_len);
+	} else if (PKT_TYPE_ASYNC == flag) {
+		WLAND_DBG(EVENT, TRACE, "sync frame indication val_len:%d\n",
+			val_len);
+	}
+
+	return ret;
+}
+
+static int wland_proto_cdc_msg(struct wland_private *drvr)
+{
+	struct wland_proto *prot = drvr->prot;
+	uint len = le16_to_cpu(prot->msg.wid_pkg_length) & CDC_DCMD_LEN_MASK;
+
+	WLAND_DBG(DCMD, TRACE, "Enter(real_pkt_len:%d)\n", len);
+
+	/*
+	 * NOTE : cdc->msg.len holds the desired length of the buffer to be
+	 * *        returned. Only up to CDC_MAX_MSG_SIZE of this buffer area
+	 * *        is actually sent to the dongle
+	 */
+	if (len > CDC_MAX_MSG_SIZE)
+		len = CDC_MAX_MSG_SIZE;
+
+	/*
+	 * Send request
+	 */
+	return wland_bus_txctl(drvr->bus_if, (u8 *) & prot->msg, len);
+}
+
+static int wland_proto_cdc_cmplt(struct wland_private *drvr, u8 id, u16 len)
+{
+	int ret;
+	struct wland_proto *prot = drvr->prot;
+
+	do {
+		ret = wland_bus_rxctl(drvr->bus_if, (u8 *) & prot->msg, len);
+		if (ret < 0) {
+			WLAND_ERR("***response failed***\n");
+			break;
+		}
+	} while (prot->msg.wid_msg_id != id);
+
+	WLAND_DBG(EVENT, TRACE,
+		"Done(SendMsgId:%d, ReceivedMsgId:%d, RespLen:%d)\n", id,
+		prot->msg.wid_msg_id, ret);
+	return ret;
+}
+
+int wland_proto_cdc_data(struct wland_private *drvr, u16 wid_msg_len)
+{
+	struct wland_proto *prot = drvr->prot;
+	int err, retries = 0;
+	u16 wid_pkg_len = 0;
+	u8 wid_msg_id = wland_get_seqidx(drvr);
+
+	if (drvr->bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus is down. we have nothing to do.\n");
+		return -EINVAL;
+	}
+
+	prot->msg.wid_msg_type = WLAND_WID_MSG_WRITE;
+	prot->msg.wid_msg_id = wid_msg_id;
+
+	wid_pkg_len = wid_msg_len + WID_HEADER_LEN;
+	prot->msg.wid_msg_length = cpu_to_le16(wid_msg_len);
+	prot->msg.wid_pkg_length =
+		cpu_to_le16((wid_pkg_len & CDC_DCMD_LEN_MASK) |
+		(PKT_TYPE_CFG_REQ << CDC_DCMD_LEN_SHIFT));
+
+	err = wland_proto_cdc_msg(drvr);
+	if (err < 0) {
+		WLAND_ERR("set_dcmd failed status: %d\n", err);
+		goto done;
+	}
+
+retry:
+	/*
+	 * wait for interrupt and get first fragment
+	 */
+	err = wland_proto_cdc_cmplt(drvr, wid_msg_id, WLAND_DCMD_MEDLEN);
+	if (err < 0) {
+		WLAND_ERR("cdc_cmplt fail.\n");
+		goto done;
+	}
+
+	if ((prot->msg.wid_msg_id < wid_msg_id) && (++retries < RETRIES))
+		goto retry;
+
+	if (prot->msg.wid_msg_id != wid_msg_id) {
+		WLAND_ERR("unexpected request id %d (expected %d)\n",
+			prot->msg.wid_msg_id, wid_msg_id);
+		err = -EINVAL;
+	}
+
+	if (err > 0)
+		err = wland_wid_hdrpull(drvr, (u8 *) & prot->msg, (u16) err);
+
+	WLAND_DBG(DCMD, TRACE, "Write_MsgIdx:%d, Read_MsgIdx:%d.\n", wid_msg_id,
+		prot->msg.wid_msg_id);
+done:
+	WLAND_DBG(DCMD, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+/* The format of the message is:                                         */
+
+/* +-------------------------------------------------------------------+ */
+
+/* | Message Type | Message ID |  Message Length |Message body         | */
+
+/* +-------------------------------------------------------------------+ */
+
+/* |     1 Byte   |   1 Byte   |     2 Bytes     | Message Length      | */
+
+/* +-------------------------------------------------------------------+ */
+
+int wland_fil_set_cmd_data(struct wland_if *ifp, u16 cmd, void *data, u16 len)
+{
+	int err, retries = 0;
+	u8 wid_msg_id = 0;
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+
+	if (!(drvr && prot)) {
+		WLAND_ERR("some init failed.\n");
+		return -EIO;
+	}
+
+	if (drvr->bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus is down. we have nothing to do.\n");
+		return -EIO;
+	}
+
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	err = wland_wid_hdrpush(drvr, cmd, true, data, len);
+	if (err < 0) {
+		WLAND_ERR("set_dcmd failed status: %d\n", err);
+		goto done;
+	}
+
+	wid_msg_id = prot->msg.wid_msg_id;
+
+	err = wland_proto_cdc_msg(drvr);
+	if (err < 0) {
+		WLAND_ERR("set_dcmd failed status: %d\n", err);
+		goto done;
+	}
+
+retry:
+	/*
+	 * wait for interrupt and get first fragment
+	 */
+	err = wland_proto_cdc_cmplt(drvr, wid_msg_id, WLAND_DCMD_MEDLEN);
+	if (err < 0) {
+		WLAND_ERR("cdc_cmplt fail.\n");
+		goto done;
+	}
+
+	if ((prot->msg.wid_msg_id < wid_msg_id) && (++retries < RETRIES)) {
+		WLAND_ERR("MisMatch(Write_MsgIdx:%d,Read_MsgIdx:%d)\n",
+			wid_msg_id, prot->msg.wid_msg_id);
+		goto retry;
+	}
+
+	if (prot->msg.wid_msg_id != wid_msg_id) {
+		WLAND_ERR("unexpected request id:%d (expected:%d)\n",
+			prot->msg.wid_msg_id, wid_msg_id);
+		err = -EINVAL;
+	}
+	WLAND_DBG(DCMD, TRACE, "Write_MsgIdx:%d, Read_MsgIdx:%d.\n", wid_msg_id,
+		prot->msg.wid_msg_id);
+done:
+	mutex_unlock(&drvr->proto_block);
+
+	WLAND_DBG(DCMD, TRACE,
+		"Done(cmd:0x%x,len:%d,rsplen:%d,widx:%d,ridx:%d)\n", cmd, len,
+		err, wid_msg_id, prot->msg.wid_msg_id);
+
+	return (err >= 0) ? 0 : err;
+}
+
+int wland_fil_get_cmd_data(struct wland_if *ifp, u16 cmd, void *data, u16 len)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	int err = 0, retries = 0;
+	u8 wid_msg_id = 0;
+
+	if (!(drvr && prot)) {
+		WLAND_ERR("some init failed.\n");
+		return -EIO;
+	}
+
+	if (drvr->bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus is down. we have nothing to do.\n");
+		return -EIO;
+	}
+
+	WLAND_DBG(DCMD, TRACE, "(cmd:0x%x,len:%d),Enter\n", cmd, len);
+
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	err = wland_wid_hdrpush(drvr, cmd, false, data, len);
+	if (err < 0) {
+		WLAND_ERR("set_dcmd failed status: %d\n", err);
+		goto done;
+	}
+
+	wid_msg_id = prot->msg.wid_msg_id;
+
+	/*
+	 * send msg to chip
+	 */
+	err = wland_proto_cdc_msg(drvr);
+	if (err < 0) {
+		WLAND_ERR("query_dcmd failed w/status %d\n", err);
+		goto done;
+	}
+
+retry:
+	/*
+	 * wait for interrupt and get first fragment
+	 */
+	err = wland_proto_cdc_cmplt(drvr, wid_msg_id, WLAND_DCMD_MEDLEN);
+	if (err < 0) {
+		WLAND_ERR("query_dcmd failed.\n");
+		goto done;
+	}
+
+	if ((prot->msg.wid_msg_id < wid_msg_id) && (++retries < RETRIES))
+		goto retry;
+
+	if (prot->msg.wid_msg_id != wid_msg_id) {
+		WLAND_ERR("%s: unexpected request id:%d(expected:%d)\n",
+			wland_ifname(drvr, ifp->ifidx), prot->msg.wid_msg_id,
+			wid_msg_id);
+		err = -EINVAL;
+		goto done;
+	}
+
+	/*
+	 * Copy info buffer
+	 */
+	if (data) {
+		if (err > 0)
+			err = wland_wid_hdrpull(drvr, (u8 *) & prot->msg,
+				(u16) err);
+
+		if (!err) {
+			len = (prot->rsplen > len) ? len : prot->rsplen;
+			memcpy(data, &prot->buf[prot->offset], len);
+		}
+	}
+	WLAND_DBG(DCMD, TRACE, "Write_MsgIdx:%d, Read_MsgIdx:%d.\n", wid_msg_id,
+		prot->msg.wid_msg_id);
+done:
+	mutex_unlock(&drvr->proto_block);
+
+	WLAND_DBG(DCMD, TRACE, "(cmd:0x%x,len:%d),Done.\n", cmd, len);
+
+	return (err >= 0) ? 0 : err;
+}
+
+s32 wland_fil_iovar_data_set(struct wland_if * ifp, char *name, void *data,
+	u16 len)
+{
+	s32 err = 0;
+
+#if 0
+	struct wland_private *drvr = ifp->drvr;
+
+	mutex_lock(&drvr->proto_block);
+
+	WLAND_DBG(DCMD, TRACE, "name=%s, len=%d\n", name, len);
+
+	memcpy(drvr->proto_buf, data, len);
+	err = wland_proto_cdc_set_dcmd(drvr, ifp->ifidx, drvr->proto_buf, len);
+	mutex_unlock(&drvr->proto_block);
+#endif
+	return err;
+}
+
+s32 wland_fil_iovar_data_get(struct wland_if * ifp, char *name, void *data,
+	u16 len)
+{
+	s32 err = 0;
+
+#if 0
+	struct wland_private *drvr = ifp->drvr;
+
+	mutex_lock(&drvr->proto_block);
+
+	memcpy(drvr->proto_buf, data, len);
+
+	err = wland_proto_cdc_query_dcmd(drvr, ifp->ifidx, drvr->proto_buf,
+		len);
+	if (err == 0)
+		memcpy(data, drvr->proto_buf, len);
+
+	WLAND_DBG(DCMD, TRACE, "name=%s, len=%d\n", name, len);
+
+	mutex_unlock(&drvr->proto_block);
+#endif
+	return err;
+}
+
+bool wland_prec_enq(struct device * dev, struct pktq * q, struct sk_buff * pkt,
+	int prec)
+{
+	struct sk_buff *p;
+	int eprec = -1;		/* precedence to evict from */
+	bool discard_oldest = false;
+
+	//WLAND_DUMP(DCMD, pkt->data, pkt->len, "TxData,prec:%d,TxDatalen:%Zu\n", prec, pkt->len);
+	prec = 0;
+	/*
+	 * Fast case, precedence queue is not full and we are also not exceeding total queue length
+	 */
+	if (!pktq_pfull(q, prec) && !pktq_full(q)) {
+		wland_pktq_penq(q, prec, pkt);
+		return true;
+	}
+	WLAND_ERR("PKT queue is over flow!\n");
+
+	/*
+	 * Determine precedence from which to evict packet, if any
+	 */
+	if (pktq_pfull(q, prec)) {
+		eprec = prec;
+	} else if (pktq_full(q)) {
+		p = wland_pktq_peek_tail(q, &eprec);
+		if (eprec > prec)
+			return false;
+	}
+
+	/*
+	 * Evict if needed
+	 */
+	if (eprec >= 0) {
+		/*
+		 * refuse newer (incoming) packet
+		 */
+		if (eprec == prec && !discard_oldest)
+			return false;
+
+		/*
+		 * Evict packet according to discard policy
+		 */
+		p = discard_oldest ? wland_pktq_pdeq(q,
+			eprec) : wland_pktq_pdeq_tail(q, eprec);
+
+		if (p == NULL)
+			WLAND_ERR("failed, oldest %d\n", discard_oldest);
+
+		wland_pkt_buf_free_skb(p);
+	}
+
+	/*
+	 * Enqueue
+	 */
+	p = wland_pktq_penq(q, prec, pkt);
+	if (p == NULL)
+		WLAND_ERR("failed\n");
+
+	WLAND_DBG(DCMD, TRACE, "Done\n");
+
+	return p != NULL;
+}
+
+s32 wland_set_scan_timeout(struct wland_if * ifp)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	u8 *buf = prot->buf;
+	s32 ret = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+
+	if (drvr->dev_mode) {
+		WLAND_DBG(DCMD, TRACE, "SoftAp: No Need To Set\n");
+		return ret;
+	}
+
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	/*
+	 * wid body
+	 */
+	wid = WID_SITE_SURVEY_SCAN_TIME;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = 2;
+	buf[3] = SCAN_CHANNEL_TIME;	//50 ms one channel
+	buf[4] = 0;
+	/*
+	 * offset
+	 */
+	buf += 5;
+	wid_msg_len += 5;
+
+	/*
+	 * wid body
+	 */
+	wid = WID_ACTIVE_SCAN_TIME;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = 2;
+	buf[3] = SCAN_ACTIVE_TIME;	//50 ms one channel
+	buf[4] = 0;
+	/*
+	 * offset
+	 */
+	buf += 5;
+	wid_msg_len += 5;
+
+	/*
+	 * wid body
+	 */
+	wid = WID_PASSIVE_SCAN_TIME;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = 2;
+	buf[3] = SCAN_PASSIVE_TIME;	//50 ms one channel
+	buf[4] = 0;
+	/*
+	 * offset
+	 */
+	buf += 5;
+	wid_msg_len += 5;
+
+	ret = wland_proto_cdc_data(drvr, wid_msg_len);
+
+	mutex_unlock(&drvr->proto_block);
+
+	WLAND_DBG(DCMD, TRACE, "Done(ret:%d,wid_pkg_len:%d,wid_msg_len:%d)\n",
+		ret, (wid_msg_len + WID_HEADER_LEN), wid_msg_len);
+
+	return ret;
+}
+
+s32 wland_start_ap_set(struct wland_if * ifp,
+	struct wland_cfg80211_profile * profile, bool is_p2p)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	u8 *buf = prot->buf;
+	s32 ret = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wid_type type;
+	enum wland_firmw_wid wid;
+	u8 size;
+	u32 u32Value;
+
+	WLAND_DBG(DCMD, DEBUG, "Enter\n");
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	/*
+	 * wid body
+	 */
+	wid = WID_802_11I_MODE;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;		/* size */
+#if 0
+	if (profile->sec.security == 0x9
+		&& (drvr->bus_if->chip == WLAND_VER_91_E
+			|| drvr->bus_if->chip == WLAND_VER_91_F)) {
+		//huanglei add for wps
+		buf[3] = 0x49;
+	} else {
+		//for wep104 need set imode 0x07 firmware problem
+		buf[3] = (profile->sec.security ==
+			0x05) ? 0x07 : profile->sec.security;
+	}
+#else
+	buf[3] = profile->sec.security;
+	WLAND_DBG(DCMD, TRACE, "profile->sec.security=0x%x\n",
+		profile->sec.security);
+#endif
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_AUTH_TYPE;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;		/* size */
+	buf[3] = profile->sec.firmware_autype;
+	WLAND_DBG(DCMD, TRACE, "profile->sec.firmware_autype=%d\n",
+		profile->sec.firmware_autype);
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_11I_PTKSA_REPLAY_COUNTER;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;		/* size */
+	buf[3] = profile->rsn_cap;
+	WLAND_DBG(DCMD, DEBUG, "profile->rsn_cap=0x%02x\n", profile->rsn_cap);
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_BEACON_INTERVAL;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	WLAND_DBG(DCMD, TRACE, "WID_BEACON_INTERVAL size:%d, value:0x%x\n",
+		size, profile->beacon);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = (u8) (profile->beacon & 0x00FF);
+	buf[4] = (u8) ((profile->beacon & 0xFF00) >> 8);
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_DTIM_PERIOD;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = (u8) (profile->dtim & 0x00FF);
+	buf[4] = (u8) ((profile->dtim & 0xFF00) >> 8);
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+#if 0
+	/*
+	 * bssid
+	 */
+	wid = WID_BSSID;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = 6;
+	memcpy(buf + 3, profile->bssid, ETH_ALEN);
+	wid_msg_len += 9;
+	buf += 9;
+#endif
+	/*
+	 * ssid
+	 */
+	wid = WID_SSID;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, profile->ssid.SSID_len);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	memcpy(buf + 3, profile->ssid.SSID, size);
+	wid_msg_len += (size + 3);
+	buf += (size + 3);
+#if 1
+	/*
+	 * Network Event enable
+	 */
+	wid = WID_NETWORK_EVENT_EN;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	u32Value = 0x8000F800;
+	buf[0] = (char) (wid & 0x00FF);
+	buf[1] = (char) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	memcpy(buf + 3, &u32Value, size);
+	wid_msg_len += (size + 3);
+	buf += (size + 3);
+#endif
+	WLAND_DBG(DCMD, DEBUG, "Start SoftAp(SSID:%s, SSIDlen:%d)\n",
+		profile->ssid.SSID, profile->ssid.SSID_len);
+
+	ret = wland_proto_cdc_data(drvr, wid_msg_len);
+
+	mutex_unlock(&drvr->proto_block);
+	WLAND_DBG(DCMD, DEBUG, "Done(ret=%d).\n", ret);
+
+	return ret;
+}
+
+s32 wland_start_scan_set(struct wland_if * ifp,
+	struct wland_ssid_le * scan_ssid, bool enable)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	u8 *buf = prot->buf;
+	s32 ret = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+	enum wid_type type;
+	u8 size;
+
+	WLAND_DBG(DCMD, TRACE, "Enter %s scan\n", enable ? "start" : "stop");
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	/*
+	 * wid body
+	 */
+	wid = WID_SITE_SURVEY;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = SITE_SURVEY_ALL_CH;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_START_SCAN_REQ;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = USER_SCAN;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_NETWORK_INFO_EN;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	if (enable)
+		buf[3] = 1;	// 0x01:enable scan network info
+	else
+		buf[3] = 0;	// 0x01:disable scan network info
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	if (drvr->bus_if->chip == WLAND_VER_90_D
+		|| drvr->bus_if->chip == WLAND_VER_90_E) {
+		s32 i = 0;
+
+		while (i <= scan_ssid->SSID_len) {
+			/*
+			 * wid body
+			 */
+			wid = WID_MEMORY_ADDRESS;
+			type = wland_get_wid_type(wid);
+			size = wland_get_wid_size(type, 1);
+			buf[0] = (u8) (wid & 0x00FF);
+			buf[1] = (u8) ((wid & 0xFF00) >> 8);
+			buf[2] = size;
+			buf[3] = 0x80 + i;
+			buf[4] = 0x81;
+			buf[5] = 0x10;
+			buf[6] = 0x00;
+			/*
+			 * offset
+			 */
+			buf += (size + 3);
+			wid_msg_len += (size + 3);
+
+			/*
+			 * wid body
+			 */
+			wid = WID_MEMORY_ACCESS_32BIT;
+			type = wland_get_wid_type(wid);
+			size = wland_get_wid_size(type, 1);
+			buf[0] = (u8) (wid & 0x00FF);
+			buf[1] = (u8) ((wid & 0xFF00) >> 8);
+			buf[2] = size;
+			if (scan_ssid->SSID_len > 0) {
+				buf[3] = scan_ssid->SSID[i + 0];
+				buf[4] = scan_ssid->SSID[i + 1];
+				buf[5] = scan_ssid->SSID[i + 2];
+				buf[6] = scan_ssid->SSID[i + 3];
+			} else {
+				memset(&buf[3], 0x00, 4);
+			}
+			/*
+			 * offset
+			 */
+			buf += (size + 3);
+			wid_msg_len += (size + 3);
+			i += 4;
+		}
+	} else if (drvr->bus_if->chip == WLAND_VER_91
+		|| drvr->bus_if->chip == WLAND_VER_91_E
+		|| drvr->bus_if->chip == WLAND_VER_91_F
+		|| drvr->bus_if->chip == WLAND_VER_91_G) {
+		/*
+		 * wid body
+		 */
+		wid = WID_HIDE_SSID;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, scan_ssid->SSID_len);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		if (scan_ssid->SSID_len > 0) {
+			buf[2] = size;
+			memcpy(buf + 3, scan_ssid->SSID, size);
+		} else {
+			size = 1;
+			buf[2] = size;
+			buf[3] = 0x00;
+		}
+		/*
+		 * offset
+		 */
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+	}
+
+	//WLAND_DUMP(DCMD, prot->buf, wid_msg_len, "Start Scan(SSID: %s,SSID_len:%d)widlen: %Zu\n", scan_ssid->SSID, scan_ssid->SSID_len, wid_msg_len);
+
+	ret = wland_proto_cdc_data(drvr, wid_msg_len);
+
+	mutex_unlock(&drvr->proto_block);
+	WLAND_DBG(DCMD, DEBUG, "Done %s scan\n", enable ? "start" : "stop");
+
+	//if the chip version is 91G ,return -ENOMEM while sending wid error to inform android reopen WIFI, otherwise it always return 0.
+	if ((ret < 0) && (drvr->bus_if->chip == WLAND_VER_91_G))
+		ret = -ENOMEM;
+	else
+		ret = 0;
+	return ret;
+}
+
+s32 wland_start_join(struct wland_if * ifp,
+	struct wland_cfg80211_profile * profile)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	u8 *buf = prot->buf;
+	s32 ret = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+	enum wid_type type;
+	u8 size;
+	u8 char_val;
+
+	WLAND_DBG(DCMD, TRACE,
+		"imode:0x%x, authtype:%d, ssid:%s, SSID_len:%d\n",
+		profile->sec.security, profile->sec.firmware_autype,
+		profile->ssid.SSID, profile->ssid.SSID_len);
+	WLAND_DBG(DCMD, INFO, "Connecting to " MACDBG "\n",
+		MAC2STRDBG(profile->bssid));
+	mutex_lock(&drvr->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	if (drvr->bus_if->chip == WLAND_VER_91_F) {
+		/*
+		 * wid body
+		 */
+		wid = WID_11G_OPERATING_MODE;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		char_val = 0;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = char_val;
+		/*
+		 * offset
+		 */
+		buf += (size + 3);
+		wid_msg_len += (size + 3);
+	}
+
+	/*
+	 * wid body
+	 */
+	wid = WID_802_11I_MODE;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	if (profile->sec.security == 0x9
+		&& (drvr->bus_if->chip == WLAND_VER_91_E
+			|| drvr->bus_if->chip == WLAND_VER_91_F
+			|| drvr->bus_if->chip == WLAND_VER_91_G)) {
+		//huanglei add for wps
+		char_val = 0x49;
+	} else {
+		//for wep104 need set imode 0x07 firmware problem
+
+		char_val =
+			(profile->sec.security ==
+			0x05) ? 0x07 : profile->sec.security;
+	}
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = char_val;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_AUTH_TYPE;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	char_val = profile->sec.firmware_autype;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = char_val;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_NETWORK_INFO_EN;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	char_val = 0;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = char_val;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	/*
+	 * wid body
+	 */
+	wid = WID_CURRENT_TX_RATE;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	char_val = 1;
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = char_val;
+	/*
+	 * offset
+	 */
+	buf += (size + 3);
+	wid_msg_len += (size + 3);
+
+	if ((drvr->bus_if->chip == WLAND_VER_90_D)
+		|| (drvr->bus_if->chip == WLAND_VER_90_E)) {
+		/*
+		 * set bssid
+		 */
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0xec;
+		buf[4] = 0x81;
+		buf[5] = 0x10;
+		buf[6] = 0x00;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_32BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = profile->bssid[0];
+		buf[4] = profile->bssid[1];
+		buf[5] = profile->bssid[2];
+		buf[6] = profile->bssid[3];
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0xf0;
+		buf[4] = 0x81;
+		buf[5] = 0x10;
+		buf[6] = 0x00;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_32BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = profile->bssid[4];
+		buf[4] = profile->bssid[5];
+		buf[5] = 0;
+		buf[6] = 0;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+	}
+
+	if ((drvr->bus_if->chip == WLAND_VER_90_D)
+		|| (drvr->bus_if->chip == WLAND_VER_90_E)) {
+		/*
+		 * huanglei add begin
+		 */
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x04;
+		buf[4] = 0x01;
+		buf[5] = 0x00;
+		buf[6] = 0x50;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_16BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x1;	//(cmax << 4) | (cmin) 00010001
+		buf[4] = 0x1;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x08;
+		buf[4] = 0x01;
+		buf[5] = 0x00;
+		buf[6] = 0x50;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_16BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x1;	//(cmax << 4) | (cmin) 00010001
+		buf[4] = 0x1;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x0C;
+		buf[4] = 0x01;
+		buf[5] = 0x00;
+		buf[6] = 0x50;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_16BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x1;	//(cmax << 4) | (cmin) 00010001
+		buf[4] = 0x1;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ADDRESS;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x10;
+		buf[4] = 0x01;
+		buf[5] = 0x00;
+		buf[6] = 0x50;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+
+		wid = WID_MEMORY_ACCESS_16BIT;
+		type = wland_get_wid_type(wid);
+		size = wland_get_wid_size(type, 1);
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = size;
+		buf[3] = 0x1;	//(cmax << 4) | (cmin) 00010001
+		buf[4] = 0x1;
+		wid_msg_len += (size + 3);
+		buf += (size + 3);
+		//huanglei add end
+	}
+
+	/*
+	 * bssid
+	 */
+	wid = WID_BSSID;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, sizeof(profile->bssid));
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	memcpy(buf + 3, profile->bssid, size);
+	wid_msg_len += (size + 3);
+	buf += (size + 3);
+
+	/*
+	 * ssid
+	 */
+	wid = WID_SSID;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, profile->ssid.SSID_len);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	memcpy(buf + 3, profile->ssid.SSID, size);
+	wid_msg_len += (size + 3);
+	buf += (size + 3);
+
+	wid = WID_START_SCAN_REQ;
+	type = wland_get_wid_type(wid);
+	size = wland_get_wid_size(type, 1);
+	buf[0] = (u8) (wid & 0x00FF);
+	buf[1] = (u8) ((wid & 0xFF00) >> 8);
+	buf[2] = size;
+	buf[3] = 0;
+	wid_msg_len += (size + 3);
+	buf += (size + 3);
+
+	wid = WID_WEP_KEY_VALUE0;
+	type = wland_get_wid_type(wid);
+
+	//write wep key
+	if (profile->sec.security == 3 || profile->sec.security == 5) {
+		s32 i;
+		u8 *key, key_str_len, key_str[WLAN_MAX_KEY_LEN];
+
+		for (i = 0; i < MAX_WSEC_KEY; i++) {
+			key = profile->wepkeys[i].data;
+
+			if (profile->wepkeys[i].len == 0)
+				continue;
+
+			if (profile->wepkeys[i].len == KEY_LEN_WEP_40) {
+				sprintf(key_str, "%02x%02x%02x%02x%02x\n",
+					key[0], key[1], key[2], key[3], key[4]);
+				key_str_len = 10;
+				key_str[key_str_len] = '\0';
+			} else if (profile->wepkeys[i].len == KEY_LEN_WEP_104) {
+				sprintf(key_str,
+					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+					key[0], key[1], key[2], key[3], key[4],
+					key[5], key[6], key[7], key[8], key[9],
+					key[10], key[11], key[12]);
+				key_str_len = 26;
+				key_str[key_str_len] = '\0';
+			} else {
+				continue;
+			}
+			size = wland_get_wid_size(type, key_str_len);
+			buf[0] = (u8) ((wid + i) & 0x00FF);
+			buf[1] = (u8) (((wid + i) & 0xFF00) >> 8);
+			buf[2] = size;
+
+			memcpy(buf + 3, key_str, size);
+
+			buf += (size + 3);
+			wid_msg_len += (size + 3);
+		}
+	}
+	//WLAND_DUMP(DCMD, prot->buf, wid_msg_len, "Start Join:%Zu\n", wid_msg_len);
+
+	ret = wland_proto_cdc_data(drvr, wid_msg_len);
+
+	mutex_unlock(&drvr->proto_block);
+
+	return ret;
+}
+
+s32 wland_disconnect_bss(struct wland_if * ifp,
+	struct wland_scb_val_le * scbval)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_proto *prot = drvr->prot;
+	u8 *buf = prot->buf;
+	s32 ret = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+
+	WLAND_DBG(DCMD, TRACE, "Enter(" MACDBG ")\n", MAC2STRDBG(scbval->ea));
+
+	if (drvr->bus_if->chip == WLAND_VER_90_D
+		|| drvr->bus_if->chip == WLAND_VER_90_E) {
+		memset(scbval->ea, '\0', ETH_ALEN);
+
+		ret = wland_fil_set_cmd_data(ifp, WID_SSID, scbval->ea,
+			ETH_ALEN);
+	} else {
+
+		mutex_lock(&drvr->proto_block);
+
+		memset(prot->buf, '\0', sizeof(prot->buf));
+
+		/*
+		 * wid body
+		 */
+		wid = WID_BSSID;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 6;
+		wid_msg_len += 9;
+		buf += 9;
+
+		wid = WID_SSID;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 6;
+		wid_msg_len += 9;
+		buf += 9;
+
+		ret = wland_proto_cdc_data(drvr, wid_msg_len);
+
+		mutex_unlock(&drvr->proto_block);
+	}
+
+	WLAND_DBG(DCMD, TRACE, "Done(disconnect reason:%d).\n", scbval->val);
+
+	return ret;
+}
+
+s32 wland_add_wep_key_bss_sta(struct wland_if * ifp, u8 * key, u8 wep_len,
+	u8 key_id)
+{
+	s32 err = 0;
+	u8 *buf = kzalloc(wep_len + 2, GFP_KERNEL);
+
+	if (buf == NULL) {
+		WLAND_ERR("No Memory.\n");
+		return -ENOMEM;
+	}
+
+	buf[0] = key_id;
+	buf[1] = wep_len;
+
+	memcpy(buf + 2, key, wep_len);
+
+	err = wland_fil_set_cmd_data(ifp, WID_ADD_WEP_KEY, buf, (wep_len + 2));
+
+	kfree(buf);
+
+	WLAND_DBG(DCMD, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+s32 wland_fil_set_mgmt_ie(struct wland_if * ifp, u8 * vndr_ie_buf,
+	u16 vndr_ie_len)
+{
+	s32 ret = 0;
+	struct wland_private *drvr = ifp->drvr;
+
+	vndr_ie_len = vndr_ie_buf[1] + 2;
+	WLAND_DBG(DCMD, TRACE,"Enter vndr_ie_len=%d, vndr_ie_buf=%p\n", vndr_ie_len, vndr_ie_buf);
+	WLAND_DUMP(TX_CTRL, vndr_ie_buf, vndr_ie_len, "mgmt_le_len:%Zu\n", vndr_ie_len);
+
+	if (drvr->bus_if->chip == WLAND_VER_91_E
+		|| drvr->bus_if->chip == WLAND_VER_91_F
+		|| drvr->bus_if->chip == WLAND_VER_91_G)
+		ret = wland_fil_set_cmd_data(ifp, WID_GEN_ASSOC_IE, vndr_ie_buf,
+			vndr_ie_len);
+
+	/*
+	 * wapi ies
+	 */
+	if (vndr_ie_buf[0] == 0x44)
+		ret = wland_fil_set_cmd_data(ifp, WID_WAPI_ASSOC_IE,
+			vndr_ie_buf, vndr_ie_len);
+
+	WLAND_DBG(DCMD, TRACE, "Enter(vndr_ie_buf:0x%x,ret:%d)\n",
+		vndr_ie_buf[0], ret);
+
+	return ret;
+}
+
+s32 wland_set_txrate(struct wland_if * ifp, u8 mbps)
+{
+	s32 ret = 0;
+	struct wland_private *drvr = ifp->drvr;
+	u32 u32Value = 0;
+	u16 u16Value = 0;
+
+	WLAND_DBG(DCMD, TRACE, "Enter\n");
+	if (wland_fil_set_cmd_data(ifp, WID_CURRENT_TX_RATE, &mbps,
+			sizeof(mbps))) {
+		WLAND_ERR("Set WID_CURRENT_TX_RATE value=%d failed \n", mbps);
+		goto out;
+	}
+	if (drvr->bus_if->chip == WLAND_VER_90_D
+		|| drvr->bus_if->chip == WLAND_VER_90_E) {
+		u32Value = 0x50000104;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ADDRESS, &u32Value,
+				sizeof(u32Value))) {
+			WLAND_ERR("Set WID_MEMORY_ADDRESS value=%d failed \n",
+				u32Value);
+			goto out;
+		}
+		u16Value = 0x0101;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ACCESS_16BIT,
+				&u16Value, sizeof(u16Value))) {
+			WLAND_ERR
+				("Set WID_MEMORY_ACCESS_16BIT value=%d failed \n",
+				u16Value);
+			goto out;
+		}
+		u32Value = 0x50000108;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ADDRESS, &u32Value,
+				sizeof(u32Value))) {
+			WLAND_ERR("Set WID_MEMORY_ADDRESS value=%d failed \n",
+				u32Value);
+			goto out;
+		}
+		u16Value = 0x0101;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ACCESS_16BIT,
+				&u16Value, sizeof(u16Value))) {
+			WLAND_ERR
+				("Set WID_MEMORY_ACCESS_16BIT value=%d failed \n",
+				u16Value);
+			goto out;
+		}
+		u32Value = 0x5000010C;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ADDRESS, &u32Value,
+				sizeof(u32Value))) {
+			WLAND_ERR("Set WID_MEMORY_ADDRESS value=%d failed \n",
+				u32Value);
+			goto out;
+		}
+		u16Value = 0x0101;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ACCESS_16BIT,
+				&u16Value, sizeof(u16Value))) {
+			WLAND_ERR
+				("Set WID_MEMORY_ACCESS_16BIT value=%d failed \n",
+				u16Value);
+			goto out;
+		}
+		u32Value = 0x50000110;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ADDRESS, &u32Value,
+				sizeof(u32Value))) {
+			WLAND_ERR("Set WID_MEMORY_ADDRESS value=%d failed \n",
+				u32Value);
+			goto out;
+		}
+		u16Value = 0x0101;
+		if (wland_fil_set_cmd_data(ifp, WID_MEMORY_ACCESS_16BIT,
+				&u16Value, sizeof(u16Value))) {
+			WLAND_ERR
+				("Set WID_MEMORY_ACCESS_16BIT value=%d failed \n",
+				u16Value);
+			goto out;
+		}
+	}
+
+	WLAND_DBG(DCMD, TRACE, "Done.\n");
+
+out:
+	return ret;
+}
+
+int wland_dev_get_rssi(struct net_device *ndev, s16 * pRssi)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	u8 rssi = 0;
+	int error = 0;
+	static int count = 0;
+	static u8 preVal = 0;
+	int mod = 2;
+
+	if (!pRssi)
+		return -EINVAL;
+	if ((preVal == 0) || !((count++) % mod)) {
+		WLAND_DBG(DCMD, TRACE, "Get RSSI!\n");
+		error = wland_fil_get_cmd_data(ifp, WID_RSSI, &rssi,
+			sizeof(rssi));
+
+	//error < 0 appear wl_getrssi_err_max times continuously return -ENOMEM to inform WIFI reopen.
+		if (error == 0)
+			wl_getrssi_err_counter = 0;
+		if (error < 0) {
+			WLAND_ERR("Get RSSI failed!\n");
+
+			if (ifp->drvr->bus_if->chip == WLAND_VER_91_G) {
+				wl_getrssi_err_counter++;
+
+				if (wl_getrssi_err_counter >= wl_getrssi_err_max) {
+					wl_getrssi_err_counter = 0;
+					return -ENOMEM;
+				}
+			}
+			return error;
+		}
+
+		preVal = rssi;
+#ifdef WLAND_RSSIOFFSET_SUPPORT
+		if(rssi < WLAND_RSSI_MAXVAL_FOR_OFFSET)
+			*pRssi = (signed char)(rssi + WLAND_RSSI_OFFSET);
+		else
+			*pRssi = (signed char)(rssi);
+#else
+		*pRssi = (signed char)(rssi);
+#endif
+	} else {
+#ifdef WLAND_RSSIOFFSET_SUPPORT
+		if(preVal < WLAND_RSSI_MAXVAL_FOR_OFFSET)
+			*pRssi = (signed char)(preVal + WLAND_RSSI_OFFSET);
+		else
+			*pRssi = (signed char)(preVal);
+#else
+		*pRssi = (signed char)(preVal);
+#endif
+	}
+	WLAND_DBG(DCMD, TRACE, "*pRssi =%d\n", *pRssi);
+	return error;
+}
+
+#if 0
+s32 wland_set_ptk(struct wland_if * ifp, u8 * key, u8 key_len)
+{
+	s32 ret;
+	u8 key_str[32 + ETH_ALEN + 1];
+	u8 key_str_len = key_len + ETH_ALEN + 1;
+
+	WLAND_DBG(DCMD, TRACE, "Set PTK: len = %d\n", key_len);
+
+	if (priv->connect_status != MAC_CONNECTED) {
+		WLAND_ERR("Adding PTK while not connected\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*----------------------------------------*/
+	/*
+	 * STA Addr     | KeyLength |   Key
+	 */
+
+	/*----------------------------------------*/
+	/*
+	 * 6            |         1     |  KeyLength
+	 */
+
+	/*----------------------------------------*/
+
+	/*---------------------------------------------------------*/
+	/*
+	 * key
+	 */
+
+	/*---------------------------------------------------------*/
+	/*
+	 * Temporal Key    | Rx Micheal Key    |   Tx Micheal Key
+	 */
+
+	/*---------------------------------------------------------*/
+	/*
+	 * 16 bytes        |      8 bytes          |       8 bytes
+	 */
+
+	/*---------------------------------------------------------*/
+
+	memcpy(key_str, priv->curbssparams.bssid, ETH_ALEN);
+	key_str[6] = key_len;
+	memcpy(key_str + 7, key, 16);
+
+	/*
+	 * swap TX MIC and RX MIC, wlan need RX MIC to be ahead
+	 */
+	if (key_len > 16) {
+		memcpy(key_str + 7 + 16, key + 24, 8);
+		memcpy(key_str + 7 + 24, key + 16, 8);
+	}
+
+	if (priv->is_wapi)
+		ret = wland_fil_set_cmd_data(ifp, WID_ADD_WAPI_PTK, key_str,
+			key_str_len);
+	else
+		ret = wland_fil_set_cmd_data(ifp, WID_ADD_PTK, key_str,
+			key_str_len);
+
+	if (ret < 0) {
+		goto out;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "Set PTK Done\n");
+
+out:
+	return ret;
+}
+
+s32 wland_set_gtk(struct wland_if * ifp, u8 key_id, u8 * key_rsc,
+	u8 key_rsc_len, u8 * key, u8 key_len)
+{
+	s32 ret;
+	u8 key_str[32 + ETH_ALEN + 8 + 2];
+	u8 key_str_len = key_len + ETH_ALEN + 8 + 2;
+
+	/*---------------------------------------------------------*/
+	/*
+	 * STA Addr     | KeyRSC | KeyID | KeyLength |   Key
+	 */
+
+	/*---------------------------------------------------------*/
+	/*
+	 * 6            |       8        |       1       |         1     |      KeyLength
+	 */
+
+	/*---------------------------------------------------------*/
+
+	/*-------------------------------------*/
+	/*
+	 * key
+	 */
+
+	/*-------------------------------------*/
+	/*
+	 * Temporal Key    | Rx Micheal Key
+	 */
+
+	/*-------------------------------------*/
+	/*
+	 * 16 bytes        |      8 bytes
+	 */
+
+	/*-------------------------------------*/
+
+	WLAND_DBG(DCMD, TRACE, "Set GTK: len = %d\n", key_len);
+
+	if (priv->connect_status != MAC_CONNECTED) {
+		WLAND_ERR("Adding GTK while not connected\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(key_str, priv->curbssparams.bssid, ETH_ALEN);
+	memcpy(key_str + 6, key_rsc, key_rsc_len);
+
+	key_str[14] = key_id;
+	key_str[15] = key_len;
+
+	memcpy(key_str + 16, key, 16);
+
+	/*
+	 * swap TX MIC and RX MIC, wlan need RX MIC to be ahead
+	 */
+	if (key_len > 16) {
+		memcpy(key_str + 16 + 16, key + 24, 8);
+		memcpy(key_str + 16 + 24, key + 16, 8);
+	}
+
+	if (priv->is_wapi)
+		ret = wland_fil_set_cmd_data(ifp, WID_ADD_WAPI_RX_GTK, key_str,
+			key_str_len);
+	else
+		ret = wland_fil_set_cmd_data(ifp, WID_ADD_RX_GTK, key_str,
+			key_str_len);
+
+	WLAND_DBG(EVENT, TRACE, "Set GTK Done(ret:%d)\n", ret);
+
+	return ret;
+}
+#endif
+
+int wland_proto_attach(struct wland_private *drvr)
+{
+	struct wland_proto *cdc =
+		osl_malloc(drvr->bus_if->osh, sizeof(struct wland_proto));
+
+	if (!cdc) {
+		WLAND_ERR("no memory for cdc!\n");
+		return -ENOMEM;
+	}
+
+	memset(cdc, '\0', sizeof(struct wland_proto));
+
+	/*
+	 * ensure that the msg buf directly follows the cdc msg struct
+	 */
+	if ((ulong) (&cdc->msg + 1) != (ulong) cdc->buf) {
+		WLAND_ERR("struct wland_proto is not correctly defined\n");
+		if (cdc)
+			osl_free(drvr->bus_if->osh, cdc,
+				sizeof(struct wland_proto));
+		return -ENOMEM;
+	}
+
+	drvr->prot = cdc;
+	drvr->hdrlen += WID_HEADER_LEN;
+	drvr->maxctl =
+		WLAND_DCMD_MEDLEN + sizeof(struct wland_dcmd) + ROUND_UP_MARGIN;
+
+	WLAND_DBG(DCMD, TRACE, "Done(drvr->hdrlen:%d,drvr->maxctl:%d)\n",
+		drvr->hdrlen, drvr->maxctl);
+
+	return 0;
+}
+
+void wland_proto_detach(struct wland_private *drvr)
+{
+	if (drvr) {
+		osl_free(drvr->bus_if->osh, drvr->prot,
+			sizeof(struct wland_proto));
+		drvr->prot = NULL;
+	}
+	WLAND_DBG(DCMD, TRACE, "Done\n");
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_d11.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_d11.c
new file mode 100644
index 000000000000..bb99ff64157e
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_d11.c
@@ -0,0 +1,186 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_trap.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+#include <wland_d11.h>
+
+static void wland_d11n_encchspec(struct wland_chan *ch)
+{
+	ch->chspec = ch->chnum & WLAND_CHSPEC_CH_MASK;
+
+	switch (ch->bw) {
+	case CHAN_BW_20:
+		ch->chspec |= WLAND_CHSPEC_D11N_BW_20 | WLAND_CHSPEC_D11N_SB_N;
+		break;
+	case CHAN_BW_40:
+	default:
+		WLAND_ERR("Invalid,ch->bw:%d\n", ch->bw);
+		break;
+	}
+
+	if (ch->chnum <= CH_MAX_2G_CHANNEL)
+		ch->chspec |= WLAND_CHSPEC_D11N_BND_2G;
+	else
+		ch->chspec |= WLAND_CHSPEC_D11N_BND_5G;
+}
+
+static void wland_d11ac_encchspec(struct wland_chan *ch)
+{
+	ch->chspec = ch->chnum & WLAND_CHSPEC_CH_MASK;
+
+	switch (ch->bw) {
+	case CHAN_BW_20:
+		ch->chspec |= WLAND_CHSPEC_D11AC_BW_20;
+		break;
+	case CHAN_BW_40:
+	case CHAN_BW_80:
+	case CHAN_BW_80P80:
+	case CHAN_BW_160:
+	default:
+		WLAND_ERR("Invalid,ch->bw:%d\n", ch->bw);
+		break;
+	}
+
+	if (ch->chnum <= CH_MAX_2G_CHANNEL)
+		ch->chspec |= WLAND_CHSPEC_D11AC_BND_2G;
+	else
+		ch->chspec |= WLAND_CHSPEC_D11AC_BND_5G;
+}
+
+static void wland_d11n_decchspec(struct wland_chan *ch)
+{
+	u16 val;
+
+	ch->chnum = (u8) (ch->chspec & WLAND_CHSPEC_CH_MASK);
+
+	switch (ch->chspec & WLAND_CHSPEC_D11N_BW_MASK) {
+	case WLAND_CHSPEC_D11N_BW_20:
+		ch->bw = CHAN_BW_20;
+		break;
+	case WLAND_CHSPEC_D11N_BW_40:
+		ch->bw = CHAN_BW_40;
+		val = ch->chspec & WLAND_CHSPEC_D11N_SB_MASK;
+		if (val == WLAND_CHSPEC_D11N_SB_L) {
+			ch->sb = WLAND_CHAN_SB_L;
+			ch->chnum -= CH_10MHZ_APART;
+		} else {
+			ch->sb = WLAND_CHAN_SB_U;
+			ch->chnum += CH_10MHZ_APART;
+		}
+		break;
+	default:
+		WLAND_ERR("Invalid BW,ch->chspec :%d\n", ch->chspec);
+		break;
+	}
+
+	switch (ch->chspec & WLAND_CHSPEC_D11N_BND_MASK) {
+	case WLAND_CHSPEC_D11N_BND_5G:
+		ch->band = CHAN_BAND_5G;
+		break;
+	case WLAND_CHSPEC_D11N_BND_2G:
+		ch->band = CHAN_BAND_2G;
+		break;
+	default:
+		WLAND_ERR("Invalid BND,ch->chspec :%d\n", ch->chspec);
+		break;
+	}
+}
+
+static void wland_d11ac_decchspec(struct wland_chan *ch)
+{
+	u16 val;
+
+	ch->chnum = (u8) (ch->chspec & WLAND_CHSPEC_CH_MASK);
+
+	switch (ch->chspec & WLAND_CHSPEC_D11AC_BW_MASK) {
+	case WLAND_CHSPEC_D11AC_BW_20:
+		ch->bw = CHAN_BW_20;
+		break;
+	case WLAND_CHSPEC_D11AC_BW_40:
+		ch->bw = CHAN_BW_40;
+		val = ch->chspec & WLAND_CHSPEC_D11AC_SB_MASK;
+		if (val == WLAND_CHSPEC_D11AC_SB_L) {
+			ch->sb = WLAND_CHAN_SB_L;
+			ch->chnum -= CH_10MHZ_APART;
+		} else if (val == WLAND_CHSPEC_D11AC_SB_U) {
+			ch->sb = WLAND_CHAN_SB_U;
+			ch->chnum += CH_10MHZ_APART;
+		} else {
+			WLAND_ERR("Invalid,val:%d\n", val);
+		}
+		break;
+	case WLAND_CHSPEC_D11AC_BW_80:
+		ch->bw = CHAN_BW_80;
+		break;
+	case WLAND_CHSPEC_D11AC_BW_8080:
+	case WLAND_CHSPEC_D11AC_BW_160:
+	default:
+		WLAND_ERR("Invalid BW,ch->chspec :%d\n", ch->chspec);
+		break;
+	}
+
+	switch (ch->chspec & WLAND_CHSPEC_D11AC_BND_MASK) {
+	case WLAND_CHSPEC_D11AC_BND_5G:
+		ch->band = CHAN_BAND_5G;
+		break;
+	case WLAND_CHSPEC_D11AC_BND_2G:
+		ch->band = CHAN_BAND_2G;
+		break;
+	default:
+		WLAND_ERR("Invalid BND,ch->chspec :%d\n", ch->chspec);
+		break;
+	}
+}
+
+void wland_d11_attach(struct wland_d11inf *d11inf)
+{
+	if (d11inf->io_type == WLAND_D11N_IOTYPE) {
+		d11inf->encchspec = wland_d11n_encchspec;
+		d11inf->decchspec = wland_d11n_decchspec;
+	} else {
+		d11inf->encchspec = wland_d11ac_encchspec;
+		d11inf->decchspec = wland_d11ac_decchspec;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "d11inf->encchspec:%p,d11inf->decchspec:%p\n",
+		d11inf->encchspec, d11inf->decchspec);
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.c
new file mode 100644
index 000000000000..40a5dc8d72d5
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.c
@@ -0,0 +1,354 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+
+#include <wland_defs.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_bus.h>
+#include <wland_dbg.h>
+
+/* Error Debug Area Bit Map */
+int wland_dbg_area = WLAND_DATA_VAL |
+	WLAND_TRAP_VAL |
+	WLAND_DCMD_VAL |
+	WLAND_EVENT_VAL |
+	WLAND_BUS_VAL |
+	WLAND_WEXT_VAL |
+	WLAND_DEFAULT_VAL | WLAND_SDIO_VAL | WLAND_CFG80211_VAL;
+
+int wland_dbg_level = WLAND_ERROR_LEVEL;
+int wland_dump_area =
+	//WLAND_TX_CTRL_AREA                    |
+	//WLAND_TX_MSDU_AREA                   |
+	//WLAND_RX_WIDRSP_AREA          |
+	//WLAND_RX_MACSTAT_AREA         |
+	//WLAND_RX_NETINFO_AREA         |
+	//WLAND_RX_MSDU_AREA                   |
+	//WLAND_RX_NETEVENT_AREA          |
+	WLAND_NONE_AREA;
+
+/* Set Default Debug Dir */
+static struct dentry *root_folder = NULL;
+
+static ssize_t wland_debugfs_sdio_counter_read(struct file *f,
+	char __user * data, size_t count, loff_t * ppos)
+{
+	struct wland_sdio_count *sdcnt = f->private_data;
+	int buf_size = 750;
+	int res;
+	int ret;
+	char *buf;
+
+	/*
+	 * only allow read from start
+	 */
+	if (*ppos > 0)
+		return 0;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (buf == NULL) {
+		WLAND_ERR("kmalloc buf failed\n");
+		return -ENOMEM;
+	}
+
+
+	res = scnprintf(buf, buf_size,
+		"intrcount:    %u\nlastintrs:    %u\n"
+		"pollcnt:      %u\nregfails:     %u\n"
+		"tx_sderrs:    %u\nfcqueued:     %u\n"
+		"rxrtx:        %u\nrx_toolong:   %u\n"
+		"rxc_errors:   %u\nrx_hdrfail:   %u\n"
+		"rx_badhdr:    %u\nrx_badseq:    %u\n"
+		"fc_rcvd:      %u\nfc_xoff:      %u\n"
+		"fc_xon:       %u\n                  "
+		"f2rxhdrs:     %u\nf2rxdata:     %u\n"
+		"f2txdata:     %u\nf1regdata:    %u\n"
+		"tickcnt:      %u\ntx_ctlerrs:   %lu\n"
+		"tx_ctlpkts:   %lu\nrx_ctlerrs:   %lu\n"
+		"rx_ctlpkts:   %lu\nrx_readahead: %lu\n",
+		sdcnt->intrcount, sdcnt->lastintrs,
+		sdcnt->pollcnt, sdcnt->regfails,
+		sdcnt->tx_sderrs, sdcnt->fcqueued,
+		sdcnt->rxrtx, sdcnt->rx_toolong,
+		sdcnt->rxc_errors, sdcnt->rx_hdrfail,
+		sdcnt->rx_badhdr, sdcnt->rx_badseq,
+		sdcnt->fc_rcvd, sdcnt->fc_xoff,
+		sdcnt->fc_xon,
+		sdcnt->f2rxhdrs, sdcnt->f2rxdata,
+		sdcnt->f2txdata, sdcnt->f1regdata,
+		sdcnt->tickcnt, sdcnt->tx_ctlerrs,
+		sdcnt->tx_ctlpkts, sdcnt->rx_ctlerrs,
+		sdcnt->rx_ctlpkts, sdcnt->rx_readahead_cnt);
+
+	ret = simple_read_from_buffer(data, count, ppos, buf, res);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations wland_debugfs_sdio_counter_ops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = wland_debugfs_sdio_counter_read
+};
+
+static ssize_t wland_debugarea_read(struct file *file, char __user * userbuf,
+	size_t count, loff_t * ppos)
+{
+	size_t pos = 0;
+	u32 addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *) addr;
+	ssize_t res;
+
+	WLAND_DBG(DEFAULT, TRACE, "get debug_area:0x%x\n", wland_dbg_area);
+
+	pos += snprintf(buf + pos, PAGE_SIZE - pos, "%x\n", wland_dbg_area);
+
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+
+	free_page(addr);
+	return res;
+}
+
+static ssize_t wland_debugarea_write(struct file *file,
+	const char __user * user_buf, size_t count, loff_t * ppos)
+{
+	ssize_t ret;
+	int debug_area;
+	u32 addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *) addr;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (copy_from_user(buf, user_buf, count)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
+
+	ret = sscanf(buf, "%x", &debug_area);
+	if (ret != 1) {
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	wland_dbg_area = debug_area;
+
+	WLAND_DBG(DEFAULT, TRACE, "set debug_area = 0x%x\n", wland_dbg_area);
+
+	ret = count;
+out_unlock:
+	free_page(addr);
+	return ret;
+}
+
+static const struct file_operations wland_dbgarea_ops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = wland_debugarea_read,
+	.write = wland_debugarea_write
+};
+
+static ssize_t wland_debuglevel_read(struct file *file, char __user * userbuf,
+	size_t count, loff_t * ppos)
+{
+	size_t pos = 0;
+	u32 addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *) addr;
+	ssize_t res;
+
+	WLAND_DBG(DEFAULT, TRACE, "get debug_level:%d\n", wland_dbg_level);
+
+	pos += snprintf(buf + pos, PAGE_SIZE - pos, "%d\n", wland_dbg_level);
+
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+
+	free_page(addr);
+	return res;
+}
+
+static ssize_t wland_debuglevel_write(struct file *file,
+	const char __user * user_buf, size_t count, loff_t * ppos)
+{
+	ssize_t ret;
+	int debug_level;
+	u32 addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *) addr;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (copy_from_user(buf, user_buf, count)) {
+		ret = -EFAULT;
+		goto out_unlock;
+	}
+
+	ret = sscanf(buf, "%d", &debug_level);
+	if (ret != 1) {
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	wland_dbg_level = debug_level;
+
+	WLAND_DBG(DEFAULT, TRACE, "set debug_level = %d\n", wland_dbg_level);
+
+	ret = count;
+out_unlock:
+	free_page(addr);
+	return ret;
+}
+
+static const struct file_operations wland_dbglevel_ops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = wland_debuglevel_read,
+	.write = wland_debuglevel_write
+};
+
+#ifdef DEBUG
+static ssize_t wland_sdio_forensic_read(struct file *f, char __user * data,
+	size_t count, loff_t * ppos)
+{
+	//wland_private *drvr = f->private_data;
+	int res = 0;
+
+	//res = brcmf_sdio_trap_info(bus, &sh, data, count);
+
+	if (res > 0)
+		*ppos += res;
+	return (ssize_t) res;
+}
+
+static const struct file_operations sdio_forensic_ops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = wland_sdio_forensic_read
+};
+#endif /* DEBUG */
+
+void wland_sdio_debugfs_create(struct wland_private *drvr)
+{
+#ifdef DEBUG
+	struct dentry *dentry = drvr->dbgfs_dir;;
+
+	if (IS_ERR_OR_NULL(dentry))
+		return;
+
+	debugfs_create_file("forensics", S_IRUGO, dentry, drvr,
+		&sdio_forensic_ops);
+
+	debugfs_create_file("counters", S_IRUGO, dentry, drvr,
+		&wland_debugfs_sdio_counter_ops);
+
+	debugfs_create_file("dbglevel", S_IRUGO, dentry, drvr,
+		&wland_dbglevel_ops);
+
+	debugfs_create_file("dbgarea", S_IRUGO, dentry, drvr,
+		&wland_dbgarea_ops);
+#endif /* DEBUG */
+}
+
+char *wland_dbgarea(int dbg_flags)
+{
+	switch (dbg_flags) {
+	case WLAND_TRAP_VAL:
+		return "[RDAWLAN_TRAP]";
+	case WLAND_EVENT_VAL:
+		return "[RDAWLAN_EVENT]";
+	case WLAND_DCMD_VAL:
+		return "[RDAWLAN_DCMD]";
+	case WLAND_WEXT_VAL:
+		return "[RDAWLAN_WEXT]";
+	case WLAND_DEFAULT_VAL:
+		return "[RDAWLAN_DEFAULT]";
+	case WLAND_SDIO_VAL:
+		return "[RDAWLAN_SDIO]";
+	case WLAND_USB_VAL:
+		return "[RDAWLAN_USB]";
+	case WLAND_CFG80211_VAL:
+		return "[RDAWLAN_CFG80211]";
+	case WLAND_BUS_VAL:
+		return "[RDAWLAN_BUS]";
+	case WLAND_DATA_VAL:
+		return "[RDAWLAN_DATA]";
+	default:
+		return "[RDAWLAN_UNKNOW]";
+	}
+}
+
+/* dbg attach */
+int wland_debugfs_attach(struct wland_private *drvr)
+{
+	struct device *dev = drvr->bus_if->dev;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter.\n");
+
+	if (!root_folder)
+		return -ENODEV;
+
+	drvr->dbgfs_dir = debugfs_create_dir(dev_name(dev), root_folder);
+
+	if (!IS_ERR_OR_NULL(drvr->dbgfs_dir))
+		return -ENODEV;
+
+	WLAND_DBG(DEFAULT, TRACE, "Done.\n");
+
+	return 0;
+}
+
+/* dbg dettach */
+void wland_debugfs_detach(struct wland_private *drvr)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (!IS_ERR_OR_NULL(drvr->dbgfs_dir))
+		debugfs_remove_recursive(drvr->dbgfs_dir);
+
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
+
+/* dbg dir init */
+void wland_debugfs_init(void)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	root_folder = debugfs_create_dir(KBUILD_MODNAME, NULL);
+
+	if (IS_ERR(root_folder))
+		root_folder = NULL;
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
+
+/* dbg dir exit */
+void wland_debugfs_exit(void)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	if (!root_folder)
+		return;
+
+	debugfs_remove_recursive(root_folder);
+
+	root_folder = NULL;
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.h
new file mode 100644
index 000000000000..cf75f5793247
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_dbg.h
@@ -0,0 +1,171 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLAND_DBG_H_
+#define _WLAND_DBG_H_
+
+enum {
+	WLAND_ERROR_LEVEL = 0,
+	WLAND_WARNING_LEVEL = 1,
+	WLAND_NOTICE_LEVEL = 2,
+	WLAND_INFO_LEVEL = 3,
+	WLAND_DEBUG_LEVEL = 4,
+	WLAND_TRACE_LEVEL = 5,
+};
+
+#define WLAND_TRAP_VAL	            BIT0
+#define WLAND_EVENT_VAL	            BIT1
+#define WLAND_DCMD_VAL	            BIT2
+#define WLAND_WEXT_VAL	            BIT3
+#define WLAND_DEFAULT_VAL           BIT4
+#define WLAND_SDIO_VAL              BIT5
+#define WLAND_USB_VAL               BIT6
+#define WLAND_CFG80211_VAL          BIT7
+#define WLAND_BUS_VAL               BIT8
+#define WLAND_DATA_VAL	            BIT9
+#define WLAND_UNMASK_VAL            ((int)(0xFFFF))
+
+#define WLAND_TX_CTRL_AREA				BIT0
+#define WLAND_TX_MSDU_AREA				BIT1
+#define WLAND_RX_WIDRSP_AREA			BIT2
+#define WLAND_RX_MACSTAT_AREA			BIT3
+#define WLAND_RX_NETINFO_AREA			BIT4
+#define WLAND_RX_MSDU_AREA				BIT5
+#define WLAND_RX_NETEVENT_AREA			BIT6
+#define WLAND_ALL_AREA					(0xFFFFFFFF)
+#define WLAND_NONE_AREA					(0)
+
+#define TX_CTRL					(wland_dump_area & WLAND_TX_CTRL_AREA)
+#define TX_MSDU					(wland_dump_area & WLAND_TX_MSDU_AREA)
+#define RX_WIDRSP				(wland_dump_area & WLAND_RX_WIDRSP_AREA)
+#define RX_MACSTAT				(wland_dump_area & WLAND_RX_MACSTAT_AREA)
+#define RX_NETINFO				(wland_dump_area & WLAND_RX_NETINFO_AREA)
+#define RX_NETEVENT				(wland_dump_area & WLAND_RX_NETEVENT_AREA)
+#define RX_MSDU					(wland_dump_area & WLAND_RX_MSDU_AREA)
+
+#define MACDBG                      "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC2STRDBG(ea)              (ea)[0], (ea)[1], (ea)[2], (ea)[3], (ea)[4], (ea)[5]
+
+/* Macro for error messages. net_ratelimit() is used when driver
+ * debugging is not selected. When debugging the driver error
+ * messages are as important as other tracing or even more so.
+ */
+#ifdef DEBUG
+#define WLAND_ERR(fmt, ...)	        pr_err("[RDAWLAN_ERR]:<%s,%d>: " fmt, __func__, __LINE__, ##__VA_ARGS__)
+#else /* defined(DEBUG) */
+#define WLAND_ERR(fmt, ...)         do {\
+                    					if (net_ratelimit()){\
+                    						pr_err("[RDAWLAN_ERR]:<%s,%d>: " fmt, __func__, __LINE__, ##__VA_ARGS__);\
+                    					}                                                                            \
+                    				} while (0)
+#endif /* defined(DEBUG) */
+
+#ifdef DEBUG
+#define WLAND_DBG(area, level, fmt, ...)  do {\
+										int dgb_area = WLAND_##area##_VAL & wland_dbg_area;\
+                                        int dbg_level = WLAND_##level##_LEVEL;\
+                                        if(dgb_area && (dbg_level <= wland_dbg_level)){\
+                                    	    pr_err("%s:<%s,%d>  " fmt, wland_dbgarea(dgb_area), __func__, __LINE__, ##__VA_ARGS__);\
+                                    	}                                                                           \
+                                    } while (0)
+#else /* defined(DEBUG) */
+#define WLAND_DBG(area, level, fmt, ...)  no_printk(fmt, ##__VA_ARGS__)
+#endif /* defined(DEBUG) */
+
+#define WLAND_DUMP(area, data, len, fmt, ...)\
+                                    do {\
+                                        if (area){\
+                                            pr_err("[RDAWLAN_DUMP]:<%s,%d>: " fmt, __func__, __LINE__, ##__VA_ARGS__);\
+                                            wland_dbg_hex_dump(area, data, len, fmt, ##__VA_ARGS__);\
+                                        }\
+                                    } while (0)
+
+/* hold counter variables used in wlanfmac sdio driver. */
+struct wland_sdio_count {
+	uint intrcount;		/* Count of device interrupt callbacks */
+	uint lastintrs;		/* Count as of last watchdog timer */
+	uint pollcnt;		/* Count of active polls */
+	uint regfails;		/* Count of R_REG failures */
+	uint tx_sderrs;		/* Count of tx attempts with sd errors */
+	uint fcqueued;		/* Tx packets that got queued */
+	uint rxrtx;		/* Count of rtx requests (NAK to dongle) */
+	uint rx_toolong;	/* Receive frames too long to receive */
+	uint rxc_errors;	/* SDIO errors when reading control frames */
+	uint rx_hdrfail;	/* SDIO errors on header reads */
+	uint rx_badhdr;		/* Bad received headers (roosync?) */
+	uint rx_badseq;		/* Mismatched rx sequence number */
+	uint fc_rcvd;		/* Number of flow-control events received */
+	uint fc_xoff;		/* Number which turned on flow-control */
+	uint fc_xon;		/* Number which turned off flow-control */
+	uint f2rxhdrs;		/* Number of header reads */
+	uint f2rxdata;		/* Number of frame data reads */
+	uint f2txdata;		/* Number of f2 frame writes */
+	uint f1regdata;		/* Number of f1 register accesses */
+	uint tickcnt;		/* Number of watchdog been schedule */
+	ulong tx_ctlerrs;	/* Err of sending ctrl frames */
+	ulong tx_ctlpkts;	/* Ctrl frames sent to dongle */
+	ulong rx_ctlerrs;	/* Err of processing rx ctrl frames */
+	ulong rx_ctlpkts;	/* Ctrl frames processed from dongle */
+	ulong rx_readahead_cnt;	/* packets where header read-ahead was used */
+};
+
+struct wland_fws_stats {
+	u32 tlv_parse_failed;
+	u32 tlv_invalid_type;
+	u32 header_only_pkt;
+	u32 header_pulls;
+	u32 pkt2bus;
+	u32 send_pkts[5];
+	u32 requested_sent[5];
+	u32 generic_error;
+	u32 mac_update_failed;
+	u32 mac_ps_update_failed;
+	u32 if_update_failed;
+	u32 packet_request_failed;
+	u32 credit_request_failed;
+	u32 rollback_success;
+	u32 rollback_failed;
+	u32 delayq_full_error;
+	u32 supprq_full_error;
+	u32 txs_indicate;
+	u32 txs_discard;
+	u32 txs_supp_core;
+	u32 txs_supp_ps;
+	u32 txs_tossed;
+	u32 txs_host_tossed;
+	u32 bus_flow_block;
+	u32 fws_flow_block;
+};
+
+struct wland_sdio;
+struct wland_private;
+
+extern int wland_dbg_area;
+extern int wland_dbg_level;
+extern int wland_dump_area;
+
+extern char *wland_dbgarea(int dbg_flags);
+
+/* setup bug info dir */
+extern void wland_debugfs_init(void);
+extern void wland_debugfs_exit(void);
+
+extern void wland_sdio_debugfs_create(struct wland_private *drvr);
+extern int wland_debugfs_attach(struct wland_private *drvr);
+extern void wland_debugfs_detach(struct wland_private *drvr);
+
+#endif /* _WLAND_DBG_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_defs.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_defs.h
new file mode 100644
index 000000000000..a785d462fb61
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_defs.h
@@ -0,0 +1,276 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_DEFS_H_
+#define _WLAND_DEFS_H_
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+
+/****************************************************************************
+                        Wlan Const Defines
+ ****************************************************************************/
+
+/* init_scan support */
+//#define WLAND_INIT_SCAN_SUPPORT
+
+/* Driver Version Sync With Source Server */
+#define WLAND_VER_MAJ                           5
+#define WLAND_VER_MIN                           9
+#define WLAND_VER_BLD                           95
+
+/* define for chip version */
+enum WLAND_CHIP_VERSION {
+	WLAND_VER_90_D = 1,
+	WLAND_VER_90_E = 2,
+	WLAND_VER_91 = 3,
+	WLAND_VER_91_E = 4,
+	WLAND_VER_91_F = 5,
+	WLAND_VER_91_G = 6,
+	WLAND_VER_MAX = 10
+};
+
+#define WLAND_VERSION_STR		                "9.59.95.5"
+#define CHIP_ID_MASK                            (0x1F)
+
+/* SDIO Device ID */
+#define SDIO_VENDOR_ID_RDAWLAN		            0x5449
+#define SDIO_DEVICE_ID_RDA599X      	        0x0145
+
+/* USB  Device ID */
+#define USB_VENDOR_ID_RDAMICRO	                0x1E04
+#define USB_DEVICE_ID_RDA599X	                0x8888
+#define USB_DEVICE_ID_BCMFW	                    0x0BDC
+
+#define WIFI_MAC_ACTIVATED_FLAG    				0x5990
+
+#ifndef TRUE
+#define TRUE            (1)
+#endif
+
+/*
+#ifndef FALSE
+#define FALSE           (0)
+#endif
+*/
+#ifndef NULL
+#define NULL                                    ((void*)0)
+#endif
+
+/* Support BUS TYPE */
+#define SDIO_BUS		                        1	/* SDIO target */
+#define USB_BUS			                        2	/* USB  target */
+
+/* bit mask */
+#define BIT9                                    (1 << 9)
+#define BIT8                                    (1 << 8)
+#define BIT7                                    (1 << 7)
+#define BIT6                                    (1 << 6)
+#define BIT5                                    (1 << 5)
+#define BIT4                                    (1 << 4)
+#define BIT3                                    (1 << 3)
+#define BIT2                                    (1 << 2)
+#define BIT1                                    (1 << 1)
+#define BIT0                                    (1 << 0)
+
+#define CLEAR_BIT(X , Y)                        (X) &= (~(Y))
+#define SET_BIT(X , Y)                          (X) |= (Y)
+
+/* Values for PM */
+#define	OFF	                                    0
+#define	ON	                                    1	/* ON = 1    */
+#define	AUTO	                                (-1)	/* Auto = -1 */
+
+#define ACTIVE_SCAN_TIME			            10
+#define PASSIVE_SCAN_TIME			            1200
+#define MIN_SCAN_TIME				            10
+#define MAX_SCAN_TIME				            1200
+#define DEFAULT_SCAN				            0
+#define USER_SCAN					            BIT0
+
+/* Return Results */
+#define STATUS_SUCCESS                          (1)
+#define STATUS_TIMEOUT			                (2)
+#define STATUS_ABORTED      	                (3)
+#define STATUS_FAILED                           (4)
+#define STATUS_NO_NETWORKS                      (5)
+
+#define MAC_CONNECTED                           (1)
+#define MAC_DISCONNECTED                        (0)
+
+/* Priority definitions according 802.1D */
+#define	PRIO_8021D_NONE		                    2
+#define	PRIO_8021D_BK		                    1
+#define	PRIO_8021D_BE		                    0
+#define	PRIO_8021D_EE		                    3
+#define	PRIO_8021D_CL		                    4
+#define	PRIO_8021D_VI		                    5
+#define	PRIO_8021D_VO		                    6
+#define	PRIO_8021D_NC		                    7
+
+#define	MAXPRIO			                        7
+#define NUMPRIO			                        (MAXPRIO + 1)
+
+/* Bit masks for radio disabled status - returned by WL_GET_RADIO */
+#define RADIO_SW_DISABLE		                (1<<0)
+#define RADIO_HW_DISABLE		                (1<<1)
+
+/* some countries don't support any channel */
+#define RADIO_COUNTRY_DISABLE	                (1<<3)
+
+/* Override bit for SET_TXPWR.  if set, ignore other level limits */
+#define TXPWR_OVERRIDE	                        (1U<<31)
+
+/* band types */
+#define	WLAND_BAND_AUTO		                    0	/* auto-select */
+#define	WLAND_BAND_5G		                    1	/* 5 Ghz */
+#define	WLAND_BAND_2G		                    2	/* 2.4 Ghz */
+#define	WLAND_BAND_ALL		                    3	/* all bands */
+
+#ifndef WLAN_EID_GENERIC
+#define WLAN_EID_GENERIC                        0xDD
+#endif
+
+/* define for debug information */
+#define MAX_HEX_DUMP_LEN	                    64
+
+#define ALL_INTERFACES	                        0xFF
+
+#define IOCTL_RESP_TIMEOUT                      (5*1000)
+
+/* scan relation timeout  */
+#define SCAN_CHANNEL_TIME		                102	/* ms */
+#define SCAN_ACTIVE_TIME		                102	/* ms */
+#define SCAN_PASSIVE_TIME		                102	/* ms */
+
+#define SKIP_REPORT_CHANNEL_14
+
+// Low snr agc setting
+#define CHINA_VERSION
+
+/* CDC flag definitions */
+#define CDC_DCMD_LEN_MASK	                    0x0FFF	/* id an cmd pairing */
+#define CDC_DCMD_LEN_SHIFT	                    12	/* ID Mask shift bits */
+
+/****************************************************************************
+                        Wlan Features Support
+ ****************************************************************************/
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+/*
+ * WLAND_BSSCACHE_SUPPORT     : Cache bss list
+ * WLAND_RSSIAVG_SUPPORT      : Average RSSI of BSS list
+ * WLAND_RSSIOFFSET_SUPPORT   : RSSI offset
+ */
+#define WLAND_BSSCACHE_SUPPORT
+#define WLAND_RSSIAVG_SUPPORT
+#define WLAND_RSSIOFFSET_SUPPORT
+
+#ifdef WLAND_RSSIOFFSET_SUPPORT
+#define WLAND_RSSI_MAXVAL_FOR_OFFSET	236
+#define WLAND_RSSI_OFFSET	                12
+#endif
+
+/* define support FPGA mode */
+//#define WLAND_FPGA_SUPPORT
+
+/* define for use random mac address  */
+//#define WLAND_MACADDR_DYNAMIC
+//#define USE_MAC_FROM_RDA_NVRAM
+
+/* define support cfg80211 or wext mode */
+#define WLAND_CFG80211_SUPPORT
+
+/* define support wapi sec mode */
+//#define WLAND_WAPI_SUPPORT
+
+#define WLAND_SDIO_SUPPORT
+
+/* define support p2p mode */
+//#define WLAND_P2P_SUPPORT
+
+/*define for power manager*/
+#define WLAND_POWER_MANAGER
+
+/*define for flow ctrl*/
+#define WLAND_SDIO_FC_SUPPORT
+
+/* define for chip patch */
+//#define NORMAL_FIXED
+#define WLAN_BIG_CURRENT_90E
+
+/* rda platform sdio should 2^n alligen */
+#define WLAND_RDAPLATFORM_SUPPORT
+
+/* define for support 5G rf,default 2.4G */
+//#define WLAND_5GRF_SUPPORT
+
+#define CARD_ENTER_SLEEP_TIMER                  (200)
+#define FLOW_CTRL_INT_SLEEP_RETRY_COUNT_91      (25)
+#define FLOW_CTRL_RXCMPL_RETRY_COUNT_91         (30)
+#define FLOW_CTRL_RXCMPL_RETRY_COUNT_90         (2000)
+
+#define DEFAULT_MAX_SCAN_AGE                    (15*HZ)
+
+#define WID_HEADER_LEN                          (2)
+
+/* Space for header read, limit for data packets */
+#ifdef WLAND_SDIO_SUPPORT
+#define WLAND_MAX_BUFSZ                         2048	/* Maximum size of a sdio dma buffer */
+#else /*WLAND_SDIO_SUPPORT */
+#define WLAND_MAX_BUFSZ                         1660	/* Maximum size of a sdio dma buffer */
+#endif /*WLAND_SDIO_SUPPORT */
+
+/* Driver Features Config */
+#define WLAND_SLEEP_ENABLE                      BIT0
+#define WLAND_SLEEP_PREASSO                     BIT1
+
+/* Mac Listen Interval */
+#define WIFI_LISTEN_INTERVAL                    0x06
+
+/* Link Loss Threshold */
+#define WIFI_LINK_LOSS_THRESHOLD_90                0x20
+#define WIFI_LINK_LOSS_THRESHOLD_91                0x40
+
+/* Link Sleep Threashold,old Value: 0x00A00080 */
+#define WIFI_PREASSO_SLEEP                      0x000500FF
+
+/* max sequential rxcntl timeouts to set HANG event */
+#ifndef MAX_CNTL_TIMEOUT
+#define MAX_CNTL_TIMEOUT                        2
+#endif
+
+/*BT WIFI CONEXIST*/
+#define BT_COEXIST  SIOCDEVPRIVATE + 2
+#define BT_STATE_SCO_ON  0x01
+#define BT_STATE_SCO_OFF  0x02
+#define BT_STATE_SCO_ONGOING 0x04
+#define BT_STATE_A2DP_PLAYING  0x08
+#define BT_STATE_A2DP_NO_PLAYING 0x10
+#define BT_STATE_CONNECTION_ON 0x20
+#define BT_STATE_CONNECTION_OFF 0x40
+
+/*BT WIFI CONEXIST*/
+
+/*get mac from rda nvram*/
+struct wlan_mac_info {
+	u16 activated;
+	u8 mac_addr[ETH_ALEN];
+};
+
+#endif /* _WLAND_DEFS_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_dev.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_dev.h
new file mode 100644
index 000000000000..4e289c4ac470
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_dev.h
@@ -0,0 +1,858 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_DEV_H_
+#define _WLAND_DEV_H_
+
+#include <linux/wireless.h>
+
+#ifndef FCS_LEN
+#define FCS_LEN                         4
+#endif
+
+#define ALIGNMENT                       4
+
+#ifndef MAX_WPA_IE_LEN
+#define MAX_WPA_IE_LEN                  100
+#endif
+
+#ifndef MAX_RATES
+#define MAX_RATES                       16	/* max # of rates in rateset */
+#endif
+
+#define MAX_WSEC_KEY                    4	/* max # of rates in rateset */
+
+#define KEY_LEN_WPA_AES                 16
+#define KEY_LEN_WPA_TKIP                32
+#define KEY_LEN_WEP_104                 13
+#define KEY_LEN_WEP_40                  5
+
+#define ASSOC_FLAG_SSID                 1
+#define ASSOC_FLAG_CHANNEL              2
+#define ASSOC_FLAG_BAND                 3
+#define ASSOC_FLAG_MODE                 4
+#define ASSOC_FLAG_BSSID                5
+#define ASSOC_FLAG_WEP_KEYS             6
+#define ASSOC_FLAG_WEP_TX_KEYIDX        7
+#define ASSOC_FLAG_WPA_MCAST_KEY        8
+#define ASSOC_FLAG_WPA_UCAST_KEY        9
+#define ASSOC_FLAG_SECINFO              10
+#define ASSOC_FLAG_WPA_IE               11
+#define ASSOC_FLAG_ASSOC_RETRY          12
+#define ASSOC_FLAG_ASSOC_START          13
+#define ASSOC_FLAG_WLAN_CONNECTING      14
+
+#define WLAN_NF_DEFAULT_SCAN_VALUE      (-96)
+#define PERFECT_RSSI                    ((u8)50)
+#define WORST_RSSI                      ((u8)0)
+#define RSSI_DIFF                       ((u8)(PERFECT_RSSI - WORST_RSSI))
+
+#define WLAN_RTS_MIN_VALUE              0
+#define WLAN_RTS_MAX_VALUE              2347
+#define WLAN_FRAG_MIN_VALUE             256
+#define WLAN_FRAG_MAX_VALUE             2346
+
+#define AUTH_OPEN                       0	/* d11 open authentication   */
+#define AUTH_SHARED_KEY                 1	/* d11 shared authentication */
+#define AUTH_OPEN_SHARED                2	/* try open, then shared if open failed w/rc 13 */
+
+#define CAPABILITY_ESS                  (1<<0)
+#define CAPABILITY_IBSS                 (1<<1)
+#define CAPABILITY_CF_POLLABLE          (1<<2)
+#define CAPABILITY_CF_POLL_REQUEST      (1<<3)
+#define CAPABILITY_PRIVACY              (1<<4)
+#define CAPABILITY_SHORT_PREAMBLE       (1<<5)
+#define CAPABILITY_PBCC                 (1<<6)
+#define CAPABILITY_CHANNEL_AGILITY      (1<<7)
+
+#define IW_AUTH_ALG_WAPI                0x08
+#define IW_ENCODE_ALG_WAPI              0x80
+#define IW_AUTH_WAPI_ENABLED            0x20
+#define IW_ENCODE_ALG_SM4               0x20
+
+#define WAPI_KEY_MGMT_NONE              0
+#define WAPI_KEY_MGMT_CERT              BIT2
+#define WAPI_KEY_MGMT_PSK               BIT3
+
+#define WLAND_FIL_ACTION_FRAME_SIZE	    1800
+
+#define MCSSET_LEN	                    16
+
+#define TOE_TX_CSUM_OL		            0x00000001
+#define TOE_RX_CSUM_OL		            0x00000002
+
+/* primary (ie tx) key */
+#define WL_PRIMARY_KEY	                (1 << 1)
+
+/* For supporting multiple interfaces */
+#define WLAND_MAX_IFS	                 4
+
+#define WLAND_STA_ASSOC			         0x10	/* Associated */
+
+/* Enumerate crypto algorithms */
+#define	CRYPTO_ALGO_OFF			         0
+#define	CRYPTO_ALGO_WEP1		         1
+#define	CRYPTO_ALGO_TKIP		         2
+#define	CRYPTO_ALGO_WEP128		         3
+#define CRYPTO_ALGO_AES_CCM		         4
+#define CRYPTO_ALGO_AES_RESERVED1	     5
+#define CRYPTO_ALGO_AES_RESERVED2	     6
+#define CRYPTO_ALGO_CKIP		         7
+#define CRYPTO_ALGO_CKIP_MMH		     8
+#define CRYPTO_ALGO_WEP_MMH		         9
+#define CRYPTO_ALGO_NALG		         10
+
+#ifdef WLAND_WAPI_SUPPORT
+#define CRYPTO_ALGO_SMS4                 11
+#endif /* WLAND_WAPI_SUPPORT */
+#define CRYPTO_ALGO_PMK			         12	/* for 802.1x supp to set PMK before 4-way */
+
+/* wireless security bitvec */
+#define WEP_ENABLED		                0x0001
+#define TKIP_ENABLED		            0x0002
+#define AES_ENABLED		                0x0004
+#define WSEC_SWFLAG		                0x0008
+
+/* to go into transition mode without setting wep */
+#define SES_OW_ENABLED		            0x0040
+#define SMS4_ENABLED                    0x0100
+
+/* WPA authentication mode bitvec */
+#define WPA_AUTH_DISABLED	            0x0000	/* Legacy (i.e., non-WPA) */
+#define WPA_AUTH_NONE		            0x0001	/* none (IBSS) */
+#define WPA_AUTH_UNSPECIFIED	        0x0002	/* over 802.1x */
+#define WPA_AUTH_PSK		            0x0004	/* Pre-shared key */
+#define WPA_AUTH_RESERVED1	            0x0008
+#define WPA_AUTH_RESERVED2	            0x0010
+
+#define WPA2_AUTH_RESERVED1	            0x0020
+#define WPA2_AUTH_UNSPECIFIED	        0x0040	/* over 802.1x */
+#define WPA2_AUTH_PSK		            0x0080	/* Pre-shared key */
+#define WPA2_AUTH_RESERVED3	            0x0200
+#define WPA2_AUTH_RESERVED4	            0x0400
+#define WPA2_AUTH_RESERVED5	            0x0800
+
+/* Small, medium and maximum buffer size for dcmd */
+#define WLAND_DCMD_SMLEN	            256
+#define WLAND_DCMD_MEDLEN	            1536
+#define WLAND_DCMD_LARGE	            8192
+#define ROUND_UP_MARGIN	                32	/* Biggest SDIO block size possible for round off at the end of buffer */
+
+#define MAKE_WORD16(lsb, msb)           (((u16)(msb) << 8)  & 0xFF00) | (lsb)
+#define MAKE_WORD32(lsw, msw)           (((u32)(msw) << 16) & 0xFFFF0000) | (lsw)
+
+enum WLAN_SCAN_STATUS {
+	WLAN_SCAN_IDLE = 0,
+	WLAN_SCAN_RUNNING = 1,
+	WLAN_SCAN_COMPLET = 2
+};
+
+enum WLAN_PACKET_TYPE {
+	WLAN_CMD = 1,
+	WLAN_DATA = 2
+};
+
+/* KEY_TYPE_ID */
+enum KEY_TYPE_ID {
+	KEY_TYPE_ID_WEP = 0,
+	KEY_TYPE_ID_TKIP,
+	KEY_TYPE_ID_AES
+};
+
+enum PACKET_TYPE {
+	WID_REQUEST_PACKET,
+	WID_REQUEST_POLLING_PACKET,
+	DATA_REQUEST_PACKET
+};
+
+/** KEY_INFO_WPA (applies to both TKIP and AES/CCMP) */
+enum KEY_INFO_WPA {
+	KEY_INFO_WPA_MCAST = 0x01,
+	KEY_INFO_WPA_UNICAST = 0x02,
+	KEY_INFO_WPA_ENABLED = 0x04
+};
+
+/*
+ *  @user set ps mode for save power
+ */
+enum USER_PS_MODE_T {
+	NO_POWERSAVE = 0,
+	MIN_FAST_PS = 1,
+	MAX_FAST_PS = 2,
+	MIN_PSPOLL_PS = 3,
+	MAX_PSPOLL_PS = 4
+};
+
+enum SITE_SURVEY_T {
+	SITE_SURVEY_1CH = 0,
+	SITE_SURVEY_ALL_CH = 1,
+	SITE_SURVEY_OFF = 2
+};
+
+enum DEVICE_MODE_T {
+	NOT_CONFIGURED = 0,
+	ACCESS_POINT = 1,
+	BSS_STA = 2,
+	IBSS_STA = 3,
+	P2P_GO = 4,
+	P2P_DEVICE = 5,
+	P2P_CLIENT = 6
+};
+
+enum MAC_ROLE_T {
+	MAC_ROLE_STA = 0,
+	MAC_ROLE_AP = 1
+};
+
+struct wlan_bss_descriptor {
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 bss_type;
+	u8 channel;
+	u8 dot11i_info;
+	u8 bssid[ETH_ALEN];
+	u8 rssi;
+	u8 auth_info;
+	u8 rsn_cap[2];
+};
+
+/*
+ *  @brief Structure used to store information for each beacon/probe response
+ */
+struct bss_descriptor {
+	u8 bssid[ETH_ALEN];
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+
+	u16 capability;
+	u32 rssi;
+	u32 channel;
+	u16 beaconperiod;
+
+	/*
+	 * IW_MODE_AUTO, IW_MODE_ADHOC, IW_MODE_INFRA
+	 */
+	u8 mode;
+
+	/*
+	 * zero-terminated array of supported data rates
+	 */
+	u8 rates[MAX_RATES + 1];
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	size_t wpa_ie_len;
+	u8 rsn_ie[MAX_WPA_IE_LEN];
+	size_t rsn_ie_len;
+
+	u8 wapi_ie[100];
+	size_t wapi_ie_len;	//wapi valid payload length
+
+	u32 last_scanned;
+	struct list_head list;
+};
+
+struct wlan_802_11_security {
+	u8 WPAenabled;
+	u8 WPA2enabled;
+	u8 wep_enabled;
+	u8 auth_mode;
+	u32 key_mgmt;
+	u32 cipther_type;
+};
+
+/* Generic structure to hold all key types. */
+struct enc_key {
+	u16 len;
+	u16 flags;		/* KEY_INFO_* from defs.h */
+	u16 type;		/* KEY_TYPE_* from defs.h */
+	u8 key[32];
+};
+
+struct wland_drv_timer;
+
+struct wlan_private {
+	u8 CardRemoved;
+	int Open;
+	int version;
+	u8 wlan_pm_enable;
+
+	u8 netDevRegistered;
+	atomic_t netifQuStop;
+	void *card;
+	u32 SdioErrorCount;
+	u8 sdio_irq_enable;
+	u8 IgnoreFisrtDisconnect;
+	u8 Suspend;
+	atomic_t CardNeedSleep;
+	u8 CardInSleep;
+	//struct wland_drv_timer  CardToSleepTimer;
+
+	spinlock_t TxLock;
+	spinlock_t RxLock;
+	spinlock_t WidLock;
+	spinlock_t EventLock;
+	u8 CardSleepWakeLockOn;
+	u8 wid_msg_id;
+
+    /** Pending command buffers */
+	struct list_head WidPendingQ;
+
+    /**rx packet queue*/
+	struct list_head RxQueue;
+
+    /**tx packet queue*/
+	wait_queue_head_t UsbSendDone;
+	u8 UsbTxStatus;
+
+	struct iw_statistics wstats;
+	struct bss_descriptor curbssparams;
+	int connect_status;
+	int ToggalAssociation;
+	u8 assoc_ongoing;
+	u8 assoc_bssid[6];
+	u8 assoc_ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 assoc_ssid_len;
+//  struct wland_drv_timer      StartAssociationTimeOut;
+//  struct wland_drv_timer      AssociationTimeOut;
+//  struct wland_drv_timer      ReAssociationTimeOut;
+
+    /** Encryption parameter */
+	u8 imode;
+	u8 authtype;
+	struct wlan_802_11_security secinfo;
+
+    /** WEP keys */
+	struct enc_key wep_keys[4];
+	u16 wep_tx_keyidx;
+
+    /** WPA keys */
+	struct enc_key wpa_mcast_key;
+	struct enc_key wpa_unicast_key;
+
+    /** WPA Information Elements*/
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	u8 wpa_ie_len;
+	u8 is_wapi;
+
+    /** Scan results list */
+	int scan_running;
+	int active_scan;
+	//wland_drv_timer ScanResultsTimeout;
+	spinlock_t ScanListLock;
+	struct list_head network_list;
+	struct list_head network_free_list;
+	struct bss_descriptor *networks;
+	int scan_ssid_len;
+	u8 scan_ssid[IW_ESSID_MAX_SIZE + 1];
+};
+
+enum wland_fil_p2p_if_types {
+	FIL_P2P_IF_CLIENT,
+	FIL_P2P_IF_GO,
+	FIL_P2P_IF_DYNBCN_GO,
+	FIL_P2P_IF_DEV,
+};
+
+struct wland_fil_p2p_if_le {
+	u8 addr[ETH_ALEN];
+	__le16 type;
+	__le16 chspec;
+};
+
+struct wland_fil_chan_info_le {
+	__le32 hw_channel;
+	__le32 target_channel;
+	__le32 scan_channel;
+};
+
+struct wland_fil_action_frame_le {
+	u8 da[ETH_ALEN];
+	__le16 len;
+	__le32 packet_id;
+	u8 data[WLAND_FIL_ACTION_FRAME_SIZE];
+};
+
+struct wland_fil_af_params_le {
+	__le32 channel;
+	__le32 dwell_time;
+	u8 bssid[ETH_ALEN];
+	u8 pad[2];
+	struct wland_fil_action_frame_le action_frame;
+};
+
+struct wland_fil_bss_enable_le {
+	__le32 bsscfg_idx;
+	__le32 enable;
+};
+
+#define WLC_CNTRY_BUF_SZ	                    4	/* Country string is 3 bytes + NUL */
+
+struct wland_country {
+	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* nul-terminated country code used in the Country IE */
+	int rev;		/* revision specifier for ccode on set, -1 indicates unspecified. on get, rev >= 0 */
+	char ccode[WLC_CNTRY_BUF_SZ];	/* nul-terminated built-in country code. variable length, but fixed size in
+					 * struct allows simple allocation for expected country strings <= 3 chars.
+					 */
+};
+
+/*
+ * struct tdls_iovar - common structure for tdls iovars.
+ *
+ * @ea: ether address of peer station.
+ * @mode: mode value depending on specific tdls iovar.
+ * @chanspec: channel specification.
+ * @pad: unused (for future use).
+ */
+struct wland_tdls_iovar_le {
+	u8 ea[ETH_ALEN];	/* Station address */
+	u8 mode;		/* mode: depends on iovar */
+	__le16 chanspec;
+	__le32 pad;		/* future */
+};
+
+enum wland_tdls_manual_ep_ops {
+	TDLS_MANUAL_EP_CREATE = 1,
+	TDLS_MANUAL_EP_DELETE = 3,
+	TDLS_MANUAL_EP_DISCOVERY = 6
+};
+
+/* BSS info structure
+ * Applications MUST CHECK ie_offset field and length field to access IEs and
+ * next bss_info structure in a vector (in struct wland_scan_results)
+ */
+struct wland_bss_info_le {
+	u32 length;		/* byte length of data in this record, starting at version and including IEs */
+	u8 BSSID[ETH_ALEN];
+	u16 beacon_period;	/* units are Kusec          */
+	u16 capability;		/* Capability information   */
+	u8 SSID_len;
+	u8 SSID[32];
+	struct {
+		u8 count;	/* # rates in this set      */
+		u8 rates[MAX_RATES + 2];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;		/* supported rates          */
+	u16 chanspec;		/* chanspec for bss         */
+	u16 atim_window;	/* units are Kusec          */
+	u8 dtim_period;		/* DTIM period              */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s8 phy_noise;		/* noise (in dBm)           */
+
+	u8 n_cap;		/* BSS is 802.11N Capable   */
+	/*
+	 * 802.11N BSS Capabilities (based on HT_CAP_*):
+	 */
+	u32 nbss_cap;
+	u8 ctl_ch;		/* 802.11N BSS control channel number */
+	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+	u8 *ie;
+	u32 ie_length;		/* byte length of Information Elements */
+	s16 SNR;		/* average SNR of during frame reception */
+	unsigned long time;
+	struct list_head list;
+	/*
+	 * Add new fields here
+	 */
+	/*
+	 * variable length Information Elements
+	 */
+};
+
+struct wland_ssid {
+	u32 SSID_len;
+	u8 SSID[32];
+};
+
+struct wland_ssid_le {
+	__le32 SSID_len;
+	u8 SSID[32];
+};
+
+struct wland_scan_params_le {
+	struct wland_ssid_le ssid_le;	/* default: {0, ""} */
+	u8 bssid[ETH_ALEN];	/* default: bcast */
+	s8 bss_type;		/* default: any,
+				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
+				 */
+	u8 scan_type;		/* flags, 0 use default */
+	__le32 nprobes;		/* -1 use default, number of probes per channel */
+	__le32 active_time;	/* -1 use default, dwell time per channel for active scanning */
+	__le32 passive_time;	/* -1 use default, dwell time per channel for passive scanning */
+	__le32 home_time;	/* -1 use default, dwell time for the home channel between channel scans */
+	__le32 channel_num;	/* count of channels and ssids that follow
+				 *
+				 * low half is count of channels in channel_list, 0 means default (use all available channels)
+				 *
+				 * high half is entries in struct wland_ssid array that follows channel_list, aligned for
+				 * s32 (4 bytes) meaning an odd channel count
+				 * implies a 2-byte pad between end of channel_list and first ssid
+				 *
+				 * if ssid count is zero, single ssid in the fixed parameter portion is assumed, otherwise
+				 * ssid in the fixed portion is ignored
+				 */
+	__le16 channel_list[1];	/* list of chanspecs */
+};
+
+struct wland_scan_results {
+	u32 version;
+	u32 count;
+};
+
+struct wland_escan_params_le {
+	u32 version;
+	u16 action;
+	u16 sync_id;
+	struct wland_scan_params_le params_le;
+};
+
+/* used for association with a specific BSSID and chanspec list */
+struct wland_assoc_params_le {
+	/*
+	 * 00:00:00:00:00:00: broadcast scan
+	 */
+	u8 bssid[ETH_ALEN];
+	/*
+	 * 0: all available channels, otherwise count of chanspecs in chanspec_list
+	 */
+	__le32 chanspec_num;
+	/*
+	 * list of chanspecs
+	 */
+	__le16 chanspec_list[1];
+};
+
+/* used for join with or without a specific bssid and channel list */
+struct wland_join_params {
+	struct wland_ssid_le ssid_le;
+	struct wland_assoc_params_le params_le;
+};
+
+struct wland_wsec_key {
+	u32 index;		/* key index */
+	u32 len;		/* key length */
+	u8 data[WLAN_MAX_KEY_LEN];	/* key data */
+	u32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	u32 flags;		/* misc flags */
+	u32 iv_initialized;	/* has IV been initialized already? */
+	/*
+	 * Rx IV
+	 */
+	struct {
+		u32 hi;		/* upper 32 bits of IV */
+		u16 lo;		/* lower 16 bits of IV */
+	} rxiv;
+	u8 ea[ETH_ALEN];	/* per station */
+};
+struct wland_ptkey {
+	u8 ea[ETH_ALEN];	/* per station */
+	u8 keyLen;		/* key length */
+	u8 key[WLAN_MAX_KEY_LEN];	/* key data */
+};
+struct wland_rx_gtkey {
+	u8 ea[ETH_ALEN];	/* per station */
+	u8 keyRSC[8];		/* key data */
+	u8 keyIdx;		/* key index */
+	u8 keyLen;		/* key length */
+	u8 key[WLAN_MAX_KEY_LEN];	/* key data */
+};
+
+/* Used to get specific STA parameters */
+struct wland_scb_val_le {
+	s16 val;
+	u8 ea[ETH_ALEN];
+};
+
+/* security information with currently associated ap */
+struct wland_cfg80211_security {
+	u32 wpa_versions;
+	u32 auth_type;
+	u32 cipher_pairwise;
+	u32 cipher_group;
+	u32 wpa_auth;
+	u8 security;
+	u8 firmware_autype;
+};
+
+/*
+ * struct wland_cfg80211_profile - profile information.
+ *
+ * @ssid        : ssid of associated/associating ap.
+ * @bssid       : bssid of joined/joining ibss.
+ * @sec         : security information.
+ * @wepkey_idx  : wep_default_index.
+ * @wepkeys     : wep-keys.
+ */
+struct wland_cfg80211_profile {
+	struct wland_ssid ssid;
+	u8 bssid[ETH_ALEN];
+	struct wland_cfg80211_security sec;
+	u32 wepkey_idx;
+	struct wland_wsec_key wepkeys[MAX_WSEC_KEY];
+	u32 beacon;		/* beacon interval */
+	u32 dtim;		/* dtim period */
+	u8 rsn_cap;		/* RSN Capabilities */
+	bool valid_bssid;
+};
+
+struct wland_sta_info_le {
+	__le16 ver;		/* version of this struct */
+	__le16 len;		/* length in bytes of this structure */
+	__le16 cap;		/* sta's advertised capabilities */
+	__le32 flags;		/* flags defined below */
+	__le32 idle;		/* time since data pkt rx'd from sta */
+	u8 ea[ETH_ALEN];	/* Station address */
+	__le32 count;		/* # rates in this set */
+	u8 rates[MAX_RATES];	/* rates in 500kbps units */
+	/*
+	 * w/hi bit set if basic
+	 */
+	__le32 in;		/* seconds elapsed since associated */
+	__le32 listen_interval_inms;	/* Min Listen interval in ms for STA */
+	__le32 tx_pkts;		/* # of packets transmitted */
+	__le32 tx_failures;	/* # of packets failed */
+	__le32 rx_ucast_pkts;	/* # of unicast packets received */
+	__le32 rx_mcast_pkts;	/* # of multicast packets received */
+	__le32 tx_rate;		/* Rate of last successful tx frame */
+	__le32 rx_rate;		/* Rate of last successful rx frame */
+	__le32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
+	__le32 rx_decrypt_failures;	/* # of packet decrypted failed */
+};
+
+struct wland_chanspec_list {
+	__le32 count;		/* # of entries */
+	__le32 element[1];	/* variable length u32 list */
+};
+
+/*
+ * WLC_E_PROBRESP_MSG
+ * WLC_E_P2P_PROBREQ_MSG
+ * WLC_E_ACTION_FRAME_RX
+ */
+struct wland_rx_mgmt_data {
+	__be16 version;
+	__be16 chanspec;
+	__be32 rssi;
+	__be32 mactime;
+	__be32 rate;
+};
+
+/* Bus independent dongle command */
+struct wland_dcmd {
+	__le16 wid_pkg_length;	/*
+				 *  bit[0:11] : store pkg_length
+				 *  bit[12:15]: store host_msg_type
+				 *         PKT_TYPE_DATAOUT      0x1
+				 *         PKT_TYPE_DATAIN               0x2
+				 *         PKT_TYPE_CFG_RSP          0x3
+				 *         PKT_TYPE_CFG_REQ          0x4
+				 *         HOST_MSG_ASYNCEVENT   0x5
+				 */
+	u8 wid_msg_type;	/*
+				 *'Q'  -- request  for wid query
+				 *'W'  -- request  for wid write
+				 *'R'  -- response for write or query
+				 *'I'  -- mac status indication
+				 *'N'  -- network info: scan AP list
+				 */
+
+	u8 wid_msg_id;		/* message id     */
+	__le16 wid_msg_length;	/* message length */
+};
+
+/* Forward decls for struct wland_private (see below) */
+struct wland_proto {
+	u8 reqid;
+	u8 rsplen;		/* response length          */
+	u32 cmd;		/* dongle command value     */
+	u32 offset;		/* response data offset     */
+	struct wland_dcmd msg;
+	u8 buf[WLAND_DCMD_MEDLEN + ROUND_UP_MARGIN];
+};
+
+/* forward declarations */
+struct wland_cfg80211_vif;
+struct wland_mac_descriptor;
+struct wland_fw_info;
+
+/*
+ * struct wland_if - interface control information.
+ *
+ * @drvr:            points to device related information.
+ * @vif:             points to cfg80211 specific interface information.
+ * @ndev:            associated network device.
+ * @stats:           interface specific network statistics.
+ * @setmacaddr_work: worker object for setting mac address.
+ * @multicast_work:  worker object for multicast provisioning.
+ * @fws_desc:        interface specific firmware-signalling descriptor.
+ * @ifidx:           interface index in device firmware.
+ * @bssidx:          index of bss associated with this interface.
+ * @mac_addr:        assigned mac address.
+ * @netif_stop:      bitmap indicates reason why netif queues are stopped.
+ * @netif_stop_lock: spinlock for update netif_stop from multiple sources.
+ * @pend_8021x_cnt:  tracks outstanding number of 802.1x frames.
+ * @pend_8021x_wait: used for signalling change in count.
+ */
+struct wland_if {
+	struct wland_private *drvr;
+	struct wland_cfg80211_vif *vif;
+	struct net_device *ndev;
+	struct net_device_stats stats;
+	struct work_struct setmacaddr_work;
+	struct work_struct multicast_work;
+	struct wland_mac_descriptor *fws_desc;
+	s32 ifidx;
+	s32 bssidx;
+	u8 mac_addr[ETH_ALEN];
+	u8 netif_stop;
+	spinlock_t netif_stop_lock;
+	atomic_t pend_8021x_cnt;
+	wait_queue_head_t pend_8021x_wait;
+};
+
+/* Common structure for module and instance linkage */
+struct wland_private {
+	/*
+	 * Linkage ponters
+	 */
+	struct wland_bus *bus_if;
+	struct wland_proto *prot;
+	struct wland_cfg80211_info *config;
+
+	/*
+	 * Internal items
+	 */
+	uint hdrlen;		/* Total WLAND header length (proto + bus)  */
+	uint maxctl;		/* Max size rxctl request from proto to bus */
+	u8 wme_dp;		/* wme discard priority                     */
+	bool p2p_enable;	/* P2P enable                               */
+	bool dev_mode;		/* Device Mode                              */
+#ifdef WLAND_POWER_MANAGER
+	int sleep_flags;
+#endif				/*WLAND_POWER_MANAGER */
+	/*
+	 * chip media info
+	 */
+	u32 drv_version;	/* Version of dongle-resident driver        */
+	u8 mac[ETH_ALEN];	/* MAC address obtained from dongle         */
+
+	/*
+	 * Multicast data packets sent to chip
+	 */
+	u32 tx_multicast;
+	u8 channel;
+
+	struct wland_if *iflist[WLAND_MAX_IFS];
+
+	struct mutex proto_block;
+
+	struct wland_fw_info fweh;	/* process firmware events */
+	struct wland_fws_info *fws;
+
+	struct dentry *dbgfs_dir;
+};
+
+/*
+ * enum wland_netif_stop_reason - reason for stopping netif queue.
+ *
+ * @NETIF_STOP_REASON_FWS_FC:	netif stopped due to firmware signalling flow control.
+ * @NETIF_STOP_REASON_BLOCK_BUS:netif stopped due to bus blocking.
+ */
+enum wland_netif_stop_reason {
+	NETIF_STOP_REASON_FWS_FC = 1,
+	NETIF_STOP_REASON_BLOCK_BUS = 2
+};
+
+struct wland_platform_data {
+	u16 sd_head_align;
+	void (*power_on) (void);
+	void (*power_off) (void);
+	void (*reset) (void);
+};
+
+static inline int is_same_network(struct bss_descriptor *src,
+	struct bss_descriptor *dst)
+{
+	/*
+	 * A network is only a duplicate if the channel, BSSID, and ESSID
+	 * * all match.  We treat all <hidden> with the same BSSID and channel
+	 * * as one network
+	 */
+	return ((src->channel == dst->channel) &&
+		!compare_ether_addr(src->bssid, dst->bssid) &&
+		!memcmp(src->ssid, dst->ssid, IW_ESSID_MAX_SIZE));
+}
+
+static inline void clear_bss_descriptor(struct bss_descriptor *bss)
+{
+	/*
+	 * Don't blow away ->list, just BSS data
+	 */
+	memset(bss, 0, offsetof(struct bss_descriptor, list));
+}
+
+static inline void pkt_align(struct sk_buff *p, int len, int align)
+{
+	uint datalign;
+
+	datalign = (ulong) (p->data);
+	datalign = roundup(datalign, (align)) - datalign;
+	if (datalign)
+		skb_pull(p, datalign);
+	__skb_trim(p, len);
+}
+
+static inline void skb_align(struct sk_buff *p, uint datalign)
+{
+	uint offset = ((ulong) (p->data) & (datalign - 1));
+
+	if (offset) {
+		skb_pull(p, (datalign - offset));
+	}
+}
+
+extern s32 dhd_net2idx(struct wland_private *dhd, struct net_device *net);
+extern struct net_device *dhd_idx2net(void *pub, s32 ifidx);
+
+extern int wland_netdev_wait_pend8021x(struct net_device *ndev);
+
+/* Return pointer to interface name */
+extern char *wland_ifname(struct wland_private *drvr, int idx);
+
+/* net attach */
+extern int netdev_attach(struct wland_if *ifp);
+extern int netdev_p2p_attach(struct wland_if *ifp);
+
+/* wland if */
+extern struct wland_if *wland_add_if(struct wland_private *drvr, s32 bssidx,
+	s32 ifidx, char *name, u8 * mac_addr);
+extern void wland_del_if(struct wland_private *drvr, s32 bssidx);
+
+#ifdef WLAND_SDIO_SUPPORT
+extern void rda_mmc_set_sdio_irq(u32 host_id, u8 enable);
+extern void rda_mmc_bus_scan(u32 host_id);
+#endif /*WLAND_SDIO_SUPPORT */
+
+/* get chip id by i2c register */
+extern u32 rda_wlan_version(void);
+extern u8 check_test_mode(void);
+extern u8 check_role_mode(void);
+extern int rda_wifi_power_on(void);
+extern int rda_wifi_power_off(void);
+
+extern void wland_registration_sem_up(bool check_flag);
+
+/* read/store mac address by file */
+int wlan_read_mac_from_nvram(char *buf);
+int wlan_write_mac_to_nvram(const char *buf);
+
+#endif /*_WLAND_DEV_H_*/
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.c
new file mode 100644
index 000000000000..54b16f20ecc6
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.c
@@ -0,0 +1,575 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_trap.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+#ifdef DEBUG
+#define WLAND_ENUM_DEF(id, val)  	{ val, #id },
+
+struct wland_fweh_event_name {
+	enum wland_fweh_event_code code;
+	const char *name;
+};
+
+/* array for mapping code to event name */
+static struct wland_fweh_event_name fweh_event_names[] = {
+	FIRMW_EVENT_ENUM_DEFLIST
+};
+
+#undef WLAND_ENUM_DEF
+#endif /* DEBUG */
+
+static const char *fweh_event_name(enum wland_fweh_event_code code)
+{
+#ifdef DEBUG
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fweh_event_names); i++) {
+		if (fweh_event_names[i].code == code)
+			return fweh_event_names[i].name;
+	}
+	return "unknown";
+#else
+	return "nodebug";
+#endif
+}
+
+#if 0
+
+/* This function extracts the 'from ds' bit from the MAC header of the input */
+
+/* frame.                                                                    */
+
+/* Returns the value in the LSB of the returned value.                       */
+static inline u8 get_from_ds(u8 * header)
+{
+	return ((header[1] & 0x02) >> 1);
+}
+
+/* This function extracts the 'to ds' bit from the MAC header of the input   */
+
+/* frame.                                                                    */
+
+/* Returns the value in the LSB of the returned value.                       */
+static inline u8 get_to_ds(u8 * header)
+{
+	return (header[1] & 0x01);
+}
+
+/* This function extracts the BSSID from the incoming WLAN packet based on   */
+
+/* the 'from ds' bit, and updates the MAC Address in the allocated 'addr'    */
+
+/* variable.                                                                 */
+static void get_BSSID(u8 * data, u8 * bssid)
+{
+	if (get_from_ds(data) == 1)
+		memcpy(bssid, data + 10, 6);
+	else if (get_to_ds(data) == 1)
+		memcpy(bssid, data + 4, 6);
+	else
+		memcpy(bssid, data + 16, 6);
+}
+#endif
+
+/*
+ * fweh_dequeue_event() - get event from the queue.
+ *
+ * @fweh: firmware event handling info.
+ */
+static struct wland_fweh_queue_item *fweh_dequeue_event(struct wland_fw_info
+	*fweh)
+{
+	struct wland_fweh_queue_item *event = NULL;
+	ulong flags;
+
+	spin_lock_irqsave(&fweh->evt_q_lock, flags);
+	if (!list_empty(&fweh->event_q)) {
+		event = list_first_entry(&fweh->event_q,
+			struct wland_fweh_queue_item, q);
+		list_del(&event->q);
+	}
+	spin_unlock_irqrestore(&fweh->evt_q_lock, flags);
+
+	return event;
+}
+
+/*
+ * fweh_event_worker() - firmware event worker.
+ *
+ * @work: worker object.
+ */
+static void fweh_event_worker(struct work_struct *work)
+{
+	struct wland_fw_info *fweh =
+		container_of(work, struct wland_fw_info, event_work);
+	struct wland_private *drvr =
+		container_of(fweh, struct wland_private, fweh);
+	struct wland_fweh_queue_item *event;
+	struct wland_event_msg *emsg_be;
+	struct wland_if *ifp = NULL;
+	int err = 0;
+
+	while ((event = fweh_dequeue_event(fweh))) {
+		WLAND_DBG(EVENT, TRACE,
+			"event:%s(%u), status:%u, reason:%u, ifidx:%u, bsscfg:%u, addr:%pM\n",
+			fweh_event_name(event->code), event->code,
+			event->emsg.status, event->emsg.reason,
+			event->emsg.ifidx, event->emsg.bsscfgidx,
+			event->emsg.addr);
+
+		/*
+		 * convert event message
+		 */
+		emsg_be = &event->emsg;
+
+		/*
+		 * special handling of interface event
+		 */
+		if (emsg_be->ifidx >= WLAND_MAX_IFS) {
+			WLAND_ERR("invalid interface index: %u\n",
+				emsg_be->ifidx);
+
+			goto event_free;
+		}
+
+		if (event->code == WLAND_E_IF_ADD) {
+			WLAND_DBG(EVENT, DEBUG, "adding %s (%pM)\n",
+				emsg_be->ifname, emsg_be->addr);
+
+			ifp = wland_add_if(drvr, emsg_be->bsscfgidx,
+				emsg_be->ifidx, emsg_be->ifname, emsg_be->addr);
+			if (IS_ERR(ifp))
+				goto event_free;
+			wland_fws_add_interface(ifp);
+
+			if (netdev_attach(ifp) < 0)
+				goto event_free;
+		} else if (event->code == WLAND_E_IF_CHANGE) {
+			WLAND_DBG(EVENT, DEBUG, "enter: idx=%d\n", ifp->bssidx);
+
+			wland_fws_macdesc_init(ifp->fws_desc, ifp->mac_addr,
+				ifp->ifidx);
+		} else if (event->code == WLAND_E_IF_DEL) {
+			wland_fws_del_interface(ifp);
+			wland_del_if(drvr, emsg_be->bsscfgidx);
+		}
+
+		/*
+		 * handle the event if valid interface and handler
+		 */
+		if (fweh->evt_handler[emsg_be->event_code])
+			err = fweh->evt_handler[emsg_be->event_code] (drvr->
+				iflist[emsg_be->bsscfgidx], emsg_be,
+				event->data);
+		else
+			WLAND_ERR("unhandled event %d ignored\n",
+				emsg_be->event_code);
+
+		if (err < 0) {
+			WLAND_ERR("event handler failed (%d)\n", event->code);
+			err = 0;
+		}
+event_free:
+		kfree(event);
+	}
+}
+
+#if 0
+
+/*                         imode                          */
+
+/* BIT0: 1 -> Security ON              0 -> OFF           */
+
+/* BIT1: 1 -> WEP40  cypher supported  0 -> Not supported */
+
+/* BIT2: 1 -> WEP104 cypher supported  0 -> Not supported */
+
+/* BIT3: 1 -> WPA mode      supported  0 -> Not supported */
+
+/* BIT4: 1 -> WPA2 (RSN)    supported  0 -> Not supported */
+
+/* BIT5: 1 -> AES-CCMP cphr supported  0 -> Not supported */
+
+/* BIT6: 1 -> TKIP   cypher supported  0 -> Not supported */
+
+/* BIT7: 1 -> TSN           supported  0 -> Not supported */
+
+/*                        authtype                        */
+
+/* BIT0: 1 -> OPEN SYSTEM                                 */
+
+/* BIT1: 1 -> SHARED KEY                                  */
+
+/* BIT3: 1 -> WAPI                                        */
+
+static int assoc_helper_secinfo(struct wlan_private *priv,
+	struct bss_descriptor *assoc_bss)
+{
+	int ret = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "%s <<<\n", __func__);
+
+	/*
+	 * set imode and key
+	 */
+	if (!priv->secinfo.wep_enabled
+		&& !priv->secinfo.WPAenabled && !priv->secinfo.WPA2enabled) {
+		WLAND_DBG(DEFAULT, TRACE, "%s, NO SEC\n", __func__);
+		priv->imode = 0;
+	} else {
+		u16 key_len = 0;
+
+		if (priv->secinfo.wep_enabled
+			&& !priv->secinfo.WPAenabled
+			&& !priv->secinfo.WPA2enabled) {
+			/*
+			 * WEP
+			 */
+			key_len = priv->wep_keys[0].len;
+			WLAND_DBG(DEFAULT, TRACE, "%s, WEP, len = %d\n",
+				__func__, key_len * 8);
+			if (key_len == KEY_LEN_WEP_40) {
+				priv->imode = BIT0 | BIT1;
+			} else if (key_len == KEY_LEN_WEP_104) {
+				priv->imode = BIT0 | BIT2;
+			} else {
+				WLAND_ERR("Invalide WEP Key length %d\n",
+					key_len);
+				ret = -EINVAL;
+				goto out;
+			}
+		} else if (!priv->secinfo.wep_enabled
+			&& (priv->secinfo.WPAenabled
+				|| priv->secinfo.WPA2enabled)) {
+			/*
+			 * WPA
+			 */
+			struct enc_key *pkey = NULL;
+
+			WLAND_DBG(DEFAULT, TRACE,
+				"%s, WPA cp:%x wpa:%d wpa2:%d \n", __func__,
+				priv->secinfo.cipther_type,
+				priv->secinfo.WPAenabled,
+				priv->secinfo.WPA2enabled);
+
+			if (priv->wpa_mcast_key.len
+				&& (priv->wpa_mcast_key.flags &
+					KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_mcast_key;
+			else if (priv->wpa_unicast_key.len
+				&& (priv->wpa_unicast_key.flags &
+					KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_unicast_key;
+
+			priv->imode = 0;
+			/*
+			 * turn on security
+			 */
+			priv->imode |= (BIT0);
+			priv->imode &= ~(BIT3 | BIT4);
+
+			if (priv->secinfo.WPA2enabled)
+				priv->imode |= (BIT4);
+			else if (priv->secinfo.WPAenabled)
+				priv->imode |= (BIT3);
+			/*
+			 * we don't know the cipher type by now
+			 * use dot11i_info to decide and use CCMP if possible
+			 */
+			priv->imode &= ~(BIT5 | BIT6);
+
+			if (priv->secinfo.cipther_type & IW_AUTH_CIPHER_CCMP)
+				priv->imode |= BIT5;
+			else if (priv->secinfo.
+				cipther_type & IW_AUTH_CIPHER_TKIP)
+				priv->imode |= BIT6;
+		} else {
+			WLAND_ERR("WEP and WPA/WPA2 enabled simutanously\n");
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	/*
+	 * set authtype
+	 */
+	if (priv->secinfo.auth_mode & IW_AUTH_ALG_OPEN_SYSTEM
+		|| priv->secinfo.auth_mode & IW_AUTH_ALG_SHARED_KEY) {
+		if (priv->secinfo.auth_mode & IW_AUTH_ALG_OPEN_SYSTEM) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"Open Auth, KEY_MGMT = %d, AUTH_ALG mode:%x\n",
+				priv->secinfo.key_mgmt,
+				priv->secinfo.auth_mode);
+
+			if (priv->secinfo.key_mgmt == 0x01)
+				priv->authtype = BIT2;
+			else
+				priv->authtype = BIT0;
+		} else if (priv->secinfo.auth_mode & IW_AUTH_ALG_SHARED_KEY) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"Shared-Key Auth AUTH_ALG mode:%x \n",
+				priv->secinfo.auth_mode);
+			priv->authtype = BIT1;
+		}
+
+		if (priv->secinfo.key_mgmt == WAPI_KEY_MGMT_PSK
+			|| priv->secinfo.key_mgmt == WAPI_KEY_MGMT_CERT)
+			priv->authtype = BIT3;
+	} else if (priv->secinfo.auth_mode == IW_AUTH_ALG_WAPI) {
+		WLAND_DBG(DEFAULT, TRACE, "Wapi.\n");
+
+		priv->authtype = IW_AUTH_ALG_WAPI;
+	} else if (priv->secinfo.auth_mode == IW_AUTH_ALG_LEAP) {
+		WLAND_DBG(DEFAULT, TRACE, "LEAP Auth, Not supported.\n");
+		ret = -EINVAL;
+		goto out;
+	} else {
+		WLAND_ERR("Unknown Auth\n");
+		ret = -EINVAL;
+		goto out;
+	}
+out:
+	return ret;
+}
+#endif
+
+void wland_timer_handler(ulong fcontext)
+{
+#if 0
+	struct wland_drv_timer *timer = (struct wland_drv_timer *) fcontext;
+
+	if (timer->func) {
+		timer->func(timer->data);
+	} else {
+		wlan_event *event = wlan_alloc_event(timer->event);
+
+		if (event) {
+			event->Para = timer->data;
+			wlan_push_event((wlan_private *) timer->data, event,
+				true);
+		}
+	}
+
+	if (timer->timer_is_periodic == true) {
+		mod_timer(&timer->tl,
+			jiffies + msecs_to_jiffies(timer->time_period));
+	} else {
+		timer->timer_is_canceled = true;
+	}
+#endif
+}
+
+/* The format of the message is:                                         */
+
+/* +-------------------------------------------------------------------+ */
+
+/* | pkt Type  | Message Type |  Message body according type           | */
+
+/* +-------------------------------------------------------------------+ */
+
+/* |  1 Byte   |   1 Byte     |                                        | */
+
+/* +-------------------------------------------------------------------+ */
+
+void wland_netif_rx(struct wland_if *ifp, struct sk_buff *skb)
+{
+	skb->dev = ifp->ndev;
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	skb->ip_summed = CHECKSUM_NONE;
+
+	if (skb->pkt_type == PACKET_MULTICAST)
+		ifp->stats.multicast++;
+
+	/*
+	 * free skb
+	 */
+	if (!(ifp->ndev->flags & IFF_UP)) {
+		WLAND_ERR("netdev not up\n");
+		wland_pkt_buf_free_skb(skb);
+		return;
+	}
+
+	ifp->ndev->last_rx = jiffies;
+	ifp->stats.rx_bytes += skb->len;
+	ifp->stats.rx_packets++;
+
+	WLAND_DBG(EVENT, TRACE, "rx proto:0x%X,pkt_len:%d\n",
+		ntohs(skb->protocol), skb->len);
+
+	if (in_interrupt()) {
+		netif_rx(skb);
+	} else {
+		/*
+		 * If the receive is not processed inside an ISR, the softirqd must be woken explicitly to service the NET_RX_SOFTIRQ.
+		 * * In 2.6 kernels, this is handledby netif_rx_ni(), but in earlier kernels, we need to do it manually.
+		 */
+		netif_rx_ni(skb);
+	}
+}
+
+/*
+ * firmweh_push_event() - generate self event code.
+ *
+ * @drvr    : driver information object.
+ * @code    : event code.
+ * @data    : event data.
+ */
+void firmweh_push_event(struct wland_private *drvr,
+	struct wland_event_msg *event_packet, void *data)
+{
+	struct wland_fw_info *fweh = &drvr->fweh;
+	struct wland_fweh_queue_item *event;
+	gfp_t alloc_flag = GFP_KERNEL;
+	ulong flags;
+
+	if (event_packet->event_code >= WLAND_E_LAST) {
+		WLAND_ERR("invalid event code %d\n", event_packet->event_code);
+		return;
+	}
+
+	if (!fweh->evt_handler[event_packet->event_code]) {
+		WLAND_ERR("event code %d unregistered\n",
+			event_packet->event_code);
+		return;
+	}
+
+	WLAND_DBG(EVENT, TRACE, "push event for %s.\n",
+		fweh_event_name(event_packet->event_code));
+
+	if (in_interrupt())
+		alloc_flag = GFP_ATOMIC;
+
+	event = kzalloc(sizeof(*event) + event_packet->datalen, alloc_flag);
+	if (!event) {
+		WLAND_ERR("No memory\n");
+		return;
+	}
+
+	event->code = event_packet->event_code;
+	event->ifidx = event_packet->ifidx;
+
+	/*
+	 * use memcpy to get aligned event message
+	 */
+	memcpy(&event->emsg, event_packet, sizeof(event->emsg));
+	memcpy(event->data, data, event_packet->datalen);
+	memcpy(event->ifaddr, event_packet->addr, ETH_ALEN);
+
+	/*
+	 * create and queue event.
+	 */
+	spin_lock_irqsave(&fweh->evt_q_lock, flags);
+	list_add_tail(&event->q, &fweh->event_q);
+	spin_unlock_irqrestore(&fweh->evt_q_lock, flags);
+
+	/*
+	 * schedule work
+	 */
+	schedule_work(&fweh->event_work);
+}
+
+/*
+ * firmweh_register() - register handler for given event code.
+ *
+ * @drvr    : driver information object.
+ * @code    : event code.
+ * @handler : handler for the given event code.
+ */
+int firmweh_register(struct wland_private *drvr,
+	enum wland_fweh_event_code code, fw_handler_t handler)
+{
+	if (drvr->fweh.evt_handler[code]) {
+		WLAND_ERR("event code %d already registered\n", code);
+		return -ENOSPC;
+	}
+	drvr->fweh.evt_handler[code] = handler;
+
+	WLAND_DBG(EVENT, TRACE, "event handler registered for %s\n",
+		fweh_event_name(code));
+	return 0;
+}
+
+/*
+ * firmweh_unregister() - remove handler for given code.
+ *
+ * @drvr: driver information object.
+ * @code: event code.
+ */
+void firmweh_unregister(struct wland_private *drvr,
+	enum wland_fweh_event_code code)
+{
+	WLAND_DBG(EVENT, TRACE, "event handler cleared for %s\n",
+		fweh_event_name(code));
+	if (drvr->fweh.evt_handler[code])
+		drvr->fweh.evt_handler[code] = NULL;
+}
+
+/*
+ * wland_fweh_attach() - initialize firmware event handling.
+ *
+ * @drvr: driver information object.
+ */
+void wland_fweh_attach(struct wland_private *drvr)
+{
+	struct wland_fw_info *fweh = &drvr->fweh;
+
+	INIT_WORK(&fweh->event_work, fweh_event_worker);
+	spin_lock_init(&fweh->evt_q_lock);
+	INIT_LIST_HEAD(&fweh->event_q);
+}
+
+/*
+ * wland_fweh_detach() - cleanup firmware event handling.
+ *
+ * @drvr: driver information object.
+ */
+void wland_fweh_detach(struct wland_private *drvr)
+{
+	struct wland_fw_info *fweh = &drvr->fweh;
+
+	/*
+	 * cancel the worker
+	 */
+	cancel_work_sync(&fweh->event_work);
+	WARN_ON(!list_empty(&fweh->event_q));
+	memset(fweh->evt_handler, 0, sizeof(fweh->evt_handler));
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.h
new file mode 100644
index 000000000000..e9ea9a7d3a1a
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_fweh.h
@@ -0,0 +1,161 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_FWEH_H_
+#define _WLAND_FWEH_H_
+
+struct wland_if;
+struct wland_private;
+
+/* Firmware Header - Used on data packets to convey priority. */
+#define	FMW_HEADER_LEN		                4
+#define FMW_TYPE_MASK	                    0xF0	/* Firmware Host Type Mask */
+#define FMWID_HEADER_LEN                    7
+
+#define BDC_FLAG_VER_SHIFT	                4	/* Protocol version shift */
+#define BDC_FLAG2_IF_SHIFT	                0
+
+#define BDC_GET_IF_IDX(hdr)                 ((int)((((hdr)->flags2) & FMW_TYPE_MASK) >> BDC_FLAG2_IF_SHIFT))
+
+#define WLAND_ENUM_DEF(id, val)  	        WLAND_E_##id = (val),
+
+/* list of firmware events */
+#define FIRMW_EVENT_ENUM_DEFLIST \
+    WLAND_ENUM_DEF(ESCAN_RESULT,            0)\
+    WLAND_ENUM_DEF(CONNECT_IND,             1)\
+    WLAND_ENUM_DEF(DISCONNECT_IND,          2)\
+    WLAND_ENUM_DEF(ROAM,                    3)\
+    WLAND_ENUM_DEF(PFN_NET_FOUND,           4)\
+    WLAND_ENUM_DEF(P2P_DISC_LISTEN_COMPLETE,5)\
+    WLAND_ENUM_DEF(ACTION_FRAME_COMPLETE,   6)\
+    WLAND_ENUM_DEF(ACTION_FRAME_OFF_CHAN_COMPLETE, 7)\
+    WLAND_ENUM_DEF(P2P_PROBEREQ_MSG,        8)\
+    WLAND_ENUM_DEF(FIFO_CREDIT_MAP,         9)\
+    WLAND_ENUM_DEF(ACTION_FRAME_RX,         10)\
+    WLAND_ENUM_DEF(IF_ADD,                  11)\
+    WLAND_ENUM_DEF(IF_DEL,                  12)\
+    WLAND_ENUM_DEF(IF_CHANGE,               13)
+
+/* firmware event codes sent by the dongle */
+enum wland_fweh_event_code {
+#if 1
+	WLAND_E_ESCAN_RESULT,
+	WLAND_E_CONNECT_IND,
+	WLAND_E_DISCONNECT_IND,
+	WLAND_E_ROAM,
+	WLAND_E_PFN_NET_FOUND,
+	WLAND_E_P2P_DISC_LISTEN_COMPLETE,
+	WLAND_E_ACT_FRAME_COMPLETE,
+	WLAND_E_ACT_FRAME_OFF_CHAN_COMPLETE,
+	WLAND_E_P2P_PROBEREQ_MSG,
+	WLAND_E_FIFO_CREDIT_MAP,
+	WLAND_E_ACTION_FRAME_RX,
+	WLAND_E_IF_ADD,
+	WLAND_E_IF_DEL,
+	WLAND_E_IF_CHANGE,
+#else
+	FIRMW_EVENT_ENUM_DEFLIST
+#endif
+	WLAND_E_LAST
+};
+
+#undef WLAND_ENUM_DEF
+
+/*
+ * struct wland_event_msg - firmware event message.
+ *
+ * @version:    version information.
+ * @flags:      event flags.
+ * @event_code: firmware event code.
+ * @status:     status information.
+ * @reason:     reason code.
+ * @auth_type:  authentication type.
+ * @datalen:    lenght of event data buffer.
+ * @addr:       ether address.
+ * @ifname:     interface name.
+ * @ifidx:      interface index.
+ * @bsscfgidx:  bsscfg index.
+ */
+struct wland_event_msg {
+	u32 event_code;		/* firmware response eventcode or rspwid */
+	u32 status;
+	u32 reason;
+	s32 auth_type;
+	u32 datalen;		/* firmware request or response datalen  */
+	u8 addr[ETH_ALEN];
+	char ifname[IFNAMSIZ];
+	u8 action;
+	u8 role;
+	u8 ifidx;
+	u8 bsscfgidx;
+};
+
+/*
+ * struct wland_fweh_queue_item - event item on event queue.
+ *
+ * @q       : list element for queuing.
+ * @code    : event code.
+ * @ifidx   : interface index related to this event.
+ * @ifaddr  : ethernet address for interface.
+ * @emsg    : common parameters of the firmware event message.
+ * @data    : event specific data part of the firmware event.
+ */
+struct wland_fweh_queue_item {
+	struct list_head q;
+	enum wland_fweh_event_code code;
+	u8 ifidx;
+	u8 ifaddr[ETH_ALEN];
+	struct wland_event_msg emsg;
+	u8 data[0];
+};
+
+/* firmare event handle cb */
+typedef s32(*fw_handler_t) (struct wland_if * ifp,
+	const struct wland_event_msg * evtmsg, void *data);
+
+/*
+ * struct wland_fw_info - firmware event handling information.
+ *
+ * @event_work:  event worker.
+ * @evt_q_lock:  lock for event queue protection.
+ * @event_q:     event queue.
+ * @evt_handler: registered event handlers.
+ */
+struct wland_fw_info {
+	struct work_struct event_work;
+	spinlock_t evt_q_lock;
+	struct list_head event_q;
+	fw_handler_t evt_handler[WLAND_E_LAST];
+};
+
+/* handle firmware rx skb */
+extern void wland_netif_rx(struct wland_if *ifp, struct sk_buff *skb);
+
+/* push event to queue */
+extern void firmweh_push_event(struct wland_private *drvr,
+	struct wland_event_msg *event_packet, void *data);
+
+/* register/unregister for firmware event handler */
+extern int firmweh_register(struct wland_private *drvr,
+	enum wland_fweh_event_code code, fw_handler_t handler);
+extern void firmweh_unregister(struct wland_private *drvr,
+	enum wland_fweh_event_code code);
+
+/* attach firmware event handler moodle */
+extern void wland_fweh_attach(struct wland_private *drvr);
+extern void wland_fweh_detach(struct wland_private *drvr);
+
+#endif /* _WLAND_FWEH_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_fwsmgr.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_fwsmgr.c
new file mode 100644
index 000000000000..703bc9aca234
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_fwsmgr.c
@@ -0,0 +1,424 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+/** wland_fws_prio2fifo - mapping from 802.1d priority to firmware fifo index. */
+static const int wland_fws_prio2fifo[] = {
+	WLAND_FWS_FIFO_AC_BE,
+	WLAND_FWS_FIFO_AC_BK,
+	WLAND_FWS_FIFO_AC_BK,
+	WLAND_FWS_FIFO_AC_BE,
+	WLAND_FWS_FIFO_AC_VI,
+	WLAND_FWS_FIFO_AC_VI,
+	WLAND_FWS_FIFO_AC_VO,
+	WLAND_FWS_FIFO_AC_VO
+};
+
+#if 0
+static u32 fws_hanger_get_free_slot(struct wland_fws_hanger *h)
+{
+	u32 i = (h->slot_pos + 1) % FWS_HANGER_MAXITEMS;
+
+	while (i != h->slot_pos) {
+		if (h->items[i].state == FWS_HANGER_ITEM_STATE_FREE) {
+			h->slot_pos = i;
+			goto done;
+		}
+		i++;
+		if (i == FWS_HANGER_MAXITEMS)
+			i = 0;
+	}
+	WLAND_ERR("all slots occupied\n");
+	h->failed_slotfind++;
+	i = FWS_HANGER_MAXITEMS;
+done:
+	return i;
+}
+
+static int fws_hanger_pushpkt(struct wland_fws_hanger *h, struct sk_buff *pkt,
+	u32 slot_id)
+{
+	if (slot_id >= FWS_HANGER_MAXITEMS)
+		return -ENOENT;
+
+	if (h->items[slot_id].state != FWS_HANGER_ITEM_STATE_FREE) {
+		WLAND_ERR("slot is not free\n");
+		h->failed_to_push++;
+		return -EINVAL;
+	}
+
+	h->items[slot_id].state = FWS_HANGER_ITEM_STATE_INUSE;
+	h->items[slot_id].pkt = pkt;
+	h->pushed++;
+	return 0;
+}
+
+static int fws_hanger_poppkt(struct wland_fws_hanger *h, u32 slot_id,
+	struct sk_buff **pktout)
+{
+	if (slot_id >= FWS_HANGER_MAXITEMS)
+		return -ENOENT;
+
+	if (h->items[slot_id].state == FWS_HANGER_ITEM_STATE_FREE) {
+		WLAND_ERR("entry not in use\n");
+		h->failed_to_pop++;
+		return -EINVAL;
+	}
+
+	*pktout = h->items[slot_id].pkt;
+
+	h->items[slot_id].state = FWS_HANGER_ITEM_STATE_FREE;
+	h->items[slot_id].pkt = NULL;
+	h->popped++;
+
+	return 0;
+}
+#endif
+static void fws_macdesc_set_name(struct wland_fws_info *fws,
+	struct wland_mac_descriptor *desc)
+{
+	if (desc == &fws->desc.other)
+		strlcpy(desc->name, "MAC-OTHER", sizeof(desc->name));
+	else if (desc->mac_handle)
+		scnprintf(desc->name, sizeof(desc->name), "MAC-%d:%d",
+			desc->mac_handle, desc->interface_id);
+	else
+		scnprintf(desc->name, sizeof(desc->name), "MACIF:%d",
+			desc->interface_id);
+}
+
+static struct wland_mac_descriptor *fws_macdesc_lookup(struct wland_fws_info
+	*fws, u8 * ea)
+{
+	struct wland_mac_descriptor *entry;
+	int i;
+
+	if (ea == NULL)
+		return ERR_PTR(-EINVAL);
+
+	entry = &fws->desc.nodes[0];
+
+	for (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++) {
+		if (entry->occupied && !memcmp(entry->ea, ea, ETH_ALEN))
+			return entry;
+		entry++;
+	}
+
+	return ERR_PTR(-ENOENT);
+}
+
+struct wland_mac_descriptor *fws_macdesc_find(struct wland_fws_info *fws,
+	struct wland_if *ifp, u8 * da)
+{
+	struct wland_mac_descriptor *entry = &fws->desc.other;
+	bool multicast = is_multicast_ether_addr(da);
+
+	/*
+	 * Multicast destination, STA and P2P clients get the interface entry.
+	 * * STA/GC gets the Mac Entry for TDLS destinations, TDLS destinations
+	 * * have their own entry.
+	 */
+	if (multicast && ifp->fws_desc) {
+		entry = ifp->fws_desc;
+		goto done;
+	}
+
+	entry = fws_macdesc_lookup(fws, da);
+
+	if (IS_ERR(entry))
+		entry = ifp->fws_desc;
+done:
+	return entry;
+}
+
+static void fws_hanger_cleanup(struct wland_fws_info *fws,
+	bool(*fn) (struct sk_buff *, void *), int ifidx)
+{
+	struct wland_fws_hanger *h = &fws->hanger;
+	struct sk_buff *skb;
+	int i;
+	enum wland_fws_hanger_item_state s;
+
+	for (i = 0; i < ARRAY_SIZE(h->items); i++) {
+		s = h->items[i].state;
+		if (s == FWS_HANGER_ITEM_STATE_INUSE ||
+			s == FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {
+			skb = h->items[i].pkt;
+			if (fn == NULL || fn(skb, &ifidx)) {
+				/*
+				 * suppress packets freed from psq
+				 */
+				if (s == FWS_HANGER_ITEM_STATE_INUSE)
+					wland_pkt_buf_free_skb(skb);
+				h->items[i].state = FWS_HANGER_ITEM_STATE_FREE;
+			}
+		}
+	}
+}
+
+bool fws_macdesc_closed(struct wland_fws_info *fws,
+	struct wland_mac_descriptor *entry, int fifo)
+{
+	struct wland_mac_descriptor *if_entry;
+	bool closed;
+
+	/*
+	 * for unique destination entries the related interface may be closed.
+	 */
+	if (entry->mac_handle) {
+		if_entry = &fws->desc.iface[entry->interface_id];
+		if (if_entry->state == FWS_STATE_CLOSE)
+			return true;
+	}
+	/*
+	 * an entry is closed when the state is closed and the firmware did not request anything.
+	 */
+	closed = entry->state == FWS_STATE_CLOSE && !entry->requested_credit
+		&& !entry->requested_packet;
+
+	/*
+	 * Or firmware does not allow traffic for given fifo
+	 */
+	return closed || !(entry->ac_bitmap & BIT(fifo));
+}
+
+void fws_macdesc_cleanup(struct wland_fws_info *fws,
+	struct wland_mac_descriptor *entry, int ifidx)
+{
+	if (entry->occupied && (ifidx == -1 || ifidx == entry->interface_id)) {
+		bool(*matchfn) (struct sk_buff *, void *) = NULL;
+		struct sk_buff *skb;
+		struct pktq *q = &entry->psq;
+		int prec;
+
+		for (prec = 0; prec < q->num_prec; prec++) {
+			skb = wland_pktq_pdeq_match(q, prec, matchfn, &ifidx);
+			while (skb) {
+				wland_pkt_buf_free_skb(skb);
+				skb = wland_pktq_pdeq_match(q, prec, matchfn,
+					&ifidx);
+			}
+		}
+
+		entry->occupied = ! !(entry->psq.len);
+	}
+}
+
+static void fws_bus_txq_cleanup(struct wland_fws_info *fws,
+	bool(*fn) (struct sk_buff *, void *), int ifidx)
+{
+	struct wland_fws_hanger_item *hi;
+	struct pktq *txq = wland_bus_gettxq(fws->drvr->bus_if);
+	struct sk_buff *skb;
+	int prec;
+	u32 hslot;
+
+	if (IS_ERR(txq)) {
+		WLAND_DBG(DEFAULT, TRACE, "no txq to clean up\n");
+		return;
+	}
+
+	for (prec = 0; prec < txq->num_prec; prec++) {
+		skb = wland_pktq_pdeq_match(txq, prec, fn, &ifidx);
+
+		while (skb) {
+			hslot = 0;
+			hi = &fws->hanger.items[hslot];
+			WARN_ON(skb != hi->pkt);
+			hi->state = FWS_HANGER_ITEM_STATE_FREE;
+			wland_pkt_buf_free_skb(skb);
+			skb = wland_pktq_pdeq_match(txq, prec, fn, &ifidx);
+		}
+	}
+}
+
+static void wland_fws_cleanup(struct wland_fws_info *fws, int ifidx)
+{
+	int i;
+	struct wland_mac_descriptor *table;
+
+	bool(*matchfn) (struct sk_buff *, void *) = NULL;
+
+	if (fws == NULL)
+		return;
+
+	/*
+	 * cleanup individual nodes
+	 */
+	table = &fws->desc.nodes[0];
+
+	for (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++)
+		fws_macdesc_cleanup(fws, &table[i], ifidx);
+
+	fws_macdesc_cleanup(fws, &fws->desc.other, ifidx);
+	fws_bus_txq_cleanup(fws, matchfn, ifidx);
+	fws_hanger_cleanup(fws, matchfn, ifidx);
+}
+
+void wland_fws_macdesc_init(struct wland_mac_descriptor *desc, u8 * addr,
+	u8 ifidx)
+{
+	if (!desc)
+		return;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter: desc %p ea=%pM, ifidx=%u\n", desc,
+		addr, ifidx);
+
+	desc->occupied = 1;
+	desc->state = FWS_STATE_OPEN;
+	desc->requested_credit = 0;
+	desc->requested_packet = 0;
+	/*
+	 * depending on use may need ifp->bssidx instead
+	 */
+	desc->interface_id = ifidx;
+	desc->ac_bitmap = 0xFF;	/* update this when handling APSD */
+	if (addr)
+		memcpy(&desc->ea[0], addr, ETH_ALEN);
+}
+
+void wland_fws_macdesc_deinit(struct wland_mac_descriptor *desc)
+{
+	WLAND_DBG(DEFAULT, TRACE, "enter: ea=%pM, ifidx=%u\n", desc->ea,
+		desc->interface_id);
+	desc->occupied = 0;
+	desc->state = FWS_STATE_CLOSE;
+	desc->requested_credit = 0;
+	desc->requested_packet = 0;
+}
+
+void wland_fws_add_interface(struct wland_if *ifp)
+{
+	struct wland_fws_info *fws = ifp->drvr->fws;
+	struct wland_mac_descriptor *entry = &fws->desc.iface[ifp->ifidx];
+
+	WLAND_DBG(DEFAULT, TRACE, "added %s,Enter\n", entry->name);
+
+	if (!ifp->ndev)
+		return;
+
+	ifp->fws_desc = entry;
+
+	wland_fws_macdesc_init(entry, ifp->mac_addr, ifp->ifidx);
+
+	fws_macdesc_set_name(fws, entry);
+
+	wland_pktq_init(&entry->psq, WLAND_FWS_PSQ_PREC_COUNT,
+		WLAND_FWS_PSQ_LEN);
+
+	WLAND_DBG(DEFAULT, TRACE, "added %s,Done\n", entry->name);
+}
+
+void wland_fws_del_interface(struct wland_if *ifp)
+{
+	struct wland_mac_descriptor *entry = ifp->fws_desc;
+
+	if (!entry)
+		return;
+
+	WLAND_DBG(DEFAULT, TRACE, "deleting %s\n", entry->name);
+
+	spin_lock_irqsave(&ifp->drvr->fws->spinlock, ifp->drvr->fws->flags);
+	ifp->fws_desc = NULL;
+	wland_fws_macdesc_deinit(entry);
+	wland_fws_cleanup(ifp->drvr->fws, ifp->ifidx);
+	spin_unlock_irqrestore(&ifp->drvr->fws->spinlock,
+		ifp->drvr->fws->flags);
+}
+
+int wland_fws_init(struct wland_private *drvr)
+{
+	struct wland_fws_info *fws;
+	int rc, i;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	drvr->fws = kzalloc(sizeof(*(drvr->fws)), GFP_KERNEL);
+	if (!drvr->fws) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	fws = drvr->fws;
+
+	spin_lock_init(&fws->spinlock);
+	/*
+	 * set linkage back
+	 */
+	fws->drvr = drvr;
+
+	/*
+	 * Setting the iovar may fail if feature is unsupported
+	 * * so leave the rc as is so driver initialization can
+	 * * continue. Set mode back to none indicating not enabled.
+	 */
+	for (i = 0; i < ARRAY_SIZE(fws->hanger.items); i++) {
+		fws->hanger.items[i].state = FWS_HANGER_ITEM_STATE_FREE;
+	}
+
+	wland_fws_macdesc_init(&fws->desc.other, NULL, 0);
+
+	fws_macdesc_set_name(fws, &fws->desc.other);
+
+	wland_pktq_init(&fws->desc.other.psq, WLAND_FWS_PSQ_PREC_COUNT,
+		WLAND_FWS_PSQ_LEN);
+	WLAND_DBG(DEFAULT, TRACE, "Done success\n");
+	return 0;
+
+fail:
+	WLAND_ERR("Done Failed\n");
+
+	return rc;
+}
+
+void wland_fws_deinit(struct wland_private *drvr)
+{
+	struct wland_fws_info *fws = drvr->fws;
+
+	if (!fws)
+		return;
+	/*
+	 * cleanup
+	 */
+	spin_lock_irqsave(&fws->spinlock, fws->flags);
+	wland_fws_cleanup(fws, -1);
+	drvr->fws = NULL;
+	spin_unlock_irqrestore(&fws->spinlock, fws->flags);
+
+	/*
+	 * free top structure
+	 */
+	kfree(fws);
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.c
new file mode 100644
index 000000000000..03a09fdaf1e4
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.c
@@ -0,0 +1,1824 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef WLAND_WEXT_SUPPORT
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+
+#include <linux/rtnetlink.h>
+
+/**
+ * 802.11b/g supported bitrates (in 500Kb/s units)
+ */
+static const u8 wlan_bg_rates[MAX_RATES] = { 0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18,
+	0x24, 0x30, 0x48, 0x60, 0x6c, 0x00, 0x00
+};
+
+static const u16 wlan_nr_chan = 11;
+
+static int iwext_get_name(struct net_device *dev, struct iw_request_info *info,
+	union iwreq_data *cwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	/*
+	 * We could add support for 802.11n here as needed. Jean II
+	 */
+	snprintf(cwrq, IFNAMSIZ, "IEEE 802.11bgn");
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+static int iwext_get_freq(struct net_device *dev, struct iw_request_info *info,
+	struct iw_freq *fwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	fwrq->m = (long) 2437 *100000;
+
+	fwrq->e = 1;
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+static int iwext_get_wap(struct net_device *dev, struct iw_request_info *info,
+	struct sockaddr *awrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	if (priv->connect_status == MAC_CONNECTED) {
+		memcpy(awrq->sa_data, priv->curbssparams.bssid, ETH_ALEN);
+	} else {
+		memset(awrq->sa_data, 0, ETH_ALEN);
+	}
+	awrq->sa_family = ARPHRD_ETHER;
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+static int iwext_set_rts(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_rts(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	int ret = 0;
+	u16 val = 600;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	vwrq->value = val;
+	vwrq->disabled = val > WLAN_RTS_MAX_VALUE;	/* min rts value is 0 */
+	vwrq->fixed = 1;
+
+	return ret;
+}
+
+static int iwext_set_frag(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_frag(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	int ret = 0;
+	u16 val = 1460;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	vwrq->value = val;
+	vwrq->disabled = ((val < WLAN_FRAG_MIN_VALUE)
+		|| (val > WLAN_FRAG_MAX_VALUE));
+	vwrq->fixed = 1;
+
+	return ret;
+}
+
+static int iwext_get_mode(struct net_device *dev, struct iw_request_info *info,
+	u32 * uwrq, char *extra)
+{
+	*uwrq = IW_MODE_INFRA;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_txpow(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	vwrq->value = 20;	// in dbm
+	vwrq->fixed = 1;
+	vwrq->disabled = 0;
+	vwrq->flags = IW_TXPOW_DBM;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_set_retry(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_retry(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	int ret = 0;
+	u16 val = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	vwrq->disabled = 0;
+
+	if (vwrq->flags & IW_RETRY_LONG) {
+		val = 7;
+
+		/*
+		 * Subtract 1 to convert try count to retry count
+		 */
+		vwrq->value = val - 1;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
+	} else {
+		val = 6;
+
+		/*
+		 * Subtract 1 to convert try count to retry count
+		 */
+		vwrq->value = val - 1;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;
+	}
+
+	return ret;
+}
+
+/**
+ *  @brief Get Range Info
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 --success, otherwise fail
+ */
+static int iwext_get_range(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	struct iw_range *range = (struct iw_range *) extra;
+	int i;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	dwrq->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+
+	range->min_nwid = 0;
+	range->max_nwid = 0;
+
+	range->num_bitrates = sizeof(wlan_bg_rates);
+	for (i = 0; i < range->num_bitrates; i++)
+		range->bitrate[i] = wlan_bg_rates[i] * 500000;
+	range->num_bitrates = i;
+
+	range->num_frequency = 0;
+
+	range->scan_capa = IW_SCAN_CAPA_ESSID;
+
+	for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+		&& (i < wlan_nr_chan); i++) {
+		range->freq[range->num_frequency].i = (long) (i + 1);
+		range->freq[range->num_frequency].m =
+			(long) ((2412 + 5 * i) * 100000);
+		range->freq[range->num_frequency].e = 1;
+		range->num_frequency++;
+	}
+
+	range->num_channels = range->num_frequency;
+
+	/*
+	 * Set an indication of the max TCP throughput in bit/s that we can
+	 * expect using this interface
+	 */
+	range->throughput = 5000 * 1000;
+
+	range->min_rts = WLAN_RTS_MIN_VALUE;
+	range->max_rts = WLAN_RTS_MAX_VALUE;
+	range->min_frag = WLAN_FRAG_MIN_VALUE;
+	range->max_frag = WLAN_FRAG_MAX_VALUE;
+
+	range->encoding_size[0] = 5;
+	range->encoding_size[1] = 13;
+	range->num_encoding_sizes = 2;
+	range->max_encoding_tokens = 4;
+
+	/*
+	 * Right now we support only "iwconfig ethX power on|off"
+	 */
+	range->pm_capa = IW_POWER_ON;
+
+	/*
+	 * Minimum version we recommend
+	 */
+	range->we_version_source = 15;
+
+	/*
+	 * Version we are compiled with
+	 */
+	range->we_version_compiled = WIRELESS_EXT;	//it should be canlced
+
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+
+	range->min_retry = 0;
+	range->max_retry = 14;
+
+	/*
+	 * Set the qual, level and noise range values
+	 */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 0;
+	range->max_qual.noise = 0;
+	range->max_qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+
+	range->avg_qual.qual = 70;
+	/*
+	 * TODO: Find real 'good' to 'bad' threshold value for RSSI
+	 */
+	range->avg_qual.level = 0;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+	range->sensitivity = 0;
+
+	/*
+	 * Setup the supported power level ranges
+	 */
+	memset(range->txpower, 0, sizeof(range->txpower));
+	range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+	range->txpower[0] = 0;
+	range->txpower[1] = 20;
+	range->num_txpower = 2;
+
+	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
+		IW_EVENT_CAPA_MASK(SIOCGIWAP) |
+		IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+	range->event_capa[1] = IW_EVENT_CAPA_K_1;
+
+	range->enc_capa = IW_ENC_CAPA_WPA
+		| IW_ENC_CAPA_WPA2
+		| IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+static int iwext_set_power(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_power(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	vwrq->value = 0;
+	vwrq->flags = 0;
+	vwrq->disabled = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int wlan_update_bss_stats(wlan_private * priv)
+{
+	int ret = 0;
+
+	memcpy(priv->curbssparams.ssid, priv->assoc_ssid,
+		sizeof(priv->curbssparams.ssid));
+
+	if (priv->scan_running == WLAN_SCAN_RUNNING)
+		return ret;
+
+	ret = wland_fil_get_cmd_data(priv, WID_RSSI, &priv->curbssparams.rssi,
+		sizeof(u8));
+	if (ret < 0)
+		WLAND_ERR("get_rssi, ret = %d\n", ret);
+
+	WLAND_DBG(WEXT, TRACE, "<<< ch = %d  rssi = %d\n",
+		priv->curbssparams.channel, priv->curbssparams.rssi);
+
+	return ret;
+}
+
+struct iw_statistics *wland_get_wireless_stats(struct net_device *dev)
+{
+	struct wlan_private *priv = (struct wlan_private *) netdev_priv(dev);
+	int stats_valid = 0;
+	u8 snr;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	if (priv->connect_status != MAC_CONNECTED)
+		goto out;
+
+	wlan_update_bss_stats(priv);
+
+	priv->wstats.miss.beacon = 0;
+	priv->wstats.discard.retries = 0;
+	priv->wstats.qual.level =
+		priv->curbssparams.rssi >
+		127 ? priv->curbssparams.rssi - 271 : priv->curbssparams.rssi -
+		15;
+
+	snr = priv->wstats.qual.level - WLAN_NF_DEFAULT_SCAN_VALUE;
+	priv->wstats.qual.qual =
+		(100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - snr) *
+		(15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI -
+				snr))) / (RSSI_DIFF * RSSI_DIFF);
+
+	if (priv->wstats.qual.qual > 100)
+		priv->wstats.qual.qual = 100;
+
+	priv->wstats.qual.noise = WLAN_NF_DEFAULT_SCAN_VALUE;
+	priv->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+
+	stats_valid = 1;
+
+out:
+	if (!stats_valid) {
+		priv->wstats.miss.beacon = 0;
+		priv->wstats.discard.retries = 0;
+		priv->wstats.qual.qual = 0;
+		priv->wstats.qual.level = 0;
+		priv->wstats.qual.noise = 0;
+		priv->wstats.qual.updated = IW_QUAL_ALL_UPDATED;
+		priv->wstats.qual.updated |=
+			IW_QUAL_NOISE_INVALID | IW_QUAL_QUAL_INVALID |
+			IW_QUAL_LEVEL_INVALID;
+	}
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return &priv->wstats;
+}
+
+static int iwext_set_freq(struct net_device *dev, struct iw_request_info *info,
+	struct iw_freq *fwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_set_rate(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_rate(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	vwrq->fixed = 0;
+	vwrq->value = 108 * 500000;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_set_mode(struct net_device *dev, struct iw_request_info *info,
+	u32 * uwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+/*
+ *  @brief Get Encryption key
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 --success, otherwise fail
+ */
+static int iwext_get_encode(struct net_device *dev,
+	struct iw_request_info *info, struct iw_point *dwrq, u8 * extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+/*
+ *  @brief Set Encryption key
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 --success, otherwise fail
+ */
+static int iwext_set_encode(struct net_device *dev,
+	struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+/*
+ *  @brief Set Encryption key (internal)
+ *
+ *  @param priv         A pointer to private card structure
+ *  @param key_material A pointer to key material
+ *  @param key_length       length of key material
+ *  @param index        key index to set
+ *  @param set_tx_key       Force set TX key (1 = yes, 0 = no)
+ *  @return             0 --success, otherwise fail
+ */
+static int copy_wep_key(wlan_private * priv, const char *key_material,
+	u16 key_length, u16 index, int set_tx_key)
+{
+	int ret = 0;
+	struct enc_key *pkey;
+
+	/*
+	 * Paranoid validation of key index
+	 */
+	if (index > 3) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * validate max key length
+	 */
+	if (key_length > KEY_LEN_WEP_104) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (key_length == KEY_LEN_WEP_40) {
+		WLAND_DBG(WEXT, TRACE, "WEP40 : %02x%02x%02x%02x%02x\n",
+			key_material[0], key_material[1], key_material[2],
+			key_material[3], key_material[4]);
+	} else if (key_length == KEY_LEN_WEP_104) {
+		WLAND_DBG(WEXT, TRACE, "WEP104 : %02x%02x%02x%02x%02x"
+			" %02x%02x%02x%02x%02x"
+			" %02x%02x%02x\n",
+			key_material[0], key_material[1], key_material[2],
+			key_material[3], key_material[4], key_material[5],
+			key_material[6], key_material[7], key_material[8],
+			key_material[9], key_material[10], key_material[11],
+			key_material[12]);
+	} else {
+		WLAND_ERR("Error in WEP Key length %d\n", key_length);
+	}
+
+	pkey = &priv->wep_keys[index];
+
+	if (key_length > 0) {
+		memset(pkey, 0, sizeof(struct enc_key));
+		pkey->type = KEY_TYPE_ID_WEP;
+
+		/*
+		 * Standardize the key length
+		 */
+		pkey->len =
+			(key_length >
+			KEY_LEN_WEP_40) ? KEY_LEN_WEP_104 : KEY_LEN_WEP_40;
+		memcpy(pkey->key, key_material, key_length);
+	}
+
+	if (set_tx_key) {
+		/*
+		 * Ensure the chosen key is valid
+		 */
+		if (!pkey->len) {
+			WLAND_ERR("key not set, so cannot enable it\n");
+			ret = -EINVAL;
+			goto out;
+		}
+		priv->wep_tx_keyidx = index;
+	}
+
+	priv->secinfo.wep_enabled = 1;
+
+out:
+	return ret;
+}
+
+static int validate_key_index(u16 def_index, u16 raw_index, u16 * out_index,
+	u16 * is_default)
+{
+	if (!out_index || !is_default)
+		return -EINVAL;
+
+	/*
+	 * Verify index if present, otherwise use default TX key index
+	 */
+	if (raw_index > 0) {
+		if (raw_index > 4)
+			return -EINVAL;
+		*out_index = raw_index - 1;
+	} else {
+		*out_index = def_index;
+		*is_default = 1;
+	}
+	return 0;
+}
+
+void disable_wep(wlan_private * priv)
+{
+	int i;
+
+	/*
+	 * Set Open System auth mode
+	 */
+	priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+	/*
+	 * Clear WEP keys and mark WEP as disabled
+	 */
+	priv->secinfo.wep_enabled = 0;
+
+	for (i = 0; i < 4; i++)
+		priv->wep_keys[i].len = 0;
+}
+
+void disable_wpa(wlan_private * priv)
+{
+	memset(&priv->wpa_mcast_key, 0, sizeof(struct enc_key));
+	priv->wpa_mcast_key.flags = KEY_INFO_WPA_MCAST;
+
+	memset(&priv->wpa_unicast_key, 0, sizeof(struct enc_key));
+	priv->wpa_unicast_key.flags = KEY_INFO_WPA_UNICAST;
+
+	priv->secinfo.WPAenabled = 0;
+	priv->secinfo.WPA2enabled = 0;
+	priv->secinfo.cipther_type = 0;
+	priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+}
+
+/**
+ *  @brief Get Extended Encryption key (WPA/802.1x and WEP)
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 on success, otherwise failure
+ */
+static int iwext_get_encodeext(struct net_device *dev,
+	struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = -EINVAL;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *) extra;
+	int index, max_key_len;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	max_key_len = dwrq->length - sizeof(*ext);
+	if (max_key_len < 0)
+		goto out;
+
+	index = dwrq->flags & IW_ENCODE_INDEX;
+	if (index) {
+		if (index < 1 || index > 4)
+			goto out;
+		index--;
+	} else {
+		index = priv->wep_tx_keyidx;
+	}
+
+	if (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+		&& ext->alg != IW_ENCODE_ALG_WEP) {
+		if (index != 0)
+			goto out;
+	}
+
+	dwrq->flags = index + 1;
+	memset(ext, 0, sizeof(*ext));
+
+	if (!priv->secinfo.wep_enabled
+		&& !priv->secinfo.WPAenabled && !priv->secinfo.WPA2enabled) {
+		ext->alg = IW_ENCODE_ALG_NONE;
+		ext->key_len = 0;
+		dwrq->flags |= IW_ENCODE_DISABLED;
+	} else {
+		u8 *key = NULL;
+
+		if (priv->secinfo.wep_enabled
+			&& !priv->secinfo.WPAenabled
+			&& !priv->secinfo.WPA2enabled) {
+			/*
+			 * WEP
+			 */
+			ext->alg = IW_ENCODE_ALG_WEP;
+			ext->key_len = priv->wep_keys[index].len;
+			key = &priv->wep_keys[index].key[0];
+		} else if (!priv->secinfo.wep_enabled
+			&& (priv->secinfo.WPAenabled
+				|| priv->secinfo.WPA2enabled)) {
+			/*
+			 * WPA
+			 */
+			struct enc_key *pkey = NULL;
+
+			if (priv->wpa_mcast_key.len
+				&& (priv->wpa_mcast_key.flags &
+					KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_mcast_key;
+			else if (priv->wpa_unicast_key.len
+				&& (priv->wpa_unicast_key.flags &
+					KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_unicast_key;
+
+			if (pkey) {
+				if (pkey->type == KEY_TYPE_ID_AES) {
+					ext->alg = IW_ENCODE_ALG_CCMP;
+				} else {
+					ext->alg = IW_ENCODE_ALG_TKIP;
+				}
+				ext->key_len = pkey->len;
+				key = &pkey->key[0];
+			} else {
+				ext->alg = IW_ENCODE_ALG_TKIP;
+				ext->key_len = 0;
+			}
+		} else {
+			goto out;
+		}
+
+		if (ext->key_len > max_key_len) {
+			ret = -E2BIG;
+			goto out;
+		}
+
+		if (ext->key_len)
+			memcpy(ext->key, key, ext->key_len);
+		else
+			dwrq->flags |= IW_ENCODE_NOKEY;
+		dwrq->flags |= IW_ENCODE_ENABLED;
+	}
+	ret = 0;
+
+out:
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+/**
+ *  @brief Set Encryption key Extended (WPA/802.1x and WEP)
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 --success, otherwise fail
+ */
+static int iwext_set_encodeext(struct net_device *dev,
+	struct iw_request_info *info, struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *) extra;
+	int alg = ext->alg;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	if ((alg == IW_ENCODE_ALG_NONE) || (dwrq->flags & IW_ENCODE_DISABLED)) {
+		WLAND_DBG(WEXT, TRACE, "NO SEC\n");
+
+		if (priv->imode != 3 && priv->imode != 5)
+			disable_wep(priv);
+		disable_wpa(priv);
+	} else if (alg == IW_ENCODE_ALG_WEP) {
+		u16 is_default = 0, index, set_tx_key = 0;
+
+		WLAND_DBG(WEXT, TRACE, "WEP, flags = 0x%04x\n", dwrq->flags);
+
+		ret = validate_key_index(priv->wep_tx_keyidx,
+			(dwrq->flags & IW_ENCODE_INDEX), &index, &is_default);
+		if (ret)
+			goto out;
+
+		/*
+		 * If WEP isn't enabled, or if there is no key data but a valid
+		 * * index, or if the set-TX-key flag was passed, set the TX key.
+		 */
+		if (!priv->secinfo.wep_enabled
+			|| (dwrq->length == 0 && !is_default)
+			|| (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY))
+			set_tx_key = 1;
+
+		/*
+		 * Copy key to driver
+		 */
+		ret = copy_wep_key(priv, ext->key, ext->key_len, index,
+			set_tx_key);
+		if (ret)
+			goto out;
+
+		if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+			priv->secinfo.auth_mode = IW_AUTH_ALG_SHARED_KEY;
+		} else if (dwrq->flags & IW_ENCODE_OPEN) {
+			priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+		}
+	} else if ((alg == IW_ENCODE_ALG_TKIP) || (alg == IW_ENCODE_ALG_CCMP)) {
+		struct enc_key *pkey;
+
+		WLAND_DBG(WEXT, TRACE,
+			"TKIP or CCMP, flags = 0x%04x, alg = %d\n", dwrq->flags,
+			alg);
+
+		/*
+		 * validate key length
+		 */
+		if (((alg == IW_ENCODE_ALG_TKIP)
+				&& (ext->key_len != KEY_LEN_WPA_TKIP))
+			|| ((alg == IW_ENCODE_ALG_CCMP)
+				&& (ext->key_len != KEY_LEN_WPA_AES))) {
+			WLAND_ERR("invalid size %d for key of alg, type %d\n",
+				ext->key_len, alg);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/*
+		 * Copy key to driver
+		 */
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+			pkey = &priv->wpa_mcast_key;
+		} else {
+			pkey = &priv->wpa_unicast_key;
+		}
+
+		memset(pkey, 0, sizeof(struct enc_key));
+		memcpy(pkey->key, ext->key, ext->key_len);
+		pkey->len = ext->key_len;
+		if (pkey->len)
+			pkey->flags |= KEY_INFO_WPA_ENABLED;
+
+		/*
+		 * Do this after zeroing key structure
+		 */
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+			pkey->flags |= KEY_INFO_WPA_MCAST;
+		} else {
+			pkey->flags |= KEY_INFO_WPA_UNICAST;
+		}
+
+		if (alg == IW_ENCODE_ALG_TKIP) {
+			pkey->type = KEY_TYPE_ID_TKIP;
+
+			if (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+				&& !(priv->imode & (BIT6))) {
+				WLAND_ERR
+					("imode [0x%x] not match with cipher alg TKIP\n",
+					priv->imode);
+			}
+		} else if (alg == IW_ENCODE_ALG_CCMP) {
+			pkey->type = KEY_TYPE_ID_AES;
+
+			if (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+				&& !(priv->imode & (BIT5))) {
+				WLAND_ERR
+					("imode [0x%x] not match with cipher alg CCMP\n",
+					priv->imode);
+			}
+		}
+
+		/*
+		 * If WPA isn't enabled yet, do that now
+		 */
+		if (priv->secinfo.WPAenabled == 0
+			&& priv->secinfo.WPA2enabled == 0) {
+			priv->secinfo.WPAenabled = 1;
+			priv->secinfo.WPA2enabled = 1;
+		}
+
+		/*
+		 * Set Keys to MAC
+		 */
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+			/*
+			 * Set GTK
+			 */
+			ret = wland_set_gtk(priv,
+				(dwrq->flags & IW_ENCODE_INDEX) - 1,
+				ext->tx_seq, IW_ENCODE_SEQ_MAX_SIZE, pkey->key,
+				pkey->len);
+			if (ret)
+				goto out;
+		} else {
+			pkey->flags |= KEY_INFO_WPA_UNICAST;
+			/*
+			 * Set PTK
+			 */
+			ret = wland_set_ptk(priv, pkey->key, pkey->len);
+			if (ret)
+				goto out;
+		}
+
+		/*
+		 * Only disable wep if necessary: can't waste time here.
+		 */
+		disable_wep(priv);
+	} else if (alg == IW_ENCODE_ALG_SM4) {	//wapi
+		if (ext->key_len != 32)
+			goto out;
+
+		priv->is_wapi = 1;
+
+		/*
+		 * Set Keys to MAC
+		 */
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+			u8 tmp[8];
+
+			/*
+			 * Set GTK
+			 */
+			ret = wland_set_gtk(priv,
+				(dwrq->flags & IW_ENCODE_INDEX) - 1, tmp,
+				IW_ENCODE_SEQ_MAX_SIZE, ext->key, ext->key_len);
+			if (ret)
+				goto out;
+		} else {
+			/*
+			 * Set PTK
+			 */
+			ret = wland_set_ptk(priv, ext->key, ext->key_len);
+			if (ret)
+				goto out;
+		}
+	}
+
+out:
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+/*
+ *  @brief PMKSA cache operation (WPA/802.1x and WEP)
+ *
+ *  @param dev                  A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 on success, otherwise failure
+ */
+static int iwext_set_pmksa(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_set_genie(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	if (extra[0] == 0x44) {	//wapi ie
+		u8 ie_len = extra[1] + 2;
+		wland_fil_set_cmd_data(priv, WID_WAPI_ASSOC_IE, extra, ie_len);
+		goto out;
+	}
+
+	if (dwrq->length > MAX_WPA_IE_LEN || (dwrq->length && extra == NULL)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (dwrq->length) {
+		memcpy(&priv->wpa_ie[0], extra, dwrq->length);
+		priv->wpa_ie_len = dwrq->length;
+	} else {
+		memset(&priv->wpa_ie[0], 0, sizeof(priv->wpa_ie));
+		priv->wpa_ie_len = 0;
+	}
+out:
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return ret;
+}
+
+static int iwext_get_genie(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	if (priv->wpa_ie_len == 0) {
+		dwrq->length = 0;
+		goto out;
+	}
+
+	if (dwrq->length < priv->wpa_ie_len) {
+		ret = -E2BIG;
+		goto out;
+	}
+
+	dwrq->length = priv->wpa_ie_len;
+
+	memcpy(extra, &priv->wpa_ie[0], priv->wpa_ie_len);
+out:
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return ret;
+}
+
+static int iwext_set_auth(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	WLAND_DBG(WEXT, TRACE, "flags = 0x%04x, value = 0x%x\n", dwrq->flags,
+		dwrq->value);
+
+	switch (dwrq->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_CIPHER_PAIRWISE:
+		if (dwrq->value & (IW_AUTH_CIPHER_WEP104 |
+				IW_AUTH_CIPHER_WEP40)) {
+			WLAND_DBG(WEXT, TRACE, "WEP Selected \n");
+			priv->secinfo.wep_enabled = 1;
+			if (dwrq->value & IW_AUTH_CIPHER_WEP104)
+				priv->secinfo.cipther_type |=
+					IW_AUTH_CIPHER_WEP104;
+			else if (dwrq->value & IW_AUTH_CIPHER_WEP40)
+				priv->secinfo.cipther_type |=
+					IW_AUTH_CIPHER_WEP40;
+		}
+		if (dwrq->value & IW_AUTH_CIPHER_TKIP) {
+			WLAND_DBG(WEXT, TRACE, "IW_AUTH_CIPHER_TKIP \n");
+			priv->secinfo.cipther_type |= IW_AUTH_CIPHER_TKIP;
+		}
+		if (dwrq->value & IW_AUTH_CIPHER_CCMP) {
+			WLAND_DBG(WEXT, TRACE, "IW_AUTH_CIPHER_CCMP \n");
+			priv->secinfo.cipther_type |= IW_AUTH_CIPHER_CCMP;
+		}
+		if (dwrq->value & IW_AUTH_CIPHER_NONE) {
+			WLAND_DBG(WEXT, TRACE, "OPEN System \n");
+			priv->secinfo.cipther_type = IW_AUTH_CIPHER_NONE;
+		}
+		break;
+
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_DROP_UNENCRYPTED:
+		/*
+		 * wlan does not use these parameters
+		 */
+		WLAND_DBG(WEXT, TRACE, "DO NOT USE\n");
+		break;
+
+	case IW_AUTH_KEY_MGMT:
+		WLAND_DBG(WEXT, TRACE, "KEY_MGMT, val = %d\n", dwrq->value);
+		priv->secinfo.key_mgmt = dwrq->value;
+		break;
+
+	case IW_AUTH_WPA_VERSION:
+		if (dwrq->value & IW_AUTH_WPA_VERSION_DISABLED) {
+			WLAND_DBG(WEXT, TRACE, "WPA_VERSION, DISABLED\n");
+			priv->secinfo.WPAenabled = 0;
+			priv->secinfo.WPA2enabled = 0;
+			disable_wpa(priv);
+		}
+		if (dwrq->value & IW_AUTH_WPA_VERSION_WPA) {
+			WLAND_DBG(WEXT, TRACE, "WPA_VERSION, WPA\n");
+			priv->secinfo.WPAenabled = 1;
+			priv->secinfo.wep_enabled = 0;
+			priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+		}
+		if (dwrq->value & IW_AUTH_WPA_VERSION_WPA2) {
+			WLAND_DBG(WEXT, TRACE, "WPA_VERSION, WPA2\n");
+			priv->secinfo.WPA2enabled = 1;
+			priv->secinfo.wep_enabled = 0;
+			priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
+		}
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		if (dwrq->value & IW_AUTH_ALG_SHARED_KEY
+			|| dwrq->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			if (dwrq->value & IW_AUTH_ALG_SHARED_KEY) {
+				WLAND_DBG(WEXT, TRACE,
+					"80211_AUTH_ALG, SHARED_KEY\n");
+				priv->secinfo.auth_mode |=
+					IW_AUTH_ALG_SHARED_KEY;
+			}
+			if (dwrq->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+				WLAND_DBG(WEXT, TRACE,
+					"80211_AUTH_ALG, OPEN\n");
+				priv->secinfo.auth_mode |=
+					IW_AUTH_ALG_OPEN_SYSTEM;
+			}
+		} else if (dwrq->value & IW_AUTH_ALG_LEAP) {
+			WLAND_DBG(WEXT, TRACE, "80211_AUTH_ALG, LEAP\n");
+			priv->secinfo.auth_mode = IW_AUTH_ALG_LEAP;
+		} else if (dwrq->value & IW_AUTH_ALG_WAPI) {
+			priv->secinfo.auth_mode = IW_AUTH_ALG_WAPI;
+		} else {
+			WLAND_DBG(WEXT, TRACE, "80211_AUTH_ALG, unknown\n");
+			ret = -EINVAL;
+		}
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		if (dwrq->value) {
+			WLAND_DBG(WEXT, TRACE, "WPA_ENABLED, value = 0x%x\n",
+				dwrq->value);
+			if (!priv->secinfo.WPAenabled
+				&& !priv->secinfo.WPA2enabled) {
+				priv->secinfo.WPAenabled = 1;
+				priv->secinfo.WPA2enabled = 1;
+				priv->secinfo.wep_enabled = 0;
+				priv->secinfo.auth_mode =
+					IW_AUTH_ALG_OPEN_SYSTEM;
+			}
+		} else {
+			WLAND_DBG(WEXT, TRACE, "WPA_ENABLED, value = ZERO\n");
+			priv->secinfo.WPAenabled = 0;
+			priv->secinfo.WPA2enabled = 0;
+			disable_wpa(priv);
+		}
+		break;
+
+	case IW_AUTH_WAPI_ENABLED:
+		if (dwrq->value & BIT1) {
+			disable_wpa(priv);
+			disable_wep(priv);
+			priv->secinfo.auth_mode = IW_AUTH_ALG_WAPI;
+		} else if (dwrq->value & BIT2) {
+			disable_wpa(priv);
+			disable_wep(priv);
+			priv->secinfo.auth_mode = IW_AUTH_ALG_WAPI;
+		}
+		break;
+
+	default:
+		WLAND_DBG(WEXT, TRACE, "NOT SUPPORT\n");
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return ret;
+}
+
+static int iwext_get_auth(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	switch (dwrq->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_KEY_MGMT:
+		dwrq->value = priv->secinfo.key_mgmt;
+		break;
+
+	case IW_AUTH_WPA_VERSION:
+		dwrq->value = 0;
+		if (priv->secinfo.WPAenabled)
+			dwrq->value |= IW_AUTH_WPA_VERSION_WPA;
+		if (priv->secinfo.WPA2enabled)
+			dwrq->value |= IW_AUTH_WPA_VERSION_WPA2;
+		if (!dwrq->value)
+			dwrq->value |= IW_AUTH_WPA_VERSION_DISABLED;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		dwrq->value = priv->secinfo.auth_mode;
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		if (priv->secinfo.WPAenabled && priv->secinfo.WPA2enabled)
+			dwrq->value = 1;
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return ret;
+}
+
+static int iwext_set_txpow(struct net_device *dev, struct iw_request_info *info,
+	struct iw_param *vwrq, char *extra)
+{
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int iwext_get_essid(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+
+	memcpy(extra, priv->curbssparams.ssid, strlen(priv->curbssparams.ssid));
+	dwrq->length = strlen(priv->curbssparams.ssid);
+	extra[dwrq->length] = '\0';
+
+	/*
+	 * If none, we may want to get the one that was set
+	 */
+	dwrq->flags = 1;	/* active */
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+	return 0;
+}
+
+struct bss_descriptor *get_bss_desc_from_scanlist(wlan_private * priv,
+	u8 * bssid)
+{
+	struct bss_descriptor *iter_bss;
+	struct bss_descriptor *ret_bss = NULL;
+
+	spin_lock(&priv->ScanListLock);
+	/*
+	 * report all bss to upper layer
+	 */
+	list_for_each_entry(iter_bss, &priv->network_list, list) {
+		if (memcmp(iter_bss->bssid, bssid, 6) == 0) {
+			ret_bss = iter_bss;
+			break;
+		}
+	}
+	spin_unlock(&priv->ScanListLock);
+	return ret_bss;
+}
+
+struct bss_descriptor *get_bss_desc_from_scanlist_ssid(wlan_private * priv,
+	u8 * ssid)
+{
+	struct bss_descriptor *iter_bss;
+	struct bss_descriptor *ret_bss = NULL;
+
+	spin_lock(&priv->ScanListLock);
+	/*
+	 * report all bss to upper layer
+	 */
+	list_for_each_entry(iter_bss, &priv->network_list, list) {
+		if (memcmp(iter_bss->ssid, ssid, iter_bss->ssid_len) == 0) {
+			ret_bss = iter_bss;
+			break;
+		}
+	}
+	spin_unlock(&priv->ScanListLock);
+	return ret_bss;
+}
+
+static int iwext_set_essid(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1], ssid_len = 0;
+	int in_ssid_len = dwrq->length;
+
+	/*
+	 * Check the size of the string
+	 */
+	if (in_ssid_len > IW_ESSID_MAX_SIZE) {
+		ret = -E2BIG;
+		goto out;
+	}
+
+	memset(&ssid, 0, sizeof(ssid));
+
+	if (!dwrq->flags || !in_ssid_len) {
+		/*
+		 * "any" SSID requested; leave SSID blank
+		 */
+	} else {
+		/*
+		 * Specific SSID requested
+		 */
+		memcpy(&ssid, extra, in_ssid_len);
+		ssid[in_ssid_len] = '\0';
+		ssid_len = in_ssid_len;
+	}
+
+	WLAND_DBG(WEXT, TRACE, "requested SSID len = %d ssid:%s\n", ssid_len,
+		ssid);
+
+	if (ssid_len) {
+		memcpy(&priv->assoc_ssid[0], ssid, sizeof(ssid));
+		priv->assoc_ssid_len = ssid_len;
+	}
+out:
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+u8 is_zero_eth_addr(u8 * addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+/*
+ *  @brief Connect to the AP or Ad-hoc Network with specific bssid
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param awrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             0 --success, otherwise fail
+ */
+static int iwext_set_wap(struct net_device *dev, struct iw_request_info *info,
+	struct sockaddr *awrq, char *extra)
+{
+	u8 *ap_addr = NULL;
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	ap_addr = awrq->sa_data;
+
+	if (!is_zero_eth_addr(ap_addr)) {
+		if (memcmp(priv->assoc_bssid, ap_addr, 6)) {
+			memcpy(priv->assoc_bssid, ap_addr, 6);
+			priv->ToggalAssociation = false;
+
+			if (!priv->ReAssociationTimeOut.timer_is_canceled)
+				wland_del_timer(&priv->ReAssociationTimeOut);
+			if (priv->StartAssociationTimeOut.timer_is_canceled)
+				wland_mod_timer(&priv->StartAssociationTimeOut,
+					100);
+		} else {
+			if (priv->ReAssociationTimeOut.timer_is_canceled)
+				wland_mod_timer(&priv->StartAssociationTimeOut,
+					100);
+		}
+		priv->assoc_ongoing = true;
+	} else {
+		memcpy(priv->assoc_bssid, ap_addr, 6);
+
+		wland_del_timer(&priv->ReAssociationTimeOut);
+		wland_del_timer(&priv->StartAssociationTimeOut);
+
+		disable_wep(priv);
+		disable_wpa(priv);
+	}
+
+	WLAND_DBG(WEXT, TRACE, "connect mac: " MACDBG "\n",
+		MAC2STRDBG(ap_addr));
+
+	return 0;
+}
+
+static char *translate_scan(wlan_private * priv,
+	struct iw_request_info *info,
+	char *start, char *stop, struct bss_descriptor *bss_desc)
+{
+
+	struct iw_event iwe;	/* Temporary buffer */
+	u8 snr;
+	struct bss_descriptor *bss = bss_desc;
+
+	WLAND_DBG(WEXT, TRACE,
+		"translate_scan, ssid = %s ssi=%d ssid_len=%d \n", bss->ssid,
+		bss->rssi, bss->ssid_len);
+
+	/*
+	 * First entry *MUST* be the BSSID
+	 */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, bss->bssid, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/*
+	 * SSID
+	 */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = bss->ssid_len;
+	start = iwe_stream_add_point(info, start, stop, &iwe, bss->ssid);
+
+	/*
+	 * Mode
+	 */
+	iwe.cmd = SIOCGIWMODE;
+	iwe.u.mode = bss->mode;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+
+	/*
+	 * Frequency
+	 */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = (2412 + 5 * (bss->channel - 1)) * 100000;
+	iwe.u.freq.e = 1;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/*
+	 * Add quality statistics
+	 */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.updated = IW_QUAL_ALL_UPDATED;
+	iwe.u.qual.level = bss->rssi > 127 ? bss->rssi - 271 : bss->rssi - 15;
+
+	snr = iwe.u.qual.level - WLAN_NF_DEFAULT_SCAN_VALUE;
+	iwe.u.qual.qual =
+		(100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - snr) *
+		(15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI - snr))) /
+		(RSSI_DIFF * RSSI_DIFF);
+	if (iwe.u.qual.qual > 100)
+		iwe.u.qual.qual = 100;
+	iwe.u.qual.noise = WLAN_NF_DEFAULT_SCAN_VALUE;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	/*
+	 * Add encryption capability
+	 */
+	iwe.cmd = SIOCGIWENCODE;
+	if (bss->capability & CAPABILITY_PRIVACY) {
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	} else {
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	}
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, bss->ssid);
+
+	memset(&iwe, 0, sizeof(iwe));
+	if (bss_desc->wpa_ie_len && !bss_desc->wapi_ie_len) {
+		char *buf = kmalloc(MAX_WPA_IE_LEN, GFP_ATOMIC);
+		if(buf == NULL) {
+			WLAND_ERR("kmalloc buf failed\n");
+			return -ENOMEM;
+		}
+		WLAND_DBG(WEXT, TRACE,
+			"%02x %02x %02x %02x ... ... %02x %02x %02x %02x\n",
+			bss_desc->wpa_ie[0], bss_desc->wpa_ie[1],
+			bss_desc->wpa_ie[2], bss_desc->wpa_ie[3],
+			bss_desc->wpa_ie[bss_desc->wpa_ie_len - 4],
+			bss_desc->wpa_ie[bss_desc->wpa_ie_len - 3],
+			bss_desc->wpa_ie[bss_desc->wpa_ie_len - 2],
+			bss_desc->wpa_ie[bss_desc->wpa_ie_len - 1]);
+
+		memcpy(buf, bss->wpa_ie, bss->wpa_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = bss_desc->wpa_ie_len;
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		kfree(buf);
+	}
+
+	memset(&iwe, 0, sizeof(iwe));
+
+	if (bss_desc->rsn_ie_len) {
+		char *buf = kmalloc(MAX_WPA_IE_LEN, GFP_ATOMIC);
+		if(buf == NULL) {
+			WLAND_ERR("kmalloc buf failed\n");
+			return -ENOMEM;
+		}
+
+		WLAND_DBG(WEXT, TRACE,
+			"%02x %02x %02x %02x ... ... %02x %02x %02x %02x\n",
+			bss_desc->rsn_ie[0], bss_desc->rsn_ie[1],
+			bss_desc->rsn_ie[2], bss_desc->rsn_ie[3],
+			bss_desc->rsn_ie[bss_desc->rsn_ie_len - 4],
+			bss_desc->rsn_ie[bss_desc->rsn_ie_len - 3],
+			bss_desc->rsn_ie[bss_desc->rsn_ie_len - 2],
+			bss_desc->rsn_ie[bss_desc->rsn_ie_len - 1]);
+
+		memcpy(buf, bss->rsn_ie, bss->rsn_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = bss_desc->rsn_ie_len;
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		kfree(buf);
+	}
+
+	if (bss_desc->wapi_ie_len) {
+		char *buf = NULL;
+		u8 pos = 0;
+		buf = kmalloc(MAX_WPA_IE_LEN, GFP_ATOMIC);
+		if(buf == NULL) {
+			WLAND_ERR("kmalloc buf failed\n");
+			return -ENOMEM;
+		}
+
+		memset(&iwe, 0, sizeof(iwe));
+		WLAND_DBG(WEXT, TRACE,
+			"%02x %02x %02x %02x ... ... %02x %02x %02x %02x\n",
+			bss_desc->wapi_ie[0], bss_desc->wapi_ie[1],
+			bss_desc->wapi_ie[2], bss_desc->wapi_ie[3],
+			bss_desc->wapi_ie[bss_desc->wapi_ie_len - 4],
+			bss_desc->wapi_ie[bss_desc->wapi_ie_len - 3],
+			bss_desc->wapi_ie[bss_desc->wapi_ie_len - 2],
+			bss_desc->wapi_ie[bss_desc->wapi_ie_len - 1]);
+
+		memcpy(buf, "wapi_ie=", 8);
+
+		while (pos < bss_desc->wapi_ie_len) {
+			//transfer hex to ascii string because wpa_supplicant need do so
+			num_2_str(bss_desc->wapi_ie[pos],
+				(unsigned char *) (buf + 8 + 2 * pos));
+			pos++;
+		}
+
+		iwe.cmd = IWEVCUSTOM;
+		iwe.u.data.length = bss_desc->wapi_ie_len * 2 + 8;
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		kfree(buf);
+	}
+
+	return start;
+}
+
+/**
+ *  @brief Handle Scan Network ioctl
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             0 --success, otherwise fail
+ */
+int iwext_set_scan(struct net_device *dev, struct iw_request_info *info,
+	union iwreq_data *wrqu, char *extra)
+{
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	WLAND_DBG(WEXT, TRACE, "scan:%d assoc:%d <<< \n", priv->scan_running,
+		priv->assoc_ongoing);
+
+	if (priv->scan_running == WLAN_SCAN_RUNNING || priv->assoc_ongoing)
+		goto out;
+
+	if (wrqu->data.length == sizeof(struct iw_scan_req)
+		&& wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+		struct iw_scan_req *req = (struct iw_scan_req *) extra;
+
+		priv->scan_ssid_len = req->essid_len > 32 ? 32 : req->essid_len;
+		memcpy(priv->scan_ssid, req->essid, priv->scan_ssid_len);
+		priv->scan_ssid[priv->scan_ssid_len] = '\0';
+	} else {
+		priv->scan_ssid_len = 0;
+		memset(priv->scan_ssid, '\0', sizeof(priv->scan_ssid));
+	}
+
+	priv->scan_running = WLAN_SCAN_RUNNING;
+	ret = wland_start_scan_set(priv, 1);
+	if (!ret) {
+		wland_mod_timer(&priv->ScanResultsTimeout, 1500);
+	} else {
+		priv->scan_running = WLAN_SCAN_IDLE;
+	}
+out:
+
+	WLAND_DBG(WEXT, TRACE, "Done\n");
+	return 0;
+}
+
+/*
+ *  @brief  Handle Retrieve scan table ioctl
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             0 --success, otherwise fail
+ */
+int iwext_get_scan(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *extra)
+{
+#define SCAN_ITEM_SIZE 128
+	wlan_private *priv = (wlan_private *) netdev_priv(dev);
+	int ret = 0;
+
+	struct bss_descriptor *iter_bss;
+	struct bss_descriptor *safe;
+	char *ev = extra;
+	char *stop = ev + dwrq->length;
+	u8 items = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter\n");
+
+	/*
+	 * iwlist should wait until the current scan is finished
+	 */
+	if (priv->scan_running != WLAN_SCAN_COMPLET) {
+		WLAND_DBG(WEXT, TRACE, "Scan is Running, return AGAIN\n");
+		return -EAGAIN;
+	}
+
+	spin_lock(&priv->ScanListLock);
+	/*
+	 * report all bss to upper layer
+	 */
+	list_for_each_entry_safe(iter_bss, safe, &priv->network_list, list) {
+		char *next_ev;
+		ulong stale_time;
+
+		if (stop - ev < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		/*
+		 * Prune old an old scan result
+		 */
+		stale_time = iter_bss->last_scanned + DEFAULT_MAX_SCAN_AGE;
+		if (time_after(jiffies, stale_time)) {
+			list_move_tail(&iter_bss->list,
+				&priv->network_free_list);
+			WLAND_DBG(WEXT, TRACE, "Prune Old Bss %s\n",
+				iter_bss->ssid);
+
+			clear_bss_descriptor(iter_bss);
+			continue;
+		}
+#ifdef WIFI_SELECT_CHANNEL
+		if (iter_bss->channel > channel_nums) {
+			clear_bss_descriptor(iter_bss);
+			continue;
+		}
+#endif
+		/*
+		 * Translate to WE format this entry
+		 */
+		next_ev = translate_scan(priv, info, ev, stop, iter_bss);
+
+		WLAND_DBG(WEXT, TRACE, "Report BSS %s\n", iter_bss->ssid);
+
+		if (next_ev == NULL)
+			continue;
+		ev = next_ev;
+		items++;
+	}
+	spin_unlock(&priv->ScanListLock);
+	dwrq->length = (ev - extra);
+	dwrq->flags = 0;
+
+	if (priv->scan_running != WLAN_SCAN_RUNNING)
+		priv->scan_running = WLAN_SCAN_IDLE;
+
+	WLAND_DBG(WEXT, TRACE, "Done,ap:%d\n", items);
+	return ret;
+}
+
+int iwext_set_mlme(struct net_device *dev, struct iw_request_info *info,
+	union iwreq_data *wrqu, char *extra)
+{
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+	wland_if *ifp = netdev_priv(dev);
+	int ret = 0;
+
+	WLAND_DBG(WEXT, TRACE, "Enter.\n");
+
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+	case IW_MLME_DISASSOC:
+		{
+			u8 ssid[6];
+
+			memset(ssid, 0, 6);
+			WLAND_DBG(WEXT, TRACE, "DISASSOC\n");
+
+			wland_del_timer(&priv->AssociationTimeOut);
+			wland_del_timer(&priv->ReAssociationTimeOut);
+			priv->assoc_ongoing = false;
+
+			/*
+			 * silently ignore
+			 */
+			ret = wland_fil_set_cmd_data(ifp, WID_SSID, ssid,
+				sizeof(ssid));
+			break;
+		}
+
+	default:
+		{
+			WLAND_DBG(WEXT, TRACE, "Not supported cmd %d\n",
+				mlme->cmd);
+			ret = -EOPNOTSUPP;
+			break;
+		}
+	}
+
+	WLAND_DBG(WEXT, TRACE, "Done.\n");
+	return ret;
+}
+
+#define MAX_WX_STRING 80
+
+static int wl_iw_get_macaddr(struct net_device *dev,
+	struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+	char *p = extra;
+	char buf[ETH_ALEN] = { 0 };
+	wlan_private *priv = netdev_priv(dev);
+	int error = wland_fil_get_cmd_data(priv, WID_MAC_ADDR, buf, ETH_ALEN);
+
+	p += snprintf(p, MAX_WX_STRING,
+		"Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n", buf[0], buf[1],
+		buf[2], buf[3], buf[4], buf[5]);
+
+	wrqu->data.length = p - extra + 1;
+
+	return error;
+}
+
+static int iwext_set_priv(struct net_device *dev, struct iw_request_info *info,
+	struct iw_point *dwrq, char *ext)
+{
+	int ret = 0;
+	char *extra;
+
+	if (!(extra = kmalloc(dwrq->length, GFP_KERNEL)))
+		return -ENOMEM;
+
+	if (copy_from_user(extra, dwrq->pointer, dwrq->length)) {
+		kfree(extra);
+		return -EFAULT;
+	}
+
+	if (dwrq->length && extra) {
+		if (strnicmp(extra, "MACADDR", strlen("MACADDR")) == 0) {
+			ret = wl_iw_get_macaddr(dev, info,
+				(union iwreq_data *) dwrq, extra);
+		} else if (strnicmp(extra, "CSCAN", strlen("CSCAN")) == 0) {
+		}
+	}
+
+	if (extra) {
+		if (copy_to_user(dwrq->pointer, extra, dwrq->length))
+			ret = -EFAULT;
+		kfree(extra);
+	}
+
+	return ret;
+}
+
+static int iwext_get_stats(struct net_device *dev, struct iw_request_info *info,
+	u32 * uwrq, char *extra)
+{
+	struct iw_statistics *wstats = (struct iw_statistics *) extra;
+	wlan_private *priv = netdev_priv(dev);
+	int ret = 0;
+
+	int stats_valid = 0;
+	u8 snr;
+
+	WLAND_DBG(WEXT, TRACE, "%s >>>\n", __func__);
+
+	if (priv->connect_status != MAC_CONNECTED)
+		goto out;
+
+	ret = wlan_update_bss_stats(priv);
+	if (ret)
+		goto out;
+
+	wstats->miss.beacon = 0;
+	wstats->discard.retries = 0;
+	wstats->qual.level =
+		priv->curbssparams.rssi >
+		127 ? priv->curbssparams.rssi - 271 : priv->curbssparams.rssi -
+		15;
+
+	snr = wstats->qual.level - WLAN_NF_DEFAULT_SCAN_VALUE;
+
+	wstats->qual.qual =
+		(100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - snr) *
+		(15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI -
+				snr))) / (RSSI_DIFF * RSSI_DIFF);
+
+	if (wstats->qual.qual > 100)
+		wstats->qual.qual = 100;
+
+	wstats->qual.noise = WLAN_NF_DEFAULT_SCAN_VALUE;
+	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+
+	stats_valid = 1;
+
+out:
+	if (!stats_valid) {
+		wstats->miss.beacon = 0;
+		wstats->discard.retries = 0;
+		wstats->qual.qual = 0;
+		wstats->qual.level = 0;
+		wstats->qual.noise = 0;
+		wstats->qual.updated = IW_QUAL_ALL_UPDATED;
+		wstats->qual.updated |=
+			IW_QUAL_NOISE_INVALID | IW_QUAL_QUAL_INVALID |
+			IW_QUAL_LEVEL_INVALID;
+	}
+	return ret;
+}
+
+/*
+ * iwconfig settable callbacks
+ */
+static const iw_handler iwext_handler[] = {
+	(iw_handler) NULL,	/* SIOCSIWCOMMIT */
+	(iw_handler) iwext_get_name,	/* SIOCGIWNAME  */
+	(iw_handler) NULL,	/* SIOCSIWNWID  */
+	(iw_handler) NULL,	/* SIOCGIWNWID  */
+	(iw_handler) iwext_set_freq,	/* SIOCSIWFREQ  */
+	(iw_handler) iwext_get_freq,	/* SIOCGIWFREQ  */
+	(iw_handler) iwext_set_mode,	/* SIOCSIWMODE  */
+	(iw_handler) iwext_get_mode,	/* SIOCGIWMODE  */
+	(iw_handler) NULL,	/* SIOCSIWSENS  */
+	(iw_handler) NULL,	/* SIOCGIWSENS  */
+	(iw_handler) NULL,	/* SIOCSIWRANGE */
+	(iw_handler) iwext_get_range,	/* SIOCGIWRANGE */
+	(iw_handler) iwext_set_priv,	/* SIOCSIWPRIV  */
+	(iw_handler) NULL,	/* SIOCGIWPRIV  */
+	(iw_handler) NULL,	/* SIOCSIWSTATS */
+	(iw_handler) iwext_get_stats,	/* SIOCGIWSTATS */
+	(iw_handler) NULL,	/* SIOCSIWSPY   */
+	(iw_handler) NULL,	/* SIOCGIWSPY   */
+	(iw_handler) NULL,	/* SIOCSIWTHRSPY */
+	(iw_handler) NULL,	/* SIOCGIWTHRSPY */
+	(iw_handler) iwext_set_wap,	/* SIOCSIWAP    */
+	(iw_handler) iwext_get_wap,	/* SIOCGIWAP    */
+	(iw_handler) iwext_set_mlme,	/* SIOCSIWMLME  */
+	(iw_handler) NULL,	/* SIOCGIWAPLIST - deprecated */
+	(iw_handler) iwext_set_scan,	/* SIOCSIWSCAN  */
+	(iw_handler) iwext_get_scan,	/* SIOCGIWSCAN  */
+	(iw_handler) iwext_set_essid,	/* SIOCSIWESSID */
+	(iw_handler) iwext_get_essid,	/* SIOCGIWESSID */
+	(iw_handler) NULL,	/* SIOCSIWNICKN */
+	(iw_handler) NULL,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole --   */
+	(iw_handler) NULL,	/* -- hole --   */
+	(iw_handler) iwext_set_rate,	/* SIOCSIWRATE  */
+	(iw_handler) iwext_get_rate,	/* SIOCGIWRATE  */
+	(iw_handler) iwext_set_rts,	/* SIOCSIWRTS   */
+	(iw_handler) iwext_get_rts,	/* SIOCGIWRTS   */
+	(iw_handler) iwext_set_frag,	/* SIOCSIWFRAG  */
+	(iw_handler) iwext_get_frag,	/* SIOCGIWFRAG  */
+	(iw_handler) iwext_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler) iwext_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler) iwext_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler) iwext_get_retry,	/* SIOCGIWRETRY */
+	(iw_handler) iwext_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler) iwext_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler) iwext_set_power,	/* SIOCSIWPOWER */
+	(iw_handler) iwext_get_power,	/* SIOCGIWPOWER */
+	(iw_handler) NULL,	/* -- hole --   */
+	(iw_handler) NULL,	/* -- hole --   */
+	(iw_handler) iwext_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) iwext_get_genie,	/* SIOCGIWGENIE */
+	(iw_handler) iwext_set_auth,	/* SIOCSIWAUTH  */
+	(iw_handler) iwext_get_auth,	/* SIOCGIWAUTH  */
+	(iw_handler) iwext_set_encodeext,	/* SIOCSIWENCODEEXT */
+	(iw_handler) iwext_get_encodeext,	/* SIOCGIWENCODEEXT */
+	(iw_handler) iwext_set_pmksa,	/* SIOCSIWPMKSA */
+};
+
+struct iw_handler_def wland_iw_handler_def = {
+	.num_standard = ARRAY_SIZE(iwext_handler),
+	.standard = (iw_handler *) iwext_handler,
+	.get_wireless_stats = wland_get_wireless_stats,
+};
+
+int iwext_attach(struct wland_private *drvr, struct device *busdev)
+{
+	return 0;
+}
+
+int iwext_dettach(void)
+{
+	return 0;
+}
+
+#endif /* defined(WL_WIRELESS_EXT) */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.h
new file mode 100644
index 000000000000..56dec842e814
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_iw.h
@@ -0,0 +1,132 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLAND_IW_H_
+#define _WLAND_IW_H_
+
+#include <linux/wireless.h>
+
+#include <proto/ethernet.h>
+#include <wlioctl.h>
+
+#define GET_SSID			        "SSID="
+#define GET_CHANNEL			        "CH="
+#define GET_NPROBE 			        "NPROBE="
+#define GET_ACTIVE_ASSOC_DWELL  	"ACTIVE="
+#define GET_PASSIVE_ASSOC_DWELL  	"PASSIVE="
+#define GET_HOME_DWELL  		    "HOME="
+#define GET_SCAN_TYPE			    "TYPE="
+#define BAND_GET_CMD				"GETBAND"
+#define BAND_SET_CMD				"SETBAND"
+#define DTIM_SKIP_GET_CMD			"DTIMSKIPGET"
+#define DTIM_SKIP_SET_CMD			"DTIMSKIPSET"
+#define SETSUSPEND_CMD				"SETSUSPENDOPT"
+#define PNOSSIDCLR_SET_CMD			"PNOSSIDCLR"
+
+/* Lin - Is the extra space needed? */
+#define PNOSETUP_SET_CMD			"PNOSETUP "	/* TLV command has extra end space */
+#define PNOENABLE_SET_CMD			"PNOFORCE"
+#define PNODEBUG_SET_CMD			"PNODEBUG"
+#define TXPOWER_SET_CMD			    "TXPOWER"
+
+#define MAC2STR(a)                  (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR                      "%02x:%02x:%02x:%02x:%02x:%02x"
+
+/* Structure to keep global parameters */
+typedef struct wl_iw_extra_params {
+	int target_channel;	/* target channel */
+} wl_iw_extra_params_t;
+
+struct cntry_locales_custom {
+	char iso_abbrev[WLC_CNTRY_BUF_SZ];	/* ISO 3166-1 country abbreviation */
+	char custom_locale[WLC_CNTRY_BUF_SZ];	/* Custom firmware locale */
+	int32 custom_locale_rev;	/* Custom local revisin default -1 */
+};
+
+/* ============================================== */
+
+/* Defines from wlc_pub.h */
+#define	WL_IW_RSSI_MINVAL		-200	/* Low value, e.g. for forcing roam */
+#define	WL_IW_RSSI_NO_SIGNAL	-91	/* NDIS RSSI link quality cutoffs */
+#define	WL_IW_RSSI_VERY_LOW	    -80	/* Very low quality cutoffs */
+#define	WL_IW_RSSI_LOW		    -70	/* Low quality cutoffs */
+#define	WL_IW_RSSI_GOOD		    -68	/* Good quality cutoffs */
+#define	WL_IW_RSSI_VERY_GOOD	-58	/* Very good quality cutoffs */
+#define	WL_IW_RSSI_EXCELLENT	-57	/* Excellent quality cutoffs */
+#define	WL_IW_RSSI_INVALID	    0	/* invalid RSSI value */
+#define MAX_WX_STRING           80
+#define SSID_FMT_BUF_LEN	    ((4 * 32) + 1)
+
+#define WL_IW_SET_ACTIVE_SCAN	(SIOCIWFIRSTPRIV+1)
+#define WL_IW_GET_RSSI			(SIOCIWFIRSTPRIV+3)
+#define WL_IW_SET_PASSIVE_SCAN	(SIOCIWFIRSTPRIV+5)
+#define WL_IW_GET_LINK_SPEED	(SIOCIWFIRSTPRIV+7)
+#define WL_IW_GET_CURR_MACADDR	(SIOCIWFIRSTPRIV+9)
+#define WL_IW_SET_STOP			(SIOCIWFIRSTPRIV+11)
+#define WL_IW_SET_START			(SIOCIWFIRSTPRIV+13)
+
+struct wl_iw {
+	char nickname[IW_ESSID_MAX_SIZE];
+	struct iw_statistics wstats;
+	int spy_num;
+	u32 pwsec;		/* pairwise wsec setting */
+	u32 gwsec;		/* group wsec setting  */
+	bool privacy_invoked;	/* IW_AUTH_PRIVACY_INVOKED setting */
+	struct ether_addr spy_addr[IW_MAX_SPY];
+	struct iw_quality spy_qual[IW_MAX_SPY];
+	void *wlinfo;
+};
+
+struct wl_ctrl {
+	struct timer_list *timer;
+	struct net_device *dev;
+	long sysioc_pid;
+	struct semaphore sysioc_sem;
+	struct completion sysioc_exited;
+};
+
+#if WIRELESS_EXT > 12
+#include <net/iw_handler.h>
+extern const struct iw_handler_def wland_iw_handler_def;
+#endif /* WIRELESS_EXT > 12 */
+
+extern int wl_iw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+extern void wl_iw_event(struct net_device *dev, wl_event_msg_t * e, void *data);
+extern int wl_iw_get_wireless_stats(struct net_device *dev,
+	struct iw_statistics *wstats);
+int iwext_attach(struct net_device *dev, void *dhdp);
+int wl_iw_send_priv_event(struct net_device *dev, char *flag);
+
+void iwext_detach(void);
+
+#define CSCAN_COMMAND				    "CSCAN "
+#define CSCAN_TLV_PREFIX 			    'S'
+#define CSCAN_TLV_VERSION			    1
+#define CSCAN_TLV_SUBVERSION			0
+#define CSCAN_TLV_TYPE_SSID_IE          'S'
+#define CSCAN_TLV_TYPE_CHANNEL_IE       'C'
+#define CSCAN_TLV_TYPE_NPROBE_IE        'N'
+#define CSCAN_TLV_TYPE_ACTIVE_IE        'A'
+#define CSCAN_TLV_TYPE_PASSIVE_IE       'P'
+#define CSCAN_TLV_TYPE_HOME_IE          'H'
+#define CSCAN_TLV_TYPE_STYPE_IE         'T'
+
+#define IWE_STREAM_ADD_EVENT(info, stream, ends, iwe, extra)	        iwe_stream_add_event(info, stream, ends, iwe, extra)
+#define IWE_STREAM_ADD_VALUE(info, event, value, ends, iwe, event_len) 	iwe_stream_add_value(info, event, value, ends, iwe, event_len)
+#define IWE_STREAM_ADD_POINT(info, stream, ends, iwe, extra)        	iwe_stream_add_point(info, stream, ends, iwe, extra)
+
+#endif /* _WLAND_IW_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_linux.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_linux.c
new file mode 100644
index 000000000000..b5b5886b2f28
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_linux.c
@@ -0,0 +1,1113 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+#include <wland_android.h>
+
+/* Version string to report */
+#ifndef SRCBASE
+#define SRCBASE        "drivers/net/wireless/rdaw80211"
+#endif
+
+static char wland_ver[] =
+	"Compiled in " SRCBASE " on " __DATE__ " at " __TIME__;
+
+#define MAX_WAIT_FOR_8021X_TX		        50	/* msecs */
+
+char *wland_ifname(struct wland_private *drvr, int ifidx)
+{
+	if (ifidx < 0 || ifidx >= WLAND_MAX_IFS) {
+		WLAND_ERR("ifidx %d out of range\n", ifidx);
+		return "<if_bad>";
+	}
+
+	if (drvr->iflist[ifidx] == NULL) {
+		WLAND_ERR("null i/f %d\n", ifidx);
+		return "<if_null>";
+	}
+
+	return ((drvr->iflist[ifidx]->ndev) ? drvr->iflist[ifidx]->ndev->
+		name : "<if_none>");
+}
+
+struct net_device *dhd_idx2net(void *pub, s32 ifidx)
+{
+	struct wland_private *priv = (struct wland_private *) pub;
+
+	if (!pub || ifidx < 0 || ifidx >= WLAND_MAX_IFS)
+		return NULL;
+
+	if (priv && priv->iflist[ifidx])
+		return priv->iflist[ifidx]->ndev;
+
+	return NULL;
+}
+
+s32 dhd_net2idx(struct wland_private * driv, struct net_device * net)
+{
+	int i = 0;
+
+	ASSERT(driv);
+
+	while (i < WLAND_MAX_IFS) {
+		if (driv->iflist[i] && (driv->iflist[i]->ndev == net))
+			return i;
+		i++;
+	}
+
+	return ALL_INTERFACES;
+}
+
+static void _wland_set_multicast_list(struct work_struct *work)
+{
+	struct wland_if *ifp =
+		container_of(work, struct wland_if, multicast_work);
+	struct net_device *ndev = ifp->ndev;
+
+	struct netdev_hw_addr *ha;
+	u32 cmd_value, cnt, buflen;
+	__le32 cnt_le;
+	char *buf, *bufp;
+	s32 err;
+
+	/*
+	 * Determine initial value of allmulti flag
+	 */
+	cmd_value = (ndev->flags & IFF_ALLMULTI) ? true : false;
+
+	/*
+	 * Send down the multicast list first.
+	 */
+	netif_addr_lock_bh(ndev);
+	cnt = netdev_mc_count(ndev);
+	netif_addr_unlock_bh(ndev);
+
+	buflen = sizeof(cnt) + (cnt * ETH_ALEN);
+	buf = kmalloc(buflen, GFP_ATOMIC);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter(idx:%d,cmd_value:%d,cnt:%d)\n",
+		ifp->bssidx, cmd_value, cnt);
+
+	if (!buf)
+		return;
+
+	bufp = buf;
+	cnt_le = cpu_to_le32(cnt);
+	memcpy(bufp, &cnt_le, sizeof(cnt_le));
+	bufp += sizeof(cnt_le);
+
+	netif_addr_lock_bh(ndev);
+	netdev_for_each_mc_addr(ha, ndev) {
+		if (!cnt)
+			break;
+		memcpy(bufp, ha->addr, ETH_ALEN);
+		bufp += ETH_ALEN;
+		cnt--;
+	}
+
+	netif_addr_unlock_bh(ndev);
+
+	err = wland_fil_iovar_data_set(ifp, "mcast_list", buf, buflen);
+	if (err < 0) {
+		WLAND_ERR("Setting mcast_list failed, %d\n", err);
+		cmd_value = cnt ? true : cmd_value;
+	}
+
+	kfree(buf);
+
+	/*
+	 * Now send the allmulti setting.  This is based on the setting in the
+	 * net_device flags, but might be modified above to be turned on if we
+	 * were trying to set some addresses and dongle rejected it...
+	 */
+	err = wland_fil_iovar_data_set(ifp, "allmulti", &cmd_value,
+		sizeof(cmd_value));
+	if (err < 0)
+		WLAND_ERR("Setting allmulti failed, %d\n", err);
+
+	/*
+	 * Finally, pick up the PROMISC flag
+	 */
+	cmd_value = (ndev->flags & IFF_PROMISC) ? true : false;
+	err = wland_fil_iovar_data_set(ifp, "promisc", &cmd_value,
+		sizeof(cmd_value));
+	if (err < 0)
+		WLAND_ERR("Setting failed,err:%d\n", err);
+}
+
+static void _wland_set_mac_address(struct work_struct *work)
+{
+	s32 err;
+	struct wland_if *ifp =
+		container_of(work, struct wland_if, setmacaddr_work);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx=%d\n", ifp->bssidx);
+
+	err = wland_fil_iovar_data_set(ifp, "cur_etheraddr", ifp->mac_addr,
+		ETH_ALEN);
+	if (err < 0) {
+		WLAND_ERR("Setting cur_etheraddr failed, %d\n", err);
+	} else {
+		WLAND_DBG(DEFAULT, TRACE, "MAC address updated to %pM\n",
+			ifp->mac_addr);
+		memcpy(ifp->ndev->dev_addr, ifp->mac_addr, ETH_ALEN);
+	}
+}
+
+static int netdev_set_mac_address(struct net_device *ndev, void *addr)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct sockaddr *sa = (struct sockaddr *) addr;
+
+	memcpy(&ifp->mac_addr, sa->sa_data, ETH_ALEN);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter %pM\n", sa->sa_data);
+
+	schedule_work(&ifp->setmacaddr_work);
+	return 0;
+}
+
+static void netdev_set_multicast_list(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	schedule_work(&ifp->multicast_work);
+}
+
+int netdev_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	int ret = NETDEV_TX_OK;
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_private *drvr = ifp->drvr;
+	struct ethhdr *eh;
+	struct wland_sdio_dev *sdiodev = drvr->bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, ifp->bssidx=%d, skb->len=%d\n",
+		ifp->bssidx, skb->len);
+
+	/*
+	 * Can the device send data?
+	 */
+	if ((drvr->bus_if->state != WLAND_BUS_DATA) || bus->hang_was_sent) {
+		WLAND_ERR("xmit rejected state=%d\n", drvr->bus_if->state);
+		netif_stop_queue(ndev);
+		dev_kfree_skb(skb);
+		ret = NETDEV_TX_BUSY;
+		goto done;
+	}
+
+	if (!drvr->iflist[ifp->bssidx]) {
+		WLAND_ERR("bad ifidx %d\n", ifp->bssidx);
+		netif_stop_queue(ndev);
+		dev_kfree_skb(skb);
+		ret = NETDEV_TX_BUSY;
+		goto done;
+	}
+	if (check_test_mode()) {
+		WLAND_DBG(DEFAULT, INFO, "WIFI in test mode.\n");
+		dev_kfree_skb(skb);
+		goto done;
+	}
+
+	/*
+	 * Make sure there's enough room for any header
+	 */
+	if (skb_headroom(skb) < drvr->hdrlen) {
+		struct sk_buff *skb2;
+
+		WLAND_DBG(DEFAULT, INFO,
+			"%s: insufficient headroom and realloc skb.\n",
+			wland_ifname(drvr, ifp->bssidx));
+		skb2 = skb_realloc_headroom(skb, drvr->hdrlen);
+		dev_kfree_skb(skb);
+		skb = skb2;
+		if (skb == NULL) {
+			WLAND_ERR("%s: skb_realloc_headroom failed\n",
+				wland_ifname(drvr, ifp->bssidx));
+			ret = -ENOMEM;
+			goto done;
+		}
+	}
+
+	/*
+	 * validate length for ether packet
+	 */
+	if (skb->len < sizeof(*eh)) {
+		WLAND_ERR("validate length for ether packet!\n");
+		ret = -EINVAL;
+		dev_kfree_skb(skb);
+		goto done;
+	}
+
+	ret = wland_sendpkt(ifp, skb);
+
+done:
+	if (ret < 0) {
+		ifp->stats.tx_dropped++;
+	} else {
+		ifp->stats.tx_packets++;
+		ifp->stats.tx_bytes += skb->len;
+	}
+
+	/*
+	 * Return ok: we always eat the packet
+	 */
+	return NETDEV_TX_OK;
+}
+
+static struct net_device_stats *netdev_get_stats(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	if (ifp == NULL) {
+		WLAND_ERR("BAD_IF\n");
+		return NULL;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "Done, idx:%d\n", ifp->bssidx);
+
+	return &ifp->stats;
+}
+
+static void ethtool_get_drvinfo(struct net_device *ndev,
+	struct ethtool_drvinfo *info)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_private *drvr = ifp->drvr;
+
+	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
+	snprintf(info->version, sizeof(info->version), "%d", drvr->drv_version);
+	strlcpy(info->bus_info, dev_name(drvr->bus_if->dev),
+		sizeof(info->bus_info));
+}
+
+static const struct ethtool_ops wland_ethtool_ops = {
+	.get_drvinfo = ethtool_get_drvinfo,
+};
+
+static int wland_ethtool(struct wland_if *ifp, void __user * uaddr)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct ethtool_drvinfo info;
+	char drvname[sizeof(info.driver)];
+	u32 cmd;
+	struct ethtool_value edata;
+	u32 toe_cmpnt, csum_dir;
+	int ret;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx=%d\n", ifp->bssidx);
+
+	/*
+	 * all ethtool calls start with a cmd word
+	 */
+	if (copy_from_user(&cmd, uaddr, sizeof(u32)))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GDRVINFO:
+		/*
+		 * Copy out any request driver name
+		 */
+		if (copy_from_user(&info, uaddr, sizeof(info)))
+			return -EFAULT;
+		strncpy(drvname, info.driver, sizeof(info.driver));
+		drvname[sizeof(info.driver) - 1] = '\0';
+
+		/*
+		 * clear struct for return
+		 */
+		memset(&info, 0, sizeof(info));
+		info.cmd = cmd;
+
+		/*
+		 * if requested, identify ourselves
+		 */
+		if (strcmp(drvname, "?dhd") == 0) {
+			sprintf(info.driver, "dhd");
+			strcpy(info.version, WLAND_VERSION_STR);
+		}
+		/*
+		 * report dongle driver type
+		 */
+		else {
+			sprintf(info.driver, "wl");
+		}
+
+		sprintf(info.version, "%d", drvr->drv_version);
+
+		if (copy_to_user(uaddr, &info, sizeof(info)))
+			return -EFAULT;
+		WLAND_DBG(DEFAULT, TRACE, "given %*s, returning %s\n",
+			(int) sizeof(drvname), drvname, info.driver);
+		break;
+
+		/*
+		 * Get toe offload components from dongle
+		 */
+	case ETHTOOL_GRXCSUM:
+	case ETHTOOL_GTXCSUM:
+		ret = wland_fil_iovar_data_get(ifp, "toe_ol", &toe_cmpnt,
+			sizeof(toe_cmpnt));
+		if (ret < 0)
+			return ret;
+
+		csum_dir = (cmd == ETHTOOL_GTXCSUM) ?
+			TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;
+
+		edata.cmd = cmd;
+		edata.data = (toe_cmpnt & csum_dir) ? 1 : 0;
+
+		if (copy_to_user(uaddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		break;
+
+		/*
+		 * Set toe offload components in dongle
+		 */
+	case ETHTOOL_SRXCSUM:
+	case ETHTOOL_STXCSUM:
+		if (copy_from_user(&edata, uaddr, sizeof(edata)))
+			return -EFAULT;
+
+		/*
+		 * Read the current settings, update and write back
+		 */
+		ret = wland_fil_iovar_data_get(ifp, "toe_ol", &toe_cmpnt,
+			sizeof(toe_cmpnt));
+		if (ret < 0)
+			return ret;
+
+		csum_dir = (cmd == ETHTOOL_STXCSUM) ?
+			TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;
+
+		if (edata.data != 0)
+			toe_cmpnt |= csum_dir;
+		else
+			toe_cmpnt &= ~csum_dir;
+
+		/*
+		 * If setting TX checksum mode, tell Linux the new mode
+		 */
+		if (cmd == ETHTOOL_STXCSUM) {
+			if (edata.data)
+				ifp->ndev->features |= NETIF_F_IP_CSUM;
+			else
+				ifp->ndev->features &= ~NETIF_F_IP_CSUM;
+		}
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int netdev_ioctl_entry(struct net_device *ndev, struct ifreq *ifr,
+	int cmd)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_private *drvr = ifp->drvr;
+	int ret = 0;
+
+	/*
+	 * bt wifi coexist
+	 */
+	static int bt_state = 0;
+	int state = 0, old_state = 0;
+	struct pta_param_s pta_param;
+
+	/*
+	 * bt wifi coexist
+	 */
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx=%d, cmd=0x%x\n", ifp->bssidx,
+		cmd);
+
+#ifdef WLAND_WEXT_SUPPORT
+	/*
+	 * linux wireless extensions
+	 */
+	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
+		/*
+		 * may recurse, do NOT lock
+		 */
+		ret = wland_iw_ioctl(ndev, ifr, cmd);
+		return ret;
+	}
+#endif /* WLAND_WEXT_SUPPORT */
+
+	if (cmd == SIOCETHTOOL) {
+		ret = wland_ethtool(ifp, ifr->ifr_data);
+		return ret;
+	}
+
+	/*
+	 * linux wireless extensions
+	 */
+	if (cmd == SIOCDEVPRIVATE + 1) {
+		ret = wland_android_priv_cmd(ndev, ifr, cmd);
+		//dhd_check_hang(net, &dhd->pub, ret);
+		return ret;
+	}
+#if 0
+	if (cmd != SIOCDEVPRIVATE) {
+		dhd_os_wake_unlock(bus);
+		return -EOPNOTSUPP;
+	}
+#endif
+
+	if ((drvr->bus_if->chip != WLAND_VER_91_E) && (drvr->bus_if->chip != WLAND_VER_91_G))
+		goto out;
+
+	if (cmd == BT_COEXIST) {
+		state = ifr->ifr_metric;
+		ret = 0;
+
+		pta_param.prot_mode = PTA_NONE_PROTECT;
+		pta_param.mac_rate = 0x0;
+		pta_param.hw_retry = 0x7;
+		pta_param.sw_retry = 0x3;
+		pta_param.cca_bypass = TRUE;
+		pta_param.active_time = 500;	/* Unit is 100us */
+		pta_param.thresh_time = 20;	/* Unit is 100us */
+		pta_param.auto_prot_thresh_time = 200;	/* Unit is 100us */
+		pta_param.flags = BIT0 | BIT1 | BIT5;
+		pta_param.listen_interval = 0x06;
+
+		if (state == BT_STATE_SCO_ONGOING) {
+			state = BT_STATE_SCO_ON;
+		}
+
+		old_state = bt_state;
+
+		if (state & (BT_STATE_SCO_ON | BT_STATE_SCO_ONGOING)) {
+			bt_state |= BT_STATE_SCO_ON;
+		}
+		if (state & BT_STATE_A2DP_PLAYING) {
+			bt_state |= BT_STATE_A2DP_PLAYING;
+		}
+		if (state & BT_STATE_CONNECTION_ON)
+			bt_state |= BT_STATE_CONNECTION_ON;
+
+		if (state == BT_STATE_SCO_OFF) {
+			bt_state &= ~BT_STATE_SCO_ON;
+		} else if (state == BT_STATE_A2DP_NO_PLAYING) {
+			bt_state &= ~BT_STATE_A2DP_PLAYING;
+		} else if (state == BT_STATE_CONNECTION_OFF)
+			bt_state &= ~BT_STATE_CONNECTION_ON;
+
+		if (old_state == bt_state)
+			goto out;
+
+		if (bt_state) {
+			if (bt_state & BT_STATE_SCO_ON) {
+				if (old_state)	//should clear pta proc before to set a new pta protec
+					ret = wland_fil_set_cmd_data(ifp,
+						WID_PTA_PARAMETER, &pta_param,
+						sizeof(struct pta_param_s));
+				pta_param.prot_mode = PTA_PS_POLL_PROTECT;
+				pta_param.mac_rate = 0x4;
+				pta_param.hw_retry = 0x1;
+				pta_param.sw_retry = 0x1;
+				pta_param.active_time = 25;
+				pta_param.thresh_time = 5;
+				pta_param.auto_prot_thresh_time = 15;
+				pta_param.flags = BIT0 | BIT1 | BIT5;
+				pta_param.listen_interval = 0x14;
+			} else if (bt_state & BT_STATE_A2DP_PLAYING) {
+				if (old_state)
+					ret = wland_fil_set_cmd_data(ifp,
+						WID_PTA_PARAMETER, &pta_param,
+						sizeof(struct pta_param_s));
+				pta_param.prot_mode = PTA_NULL_DATA_PROTECT;
+				pta_param.active_time = 800;
+				pta_param.thresh_time = 50;
+				pta_param.auto_prot_thresh_time = 100;
+				pta_param.sw_retry = 0x2;
+			} else if (bt_state & BT_STATE_CONNECTION_ON) {
+				if (old_state)
+					ret = wland_fil_set_cmd_data(ifp,
+						WID_PTA_PARAMETER, &pta_param,
+						sizeof(struct pta_param_s));
+				if(drvr->bus_if->chip == WLAND_VER_91_E)
+					pta_param.prot_mode = PTA_SELF_CTS_PROTECT;
+				else if(drvr->bus_if->chip == WLAND_VER_91_G)
+					pta_param.prot_mode = PTA_SELF_CTS_PROTECT;
+				pta_param.active_time = 1000;
+				pta_param.thresh_time = 100;
+				pta_param.auto_prot_thresh_time = 200;
+			}
+		} else {
+			pta_param.prot_mode = PTA_NONE_PROTECT;
+		}
+		ret = wland_fil_set_cmd_data(ifp, WID_PTA_PARAMETER, &pta_param,
+			sizeof(struct pta_param_s));
+		WLAND_DBG(DEFAULT, INFO, "***BT_COEXIST state:%x \n", bt_state);
+
+	}
+
+out:
+	WLAND_DBG(DEFAULT, TRACE, "Done.\n");
+
+	return ret;
+}
+
+static int netdev_stop(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx=%d\n", ifp->bssidx);
+
+	/*
+	 * Set state and stop OS transmissions
+	 */
+	if (!netif_queue_stopped(ndev)) {
+		netif_stop_queue(ndev);
+		WLAND_DBG(DEFAULT, TRACE, "netif_stop_queue(ndev)\n");
+	}
+	if (netif_carrier_ok(ndev)) {
+		netif_carrier_off(ndev);
+		WLAND_DBG(DEFAULT, TRACE, "netif_carrier_off(ndev)\n");
+	}
+
+	wland_cfg80211_down(ndev);
+
+	return 0;
+}
+
+static int netdev_open(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_bus *bus_if = drvr->bus_if;
+
+#ifdef WLAND_TBD_SUPPORT
+	u32 toe_ol;
+#endif /*WLAND_TBD_SUPPORT */
+	s32 ret = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx=%d\n", ifp->bssidx);
+
+	/*
+	 * If bus is not ready, can't continue
+	 */
+	if (bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("failed bus is not ready\n");
+		return -EAGAIN;
+	}
+
+	atomic_set(&ifp->pend_8021x_cnt, 0);
+
+#ifdef WLAND_TBD_SUPPORT
+	/*
+	 * Get current TOE mode from dongle
+	 */
+	if (wland_fil_iovar_data_get(ifp, "toe_ol", &toe_ol,
+			sizeof(toe_ol)) >= 0 && (toe_ol & TOE_TX_CSUM_OL) != 0)
+		ndev->features |= NETIF_F_IP_CSUM;
+	else
+		ndev->features &= ~NETIF_F_IP_CSUM;
+#endif /*WLAND_TBD_SUPPORT */
+
+	if (wland_cfg80211_up(ndev) < 0) {
+		WLAND_ERR("failed to bring up cfg80211\n");
+		ret = -ENODEV;
+	}
+
+	/*
+	 * Allow transmit calls
+	 */
+	if (!ret) {
+		netif_carrier_on(ndev);
+		WLAND_DBG(DEFAULT, TRACE, "netif_carrier_on(ndev)\n");
+		netif_start_queue(ndev);
+		WLAND_DBG(DEFAULT, TRACE, "netif_start_queue(ndev)\n");
+	}
+
+	return ret;
+}
+
+static void netdev_tx_timeout(struct net_device *dev)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	dev->trans_start = jiffies;	/* prevent tx timeout */
+	netif_wake_queue(dev);
+	dev->stats.tx_errors++;
+
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
+
+static const struct net_device_ops wland_netdev_ops_pri = {
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_stop,
+	.ndo_get_stats = netdev_get_stats,
+	.ndo_do_ioctl = netdev_ioctl_entry,
+	.ndo_start_xmit = netdev_start_xmit,
+	.ndo_tx_timeout = netdev_tx_timeout,
+	.ndo_set_mac_address = netdev_set_mac_address,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
+	.ndo_set_rx_mode = netdev_set_multicast_list,
+#else /*(LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)) */
+	.ndo_set_multicast_list = netdev_set_multicast_list,
+#endif /*(LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)) */
+};
+
+int netdev_attach(struct wland_if *ifp)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct net_device *ndev = ifp->ndev;
+	s32 err = 0;
+
+	/*
+	 * set appropriate operations
+	 */
+	ndev->netdev_ops = &wland_netdev_ops_pri;
+
+	ndev->hard_header_len += drvr->hdrlen;
+	ndev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+
+	ndev->ethtool_ops = &wland_ethtool_ops;
+
+#ifdef WLAND_WEXT_SUPPORT
+#if WIRELESS_EXT < 19
+	ndev->get_wireless_stats = wland_get_wireless_stats;
+#endif /* WIRELESS_EXT < 19 */
+#if WIRELESS_EXT > 12
+	ndev->wireless_handlers =
+		(struct iw_handler_def *) &wland_iw_handler_def;
+#endif /* WIRELESS_EXT > 12 */
+#endif /* WLAND_WEXT_SUPPORT */
+
+	/*
+	 * set the mac address
+	 */
+	memcpy(ndev->dev_addr, ifp->mac_addr, ETH_ALEN);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter,(%s:idx:%d,ifidx:0x%x)\n", ndev->name,
+		ifp->bssidx, ifp->ifidx);
+
+	err = register_netdev(ndev);
+	if (err != 0) {
+		WLAND_ERR("couldn't register the net device\n");
+		goto fail;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE,
+		"%s: Rdamicro Host Driver(mac:%pM,ndevmtu:0x%x)\n", ndev->name,
+		ndev->dev_addr, ndev->mtu);
+
+	INIT_WORK(&ifp->setmacaddr_work, _wland_set_mac_address);
+	INIT_WORK(&ifp->multicast_work, _wland_set_multicast_list);
+
+	ndev->destructor = free_netdev;
+	return 0;
+
+fail:
+	drvr->iflist[ifp->bssidx] = NULL;
+	ndev->netdev_ops = NULL;
+	free_netdev(ndev);
+	return -EBADE;
+}
+
+#ifdef WLAND_P2P_SUPPORT
+static int netdev_p2p_open(struct net_device *ndev)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	return wland_cfg80211_up(ndev);
+}
+
+static int netdev_p2p_stop(struct net_device *ndev)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	return wland_cfg80211_down(ndev);
+}
+
+static int netdev_p2p_do_ioctl(struct net_device *ndev, struct ifreq *ifr,
+	int cmd)
+{
+	int ret = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	/*
+	 * There is no ifidx corresponding to p2p0 in our firmware. So we should
+	 * * not Handle any IOCTL cmds on p2p0 other than ANDROID PRIVATE CMDs.
+	 * * For Android PRIV CMD handling map it to primary I/F
+	 */
+	if (cmd == SIOCDEVPRIVATE + 1) {
+		ret = wland_android_priv_cmd(ndev, ifr, cmd);
+	} else {
+		WLAND_ERR("IOCTL req 0x%x on p2p0 I/F. Ignoring. \n", cmd);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static netdev_tx_t netdev_p2p_start_xmit(struct sk_buff *skb,
+	struct net_device *ndev)
+{
+	if (skb)
+		dev_kfree_skb_any(skb);
+
+	WLAND_DBG(DEFAULT, TRACE,
+		"(%s) is not used for data operations.Droping the packet.\n",
+		ndev->name);
+
+	/*
+	 * Return ok: we always eat the packet
+	 */
+	return NETDEV_TX_OK;
+}
+
+static const struct net_device_ops wland_netdev_ops_p2p = {
+	.ndo_open = netdev_p2p_open,
+	.ndo_stop = netdev_p2p_stop,
+	.ndo_do_ioctl = netdev_p2p_do_ioctl,
+	.ndo_start_xmit = netdev_p2p_start_xmit
+};
+
+static void cfgp2p_ethtool_get_drvinfo(struct net_device *net,
+	struct ethtool_drvinfo *info)
+{
+	snprintf(info->driver, sizeof(info->driver), "p2p");
+	snprintf(info->version, sizeof(info->version), "%lu", (ulong) (0));
+}
+
+struct ethtool_ops cfgp2p_ethtool_ops = {
+	.get_drvinfo = cfgp2p_ethtool_get_drvinfo
+};
+
+/* register "p2p0" interface */
+int netdev_p2p_attach(struct wland_if *ifp)
+{
+	struct net_device *ndev = ifp->ndev;
+
+	if (!ndev) {
+		WLAND_ERR("p2p net device is empty\n");
+		return -EBADE;
+	}
+	ndev->netdev_ops = &wland_netdev_ops_p2p;
+	ndev->ethtool_ops = &cfgp2p_ethtool_ops;
+
+	/*
+	 * set the mac address
+	 */
+	memcpy(ndev->dev_addr, ifp->mac_addr, ETH_ALEN);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter(idx:%d,mac:%pM)\n", ifp->bssidx,
+		ifp->mac_addr);
+
+	if (register_netdev(ndev)) {
+		WLAND_ERR("couldn't register the p2p net device\n");
+		goto fail;
+	}
+	WLAND_DBG(DEFAULT, TRACE, "Done(%s: Rdamicro Host Driver For P2P0)\n",
+		ndev->name);
+
+	return 0;
+fail:
+	ifp->drvr->iflist[ifp->bssidx] = NULL;
+	ndev->netdev_ops = NULL;
+	free_netdev(ndev);
+	return -EBADE;
+}
+#endif /* WLAND_P2P_SUPPORT */
+
+struct wland_if *wland_add_if(struct wland_private *drvr, s32 bssidx, s32 ifidx,
+	char *name, u8 * mac_addr)
+{
+	struct net_device *ndev;
+	struct wland_if *ifp = drvr->iflist[bssidx];
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, idx:%d, ifidx:%d.\n", bssidx, ifidx);
+
+	if (!(drvr && (bssidx < WLAND_MAX_IFS))) {
+		WLAND_ERR("private not setup!\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	/*
+	 * Delete the existing interface before overwriting it in case we missed the WLAND_E_IF_DEL event.
+	 */
+	if (ifp) {
+		WLAND_ERR("netname:%s,netdev:%p,ifidx:%d,already exists\n",
+			ifp->ndev->name, ifp->ndev, ifidx);
+
+		if (ifidx) {
+			if (ifp->ndev) {
+				netif_stop_queue(ifp->ndev);
+				unregister_netdev(ifp->ndev);
+				free_netdev(ifp->ndev);
+				drvr->iflist[bssidx] = NULL;
+			}
+		} else {
+			WLAND_ERR("ignore IF event\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "drvr->p2p_enable:%d,bssidx:%d\n",
+		drvr->p2p_enable, bssidx);
+
+	if (!drvr->p2p_enable && bssidx == 1) {
+		/*
+		 * this is P2P_DEVICE interface
+		 */
+		WLAND_DBG(DEFAULT, TRACE, "allocate non-netdev interface\n");
+		ifp = kzalloc(sizeof(struct wland_if), GFP_KERNEL);
+		if (!ifp)
+			return ERR_PTR(-ENOMEM);
+		memset(ifp, '\0', sizeof(struct wland_if));
+	} else {
+		WLAND_DBG(DEFAULT, TRACE, "allocate netdev interface\n");
+		/*
+		 * Allocate netdev, including space for private structure
+		 */
+		ndev = alloc_netdev(sizeof(struct wland_if), name, ether_setup);
+		if (!ndev)
+			return ERR_PTR(-ENOMEM);
+
+		ndev->netdev_ops = NULL;
+
+		ifp = netdev_priv(ndev);
+		ifp->ndev = ndev;
+	}
+
+	ifp->drvr = drvr;
+	ifp->ifidx = ifidx;
+	ifp->bssidx = bssidx;
+
+	drvr->iflist[bssidx] = ifp;
+
+	init_waitqueue_head(&ifp->pend_8021x_wait);
+
+	spin_lock_init(&ifp->netif_stop_lock);
+
+	if (mac_addr)
+		memcpy(ifp->mac_addr, mac_addr, ETH_ALEN);
+
+	WLAND_DBG(DEFAULT, TRACE, "Done, pid:%x, if:%s (%pM) created ===\n",
+		current->pid, ifp->ndev->name, ifp->mac_addr);
+
+	return ifp;
+}
+
+void wland_del_if(struct wland_private *drvr, s32 bssidx)
+{
+	struct wland_if *ifp = drvr->iflist[bssidx];
+
+	if (!ifp) {
+		WLAND_ERR("Null interface,idx:%d\n", bssidx);
+		return;
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter,idx:%d,ifidx:%d,ndev:%p.\n", bssidx,
+		ifp->ifidx, ifp->ndev);
+
+	if (ifp->ndev) {
+		if (bssidx == 0) {
+			if (ifp->ndev->netdev_ops == &wland_netdev_ops_pri) {
+				WLAND_DBG(DEFAULT, TRACE,
+					"wlan0 interface ops.\n");
+
+				if (!rtnl_is_locked())
+					rtnl_lock();
+				netdev_stop(ifp->ndev);
+				if (rtnl_is_locked())
+					rtnl_unlock();
+			}
+		} else {
+			WLAND_DBG(DEFAULT, TRACE, "stop netdev:%p.\n",
+				ifp->ndev);
+			netif_stop_queue(ifp->ndev);
+		}
+
+		if (ifp->ndev->netdev_ops == &wland_netdev_ops_pri) {
+			cancel_work_sync(&ifp->setmacaddr_work);
+			cancel_work_sync(&ifp->multicast_work);
+		}
+
+		/*
+		 * unregister will take care of freeing it
+		 */
+		WLAND_DBG(DEFAULT, TRACE, "detach netdev:%p.\n", ifp->ndev);
+
+		unregister_netdev(ifp->ndev);
+		drvr->iflist[bssidx] = NULL;
+		if (bssidx == 0 && drvr->config && !IS_ERR(drvr->config))
+			cfg80211_detach(drvr->config);
+	} else {
+		drvr->iflist[bssidx] = NULL;
+		kfree(ifp);
+	}
+}
+
+int wland_netdev_wait_pend8021x(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	int err = wait_event_timeout(ifp->pend_8021x_wait,
+		!atomic_read(&ifp->pend_8021x_cnt),
+		msecs_to_jiffies(MAX_WAIT_FOR_8021X_TX));
+
+	WARN_ON(!err);
+
+	return !err;
+}
+
+/* Module Entery For Linux OS */
+static void wland_driver_init(struct work_struct *work)
+{
+#ifdef WLAND_SDIO_SUPPORT
+	wland_sdio_register();
+#endif /* WLAND_SDIO_SUPPORT */
+#ifdef WLAND_USB_SUPPORT
+	wland_usb_register();
+#endif /* WLAND_USB_SUPPORT  */
+}
+
+static DECLARE_WORK(wland_driver_work, wland_driver_init);
+
+struct semaphore registration_sem;
+bool registration_check = false;
+
+/* msec : allowed time to finished dhd registration */
+#define REGISTRATION_TIMEOUT                     9000
+
+void wland_registration_sem_up(bool check_flag)
+{
+	registration_check = check_flag;
+	up(&registration_sem);
+}
+
+#define INSMOD_TEST 1
+
+static int wlanfmac_module_init(void)
+{
+	WLAND_DBG(DEFAULT, TRACE, "%s.\n", wland_ver);
+	WLAND_DBG(DEFAULT, TRACE, "Ver: %d.%d.%d.\n", WLAND_VER_MAJ,
+		WLAND_VER_MIN, WLAND_VER_BLD);
+
+	sema_init(&registration_sem, 0);
+
+#ifdef INSMOD_TEST
+	rda_wifi_power_on();
+#endif /*INSMOD_TEST */
+
+	wland_debugfs_init();
+
+	if (!schedule_work(&wland_driver_work))
+		return -EBUSY;
+
+	/*
+	 * Wait till MMC sdio_register_driver callback called and made driver attach.
+	 * It's needed to make sync up exit from dhd insmod and Kernel MMC sdio device callback registration
+	 */
+	if ((down_timeout(&registration_sem,
+				msecs_to_jiffies(REGISTRATION_TIMEOUT)) != 0)
+		|| (!registration_check )) {
+		WLAND_ERR("sdio_register_driver timeout or error\n");
+		cancel_work_sync(&wland_driver_work);
+
+#ifdef WLAND_SDIO_SUPPORT
+		wland_sdio_exit();
+#endif /* WLAND_SDIO_SUPPORT */
+
+#ifdef WLAND_USB_SUPPORT
+		wland_usb_exit();
+#endif /*WLAND_USB_SUPPORT */
+
+		wland_debugfs_exit();
+
+#ifdef INSMOD_TEST
+		rda_wifi_power_off();
+#endif /* INSMOD_TEST */
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit wlanfmac_module_exit(void)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	cancel_work_sync(&wland_driver_work);
+
+#ifdef WLAND_SDIO_SUPPORT
+	wland_sdio_exit();
+#endif /* WLAND_SDIO_SUPPORT */
+
+#ifdef WLAND_USB_SUPPORT
+	wland_usb_exit();
+#endif /*WLAND_USB_SUPPORT */
+
+	wland_debugfs_exit();
+
+#ifdef INSMOD_TEST
+	rda_wifi_power_off();
+#endif /* INSMOD_TEST */
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
+
+void rda_wland_shutdown(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	cancel_work_sync(&wland_driver_work);
+	wland_sdio_release(sdiodev->bus);
+	wland_debugfs_exit();
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+}
+
+late_initcall(wlanfmac_module_init);
+module_exit(wlanfmac_module_exit);
+
+MODULE_AUTHOR("RdaMicro Corporation,BoChen");
+MODULE_DESCRIPTION("RdaMicro 802.11 Wireless LAN FullMac Driver.");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_linux_mon.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_linux_mon.c
new file mode 100644
index 000000000000..e5982bdf43f3
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_linux_mon.c
@@ -0,0 +1,400 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <linux/rtnetlink.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+#include <net/netlink.h>
+#include <net/ieee80211_radiotap.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+#ifdef WLAND_MONITOR_SUPPORT
+
+enum monitor_states {
+	MONITOR_STATE_DEINIT = 0x0,
+	MONITOR_STATE_INIT = 0x1,
+	MONITOR_STATE_INTERFACE_ADDED = 0x2,
+	MONITOR_STATE_INTERFACE_DELETED = 0x4
+};
+
+typedef struct monitor_interface {
+	int radiotap_enabled;
+	struct net_device *real_ndev;	/* The real interface that the monitor is on */
+	struct net_device *mon_ndev;
+} monitor_interface;
+
+struct wland_linux_monitor {
+	void *pub;
+	enum monitor_states monitor_state;
+	struct monitor_interface mon_if[WLAND_MAX_IFS];
+	struct mutex lock;	/* lock to protect mon_if */
+};
+
+static struct wland_linux_monitor g_monitor;
+
+extern int netdev_start_xmit(struct sk_buff *skb, struct net_device *net);
+
+/* Look up dhd's net device table to find a match (e.g. interface "eth0" is a match for "mon.eth0"
+ * "p2p-eth0-0" is a match for "mon.p2p-eth0-0")
+ */
+static struct net_device *lookup_real_netdev(char *name)
+{
+	struct net_device *ndev_found = NULL;
+	struct net_device *ndev;
+	int i, len = 0, last_name_len = 0;
+
+	/*
+	 * We need to find interface "p2p-p2p-0" corresponding to monitor interface "mon-p2p-0",
+	 * * Once mon iface name reaches IFNAMSIZ, it is reset to p2p0-0 and corresponding mon
+	 * * iface would be mon-p2p0-0.
+	 */
+	for (i = 0; i < WLAND_MAX_IFS; i++) {
+		ndev = dhd_idx2net(g_monitor.pub, i);
+
+		/*
+		 * Skip "p2p" and look for "-p2p0-x" in monitor interface name. If it
+		 * * it matches, then this netdev is the corresponding real_netdev.
+		 */
+		if (ndev && strstr(ndev->name, "p2p-p2p0")) {
+			len = strlen("p2p");
+		} else {
+			/*
+			 * if p2p- is not present, then the IFNAMSIZ have reached and name
+			 * * would have got reset. In this casse,look for p2p0-x in mon-p2p0-x
+			 */
+			len = 0;
+		}
+		if (ndev && strstr(name, (ndev->name + len))) {
+			if (strlen(ndev->name) > last_name_len) {
+				ndev_found = ndev;
+				last_name_len = strlen(ndev->name);
+			}
+		}
+	}
+
+	return ndev_found;
+}
+
+static monitor_interface *ndev_to_monif(struct net_device *ndev)
+{
+	int i;
+
+	for (i = 0; i < WLAND_MAX_IFS; i++) {
+		if (g_monitor.mon_if[i].mon_ndev == ndev)
+			return &g_monitor.mon_if[i];
+	}
+
+	return NULL;
+}
+
+static int mon_if_open(struct net_device *ndev)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int mon_if_stop(struct net_device *ndev)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	return 0;
+}
+
+static int mon_if_subif_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	int rtap_len, qos_len = 0, dot11_hdr_len = 24, snap_len = 6;
+	u8 *pdata;
+	u16 frame_ctl;
+	u8 src_mac_addr[6];
+	u8 dst_mac_addr[6];
+	struct ieee80211_hdr *dot11_hdr;
+	struct ieee80211_radiotap_header *rtap_hdr;
+	struct monitor_interface *mon_if;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	mon_if = ndev_to_monif(ndev);
+
+	if (mon_if == NULL || mon_if->real_ndev == NULL) {
+		WLAND_ERR("cannot find matched net dev, skip the packet\n");
+		goto fail;
+	}
+
+	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
+		goto fail;
+
+	rtap_hdr = (struct ieee80211_radiotap_header *) skb->data;
+	if (unlikely(rtap_hdr->it_version))
+		goto fail;
+
+	rtap_len = ieee80211_get_radiotap_len(skb->data);
+	if (unlikely(skb->len < rtap_len))
+		goto fail;
+
+	WLAND_DBG(DEFAULT, TRACE, "radiotap len (should be 14): %d\n",
+		rtap_len);
+
+	/*
+	 * Skip the ratio tap header
+	 */
+	PKTPULL(NULL, skb, rtap_len);
+
+	dot11_hdr = (struct ieee80211_hdr *) skb->data;
+	frame_ctl = le16_to_cpu(dot11_hdr->frame_control);
+
+	/*
+	 * Check if the QoS bit is set
+	 */
+	if ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {
+		/*
+		 * Check if this ia a Wireless Distribution System (WDS) frame which has 4 MAC addresses
+		 */
+		if (dot11_hdr->frame_control & 0x0080)
+			qos_len = 2;
+		if ((dot11_hdr->frame_control & 0x0300) == 0x0300)
+			dot11_hdr_len += 6;
+
+		memcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));
+		memcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));
+
+		/*
+		 * Skip the 802.11 header, QoS (if any) and SNAP, but leave spaces for for two MAC addresses
+		 */
+		PKTPULL(NULL, skb,
+			dot11_hdr_len + qos_len + snap_len -
+			sizeof(src_mac_addr) * 2);
+		pdata = (unsigned char *) skb->data;
+		memcpy(pdata, dst_mac_addr, sizeof(dst_mac_addr));
+		memcpy(pdata + sizeof(dst_mac_addr), src_mac_addr,
+			sizeof(src_mac_addr));
+		PKTSETPRIO(skb, 0);
+
+		WLAND_DBG(DEFAULT, TRACE, "if name: %s, matched if name: %s.\n",
+			ndev->name, mon_if->real_ndev->name);
+
+		/*
+		 * Use the real net device to transmit the packet
+		 */
+		return netdev_start_xmit(skb, mon_if->real_ndev);
+	}
+fail:
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static void mon_if_set_multicast_list(struct net_device *ndev)
+{
+	monitor_interface *mon_if = ndev_to_monif(ndev);
+
+	if (mon_if == NULL || mon_if->real_ndev == NULL) {
+		WLAND_ERR("cannot find matched net dev, skip the packet\n");
+	} else {
+		WLAND_DBG(DEFAULT, TRACE,
+			"Enter, if name: %s, matched if name %s\n", ndev->name,
+			mon_if->real_ndev->name);
+	}
+}
+
+static int mon_if_change_mac(struct net_device *ndev, void *addr)
+{
+	monitor_interface *mon_if = ndev_to_monif(ndev);
+
+	if (mon_if == NULL || mon_if->real_ndev == NULL) {
+		WLAND_ERR("cannot find matched net dev, skip the packet\n");
+	} else {
+		WLAND_DBG(DEFAULT, TRACE,
+			"Enter, if name: %s, matched if name %s\n", ndev->name,
+			mon_if->real_ndev->name);
+	}
+	return 0;
+}
+
+static const struct net_device_ops mon_if_ops = {
+	.ndo_open = mon_if_open,
+	.ndo_stop = mon_if_stop,
+	.ndo_start_xmit = mon_if_subif_start_xmit,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
+	.ndo_set_rx_mode = mon_if_set_multicast_list,
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+	.ndo_set_multicast_list = mon_if_set_multicast_list,
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+	.ndo_set_mac_address = mon_if_change_mac,
+};
+
+/* Global function definitions  */
+int wland_add_monitor(char *name, struct net_device **new_ndev)
+{
+	int i, idx = -1, ret = 0;
+	struct net_device *ndev = NULL;
+	struct wland_linux_monitor **mon_ptr;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, if name: %s\n", name);
+
+	mutex_lock(&g_monitor.lock);
+	if (!name || !new_ndev) {
+		WLAND_ERR("invalid parameters\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Find a vacancy
+	 */
+	for (i = 0; i < WLAND_MAX_IFS; i++) {
+		if (g_monitor.mon_if[i].mon_ndev == NULL) {
+			idx = i;
+			break;
+		}
+	}
+
+	if (idx == -1) {
+		WLAND_ERR("exceeds maximum interfaces\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct wland_linux_monitor *));
+	if (!ndev) {
+		WLAND_ERR("failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+
+	strncpy(ndev->name, name, IFNAMSIZ);
+	ndev->name[IFNAMSIZ - 1] = 0;
+	ndev->netdev_ops = &mon_if_ops;
+
+	ret = register_netdevice(ndev);
+	if (ret) {
+		WLAND_ERR("register_netdevice failed (%d)\n", ret);
+		goto out;
+	}
+
+	*new_ndev = ndev;
+
+	g_monitor.mon_if[idx].radiotap_enabled = true;
+	g_monitor.mon_if[idx].mon_ndev = ndev;
+	g_monitor.mon_if[idx].real_ndev = lookup_real_netdev(name);
+	mon_ptr = (struct wland_linux_monitor **) netdev_priv(ndev);
+	*mon_ptr = &g_monitor;
+	g_monitor.monitor_state = MONITOR_STATE_INTERFACE_ADDED;
+
+	WLAND_DBG(DEFAULT, TRACE,
+		"net device returned: 0x%p,found a matched net device, name %s\n",
+		ndev, g_monitor.mon_if[idx].real_ndev->name);
+
+out:
+	if (ret && ndev)
+		free_netdev(ndev);
+
+	mutex_unlock(&g_monitor.lock);
+
+	return ret;
+}
+
+int wland_del_monitor(struct net_device *ndev)
+{
+	int i;
+
+	if (!ndev)
+		return -EINVAL;
+
+	mutex_lock(&g_monitor.lock);
+	for (i = 0; i < WLAND_MAX_IFS; i++) {
+		if (g_monitor.mon_if[i].mon_ndev == ndev ||
+			g_monitor.mon_if[i].real_ndev == ndev) {
+			g_monitor.mon_if[i].real_ndev = NULL;
+			unregister_netdev(g_monitor.mon_if[i].mon_ndev);
+			free_netdev(g_monitor.mon_if[i].mon_ndev);
+			g_monitor.mon_if[i].mon_ndev = NULL;
+			g_monitor.monitor_state =
+				MONITOR_STATE_INTERFACE_DELETED;
+			break;
+		}
+	}
+
+	if (g_monitor.monitor_state != MONITOR_STATE_INTERFACE_DELETED)
+		WLAND_ERR
+			("interface not found in monitor IF array, is this a monitor IF? 0x%p\n",
+			ndev);
+	mutex_unlock(&g_monitor.lock);
+
+	return 0;
+}
+
+int wland_monitor_init(void *pub)
+{
+	WLAND_DBG(DEFAULT, TRACE, "Enter,(monitor_state:%d)\n",
+		g_monitor.monitor_state);
+
+	if (g_monitor.monitor_state == MONITOR_STATE_DEINIT) {
+		g_monitor.pub = pub;
+		mutex_init(&g_monitor.lock);
+		g_monitor.monitor_state = MONITOR_STATE_INIT;
+	}
+	return 0;
+}
+
+int wland_monitor_deinit(void)
+{
+	int i;
+	struct net_device *ndev;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	mutex_lock(&g_monitor.lock);
+	if (g_monitor.monitor_state != MONITOR_STATE_DEINIT) {
+		for (i = 0; i < WLAND_MAX_IFS; i++) {
+			ndev = g_monitor.mon_if[i].mon_ndev;
+			if (ndev) {
+				unregister_netdev(ndev);
+				free_netdev(ndev);
+				g_monitor.mon_if[i].real_ndev = NULL;
+				g_monitor.mon_if[i].mon_ndev = NULL;
+			}
+		}
+		g_monitor.monitor_state = MONITOR_STATE_DEINIT;
+	}
+	mutex_unlock(&g_monitor.lock);
+	return 0;
+}
+
+#endif /* WLAND_MONITOR_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_nvram.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_nvram.c
new file mode 100644
index 000000000000..9a1ab14e1e04
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_nvram.c
@@ -0,0 +1,141 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#include <linux_osl.h>
+
+#include <wland_defs.h>
+#include <wland_dbg.h>
+
+#ifdef USE_MAC_FROM_RDA_NVRAM
+#include <plat/md_sys.h>
+#endif
+
+#ifdef USE_MAC_FROM_RDA_NVRAM
+int wlan_read_mac_from_nvram(char *buf)
+{
+	int ret;
+	struct msys_device *wlan_msys = NULL;
+	struct wlan_mac_info wlan_info;
+	struct client_cmd cmd_set;
+	int retry = 3;
+
+	wlan_msys = rda_msys_alloc_device();
+	if (!wlan_msys) {
+		WLAND_ERR("nvram: can not allocate wlan_msys device\n");
+		ret = -ENOMEM;
+		goto err_handle_sys;
+	}
+
+	wlan_msys->module = SYS_GEN_MOD;
+	wlan_msys->name = "rda-wlan";
+	rda_msys_register_device(wlan_msys);
+
+	//memset(&wlan_info, sizeof(wlan_info), 0);
+	memset(&wlan_info, 0, sizeof(wlan_info));
+	cmd_set.pmsys_dev = wlan_msys;
+	cmd_set.mod_id = SYS_GEN_MOD;
+	cmd_set.mesg_id = SYS_GEN_CMD_GET_WIFI_INFO;
+	cmd_set.pdata = NULL;
+	cmd_set.data_size = 0;
+	cmd_set.pout_data = &wlan_info;
+	cmd_set.out_size = sizeof(wlan_info);
+
+	while (retry--) {
+		ret = rda_msys_send_cmd(&cmd_set);
+		if (ret) {
+			WLAND_ERR("nvram:can not get wifi mac from nvram \n");
+			ret = -EBUSY;
+		} else {
+			break;
+		}
+	}
+
+	if (ret == -EBUSY) {
+		goto err_handle_cmd;
+	}
+
+	if (wlan_info.activated != WIFI_MAC_ACTIVATED_FLAG) {
+		WLAND_ERR("nvram:get invalid wifi mac address from nvram\n");
+		ret = -EINVAL;
+		goto err_invalid_mac;
+	}
+
+	memcpy(buf, wlan_info.mac_addr, ETH_ALEN);
+	WLAND_DBG(DEFAULT, ERROR,
+		"nvram: get wifi mac address [%02x:%02x:%02x:%02x:%02x:%02x].\n",
+		buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+	ret = 0;		/* success */
+
+err_invalid_mac:
+err_handle_cmd:
+	rda_msys_unregister_device(wlan_msys);
+	rda_msys_free_device(wlan_msys);
+err_handle_sys:
+	return ret;
+}
+
+int wlan_write_mac_to_nvram(const char *buf)
+{
+	int ret;
+	struct msys_device *wlan_msys = NULL;
+	struct wlan_mac_info wlan_info;
+	struct client_cmd cmd_set;
+
+	wlan_msys = rda_msys_alloc_device();
+	if (!wlan_msys) {
+		WLAND_ERR("nvram: can not allocate wlan_msys device\n");
+		ret = -ENOMEM;
+		goto err_handle_sys;
+	}
+
+	wlan_msys->module = SYS_GEN_MOD;
+	wlan_msys->name = "rda-wlan";
+	rda_msys_register_device(wlan_msys);
+
+	memset(&wlan_info, 0, sizeof(wlan_info));
+	wlan_info.activated = WIFI_MAC_ACTIVATED_FLAG;
+	memcpy(wlan_info.mac_addr, buf, ETH_ALEN);
+
+	cmd_set.pmsys_dev = wlan_msys;
+	cmd_set.mod_id = SYS_GEN_MOD;
+	cmd_set.mesg_id = SYS_GEN_CMD_SET_WIFI_INFO;
+	cmd_set.pdata = &wlan_info;
+	cmd_set.data_size = sizeof(wlan_info);
+	cmd_set.pout_data = NULL;
+	cmd_set.out_size = 0;
+
+	ret = rda_msys_send_cmd(&cmd_set);
+	if (ret) {
+		WLAND_ERR("nvram:can not set wifi mac to nvram \n");
+		ret = -EBUSY;
+		goto err_handle_cmd;
+	}
+
+	WLAND_DBG(DEFAULT, NOTICE,
+		"nvram:set wifi mac address [%02x:%02x:%02x:%02x:%02x:%02x] to nvram success.\n",
+		buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+	ret = 0;		/* success */
+
+err_handle_cmd:
+	rda_msys_unregister_device(wlan_msys);
+	rda_msys_free_device(wlan_msys);
+err_handle_sys:
+	return ret;
+}
+#endif
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.c
new file mode 100644
index 000000000000..a26b92b89389
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.c
@@ -0,0 +1,2587 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+#include <net/netlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_trap.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+#ifdef WLAND_P2P_SUPPORT
+
+/* parameters used for p2p escan */
+#define P2PAPI_SCAN_NPROBES                     1
+#define P2PAPI_SCAN_DWELL_TIME_MS               80
+#define P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS        40
+#define P2PAPI_SCAN_HOME_TIME_MS                60
+#define P2PAPI_SCAN_NPROBS_TIME_MS              30
+#define P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS     100
+
+/* scan connect timeout */
+#define WL_SCAN_CONNECT_DWELL_TIME_MS           200
+#define WL_SCAN_JOIN_PROBE_INTERVAL_MS          20
+
+#define P2P_WILDCARD_SSID		                "DIRECT-"
+#define P2P_WILDCARD_SSID_LEN	                (sizeof(P2P_WILDCARD_SSID) - 1)
+
+/* wifi direct social channel */
+#define SOCIAL_CHAN_1		                    1
+#define SOCIAL_CHAN_2		                    6
+#define SOCIAL_CHAN_3		                    11
+
+#define IS_P2P_SOCIAL_CHANNEL(channel)         ((channel == SOCIAL_CHAN_1) || \
+                            					(channel == SOCIAL_CHAN_2) || \
+                            				    (channel == SOCIAL_CHAN_3))
+#define WLAND_P2P_TEMP_CHAN	                    SOCIAL_CHAN_3
+#define SOCIAL_CHAN_CNT		                    3
+#define AF_PEER_SEARCH_CNT	                    2
+
+#define WLAND_SCB_TIMEOUT_VALUE	                20
+
+/* p2p const */
+#define P2P_VER			                        9	/* P2P version: 9=WiFi P2P v1.0 */
+#define P2P_PUB_AF_CATEGORY	                    0x04
+#define P2P_PUB_AF_ACTION	                    0x09
+#define P2P_AF_CATEGORY		                    0x7F
+#define P2P_OUI			                        "\x50\x6F\x9A"	/* P2P OUI */
+#define P2P_OUI_LEN		                        3	/* P2P OUI length */
+
+/* Action Frame Constants */
+#define DOT11_ACTION_HDR_LEN	                2	/* action frame category + action */
+#define DOT11_ACTION_CAT_OFF	                0	/* category offset */
+#define DOT11_ACTION_ACT_OFF	                1	/* action offset */
+
+#define P2P_AF_DWELL_TIME		                200
+#define P2P_AF_MIN_DWELL_TIME		            100
+#define P2P_AF_MED_DWELL_TIME		            400
+#define P2P_AF_LONG_DWELL_TIME		            1000
+#define P2P_AF_TX_MAX_RETRY		                1
+#define P2P_AF_MAX_WAIT_TIME		            2000
+#define P2P_INVALID_CHANNEL		                -1
+#define P2P_CHANNEL_SYNC_RETRY		            5
+
+#define P2P_AF_FRM_SCAN_MAX_WAIT	            1500
+#define P2P_DEFAULT_SLEEP_TIME_VSDB	            200
+
+/* WiFi P2P Public Action Frame OUI Subtypes */
+#define P2P_PAF_GON_REQ		                    0	/* Group Owner Negotiation Req */
+#define P2P_PAF_GON_RSP		                    1	/* Group Owner Negotiation Rsp */
+#define P2P_PAF_GON_CONF	                    2	/* Group Owner Negotiation Confirm */
+#define P2P_PAF_INVITE_REQ	                    3	/* P2P Invitation Request */
+#define P2P_PAF_INVITE_RSP	                    4	/* P2P Invitation Response */
+#define P2P_PAF_DEVDIS_REQ	                    5	/* Device Discoverability Request */
+#define P2P_PAF_DEVDIS_RSP	                    6	/* Device Discoverability Response */
+#define P2P_PAF_PROVDIS_REQ	                    7	/* Provision Discovery Request */
+#define P2P_PAF_PROVDIS_RSP	                    8	/* Provision Discovery Response */
+#define P2P_PAF_SUBTYPE_INVALID	                255	/* Invalid Subtype */
+
+/* WiFi P2P Action Frame OUI Subtypes */
+#define P2P_AF_NOTICE_OF_ABSENCE	            0	/* Notice of Absence */
+#define P2P_AF_PRESENCE_REQ		                1	/* P2P Presence Request */
+#define P2P_AF_PRESENCE_RSP		                2	/* P2P Presence Response */
+#define P2P_AF_GO_DISC_REQ		                3	/* GO Discoverability Request */
+
+/* P2P Service Discovery related */
+#define P2PSD_ACTION_CATEGORY		            0x04	/* Public action frame */
+#define P2PSD_ACTION_ID_GAS_IREQ	            0x0A	/* GAS Initial Request AF */
+#define P2PSD_ACTION_ID_GAS_IRESP	            0x0B	/* GAS Initial Response AF */
+#define P2PSD_ACTION_ID_GAS_CREQ	            0x0C	/* GAS Comback Request AF */
+#define P2PSD_ACTION_ID_GAS_CRESP	            0x0D	/* GAS Comback Response AF */
+
+/*
+ * struct wland_p2p_disc_st_le - set discovery state in firmware.
+ *
+ * @state   : requested discovery state (see enum wland_p2p_disc_state).
+ * @chspec  : channel parameter for %WL_P2P_DISC_ST_LISTEN state.
+ * @dwell   : dwell time in ms for %WL_P2P_DISC_ST_LISTEN state.
+ */
+struct wland_p2p_disc_st_le {
+	u8 state;
+	__le16 chspec;
+	__le16 dwell;
+};
+
+/*
+ * enum wland_p2p_disc_state - P2P discovery state values
+ *
+ * @WL_P2P_DISC_ST_SCAN     :   P2P discovery with wildcard SSID and P2P IE.
+ * @WL_P2P_DISC_ST_LISTEN   : P2P discovery off-channel for specified time.
+ * @WL_P2P_DISC_ST_SEARCH   : P2P discovery with P2P wildcard SSID and P2P IE.
+ */
+enum wland_p2p_disc_state {
+	WL_P2P_DISC_ST_SCAN,
+	WL_P2P_DISC_ST_LISTEN,
+	WL_P2P_DISC_ST_SEARCH
+};
+
+/*
+ * struct wland_p2p_scan_le - P2P specific scan request.
+ *
+ * @type    : type of scan method requested (values: 'E' or 'S').
+ * @reserved: reserved (ignored).
+ * @eparams : parameters used for type 'E'.
+ * @sparams : parameters used for type 'S'.
+ */
+struct wland_p2p_scan_le {
+	u8 type;
+	u8 reserved[3];
+	union {
+		struct wland_escan_params_le eparams;
+		struct wland_scan_params_le sparams;
+	};
+};
+
+/*
+ * struct wland_p2p_pub_act_frame - WiFi P2P Public Action Frame
+ *
+ * @category    : P2P_PUB_AF_CATEGORY
+ * @action      : P2P_PUB_AF_ACTION
+ * @oui[3]      : P2P_OUI
+ * @oui_type    : OUI type - P2P_VER
+ * @subtype     : OUI subtype - P2P_TYPE_*
+ * @dialog_token: nonzero, identifies req/rsp transaction
+ * @elts[1]     : Variable length information elements.
+ */
+struct wland_p2p_pub_act_frame {
+	u8 category;
+	u8 action;
+	u8 oui[3];
+	u8 oui_type;
+	u8 subtype;
+	u8 dialog_token;
+	u8 elts[1];
+};
+
+/**
+ * struct wland_p2p_action_frame - WiFi P2P Action Frame
+ *
+ * @category: P2P_AF_CATEGORY
+ * @OUI[3]  : OUI - P2P_OUI
+ * @type    : OUI Type - P2P_VER
+ * @subtype : OUI Subtype - P2P_AF_*
+ * @dialog_token: nonzero, identifies req/resp tranaction
+ * @elts[1] : Variable length information elements.
+ */
+struct wland_p2p_action_frame {
+	u8 category;
+	u8 oui[3];
+	u8 type;
+	u8 subtype;
+	u8 dialog_token;
+	u8 elts[1];
+};
+
+/*
+ * struct wland_p2psd_gas_pub_act_frame - Wi-Fi GAS Public Action Frame
+ *
+ * @category        : 0x04 Public Action Frame
+ * @action          : 0x6c Advertisement Protocol
+ * @dialog_token    : nonzero, identifies req/rsp transaction
+ * @query_data[1]   : Query Data. SD gas ireq SD gas iresp
+ */
+struct wland_p2psd_gas_pub_act_frame {
+	u8 category;
+	u8 action;
+	u8 dialog_token;
+	u8 query_data[1];
+};
+
+/*
+ * struct wland_config_af_params - Action Frame Parameters for tx.
+ *
+ * @search_channel  : 1: search peer's channel to send af
+ * @extra_listen    : keep the dwell time to get af response frame.
+ */
+struct wland_config_af_params {
+	bool search_channel;
+	bool extra_listen;
+};
+
+/*
+ * wland_p2p_is_pub_action() - true if p2p public type frame.
+ *
+ * @frame       : action frame data.
+ * @frame_len   : length of action frame data.
+ *
+ * Determine if action frame is p2p public action type
+ */
+static bool wland_p2p_is_pub_action(void *frame, u32 frame_len)
+{
+	struct wland_p2p_pub_act_frame *pact_frm =
+		(struct wland_p2p_pub_act_frame *) frame;
+
+	if (frame == NULL)
+		return false;
+
+	if (frame_len < sizeof(struct wland_p2p_pub_act_frame) - 1)
+		return false;
+
+	if (pact_frm->category == P2P_PUB_AF_CATEGORY &&
+		pact_frm->action == P2P_PUB_AF_ACTION &&
+		pact_frm->oui_type == P2P_VER &&
+		memcmp(pact_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)
+		return true;
+
+	return false;
+}
+
+/*
+ * wland_p2p_is_p2p_action() - true if p2p action type frame.
+ *
+ * @frame       : action frame data.
+ * @frame_len   : length of action frame data.
+ *
+ * Determine if action frame is p2p action type
+ */
+static bool wland_p2p_is_p2p_action(void *frame, u32 frame_len)
+{
+	struct wland_p2p_action_frame *act_frm =
+		(struct wland_p2p_action_frame *) frame;
+
+	if (frame == NULL)
+		return false;
+
+	if (frame_len < sizeof(struct wland_p2p_action_frame) - 1)
+		return false;
+
+	if (act_frm->category == P2P_AF_CATEGORY &&
+		act_frm->type == P2P_VER &&
+		memcmp(act_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)
+		return true;
+
+	return false;
+}
+
+/*
+ * wland_p2p_is_gas_action() - true if p2p gas action type frame.
+ *
+ * @frame: action frame data.
+ * @frame_len: length of action frame data.
+ *
+ * Determine if action frame is p2p gas action type
+ */
+static bool wland_p2p_is_gas_action(void *frame, u32 frame_len)
+{
+	struct wland_p2psd_gas_pub_act_frame *sd_act_frm;
+
+	if (frame == NULL)
+		return false;
+
+	sd_act_frm = (struct wland_p2psd_gas_pub_act_frame *) frame;
+	if (frame_len < sizeof(struct wland_p2psd_gas_pub_act_frame) - 1)
+		return false;
+
+	if (sd_act_frm->category != P2PSD_ACTION_CATEGORY)
+		return false;
+
+	if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||
+		sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP ||
+		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ ||
+		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)
+		return true;
+
+	return false;
+}
+
+/*
+ * wland_p2p_set_firmware() - prepare firmware for peer-to-peer operation.
+ *
+ * @ifp     : ifp to use for iovars (primary).
+ * @p2p_mac : mac address to configure for p2p_da_override
+ */
+static int wland_p2p_set_firmware(struct wland_if *ifp, u8 * p2p_mac)
+{
+	s32 ret = 0;
+	u8 val = 1;
+
+	wland_fil_iovar_data_set(ifp, "apsta", &val, sizeof(u8));
+
+	/*
+	 * In case of COB type, firmware has default mac address
+	 * * After Initializing firmware, we have to set current mac address to
+	 * * firmware for P2P device address
+	 */
+	ret = wland_fil_iovar_data_set(ifp, "p2p_da_override", p2p_mac,
+		ETH_ALEN);
+	if (ret < 0)
+		WLAND_ERR("failed to update device address ret %d\n", ret);
+
+	return ret;
+}
+
+/*
+ * wland_p2p_generate_bss_mac() - derive mac addresses for P2P.
+ *
+ * @p2p     : P2P specific data.
+ * @dev_addr: optional device address.
+ *
+ * P2P needs mac addresses for P2P device and interface. If no device
+ * address it specified, these are derived from the primary net device, ie.
+ * the permanent ethernet address of the device.
+ */
+static void wland_p2p_generate_bss_mac(struct wland_p2p_info *p2p,
+	u8 * dev_addr)
+{
+	struct wland_if *pri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;
+	bool local_admin = false;
+
+	if (!dev_addr || is_zero_ether_addr(dev_addr)) {
+		dev_addr = pri_ifp->mac_addr;
+		local_admin = true;
+	}
+
+	/*
+	 * Generate the P2P Device Address.  This consists of the device's
+	 * * primary MAC address with the locally administered bit set.
+	 */
+	if (dev_addr)
+		memcpy(p2p->dev_addr, dev_addr, ETH_ALEN);
+
+	if (local_admin)
+		p2p->dev_addr[0] |= 0x02;
+
+	/*
+	 * Generate the P2P Interface Address.  If the discovery and connection
+	 * * BSSCFGs need to simultaneously co-exist, then this address must be
+	 * * different from the P2P Device Address, but also locally administered.
+	 */
+	memcpy(p2p->int_addr, p2p->dev_addr, ETH_ALEN);
+
+	p2p->int_addr[0] |= 0x02;
+	p2p->int_addr[4] ^= 0x80;
+}
+
+/*
+ * wland_p2p_scan_is_p2p_request() - is cfg80211 scan request a P2P scan.
+ *
+ * @request: the scan request as received from cfg80211.
+ *
+ * returns true if one of the ssids in the request matches the
+ * P2P wildcard ssid; otherwise returns false.
+ */
+static bool wland_p2p_scan_is_p2p_request(struct cfg80211_scan_request *request)
+{
+	struct cfg80211_ssid *ssids = request->ssids;
+	int i;
+
+	for (i = 0; i < request->n_ssids; i++) {
+		if (ssids[i].ssid_len != P2P_WILDCARD_SSID_LEN)
+			continue;
+
+		WLAND_DBG(CFG80211, TRACE, "comparing ssid \"%s\"",
+			ssids[i].ssid);
+
+		if (!memcmp(P2P_WILDCARD_SSID, ssids[i].ssid,
+				P2P_WILDCARD_SSID_LEN))
+			return true;
+	}
+	return false;
+}
+
+/*
+ * wland_p2p_set_discover_state - set discover state in firmware.
+ *
+ * @ifp         : low-level interface object.
+ * @state       : discover state to set.
+ * @chanspec    : channel parameters (for state @WL_P2P_DISC_ST_LISTEN only).
+ * @listen_ms   : duration to listen (for state @WL_P2P_DISC_ST_LISTEN only).
+ */
+static s32 wland_p2p_set_discover_state(struct wland_if *ifp, u8 state,
+	u16 chanspec, u16 listen_ms)
+{
+	struct wland_p2p_disc_st_le discover_state;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	discover_state.state = state;
+	discover_state.chspec = cpu_to_le16(chanspec);
+	discover_state.dwell = cpu_to_le16(listen_ms);
+
+	return wland_fil_iovar_data_set(ifp, "p2p_state", &discover_state,
+		sizeof(discover_state));
+}
+
+/*
+ * wland_p2p_deinit_discovery() - disable P2P device discovery.
+ *
+ * @p2p: P2P specific data.
+ *
+ * Resets the discovery state and disables it in firmware.
+ */
+static s32 wland_p2p_deinit_discovery(struct wland_p2p_info *p2p)
+{
+	u8 enable = 0;
+	struct wland_cfg80211_vif *vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	/*
+	 * Set the discovery state to SCAN
+	 */
+	wland_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);
+
+	/*
+	 * Disable P2P discovery in the firmware
+	 */
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+
+	return wland_fil_iovar_data_set(vif->ifp, "p2p_disc", &enable,
+		sizeof(u8));
+}
+
+/*
+ * wland_p2p_enable_discovery() - initialize and configure discovery.
+ *
+ * @p2p: P2P specific data.
+ *
+ * Initializes the discovery device and configure the virtual interface.
+ */
+static s32 wland_p2p_enable_discovery(struct wland_p2p_info *p2p)
+{
+	struct wland_cfg80211_vif *vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+	s32 ret = 0;
+	u8 enable = 1;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!vif) {
+		WLAND_ERR("P2P config device not available\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (test_bit(P2P_STATUS_ENABLED, &p2p->status)) {
+		WLAND_DBG(CFG80211, TRACE,
+			"P2P config device already configured\n");
+		goto exit;
+	}
+
+	/*
+	 * Re-initialize P2P Discovery in the firmware
+	 */
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+
+	ret = wland_fil_iovar_data_set(vif->ifp, "p2p_disc", &enable,
+		sizeof(u8));
+	if (ret < 0) {
+		WLAND_ERR("set p2p_disc error\n");
+		goto exit;
+	}
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+	ret = wland_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);
+	if (ret < 0) {
+		WLAND_ERR("unable to set WL_P2P_DISC_ST_SCAN\n");
+		goto exit;
+	}
+
+	/*
+	 * Set wsec to any non-zero value in the discovery bsscfg
+	 * to ensure our P2P probe responses have the privacy bit
+	 * set in the 802.11 WPA IE. Some peer devices may not
+	 * initiate WPS with us if this bit is not set.
+	 */
+	enable = AES_ENABLED;
+	ret = wland_fil_iovar_data_set(vif->ifp, "wsec", &enable, sizeof(u8));
+	if (ret < 0) {
+		WLAND_ERR("wsec error %d\n", ret);
+		goto exit;
+	}
+
+	set_bit(P2P_STATUS_ENABLED, &p2p->status);
+
+exit:
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return ret;
+}
+
+/*
+ * wland_p2p_escan() - initiate a P2P scan.
+ *
+ * @p2p         : P2P specific data.
+ * @num_chans   : number of channels to scan.
+ * @chanspecs   : channel parameters for @num_chans channels.
+ * @search_state: P2P discover state to use.
+ * @action      : scan action to pass to firmware.
+ * @bss_type    : type of P2P bss.
+ */
+static s32 wland_p2p_escan(struct wland_p2p_info *p2p, u32 num_chans,
+	u16 chanspecs[], s32 search_state, u16 action,
+	enum p2p_bss_type bss_type)
+{
+	s32 ret = 0, nprobes, active;
+	s32 memsize = offsetof(struct wland_p2p_scan_le,
+		eparams.params_le.channel_list);
+	u32 i;
+	u8 *memblk;
+	struct wland_cfg80211_vif *vif;
+	struct wland_p2p_scan_le *p2p_params;
+	struct wland_scan_params_le *sparams;
+	struct wland_ssid ssid;
+
+	memsize += num_chans * sizeof(__le16);
+	memblk = kzalloc(memsize, GFP_KERNEL);
+	if (!memblk)
+		return -ENOMEM;
+
+	vif = p2p->bss_idx[bss_type].vif;
+	if (vif == NULL) {
+		WLAND_ERR("no vif for bss type %d\n", bss_type);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	switch (search_state) {
+	case WL_P2P_DISC_ST_SEARCH:
+		/*
+		 * If we in SEARCH STATE, we don't need to set SSID explictly
+		 * because dongle use P2P WILDCARD internally by default
+		 */
+		/*
+		 * use null ssid
+		 */
+		ssid.SSID_len = 0;
+		memset(ssid.SSID, 0, sizeof(ssid.SSID));
+		break;
+	case WL_P2P_DISC_ST_SCAN:
+		/*
+		 * wpa_supplicant has p2p_find command with type social or
+		 * progressive. For progressive, we need to set the ssid to
+		 * P2P WILDCARD because we just do broadcast scan unless setting SSID.
+		 */
+		ssid.SSID_len = P2P_WILDCARD_SSID_LEN;
+		memcpy(ssid.SSID, P2P_WILDCARD_SSID, ssid.SSID_len);
+		break;
+	default:
+		WLAND_ERR(" invalid search state %d\n", search_state);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	wland_p2p_set_discover_state(vif->ifp, search_state, 0, 0);
+
+	/*
+	 * set p2p scan parameters.
+	 */
+	p2p_params = (struct wland_p2p_scan_le *) memblk;
+	p2p_params->type = 'E';
+
+	/*
+	 * determine the scan engine parameters
+	 */
+	sparams = &p2p_params->eparams.params_le;
+
+	sparams->bss_type = DOT11_BSSTYPE_ANY;
+
+	if (p2p->cfg->active_scan)
+		sparams->scan_type = 0;
+	else
+		sparams->scan_type = 1;
+
+	memset(&sparams->bssid, 0xFF, ETH_ALEN);
+
+	if (ssid.SSID_len)
+		memcpy(sparams->ssid_le.SSID, ssid.SSID, ssid.SSID_len);
+
+	sparams->ssid_le.SSID_len = cpu_to_le32(ssid.SSID_len);
+	sparams->home_time = cpu_to_le32(P2PAPI_SCAN_HOME_TIME_MS);
+
+	/*
+	 * SOCIAL_CHAN_CNT + 1 takes care of the Progressive scan supported by the supplicant.
+	 */
+	if (num_chans == SOCIAL_CHAN_CNT || num_chans == (SOCIAL_CHAN_CNT + 1))
+		active = P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS;
+	else if (num_chans == AF_PEER_SEARCH_CNT)
+		active = P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS;
+	else if (wland_vif_get_state_all(p2p->cfg, VIF_STATUS_CONNECTED))
+		active = -1;
+	else
+		active = P2PAPI_SCAN_DWELL_TIME_MS;
+
+	/*
+	 * Override scan params to find a peer for a connection
+	 */
+	if (num_chans == 1) {
+		active = WL_SCAN_CONNECT_DWELL_TIME_MS;
+		/*
+		 * WAR to sync with presence period of VSDB GO.
+		 * * send probe request more frequently
+		 */
+		nprobes = active / WL_SCAN_JOIN_PROBE_INTERVAL_MS;
+	} else {
+		nprobes = active / P2PAPI_SCAN_NPROBS_TIME_MS;
+	}
+
+	if (nprobes <= 0)
+		nprobes = 1;
+
+	WLAND_DBG(CFG80211, TRACE, "nprobes # %d, active_time %d\n", nprobes,
+		active);
+
+	sparams->active_time = cpu_to_le32(active);
+	sparams->nprobes = cpu_to_le32(nprobes);
+	sparams->passive_time = cpu_to_le32(-1);
+
+	for (i = 0; i < num_chans; i++)
+		sparams->channel_list[i] = cpu_to_le16(chanspecs[i]);
+
+	/*
+	 * set the escan specific parameters
+	 */
+	p2p_params->eparams.action = cpu_to_le16(action);
+	p2p_params->eparams.sync_id = cpu_to_le16(0x1234);
+
+	/*
+	 * perform p2p scan on primary device
+	 */
+	ret = wland_fil_iovar_data_set(vif->ifp, "p2p_scan", memblk, memsize);
+	if (!ret)
+		set_bit(SCAN_STATUS_BUSY, &p2p->cfg->scan_status);
+exit:
+	kfree(memblk);
+	return ret;
+}
+
+/*
+ * wland_p2p_run_escan() - escan callback for peer-to-peer.
+ *
+ * @cfg     : driver private data for cfg80211 interface.
+ * @ndev    : net device for which scan is requested.
+ * @request : scan request from cfg80211.
+ * @action  : scan action.
+ *
+ * Determines the P2P discovery state based to scan request parameters and
+ * validates the channels in the request.
+ */
+static s32 wland_p2p_run_escan(struct wland_cfg80211_info *cfg,
+	struct wland_if *ifp, struct cfg80211_scan_request *request, u16 action)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	s32 err = 0;
+	s32 search_state = WL_P2P_DISC_ST_SCAN;
+	struct wland_cfg80211_vif *vif;
+	struct net_device *dev = NULL;
+	int i, num_nodfs = 0;
+	u16 *chanspecs;
+
+	WLAND_DBG(DEFAULT, TRACE, "enter\n");
+
+	if (!request) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	if (request->n_channels) {
+		chanspecs =
+			kcalloc(request->n_channels, sizeof(*chanspecs),
+			GFP_KERNEL);
+		if (!chanspecs) {
+			err = -ENOMEM;
+			goto exit;
+		}
+		vif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;
+
+		if (vif)
+			dev = vif->wdev.netdev;
+
+		if (request->n_channels == 3 &&
+			request->channels[0]->hw_value == SOCIAL_CHAN_1 &&
+			request->channels[1]->hw_value == SOCIAL_CHAN_2 &&
+			request->channels[2]->hw_value == SOCIAL_CHAN_3) {
+			/*
+			 * SOCIAL CHANNELS 1, 6, 11
+			 */
+			search_state = WL_P2P_DISC_ST_SEARCH;
+			WLAND_DBG(CFG80211, TRACE, "P2P SEARCH PHASE START\n");
+		} else if (dev != NULL && vif->mode == WL_MODE_AP) {
+			/*
+			 * If you are already a GO, then do SEARCH only
+			 */
+			WLAND_DBG(CFG80211, TRACE,
+				"Already a GO. Do SEARCH Only\n");
+			search_state = WL_P2P_DISC_ST_SEARCH;
+		} else {
+			WLAND_DBG(CFG80211, TRACE, "P2P SCAN STATE START\n");
+		}
+
+		/*
+		 * no P2P scanning on passive or DFS channels.
+		 */
+		for (i = 0; i < request->n_channels; i++) {
+			struct ieee80211_channel *chan = request->channels[i];
+
+			if (chan->flags & (IEEE80211_CHAN_RADAR |
+					IEEE80211_CHAN_PASSIVE_SCAN))
+				continue;
+
+			chanspecs[i] =
+				channel_to_chanspec(&p2p->cfg->d11inf, chan);
+			WLAND_DBG(CFG80211, TRACE,
+				"%d: chan=%d, channel spec=%x\n", num_nodfs,
+				chan->hw_value, chanspecs[i]);
+			num_nodfs++;
+		}
+		err = wland_p2p_escan(p2p, num_nodfs, chanspecs, search_state,
+			action, P2PAPI_BSSCFG_DEVICE);
+	}
+exit:
+	if (err)
+		WLAND_ERR("error (%d)\n", err);
+	return err;
+}
+
+/*
+ * wland_p2p_find_listen_channel() - find listen channel in ie string.
+ *
+ * @ie     : string of information elements.
+ * @ie_len : length of string.
+ *
+ * Scan ie for p2p ie and look for attribute 6 channel.
+ * If available determine channel and return it.
+ */
+static s32 wland_p2p_find_listen_channel(const u8 * ie, u32 ie_len)
+{
+	u8 channel_ie[5];
+	s32 listen_channel;
+
+#if 0
+	s32 err;
+
+	err = cfg80211_get_p2p_attr(ie, ie_len,
+		IEEE80211_P2P_ATTR_LISTEN_CHANNEL, channel_ie,
+		sizeof(channel_ie));
+	if (err < 0)
+		return err;
+#endif
+	/*
+	 * listen channel subel length format:
+	 */
+	/*
+	 * 3(country) + 1(op. class) + 1(chan num)
+	 */
+	listen_channel = (s32) channel_ie[3 + 1];
+
+	if (listen_channel == SOCIAL_CHAN_1 ||
+		listen_channel == SOCIAL_CHAN_2 ||
+		listen_channel == SOCIAL_CHAN_3) {
+		WLAND_DBG(CFG80211, TRACE, "Found my Listen Channel %d\n",
+			listen_channel);
+		return listen_channel;
+	}
+
+	return -EPERM;
+}
+
+/*
+ * wland_p2p_scan_prep() - prepare scan based on request.
+ *
+ * @wiphy   : wiphy device.
+ * @request : scan request from cfg80211.
+ * @vif     : vif on which scan request is to be executed.
+ *
+ * Prepare the scan appropriately for type of scan requested. Overrides the
+ * escan .run() callback for peer-to-peer scanning.
+ */
+s32 wland_p2p_scan_prep(struct wiphy * wiphy,
+	struct cfg80211_scan_request * request, struct wland_cfg80211_vif * vif)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	s32 err = 0;
+
+	if (wland_p2p_scan_is_p2p_request(request)) {
+		/*
+		 * find my listen channel
+		 */
+		err = wland_p2p_find_listen_channel(request->ie,
+			request->ie_len);
+		if (err < 0)
+			return err;
+
+		p2p->afx_hdl.my_listen_chan = err;
+
+		clear_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+		WLAND_DBG(CFG80211, TRACE,
+			"P2P: GO_NEG_PHASE status cleared\n");
+
+		err = wland_p2p_enable_discovery(p2p);
+		if (err < 0)
+			return err;
+
+		vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+		/*
+		 * override .run_escan() callback.
+		 */
+		cfg->scan_info.run = wland_p2p_run_escan;
+	}
+
+	return wland_vif_set_mgmt_ie(vif, WLAND_VNDR_IE_PRBREQ_FLAG,
+		request->ie, request->ie_len);
+}
+
+/*
+ * wland_p2p_discover_listen() - set firmware to discover listen state.
+ *
+ * @p2p: p2p device.
+ * @channel: channel nr for discover listen.
+ * @duration: time in ms to stay on channel.
+ *
+ */
+static s32 wland_p2p_discover_listen(struct wland_p2p_info *p2p, u16 channel,
+	u32 duration)
+{
+	struct wland_cfg80211_vif *vif;
+	struct wland_chan ch;
+	s32 err = 0;
+
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+	if (!vif) {
+		WLAND_ERR("Discovery is not set, so we have nothing to do\n");
+		err = -EPERM;
+		goto exit;
+	}
+
+	if (test_bit(P2P_STATUS_DISCOVER_LISTEN, &p2p->status)) {
+		WLAND_ERR("Previous LISTEN is not completed yet\n");
+		/*
+		 * WAR: prevent cookie mismatch in wpa_supplicant return OK
+		 */
+		goto exit;
+	}
+
+	ch.chnum = channel;
+	ch.bw = CHAN_BW_20;
+
+	p2p->cfg->d11inf.encchspec(&ch);
+
+	err = wland_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_LISTEN,
+		ch.chspec, (u16) duration);
+	if (!err) {
+		set_bit(P2P_STATUS_DISCOVER_LISTEN, &p2p->status);
+		p2p->remain_on_channel_cookie++;
+	}
+exit:
+	return err;
+}
+
+/*
+ * cfg80211_p2p_remain_on_channel() - put device on channel and stay there.
+ *
+ * @wiphy   : wiphy device.
+ * @channel : channel to stay on.
+ * @duration: time in ms to remain on channel.
+ *
+ */
+int cfg80211_p2p_remain_on_channel(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *dev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct ieee80211_channel *channel,
+	enum nl80211_channel_type channel_type,
+	unsigned int duration, u64 * cookie)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	s32 err;
+	u16 channel_nr = ieee80211_frequency_to_channel(channel->center_freq);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter, channel: %d, duration ms (%d)\n",
+		channel_nr, duration);
+
+	err = wland_p2p_enable_discovery(p2p);
+	if (err)
+		goto exit;
+
+	err = wland_p2p_discover_listen(p2p, channel_nr, duration);
+	if (err)
+		goto exit;
+
+	memcpy(&p2p->remain_on_channel, channel, sizeof(*channel));
+	*cookie = p2p->remain_on_channel_cookie;
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	cfg80211_ready_on_channel(wdev, *cookie, channel, duration, GFP_KERNEL);
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	cfg80211_ready_on_channel(dev, *cookie, channel, channel_type, duration,
+		GFP_KERNEL);
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+exit:
+	return err;
+}
+
+/*
+ * notify_p2p_listen_complete() - p2p listen has completed.
+ *
+ * @ifp             : interfac control.
+ * @e: event message. Not used, to make it usable for fweh event dispatcher.
+ * @data            : payload of message. Not used.
+ *
+ */
+s32 notify_p2p_listen_complete(struct wland_if * ifp,
+	const struct wland_event_msg * e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_p2p_info *p2p = &cfg->p2p;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (test_and_clear_bit(P2P_STATUS_DISCOVER_LISTEN, &p2p->status)) {
+		if (test_and_clear_bit(P2P_STATUS_WAITING_NEXT_AF_LISTEN,
+				&p2p->status)) {
+			clear_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME,
+				&p2p->status);
+			WLAND_DBG(CFG80211, TRACE,
+				"Listen DONE, wake up wait_next_af\n");
+			complete(&p2p->wait_next_af);
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		cfg80211_remain_on_channel_expired(&ifp->vif->wdev,
+			p2p->remain_on_channel_cookie, &p2p->remain_on_channel,
+			GFP_KERNEL);
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		cfg80211_remain_on_channel_expired(ifp->ndev,
+			p2p->remain_on_channel_cookie, &p2p->remain_on_channel,
+			p2p->remain_on_chan_type, GFP_KERNEL);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	}
+
+	WLAND_DBG(CFG80211, TRACE, "Done\n");
+	return 0;
+}
+
+/*
+ * wland_p2p_cancel_remain_on_channel() - cancel p2p listen state.
+ *
+ * @ifp: interfac control.
+ *
+ */
+void wland_p2p_cancel_remain_on_channel(struct wland_if *ifp)
+{
+	if (!ifp)
+		return;
+
+	wland_p2p_set_discover_state(ifp, WL_P2P_DISC_ST_SCAN, 0, 0);
+
+	notify_p2p_listen_complete(ifp, NULL, NULL);
+}
+
+/*
+ * wland_p2p_act_frm_search() - search function for action frame.
+ *
+ * @p2p: p2p device.
+ * channel: channel on which action frame is to be trasmitted.
+ *
+ * search function to reach at common channel to send action frame. When
+ * channel is 0 then all social channels will be used to send af
+ */
+static s32 wland_p2p_act_frm_search(struct wland_p2p_info *p2p, u16 channel)
+{
+	s32 err;
+	u32 channel_cnt, i;
+	u16 *default_chan_list;
+	struct wland_chan ch;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (channel)
+		channel_cnt = AF_PEER_SEARCH_CNT;
+	else
+		channel_cnt = SOCIAL_CHAN_CNT;
+
+	default_chan_list =
+		kzalloc(channel_cnt * sizeof(*default_chan_list), GFP_KERNEL);
+
+	if (default_chan_list == NULL) {
+		WLAND_ERR("channel list allocation failed\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+	ch.bw = CHAN_BW_20;
+
+	if (channel) {
+		ch.chnum = channel;
+		p2p->cfg->d11inf.encchspec(&ch);
+		/*
+		 * insert same channel to the chan_list
+		 */
+		for (i = 0; i < channel_cnt; i++)
+			default_chan_list[i] = ch.chspec;
+	} else {
+		ch.chnum = SOCIAL_CHAN_1;
+		p2p->cfg->d11inf.encchspec(&ch);
+		default_chan_list[0] = ch.chspec;
+		ch.chnum = SOCIAL_CHAN_2;
+		p2p->cfg->d11inf.encchspec(&ch);
+		default_chan_list[1] = ch.chspec;
+		ch.chnum = SOCIAL_CHAN_3;
+		p2p->cfg->d11inf.encchspec(&ch);
+		default_chan_list[2] = ch.chspec;
+	}
+	err = wland_p2p_escan(p2p,
+		channel_cnt,
+		default_chan_list,
+		WL_P2P_DISC_ST_SEARCH, SCAN_ACTION_START, P2PAPI_BSSCFG_DEVICE);
+	kfree(default_chan_list);
+exit:
+	return err;
+}
+
+/*
+ * wland_p2p_afx_handler() - afx worker thread.
+ *
+ * @work:
+ *
+ */
+static void wland_p2p_afx_handler(struct work_struct *work)
+{
+	struct afx_hdl *afx_hdl = container_of(work, struct afx_hdl, afx_work);
+	struct wland_p2p_info *p2p =
+		container_of(afx_hdl, struct wland_p2p_info, afx_hdl);
+	s32 err;
+
+	if (!afx_hdl->is_active)
+		return;
+
+	if (afx_hdl->is_listen && afx_hdl->my_listen_chan)
+		/*
+		 * 100ms ~ 300ms
+		 */
+		err = wland_p2p_discover_listen(p2p, afx_hdl->my_listen_chan,
+			100 * (1 + random32() % 3));
+	else
+		err = wland_p2p_act_frm_search(p2p, afx_hdl->peer_listen_chan);
+
+	if (err) {
+		WLAND_ERR("occurred! value is (%d)\n", err);
+
+		if (test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status))
+			complete(&afx_hdl->act_frm_scan);
+	}
+}
+
+/*
+ * wland_p2p_af_searching_channel() - search channel.
+ *
+ * @p2p: p2p device info struct.
+ *
+ */
+static s32 wland_p2p_af_searching_channel(struct wland_p2p_info *p2p)
+{
+	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+	struct wland_cfg80211_vif *pri_vif =
+		p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+	ulong duration;
+	s32 retry = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	INIT_COMPLETION(afx_hdl->act_frm_scan);
+
+	set_bit(P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);
+
+	afx_hdl->is_active = true;
+	afx_hdl->peer_chan = P2P_INVALID_CHANNEL;
+
+	/*
+	 * Loop to wait until we find a peer's channel or the pending action frame tx is cancelled.
+	 */
+	duration = msecs_to_jiffies(P2P_AF_FRM_SCAN_MAX_WAIT);
+
+	while ((retry < P2P_CHANNEL_SYNC_RETRY)
+		&& (afx_hdl->peer_chan == P2P_INVALID_CHANNEL)) {
+		afx_hdl->is_listen = false;
+		WLAND_DBG(DEFAULT, TRACE,
+			"Scheduling action frame for sending.. (%d)\n", retry);
+		/*
+		 * search peer on peer's listen channel
+		 */
+		schedule_work(&afx_hdl->afx_work);
+		wait_for_completion_timeout(&afx_hdl->act_frm_scan, duration);
+
+		if ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||
+			(!test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL,
+					&p2p->status))) {
+			break;
+		}
+
+		if (afx_hdl->my_listen_chan) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"Scheduling listen peer, channel=%d\n",
+				afx_hdl->my_listen_chan);
+			/*
+			 * listen on my listen channel
+			 */
+			afx_hdl->is_listen = true;
+			schedule_work(&afx_hdl->afx_work);
+			wait_for_completion_timeout(&afx_hdl->act_frm_scan,
+				duration);
+		}
+		if ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||
+			(!test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL,
+					&p2p->status))) {
+			break;
+		}
+		retry++;
+
+		/*
+		 * if sta is connected or connecting, sleep for a while before retry af tx or finding a peer
+		 */
+		if (test_bit(VIF_STATUS_CONNECTED, &pri_vif->sme_state) ||
+			test_bit(VIF_STATUS_CONNECTING, &pri_vif->sme_state)) {
+			msleep(P2P_DEFAULT_SLEEP_TIME_VSDB);
+		}
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "Completed search/listen peer_chan=%d\n",
+		afx_hdl->peer_chan);
+	afx_hdl->is_active = false;
+
+	clear_bit(P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);
+
+	return afx_hdl->peer_chan;
+}
+
+/*
+ * wland_p2p_scan_finding_common_channel() - was escan used for finding channel
+ *
+ * @cfg : common configuration struct.
+ * @bi  : bss info struct, result from scan.
+ *
+ */
+bool wland_p2p_scan_finding_common_channel(struct wland_cfg80211_info * cfg,
+	struct wland_bss_info_le * bi)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+	struct wland_chan ch;
+	s32 err = 0;
+	u8 p2p_dev_addr[ETH_ALEN];
+
+	if (!test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status))
+		return false;
+
+	if (bi == NULL) {
+		WLAND_DBG(DEFAULT, TRACE, "ACTION FRAME SCAN Done\n");
+		if (afx_hdl->peer_chan == P2P_INVALID_CHANNEL)
+			complete(&afx_hdl->act_frm_scan);
+		return true;
+	}
+
+	memset(p2p_dev_addr, 0, sizeof(p2p_dev_addr));
+#if 0
+	err = cfg80211_get_p2p_attr(ie,
+		bi->ie_length,
+		IEEE80211_P2P_ATTR_DEVICE_INFO,
+		p2p_dev_addr, sizeof(p2p_dev_addr));
+	if (err < 0)
+		err = cfg80211_get_p2p_attr(ie,
+			bi->ie_length,
+			IEEE80211_P2P_ATTR_DEVICE_ID,
+			p2p_dev_addr, sizeof(p2p_dev_addr));
+#endif
+	if ((err >= 0)
+		&& (!memcmp(p2p_dev_addr, afx_hdl->tx_dst_addr, ETH_ALEN))) {
+		if (!bi->ctl_ch) {
+			ch.chspec = bi->chanspec;
+			cfg->d11inf.decchspec(&ch);
+			bi->ctl_ch = ch.chnum;
+		}
+		afx_hdl->peer_chan = bi->ctl_ch;
+		WLAND_DBG(DEFAULT, TRACE,
+			"ACTION FRAME SCAN: Peer %pM found, channel : %d\n",
+			afx_hdl->tx_dst_addr, afx_hdl->peer_chan);
+		complete(&afx_hdl->act_frm_scan);
+	}
+	return true;
+}
+
+/*
+ * wland_p2p_stop_wait_next_action_frame() - finish scan if af tx complete.
+ *
+ * @cfg: common configuration struct.
+ */
+static void wland_p2p_stop_wait_next_action_frame(struct wland_cfg80211_info
+	*cfg)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_if *ifp = cfg->scan_info.ifp;
+
+	if (test_bit(P2P_STATUS_SENDING_ACT_FRAME, &p2p->status) &&
+		(test_bit(P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status)
+			|| test_bit(P2P_STATUS_ACTION_TX_NOACK, &p2p->status))) {
+		WLAND_DBG(DEFAULT, TRACE,
+			"*** Wake UP ** abort actframe iovar\n");
+		/*
+		 * if channel is not zero, "actfame" uses off channel scan.
+		 * * So abort scan for off channel completion.
+		 */
+		if (p2p->af_sent_channel)
+			wland_notify_escan_complete(cfg, ifp, true, true);
+	} else if (test_bit(P2P_STATUS_WAITING_NEXT_AF_LISTEN, &p2p->status)) {
+		WLAND_DBG(DEFAULT, TRACE,
+			"*** Wake UP ** abort listen for next af frame\n");
+		/*
+		 * So abort scan to cancel listen
+		 */
+		wland_notify_escan_complete(cfg, ifp, true, true);
+	}
+}
+
+/*
+ * wland_p2p_gon_req_collision() - Check if go negotiaton collission
+ *
+ * @p2p: p2p device info struct.
+ *
+ * return true if recevied action frame is to be dropped.
+ */
+static bool wland_p2p_gon_req_collision(struct wland_p2p_info *p2p, u8 * mac)
+{
+	struct wland_cfg80211_info *cfg = p2p->cfg;
+	struct wland_if *ifp = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->ifp;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (!test_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status)
+		|| !p2p->gon_req_action)
+		return false;
+
+	WLAND_DBG(CFG80211, TRACE, "GO Negotiation Request COLLISION !!!\n");
+
+	/*
+	 * if sa(peer) addr is less than da(my) addr, then this device
+	 * * process peer's gon request and block to send gon req.
+	 * * if not (sa addr > da addr), this device will process gon request and drop gon req of peer.
+	 */
+	if (memcmp(mac, ifp->mac_addr, ETH_ALEN) < 0) {
+		WLAND_DBG(CFG80211, TRACE, "Block transmit gon req !!!\n");
+		p2p->block_gon_req_tx = true;
+		/*
+		 * if we are finding a common channel for sending af, do not scan more to block to send current gon req
+		 */
+		if (test_and_clear_bit(P2P_STATUS_FINDING_COMMON_CHANNEL,
+				&p2p->status))
+			complete(&p2p->afx_hdl.act_frm_scan);
+		if (test_and_clear_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME,
+				&p2p->status))
+			wland_p2p_stop_wait_next_action_frame(cfg);
+
+		return false;
+	}
+
+	/*
+	 * drop gon request of peer to process gon request by this device.
+	 */
+	WLAND_DBG(CFG80211, TRACE, "Drop received gon req !!!\n");
+
+	return true;
+}
+
+/*
+ * notify_p2p_action_frame_rx() - received action frame.
+ *
+ * @ifp : interfac control.
+ * @e   : event message. Not used, to make it usable for fweh event dispatcher.
+ * @data: payload of message, containing action frame data.
+ *
+ */
+s32 notify_p2p_action_frame_rx(struct wland_if * ifp,
+	const struct wland_event_msg * e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+	struct wireless_dev *wdev;
+	u32 mgmt_frame_len = e->datalen - sizeof(struct wland_rx_mgmt_data);
+	struct wland_rx_mgmt_data *rxframe = (struct wland_rx_mgmt_data *) data;
+	u8 *frame = (u8 *) (rxframe + 1);
+	struct wland_p2p_pub_act_frame *act_frm;
+	struct wland_p2psd_gas_pub_act_frame *sd_act_frm;
+	struct wland_chan ch;
+	struct ieee80211_mgmt *mgmt_frame;
+	s32 freq;
+	u16 mgmt_type;
+	u8 action;
+
+	ch.chspec = be16_to_cpu(rxframe->chanspec);
+
+	cfg->d11inf.decchspec(&ch);
+
+	/*
+	 * Check if wpa_supplicant has registered for this frame
+	 */
+	WLAND_DBG(CFG80211, TRACE, "ifp->vif->mgmt_rx_reg %04x\n",
+		ifp->vif->mgmt_rx_reg);
+
+	mgmt_type = (IEEE80211_STYPE_ACTION & IEEE80211_FCTL_STYPE) >> 4;
+
+	if ((ifp->vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)
+		return 0;
+
+	action = P2P_PAF_SUBTYPE_INVALID;
+
+	if (wland_p2p_is_pub_action(frame, mgmt_frame_len)) {
+		act_frm = (struct wland_p2p_pub_act_frame *) frame;
+		action = act_frm->subtype;
+
+		if ((action == P2P_PAF_GON_REQ)
+			&& wland_p2p_gon_req_collision(p2p, (u8 *) e->addr)) {
+			if (test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL,
+					&p2p->status)
+				&& (memcmp(afx_hdl->tx_dst_addr, e->addr,
+						ETH_ALEN) == 0)) {
+				WLAND_DBG(CFG80211, TRACE,
+					"GON request: Peer found, channel=%d\n",
+					ch.chnum);
+				afx_hdl->peer_chan = ch.chnum;
+				complete(&afx_hdl->act_frm_scan);
+			}
+			return 0;
+		}
+
+		if (action == P2P_PAF_GON_CONF) {
+			WLAND_DBG(DEFAULT, TRACE,
+				"P2P: GO_NEG_PHASE status cleared\n");
+			clear_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+		}
+	} else if (wland_p2p_is_gas_action(frame, mgmt_frame_len)) {
+		sd_act_frm = (struct wland_p2psd_gas_pub_act_frame *) frame;
+		action = sd_act_frm->action;
+	}
+
+	if (test_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status)
+		&& (p2p->next_af_subtype == action)) {
+		WLAND_DBG(DEFAULT, TRACE, "We got a right next frame! (%d)\n",
+			action);
+		clear_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);
+		/*
+		 * Stop waiting for next AF.
+		 */
+		wland_p2p_stop_wait_next_action_frame(cfg);
+	}
+
+	mgmt_frame =
+		kzalloc(offsetof(struct ieee80211_mgmt, u) + mgmt_frame_len,
+		GFP_KERNEL);
+	if (!mgmt_frame) {
+		WLAND_ERR("No memory available for action frame\n");
+		return -ENOMEM;
+	}
+	memcpy(mgmt_frame->da, ifp->mac_addr, ETH_ALEN);
+
+	wland_fil_iovar_data_get(ifp, "get_bssid", mgmt_frame->bssid, ETH_ALEN);
+
+	memcpy(mgmt_frame->sa, e->addr, ETH_ALEN);
+	mgmt_frame->frame_control = cpu_to_le16(IEEE80211_STYPE_ACTION);
+	memcpy(&mgmt_frame->u, frame, mgmt_frame_len);
+	mgmt_frame_len += offsetof(struct ieee80211_mgmt, u);
+
+	freq = ieee80211_channel_to_frequency(ch.chnum,
+		ch.band ==
+		CHAN_BAND_2G ? IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+	wdev = &ifp->vif->wdev;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	cfg80211_rx_mgmt(ifp->ndev, freq, 0, (u8 *) mgmt_frame, mgmt_frame_len,
+		GFP_ATOMIC);
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+	cfg80211_rx_mgmt(ifp->ndev, freq, (u8 *) mgmt_frame, mgmt_frame_len,
+		GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+
+//      cfg80211_rx_mgmt(wdev, freq, 0, (u8 *)mgmt_frame, mgmt_frame_len, 0, GFP_ATOMIC);
+
+	kfree(mgmt_frame);
+	return 0;
+}
+
+/*
+ * notify_p2p_action_tx_complete() - transmit action frame complete
+ *
+ * @ifp : interfac control.
+ * @e   : event message. Not used, to make it usable for fweh event dispatcher.
+ * @data: not used.
+ *
+ */
+s32 notify_p2p_action_tx_complete(struct wland_if * ifp,
+	const struct wland_event_msg * e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_p2p_info *p2p = &cfg->p2p;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter: event %s, status=%d\n",
+		e->event_code ==
+		WLAND_E_ACT_FRAME_OFF_CHAN_COMPLETE ?
+		"ACTION_FRAME_OFF_CHAN_COMPLETE" : "ACTION_FRAME_COMPLETE",
+		e->status);
+
+	if (!test_bit(P2P_STATUS_SENDING_ACT_FRAME, &p2p->status))
+		return 0;
+
+	if (e->event_code == WLAND_E_ACT_FRAME_COMPLETE) {
+		if (e->status == STATUS_SUCCESS) {
+			set_bit(P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);
+		} else {
+			set_bit(P2P_STATUS_ACTION_TX_NOACK, &p2p->status);
+			/*
+			 * If there is no ack, we don't need to wait for WLC_E_ACTION_FRAME_OFFCHAN_COMPLETE event
+			 */
+			wland_p2p_stop_wait_next_action_frame(cfg);
+		}
+	} else {
+		complete(&p2p->send_af_done);
+	}
+	return 0;
+}
+
+/*
+ * wland_p2p_tx_action_frame() - send action frame over fil.
+ *
+ * @p2p      : p2p info struct for vif.
+ * @af_params: action frame data/info.
+ *
+ * Send an action frame immediately without doing channel synchronization.
+ *
+ * This function waits for a completion event before returning.
+ * The WLC_E_ACTION_FRAME_COMPLETE event will be received when the action
+ * frame is transmitted.
+ */
+static s32 wland_p2p_tx_action_frame(struct wland_p2p_info *p2p,
+	struct wland_fil_af_params_le *af_params)
+{
+	struct wland_cfg80211_vif *vif;
+	s32 err = 0, timeout = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	INIT_COMPLETION(p2p->send_af_done);
+
+	clear_bit(P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);
+	clear_bit(P2P_STATUS_ACTION_TX_NOACK, &p2p->status);
+
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+	err = wland_fil_iovar_data_set(vif->ifp, "actframe", af_params,
+		sizeof(*af_params));
+	if (err < 0) {
+		WLAND_ERR(" sending action frame has failed\n");
+		goto exit;
+	}
+
+	p2p->af_sent_channel = le32_to_cpu(af_params->channel);
+	p2p->af_tx_sent_jiffies = jiffies;
+
+	timeout =
+		wait_for_completion_timeout(&p2p->send_af_done,
+		msecs_to_jiffies(P2P_AF_MAX_WAIT_TIME));
+
+	if (test_bit(P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status)) {
+		WLAND_DBG(DEFAULT, TRACE,
+			"TX action frame operation is success\n");
+	} else {
+		err = -EIO;
+		WLAND_DBG(DEFAULT, TRACE,
+			"TX action frame operation has failed\n");
+	}
+	/*
+	 * clear status bit for action tx
+	 */
+	clear_bit(P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);
+	clear_bit(P2P_STATUS_ACTION_TX_NOACK, &p2p->status);
+
+exit:
+	return err;
+}
+
+/*
+ * wland_p2p_pub_af_tx() - public action frame tx routine.
+ *
+ * @cfg             : driver private data for cfg80211 interface.
+ * @af_params       : action frame data/info.
+ * @config_af_params: configuration data for action frame.
+ *
+ * routine which transmits ation frame public type.
+ */
+static s32 wland_p2p_pub_af_tx(struct wland_cfg80211_info *cfg,
+	struct wland_fil_af_params_le *af_params,
+	struct wland_config_af_params *config_af_params)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_fil_action_frame_le *action_frame =
+		&af_params->action_frame;
+	struct wland_p2p_pub_act_frame *act_frm =
+		(struct wland_p2p_pub_act_frame *) (action_frame->data);
+	s32 err = 0;
+	u16 ie_len;
+
+	config_af_params->extra_listen = true;
+
+	switch (act_frm->subtype) {
+	case P2P_PAF_GON_REQ:
+		WLAND_DBG(DEFAULT, TRACE, "P2P: GO_NEG_PHASE status set\n");
+		set_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+		config_af_params->search_channel = true;
+
+		p2p->next_af_subtype = act_frm->subtype + 1;
+		p2p->gon_req_action = true;
+		/*
+		 * increase dwell time to wait for RESP frame
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		break;
+	case P2P_PAF_GON_RSP:
+		p2p->next_af_subtype = act_frm->subtype + 1;
+		/*
+		 * increase dwell time to wait for CONF frame
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		break;
+	case P2P_PAF_GON_CONF:
+		/*
+		 * If we reached till GO Neg confirmation reset the filter
+		 */
+		WLAND_DBG(DEFAULT, TRACE, "P2P: GO_NEG_PHASE status cleared\n");
+		clear_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+		/*
+		 * minimize dwell time
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);
+		config_af_params->extra_listen = false;
+		break;
+	case P2P_PAF_INVITE_REQ:
+		config_af_params->search_channel = true;
+		p2p->next_af_subtype = act_frm->subtype + 1;
+		/*
+		 * increase dwell time
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		break;
+	case P2P_PAF_INVITE_RSP:
+		/*
+		 * minimize dwell time
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);
+		config_af_params->extra_listen = false;
+		break;
+	case P2P_PAF_DEVDIS_REQ:
+		config_af_params->search_channel = true;
+		p2p->next_af_subtype = act_frm->subtype + 1;
+		/*
+		 * maximize dwell time to wait for RESP frame
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_LONG_DWELL_TIME);
+		break;
+	case P2P_PAF_DEVDIS_RSP:
+		/*
+		 * minimize dwell time
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);
+		config_af_params->extra_listen = false;
+		break;
+	case P2P_PAF_PROVDIS_REQ:
+		ie_len = le16_to_cpu(action_frame->len) -
+			offsetof(struct wland_p2p_pub_act_frame, elts);
+#if 0
+		if (cfg80211_get_p2p_attr(&act_frm->elts[0], ie_len,
+				IEEE80211_P2P_ATTR_GROUP_ID, NULL, 0) < 0)
+			config_af_params->search_channel = true;
+#endif
+		p2p->next_af_subtype = act_frm->subtype + 1;
+		/*
+		 * increase dwell time to wait for RESP frame
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		break;
+	case P2P_PAF_PROVDIS_RSP:
+		/*
+		 * wpa_supplicant send go nego req right after prov disc
+		 */
+		p2p->next_af_subtype = P2P_PAF_GON_REQ;
+		/*
+		 * increase dwell time to MED level
+		 */
+		af_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		config_af_params->extra_listen = false;
+		break;
+	default:
+		WLAND_ERR("Unknown p2p pub act frame subtype: %d\n",
+			act_frm->subtype);
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
+/*
+ * wland_p2p_send_action_frame() - send action frame .
+ *
+ * @cfg			: driver private data for cfg80211 interface.
+ * @ndev		: net device to transmit on.
+ * @af_params	: configuration data for action frame.
+ */
+bool wland_p2p_send_action_frame(struct wland_cfg80211_info * cfg,
+	struct net_device * ndev, struct wland_fil_af_params_le * af_params)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_fil_action_frame_le *action_frame;
+	struct wland_config_af_params config_af_params;
+	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+	u16 action_frame_len;
+	bool ack = false;
+	u8 category, action;
+	s32 tx_retry, extra_listen_time;
+	uint delta_ms;
+
+	action_frame = &af_params->action_frame;
+	action_frame_len = le16_to_cpu(action_frame->len);
+
+	/*
+	 * Add the default dwell time. Dwell time to stay off-channel
+	 */
+	/*
+	 * to wait for a response action frame after transmitting an
+	 */
+	/*
+	 * GO Negotiation action frame
+	 */
+	af_params->dwell_time = cpu_to_le32(P2P_AF_DWELL_TIME);
+
+	category = action_frame->data[DOT11_ACTION_CAT_OFF];
+	action = action_frame->data[DOT11_ACTION_ACT_OFF];
+
+	/*
+	 * initialize variables
+	 */
+	p2p->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;
+	p2p->gon_req_action = false;
+
+	/*
+	 * config parameters
+	 */
+	config_af_params.search_channel = false;
+	config_af_params.extra_listen = false;
+
+	if (wland_p2p_is_pub_action(action_frame->data, action_frame_len)) {
+		/*
+		 * p2p public action frame process
+		 */
+		if (wland_p2p_pub_af_tx(cfg, af_params, &config_af_params)) {
+			/*
+			 * Just send unknown subtype frame with
+			 */
+			/*
+			 * default parameters.
+			 */
+			WLAND_ERR
+				("P2P Public action frame, unknown subtype.\n");
+		}
+	} else if (wland_p2p_is_gas_action(action_frame->data,
+			action_frame_len)) {
+		/*
+		 * service discovery process
+		 */
+		if (action == P2PSD_ACTION_ID_GAS_IREQ
+			|| action == P2PSD_ACTION_ID_GAS_CREQ) {
+			/*
+			 * configure service discovery query frame
+			 */
+			config_af_params.search_channel = true;
+
+			/*
+			 * save next af suptype to cancel remaining dwell time
+			 */
+			p2p->next_af_subtype = action + 1;
+			af_params->dwell_time =
+				cpu_to_le32(P2P_AF_MED_DWELL_TIME);
+		} else if (action == P2PSD_ACTION_ID_GAS_IRESP
+			|| action == P2PSD_ACTION_ID_GAS_CRESP) {
+			/*
+			 * configure service discovery response frame
+			 */
+			af_params->dwell_time =
+				cpu_to_le32(P2P_AF_MIN_DWELL_TIME);
+		} else {
+			WLAND_ERR("Unknown action type: %d\n", action);
+			goto exit;
+		}
+	} else if (wland_p2p_is_p2p_action(action_frame->data,
+			action_frame_len)) {
+		/*
+		 * do not configure anything. it will be sent with a default configuration
+		 */
+	} else {
+		WLAND_ERR("Unknown Frame: category 0x%x, action 0x%x\n",
+			category, action);
+		return false;
+	}
+
+	/*
+	 * if connecting on primary iface, sleep for a while before sending af tx for VSDB
+	 */
+	if (test_bit(VIF_STATUS_CONNECTING,
+			&p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->sme_state))
+		msleep(50);
+
+	/*
+	 * if scan is ongoing, abort current scan.
+	 */
+	if (test_bit(SCAN_STATUS_BUSY, &cfg->scan_status))
+		wland_abort_scanning(cfg);
+
+	memcpy(afx_hdl->tx_dst_addr, action_frame->da, ETH_ALEN);
+
+	/*
+	 * set status and destination address before sending af
+	 */
+	if (p2p->next_af_subtype != P2P_PAF_SUBTYPE_INVALID) {
+		/*
+		 * set status to cancel the remained dwell time in rx process
+		 */
+		set_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);
+	}
+
+	p2p->af_sent_channel = 0;
+
+	set_bit(P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);
+
+	/*
+	 * validate channel and p2p ies
+	 */
+	if (config_af_params.search_channel &&
+		IS_P2P_SOCIAL_CHANNEL(le32_to_cpu(af_params->channel)) &&
+		p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->saved_ie.
+		probe_req_ie_len) {
+		afx_hdl = &p2p->afx_hdl;
+		afx_hdl->peer_listen_chan = le32_to_cpu(af_params->channel);
+
+		if (wland_p2p_af_searching_channel(p2p) == P2P_INVALID_CHANNEL) {
+			WLAND_ERR("Couldn't find peer's channel.\n");
+			goto exit;
+		}
+
+		/*
+		 * Abort scan even for VSDB scenarios. Scan gets aborted in
+		 * * firmware but after the check of piggyback algorithm. To take
+		 * * care of current piggback algo, lets abort the scan here itself.
+		 */
+		wland_notify_escan_complete(cfg, ifp, true, true);
+
+		/*
+		 * update channel
+		 */
+		af_params->channel = cpu_to_le32(afx_hdl->peer_chan);
+	}
+
+	tx_retry = 0;
+
+	while (!p2p->block_gon_req_tx && (!ack)
+		&& (tx_retry < P2P_AF_TX_MAX_RETRY)) {
+		ack = !wland_p2p_tx_action_frame(p2p, af_params);
+		tx_retry++;
+	}
+
+	if (!ack) {
+		WLAND_ERR("Failed to send Action Frame(retry %d)\n", tx_retry);
+		clear_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+	}
+
+exit:
+	clear_bit(P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);
+
+	/*
+	 * WAR: sometimes dongle does not keep the dwell time of 'actframe'.
+	 * * if we coundn't get the next action response frame and dongle does
+	 * * not keep the dwell time, go to listen state again to get next action
+	 * * response frame.
+	 */
+	if (ack && config_af_params.extra_listen && !p2p->block_gon_req_tx &&
+		test_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) &&
+		p2p->af_sent_channel == afx_hdl->my_listen_chan) {
+		delta_ms = jiffies_to_msecs(jiffies - p2p->af_tx_sent_jiffies);
+
+		if (le32_to_cpu(af_params->dwell_time) > delta_ms)
+			extra_listen_time =
+				le32_to_cpu(af_params->dwell_time) - delta_ms;
+		else
+			extra_listen_time = 0;
+
+		if (extra_listen_time > 50) {
+			set_bit(P2P_STATUS_WAITING_NEXT_AF_LISTEN,
+				&p2p->status);
+			WLAND_DBG(CFG80211, TRACE,
+				"Wait more time! actual af time:%d, calculated extra listen:%d\n",
+				le32_to_cpu(af_params->dwell_time),
+				extra_listen_time);
+			extra_listen_time += 100;
+
+			if (!wland_p2p_discover_listen(p2p,
+					p2p->af_sent_channel,
+					extra_listen_time)) {
+				unsigned long duration;
+
+				extra_listen_time += 100;
+				duration = msecs_to_jiffies(extra_listen_time);
+				wait_for_completion_timeout(&p2p->wait_next_af,
+					duration);
+			}
+			clear_bit(P2P_STATUS_WAITING_NEXT_AF_LISTEN,
+				&p2p->status);
+		}
+	}
+
+	if (p2p->block_gon_req_tx) {
+		/*
+		 * if ack is true, supplicant will wait more time(100ms).
+		 * * so we will return it as a success to get more time .
+		 */
+		p2p->block_gon_req_tx = false;
+		ack = true;
+	}
+
+	clear_bit(P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);
+
+	return ack;
+}
+
+/*
+ * notify_p2p_rx_mgmt_probereq() - Event handler for p2p probe req.
+ *
+ * @ifp : interface pointer for which event was received.
+ * @e   : even message.
+ * @data: payload of event message (probe request).
+ */
+s32 notify_p2p_rx_mgmt_probereq(struct wland_if * ifp,
+	const struct wland_event_msg * e, void *data)
+{
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+	struct wland_cfg80211_vif *vif = ifp->vif;
+	struct wland_rx_mgmt_data *rxframe = (struct wland_rx_mgmt_data *) data;
+	struct wland_chan ch;
+	u8 *mgmt_frame;
+	u32 mgmt_frame_len;
+	s32 freq;
+	u16 mgmt_type, chanspec = be16_to_cpu(rxframe->chanspec);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter: event %d reason %d\n", e->event_code,
+		e->reason);
+
+	ch.chspec = be16_to_cpu(rxframe->chanspec);
+
+	cfg->d11inf.decchspec(&ch);
+
+	if (test_bit(P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status)
+		&& (memcmp(afx_hdl->tx_dst_addr, e->addr, ETH_ALEN) == 0)) {
+		afx_hdl->peer_chan = ch.chnum;
+		WLAND_DBG(CFG80211, TRACE,
+			"PROBE REQUEST: Peer found, channel=%d\n",
+			afx_hdl->peer_chan);
+		complete(&afx_hdl->act_frm_scan);
+	}
+
+	/*
+	 * Firmware sends us two proberesponses for each idx one. At the
+	 */
+	/*
+	 * moment anything but bsscfgidx 0 is passed up to supplicant
+	 */
+	if (e->bsscfgidx == 0)
+		return 0;
+
+	/*
+	 * Filter any P2P probe reqs arriving during the GO-NEG Phase
+	 */
+	if (test_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status)) {
+		WLAND_DBG(CFG80211, TRACE,
+			"Filtering P2P probe_req in GO-NEG phase\n");
+		return 0;
+	}
+
+	/*
+	 * Check if wpa_supplicant has registered for this frame
+	 */
+	WLAND_DBG(CFG80211, TRACE, "vif->mgmt_rx_reg %04x\n", vif->mgmt_rx_reg);
+
+	mgmt_type = (IEEE80211_STYPE_PROBE_REQ & IEEE80211_FCTL_STYPE) >> 4;
+
+	if ((vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)
+		return 0;
+
+	mgmt_frame = (u8 *) (rxframe + 1);
+	mgmt_frame_len = e->datalen - sizeof(*rxframe);
+	freq = ieee80211_channel_to_frequency(ch.chnum,
+		ch.band ==
+		CHAN_BAND_2G ? IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	cfg80211_rx_mgmt(ifp->ndev, freq, 0, mgmt_frame, mgmt_frame_len,
+		GFP_ATOMIC);
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+	cfg80211_rx_mgmt(ifp->ndev, freq, mgmt_frame, mgmt_frame_len,
+		GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+
+//      cfg80211_rx_mgmt(&vif->wdev, freq, 0, mgmt_frame, mgmt_frame_len, 0, GFP_ATOMIC);
+
+	WLAND_DBG(CFG80211, TRACE,
+		"mgmt_frame_len(%d),datalen (%d),chanspec(%04x),freq (%d)\n",
+		mgmt_frame_len, e->datalen, chanspec, freq);
+
+	return 0;
+}
+
+/*
+ * wland_p2p_get_current_chanspec() - Get current operation channel.
+ *
+ * @p2p		: P2P specific data.
+ * @chanspec: chanspec to be returned.
+ */
+static void wland_p2p_get_current_chanspec(struct wland_p2p_info *p2p,
+	u16 * chanspec)
+{
+	struct wland_chan ch;
+	struct wland_bss_info_le *bi;
+	u8 *buf;
+	u8 mac_addr[ETH_ALEN];
+	struct wland_if *ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;
+
+	if (wland_fil_iovar_data_get(ifp, "get_bssid", mac_addr, ETH_ALEN) > 0) {
+		buf = kzalloc(WLAND_BSS_INFO_MAX, GFP_KERNEL);
+
+		if (buf != NULL) {
+			*(__le32 *) buf = cpu_to_le32(WLAND_BSS_INFO_MAX);
+
+			if (wland_fil_iovar_data_get(ifp, "get_bss_info", buf,
+					WLAND_BSS_INFO_MAX) > 0) {
+				bi = (struct wland_bss_info_le *) (buf + 4);
+				*chanspec = le16_to_cpu(bi->chanspec);
+				kfree(buf);
+				return;
+			}
+			kfree(buf);
+		}
+	}
+
+	/*
+	 * Use default channel for P2P
+	 */
+	ch.chnum = WLAND_P2P_TEMP_CHAN;
+	ch.bw = CHAN_BW_20;
+	p2p->cfg->d11inf.encchspec(&ch);
+	*chanspec = ch.chspec;
+}
+
+/*
+ * Change a P2P Role.
+ * Parameters:
+ * @mac     : MAC address of the BSS to change a role
+ * Returns 0 if success.
+ */
+s32 wland_p2p_ifchange(struct wland_cfg80211_info * cfg,
+	enum wland_fil_p2p_if_types if_type)
+{
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_cfg80211_vif *vif =
+		p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+	struct wland_fil_p2p_if_le if_request;
+	s32 err, timeout;
+	u16 chanspec;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+
+	if (!vif) {
+		WLAND_ERR("vif for P2PAPI_BSSCFG_PRIMARY does not exist\n");
+		return -EPERM;
+	}
+
+	wland_notify_escan_complete(cfg, vif->ifp, true, true);
+
+	vif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;
+	if (!vif) {
+		WLAND_ERR("vif for P2PAPI_BSSCFG_CONNECTION does not exist\n");
+		return -EPERM;
+	}
+
+	/*
+	 * In concurrency case, STA may be already associated in a particular
+	 */
+	/*
+	 * channel. so retrieve the current channel of primary interface and
+	 */
+	/*
+	 * then start the virtual interface on that.
+	 */
+	wland_p2p_get_current_chanspec(p2p, &chanspec);
+
+	if_request.type = cpu_to_le16((u16) if_type);
+	if_request.chspec = cpu_to_le16(chanspec);
+
+	memcpy(if_request.addr, p2p->int_addr, sizeof(if_request.addr));
+
+	wland_cfg80211_arm_vif_event(cfg, vif);
+
+	err = wland_fil_iovar_data_set(vif->ifp, "p2p_ifupd", &if_request,
+		sizeof(if_request));
+	if (err < 0) {
+		WLAND_ERR("p2p_ifupd FAILED, err=%d\n", err);
+		wland_cfg80211_arm_vif_event(cfg, NULL);
+		return err;
+	}
+
+	err = wland_cfg80211_wait_vif_event_timeout(cfg, WLAND_E_IF_CHANGE,
+		msecs_to_jiffies(1500));
+
+	wland_cfg80211_arm_vif_event(cfg, NULL);
+	if (!err) {
+		WLAND_ERR("No WLAND_E_IF_CHANGE event received\n");
+		return -EIO;
+	}
+
+	timeout = WLAND_SCB_TIMEOUT_VALUE;
+
+	return wland_fil_iovar_data_set(vif->ifp, "scb_timeout", &timeout,
+		sizeof(timeout));
+}
+
+static s32 wland_p2p_request_p2p_if(struct wland_p2p_info *p2p,
+	struct wland_if *ifp, u8 ea[ETH_ALEN],
+	enum wland_fil_p2p_if_types iftype)
+{
+	struct wland_fil_p2p_if_le if_request;
+	u16 chanspec;
+
+	/*
+	 * we need a default channel
+	 */
+	wland_p2p_get_current_chanspec(p2p, &chanspec);
+
+	/*
+	 * fill the firmware request
+	 */
+	memcpy(if_request.addr, ea, ETH_ALEN);
+
+	if_request.type = cpu_to_le16((u16) iftype);
+	if_request.chspec = cpu_to_le16(chanspec);
+
+	return wland_fil_iovar_data_set(ifp, "p2p_ifadd", &if_request,
+		sizeof(if_request));
+}
+
+static s32 wland_p2p_disable_p2p_if(struct wland_cfg80211_vif *vif)
+{
+	struct wland_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);
+	struct net_device *pri_ndev = cfg_to_ndev(cfg);
+	struct wland_if *ifp = netdev_priv(pri_ndev);
+	u8 *addr = vif->wdev.netdev->dev_addr;
+
+	return wland_fil_iovar_data_set(ifp, "p2p_ifdis", addr, ETH_ALEN);
+}
+
+static s32 wland_p2p_release_p2p_if(struct wland_cfg80211_vif *vif)
+{
+	struct wland_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);
+	struct net_device *pri_ndev = cfg_to_ndev(cfg);
+	struct wland_if *ifp = netdev_priv(pri_ndev);
+	u8 *addr = vif->wdev.netdev->dev_addr;
+
+	return wland_fil_iovar_data_set(ifp, "p2p_ifdel", addr, ETH_ALEN);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+
+/*
+ * wland_p2p_create_p2pdev() - create a P2P_DEVICE virtual interface.
+ *
+ * @p2p:   P2P specific data.
+ * @wiphy: wiphy device of new interface.
+ * @addr:  mac address for this new interface.
+ */
+static struct wireless_dev *wland_p2p_create_p2pdev(struct wland_p2p_info *p2p,
+	struct wiphy *wiphy, u8 * addr)
+{
+	struct wland_cfg80211_vif *p2p_vif;
+	struct wland_if *p2p_ifp;
+	struct wland_if *pri_ifp;
+	int err;
+	u32 bssidx;
+
+	if (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)
+		return ERR_PTR(-ENOSPC);
+
+	p2p_vif = wland_alloc_vif(p2p->cfg,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		NL80211_IFTYPE_P2P_DEVICE,
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		NL80211_IFTYPE_P2P_CLIENT,
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+		false);
+	if (IS_ERR(p2p_vif)) {
+		WLAND_ERR("could not create discovery vif\n");
+		return (struct wireless_dev *) p2p_vif;
+	}
+
+	pri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;
+
+	wland_p2p_generate_bss_mac(p2p, addr);
+
+	wland_p2p_set_firmware(pri_ifp, p2p->dev_addr);
+
+	wland_cfg80211_arm_vif_event(p2p->cfg, p2p_vif);
+
+	/*
+	 * Initialize P2P Discovery in the firmware
+	 */
+	err = wland_fil_iovar_data_set(pri_ifp, "p2p_disc", NULL, 0);
+	if (err < 0) {
+		WLAND_ERR("set p2p_disc error\n");
+		wland_cfg80211_arm_vif_event(p2p->cfg, NULL);
+		goto fail;
+	}
+
+	/*
+	 * wait for firmware event
+	 */
+	err = wland_cfg80211_wait_vif_event_timeout(p2p->cfg, WLAND_E_IF_ADD,
+		msecs_to_jiffies(1500));
+
+	wland_cfg80211_arm_vif_event(p2p->cfg, NULL);
+
+	if (!err) {
+		WLAND_ERR("timeout occurred\n");
+		err = -EIO;
+		goto fail;
+	}
+
+	/*
+	 * discovery interface created
+	 */
+	p2p_ifp = p2p_vif->ifp;
+
+	p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif = p2p_vif;
+
+	memcpy(p2p_ifp->mac_addr, p2p->dev_addr, ETH_ALEN);
+	memcpy(&p2p_vif->wdev.address, p2p->dev_addr, sizeof(p2p->dev_addr));
+
+	/*
+	 * verify bsscfg index for P2P discovery
+	 */
+	err = wland_fil_iovar_data_get(pri_ifp, "p2p_dev", &bssidx,
+		sizeof(bssidx));
+	if (err < 0) {
+		WLAND_ERR("retrieving discover bsscfg index failed\n");
+		goto fail;
+	}
+
+	WARN_ON(p2p_ifp->bssidx != bssidx);
+
+	init_completion(&p2p->send_af_done);
+	INIT_WORK(&p2p->afx_hdl.afx_work, wland_p2p_afx_handler);
+	init_completion(&p2p->afx_hdl.act_frm_scan);
+	init_completion(&p2p->wait_next_af);
+
+	return &p2p_vif->wdev;
+
+fail:
+	wland_free_vif(p2p->cfg, p2p_vif);
+	return ERR_PTR(err);
+}
+
+/*
+ * wland_p2p_delete_p2pdev() - delete P2P_DEVICE virtual interface.
+ *
+ * @vif: virtual interface object to delete.
+ */
+static void wland_p2p_delete_p2pdev(struct wland_cfg80211_info *cfg,
+	struct wland_cfg80211_vif *vif)
+{
+	cfg80211_unregister_wdev(&vif->wdev);
+
+	cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif = NULL;
+
+	wland_free_vif(cfg, vif);
+}
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+/*
+ * cfg80211_free_p2p_if() - free up net device related data.
+ *
+ * @ndev: net device that needs to be freed.
+ */
+static void cfg80211_free_p2p_if(struct net_device *ndev)
+{
+	struct wland_if *ifp = netdev_priv(ndev);
+	struct wland_cfg80211_info *cfg = ifp->drvr->config;
+	struct wland_cfg80211_vif *vif = ifp->vif;
+
+	wland_free_vif(cfg, vif);
+
+	free_netdev(ifp->ndev);
+}
+
+/*
+ * wland_p2p_add_vif() - create a new P2P virtual interface.
+ *
+ * @wiphy   : wiphy device of new interface.
+ * @name    : name of the new interface.
+ * @type    : nl80211 interface type.
+ * @flags   : not used.
+ * @params  : contains mac address for P2P device.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+struct wireless_dev *
+#else /*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+struct net_device *
+#endif				/*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+wland_p2p_add_vif(struct wiphy *wiphy,
+	const char *name,
+	enum nl80211_iftype type, u32 * flags, struct vif_params *params)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_if *ifp = netdev_priv(cfg_to_ndev(cfg));
+	struct wland_cfg80211_vif *vif;
+	enum wland_fil_p2p_if_types iftype;
+	enum wland_mode mode;
+	s32 err, timeout;
+
+	if (wland_cfg80211_vif_event_armed(cfg))
+		return ERR_PTR(-EBUSY);
+
+	WLAND_DBG(CFG80211, TRACE, "adding vif \"%s\" (type=%d)\n", name, type);
+
+	switch (type) {
+	case NL80211_IFTYPE_P2P_CLIENT:
+		iftype = FIL_P2P_IF_CLIENT;
+		mode = WL_MODE_BSS;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		iftype = FIL_P2P_IF_GO;
+		mode = WL_MODE_AP;
+		break;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return wland_p2p_create_p2pdev(&cfg->p2p, wiphy,
+			params->macaddr);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	default:
+		return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	vif = wland_alloc_vif(cfg, type, false);
+	if (IS_ERR(vif))
+		return NULL;
+
+	wland_cfg80211_arm_vif_event(cfg, vif);
+
+	err = wland_p2p_request_p2p_if(&cfg->p2p, ifp, cfg->p2p.int_addr,
+		iftype);
+	if (err < 0) {
+		wland_cfg80211_arm_vif_event(cfg, NULL);
+		goto fail;
+	}
+
+	/*
+	 * wait for firmware event
+	 */
+	err = wland_cfg80211_wait_vif_event_timeout(cfg, WLAND_E_IF_ADD,
+		msecs_to_jiffies(1500));
+	wland_cfg80211_arm_vif_event(cfg, NULL);
+	if (!err) {
+		WLAND_ERR("timeout occurred\n");
+		err = -EIO;
+		goto fail;
+	}
+
+	/*
+	 * interface created in firmware
+	 */
+	ifp = vif->ifp;
+	if (!ifp) {
+		WLAND_ERR("no if pointer provided\n");
+		err = -ENOENT;
+		goto fail;
+	}
+
+	strncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);
+
+	err = netdev_attach(ifp);
+	if (err < 0) {
+		WLAND_ERR("Registering netdevice failed\n");
+		goto fail;
+	}
+	/*
+	 * override destructor
+	 */
+	ifp->ndev->destructor = cfg80211_free_p2p_if;
+
+	cfg->p2p.bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = vif;
+
+	/*
+	 * Disable firmware roaming for P2P interface
+	 */
+	mode = 1;
+	wland_fil_iovar_data_set(ifp, "roam_off", &mode, sizeof(u8));
+
+	if (iftype == FIL_P2P_IF_GO) {
+		/*
+		 * set station timeout for p2p
+		 */
+		wland_fil_iovar_data_set(vif->ifp, "scb_timeout", &timeout,
+			sizeof(s32));
+	}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+	return &ifp->vif->wdev;
+#else /*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+	return ifp->ndev;
+#endif /*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+
+fail:
+	wland_free_vif(cfg, vif);
+	return ERR_PTR(err);
+}
+
+/*
+ * wland_p2p_del_vif() - delete a P2P virtual interface.
+ *
+ * @wiphy   : wiphy device of interface.
+ * @wdev    : wireless device of interface.
+ */
+s32 wland_p2p_del_vif(struct wiphy * wiphy, struct wireless_dev * wdev)
+{
+	struct wland_cfg80211_info *cfg = wiphy_priv(wiphy);
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+	ulong jiffie_timeout = msecs_to_jiffies(1500);
+	bool wait_for_disable = false;
+	s32 err;
+
+	WLAND_DBG(DEFAULT, TRACE, "delete P2P vif\n");
+
+	switch (vif->wdev.iftype) {
+	case NL80211_IFTYPE_P2P_CLIENT:
+		if (test_bit(VIF_STATUS_DISCONNECTING, &vif->sme_state))
+			wait_for_disable = true;
+		break;
+
+	case NL80211_IFTYPE_P2P_GO:
+		if (!wland_p2p_disable_p2p_if(vif))
+			wait_for_disable = true;
+		break;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	case NL80211_IFTYPE_P2P_DEVICE:
+		wland_p2p_delete_p2pdev(cfg, vif);
+		return 0;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	default:
+		return -ENOTSUPP;
+	}
+
+	clear_bit(P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+
+	WLAND_DBG(CFG80211, TRACE, "P2P: GO_NEG_PHASE status cleared\n");
+
+	if (wait_for_disable)
+		wait_for_completion_timeout(&cfg->vif_disabled,
+			msecs_to_jiffies(500));
+
+	wland_vif_clear_mgmt_ies(vif);
+
+	wland_cfg80211_arm_vif_event(cfg, vif);
+
+	err = wland_p2p_release_p2p_if(vif);
+	if (!err) {
+		/*
+		 * wait for firmware event
+		 */
+		err = wland_cfg80211_wait_vif_event_timeout(cfg, WLAND_E_IF_DEL,
+			jiffie_timeout);
+		if (!err)
+			err = -EIO;
+		else
+			err = 0;
+	}
+
+	wland_cfg80211_arm_vif_event(cfg, NULL);
+
+	p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = NULL;
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+s32 cfg80211_p2p_start_device(struct wiphy * wiphy, struct wireless_dev * wdev)
+{
+	s32 err;
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	mutex_lock(&cfg->usr_sync);
+	err = wland_p2p_enable_discovery(p2p);
+	if (!err)
+		set_bit(VIF_STATUS_READY, &vif->sme_state);
+	mutex_unlock(&cfg->usr_sync);
+
+	return err;
+}
+
+void cfg80211_p2p_stop_device(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+	struct wland_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_cfg80211_vif *vif =
+		container_of(wdev, struct wland_cfg80211_vif, wdev);
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	mutex_lock(&cfg->usr_sync);
+	wland_p2p_deinit_discovery(p2p);
+	wland_abort_scanning(cfg);
+	clear_bit(VIF_STATUS_READY, &vif->sme_state);
+	mutex_unlock(&cfg->usr_sync);
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+
+/*
+ * cfg80211_p2p_attach() - attach for P2P.
+ *
+ * @cfg: driver private data for cfg80211 interface.
+ */
+s32 cfg80211_p2p_attach(struct wland_cfg80211_info *cfg)
+{
+	struct wland_if *pri_ifp = NULL;
+	struct wland_if *p2p_ifp = NULL;
+	struct wland_cfg80211_vif *p2p_vif = NULL;
+	struct wland_p2p_info *p2p = &cfg->p2p;
+	struct wland_private *drvr = cfg->pub;
+	s32 err = 0;
+	u8 enable = 1;
+
+	p2p->cfg = cfg;
+
+	/*
+	 * primary vif same to "wlan0"
+	 */
+	pri_ifp = drvr->iflist[0];
+	p2p_ifp = drvr->iflist[1];
+
+	p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif = pri_ifp->vif;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter(pri_ifp:%p,p2p_ifp:%p)\n", pri_ifp,
+		p2p_ifp);
+
+	if (p2p_ifp) {
+		p2p_vif = wland_alloc_vif(cfg,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+			NL80211_IFTYPE_P2P_DEVICE,
+#else /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+			NL80211_IFTYPE_P2P_CLIENT,
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+			false);
+		if (IS_ERR(p2p_vif)) {
+			WLAND_ERR("could not create discovery vif\n");
+			err = -ENOMEM;
+			goto exit;
+		}
+
+		p2p_vif->ifp = p2p_ifp;
+		p2p_ifp->vif = p2p_vif;
+		p2p_vif->wdev.netdev = p2p_ifp->ndev;
+		p2p_ifp->ndev->ieee80211_ptr = &p2p_vif->wdev;
+
+		SET_NETDEV_DEV(p2p_ifp->ndev, wiphy_dev(cfg->wiphy));
+
+		p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif = p2p_vif;
+
+		wland_p2p_generate_bss_mac(p2p, NULL);
+
+		memcpy(p2p_ifp->mac_addr, p2p->dev_addr, ETH_ALEN);
+
+		wland_p2p_set_firmware(pri_ifp, p2p->dev_addr);
+
+		/*
+		 * Initialize P2P Discovery in the firmware
+		 */
+		err = wland_fil_iovar_data_set(pri_ifp, "p2p_disc", &enable,
+			sizeof(u8));
+		if (err < 0) {
+			WLAND_ERR("set p2p_disc error\n");
+			wland_free_vif(cfg, p2p_vif);
+			goto exit;
+		}
+
+		init_completion(&p2p->send_af_done);
+		INIT_WORK(&p2p->afx_hdl.afx_work, wland_p2p_afx_handler);
+		init_completion(&p2p->afx_hdl.act_frm_scan);
+		init_completion(&p2p->wait_next_af);
+	}
+exit:
+	return err;
+}
+
+/*
+ * cfg80211_p2p_detach() - detach P2P.
+ *
+ * @p2p: P2P specific data.
+ */
+void cfg80211_p2p_detach(struct wland_p2p_info *p2p)
+{
+	struct wland_cfg80211_vif *vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+	WLAND_DBG(CFG80211, TRACE, "Enter\n");
+
+	if (vif) {
+		wland_p2p_cancel_remain_on_channel(vif->ifp);
+		wland_p2p_deinit_discovery(p2p);
+		/*
+		 * remove discovery interface
+		 */
+		wland_free_vif(p2p->cfg, vif);
+		p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif = NULL;
+	}
+	/*
+	 * just set it all to zero
+	 */
+	memset(p2p, '\0', sizeof(*p2p));
+}
+
+#endif /* WLAND_P2P_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.h
new file mode 100644
index 000000000000..a0fa2f27d0b6
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_p2p.h
@@ -0,0 +1,214 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_P2P_H_
+#define _WLAND_P2P_H_
+
+#include <net/cfg80211.h>
+
+struct wland_cfg80211_info;
+
+/*
+ * enum p2p_bss_type - different type of BSS configurations.
+ *
+ * @P2PAPI_BSSCFG_PRIMARY: maps to driver's primary bsscfg.
+ * @P2PAPI_BSSCFG_DEVICE:  maps to driver's P2P device discovery bsscfg.
+ * @P2PAPI_BSSCFG_CONNECTION: maps to driver's P2P connection bsscfg.
+ * @P2PAPI_BSSCFG_MAX: used for range checking.
+ */
+enum p2p_bss_type {
+	P2PAPI_BSSCFG_PRIMARY,	/* maps to driver's primary bsscfg */
+	P2PAPI_BSSCFG_DEVICE,	/* maps to driver's P2P device discovery bsscfg */
+	P2PAPI_BSSCFG_CONNECTION,	/* maps to driver's P2P connection bsscfg */
+	P2PAPI_BSSCFG_MAX
+};
+
+/*
+ * struct p2p_bss - peer-to-peer bss related information.
+ *
+ * @vif         : virtual interface of this P2P bss.
+ * @private_data: TBD
+ */
+struct p2p_bss {
+	struct wland_cfg80211_vif *vif;
+	void *private_data;
+};
+
+/*
+ * enum wland_p2p_status - P2P specific dongle status.
+ *
+ * @P2P_STATUS_IF_ADD                : peer-to-peer vif add sent to dongle.
+ * @P2P_STATUS_IF_DEL                : NOT-USED?
+ * @P2P_STATUS_IF_DELETING           : peer-to-peer vif delete sent to dongle.
+ * @P2P_STATUS_IF_CHANGING           : peer-to-peer vif change sent to dongle.
+ * @P2P_STATUS_IF_CHANGED            : peer-to-peer vif change completed on dongle.
+ * @P2P_STATUS_ACTION_TX_COMPLETED   : action frame tx completed.
+ * @P2P_STATUS_ACTION_TX_NOACK       : action frame tx not acked.
+ * @P2P_STATUS_GO_NEG_PHASE          : P2P GO negotiation ongoing.
+ * @P2P_STATUS_DISCOVER_LISTEN       : P2P listen, remaining on channel.
+ * @P2P_STATUS_SENDING_ACT_FRAME     : In the process of sending action frame.
+ * @P2P_STATUS_WAITING_NEXT_AF_LISTEN: extra listen time for af tx.
+ * @P2P_STATUS_WAITING_NEXT_ACT_FRAME: waiting for action frame response.
+ * @P2P_STATUS_FINDING_COMMON_CHANNEL: search channel for AF active.
+ */
+enum wland_p2p_status {
+	P2P_STATUS_ENABLED,
+	P2P_STATUS_IF_ADD,
+	P2P_STATUS_IF_DEL,
+	P2P_STATUS_IF_DELETING,
+	P2P_STATUS_IF_CHANGING,
+	P2P_STATUS_IF_CHANGED,
+	P2P_STATUS_ACTION_TX_COMPLETED,
+	P2P_STATUS_ACTION_TX_NOACK,
+	P2P_STATUS_GO_NEG_PHASE,
+	P2P_STATUS_DISCOVER_LISTEN,
+	P2P_STATUS_SENDING_ACT_FRAME,
+	P2P_STATUS_WAITING_NEXT_AF_LISTEN,
+	P2P_STATUS_WAITING_NEXT_ACT_FRAME,
+	P2P_STATUS_FINDING_COMMON_CHANNEL
+};
+
+/*
+ * struct afx_hdl - action frame off channel storage.
+ *
+ * @afx_work        : worker thread for searching channel
+ * @act_frm_scan    : thread synchronizing struct.
+ * @is_active       : channel searching active.
+ * @peer_chan       : current channel.
+ * @is_listen       : sets mode for afx worker.
+ * @my_listen_chan  : this peers listen channel.
+ * @peer_listen_chan: remote peers listen channel.
+ * @tx_dst_addr     : mac address where tx af should be sent to.
+ */
+struct afx_hdl {
+	struct work_struct afx_work;
+	struct completion act_frm_scan;
+	bool is_active;
+	s32 peer_chan;
+	bool is_listen;
+	u16 my_listen_chan;
+	u16 peer_listen_chan;
+	u8 tx_dst_addr[ETH_ALEN];
+};
+
+/*
+ * struct wland_p2p_info - p2p specific driver information.
+ *
+ * @cfg                     : driver private data for cfg80211 interface.
+ * @status                  : status of P2P (see enum wland_p2p_status).
+ * @dev_addr                : P2P device address.
+ * @int_addr                : P2P interface address.
+ * @bss_idx                 : informate for P2P bss types.
+ * @listen_timer            : timer for @WL_P2P_DISC_ST_LISTEN discover state.
+ * @ssid                    : ssid for P2P GO.
+ * @listen_channel          : channel for @WL_P2P_DISC_ST_LISTEN discover state.
+ * @remain_on_channel       : contains copy of struct used by cfg80211.
+ * @remain_on_channel_cookie: cookie counter for remain on channel cmd
+ * @next_af_subtype         : expected action frame subtype.
+ * @send_af_done            : indication that action frame tx is complete.
+ * @afx_hdl                 : action frame search handler info.
+ * @af_sent_channel         : channel action frame is sent.
+ * @af_tx_sent_jiffies      : jiffies time when af tx was transmitted.
+ * @wait_next_af            : thread synchronizing struct.
+ * @gon_req_action          : about to send go negotiation requets frame.
+ * @block_gon_req_tx        : drop tx go negotiation requets frame.
+ */
+struct wland_p2p_info {
+	struct wland_cfg80211_info *cfg;
+	ulong status;
+	u8 dev_addr[ETH_ALEN];
+	u8 int_addr[ETH_ALEN];
+	struct p2p_bss bss_idx[P2PAPI_BSSCFG_MAX];
+	struct timer_list listen_timer;
+	struct wland_ssid ssid;
+	u8 listen_channel;
+	struct ieee80211_channel remain_on_channel;
+	enum nl80211_channel_type remain_on_chan_type;
+	u32 remain_on_channel_cookie;
+	u8 next_af_subtype;
+	struct completion send_af_done;
+	struct afx_hdl afx_hdl;
+	u32 af_sent_channel;
+	u32 af_tx_sent_jiffies;
+	struct completion wait_next_af;
+	bool gon_req_action;
+	bool block_gon_req_tx;
+};
+
+#ifdef WLAND_P2P_SUPPORT
+extern s32 cfg80211_p2p_attach(struct wland_cfg80211_info *cfg);
+extern void cfg80211_p2p_detach(struct wland_p2p_info *p2p);
+
+/*
+ * wland_p2p_add_vif() - create a new P2P virtual interface.
+ *
+ * @wiphy   : wiphy device of new interface.
+ * @name    : name of the new interface.
+ * @type    : nl80211 interface type.
+ * @flags   : not used.
+ * @params  : contains mac address for P2P device.
+ */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+extern struct wireless_dev *
+#else /*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+extern struct net_device *
+#endif				/*LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0) */
+
+wland_p2p_add_vif(struct wiphy *wiphy,
+	const char *name,
+	enum nl80211_iftype type, u32 * flags, struct vif_params *params);
+
+extern s32 wland_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev);
+extern s32 wland_p2p_ifchange(struct wland_cfg80211_info *cfg,
+	enum wland_fil_p2p_if_types if_type);
+extern s32 wland_p2p_scan_prep(struct wiphy *wiphy,
+	struct cfg80211_scan_request *request, struct wland_cfg80211_vif *vif);
+
+extern void wland_p2p_cancel_remain_on_channel(struct wland_if *ifp);
+
+extern s32 cfg80211_p2p_start_device(struct wiphy *wiphy,
+	struct wireless_dev *wdev);
+extern void cfg80211_p2p_stop_device(struct wiphy *wiphy,
+	struct wireless_dev *wdev);
+
+extern int cfg80211_p2p_remain_on_channel(struct wiphy *wiphy,
+#if    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct wireless_dev *wdev,
+#else				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct net_device *dev,
+#endif				/*LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0) */
+	struct ieee80211_channel *channel,
+	enum nl80211_channel_type channel_type,
+	unsigned int duration, u64 * cookie);
+
+/* p2p event callback */
+extern s32 notify_p2p_listen_complete(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data);
+extern s32 notify_p2p_rx_mgmt_probereq(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data);
+extern s32 notify_p2p_action_frame_rx(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data);
+extern s32 notify_p2p_action_tx_complete(struct wland_if *ifp,
+	const struct wland_event_msg *e, void *data);
+
+/* p2p action */
+extern bool wland_p2p_send_action_frame(struct wland_cfg80211_info *cfg,
+	struct net_device *ndev, struct wland_fil_af_params_le *af_params);
+extern bool wland_p2p_scan_finding_common_channel(struct wland_cfg80211_info
+	*cfg, struct wland_bss_info_le *bi, u8 * ie);
+
+#endif /* WLAND_P2P_SUPPORT */
+#endif /* _WLAND_P2P_H_     */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_sdio.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdio.c
new file mode 100644
index 000000000000..6645720295d0
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdio.c
@@ -0,0 +1,1793 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/kthread.h>
+#include <linux/printk.h>
+#include <linux/export.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/scatterlist.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/vmalloc.h>
+#include <asm/unaligned.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+static const char wland_version_string[WLAND_VER_MAX][15] = {
+	"Unknow chip",
+	"RDA5990_D",
+	"RDA5990_E",
+	"RDA5991_D",
+	"RDA5991_E",
+	"RDA5991_F",
+	"RDA5991_G",
+};
+
+static void wland_pkt_word_align(struct sk_buff *p)
+{
+	uint datalign = ALIGNMENT;
+	uint offset = ((unsigned long) (p->data) & (datalign - 1));
+
+	if (offset) {
+		skb_reserve(p, (datalign - offset));
+	}
+}
+
+/* Turn backplane clock on or off */
+static int sdio_htclk(struct wland_sdio *bus, bool on)
+{
+
+	WLAND_DBG(SDIO, TRACE, "(%s): Enter\n", on ? " Open" : "Stop");
+
+	if (on) {
+
+		/*
+		 * Mark clock available
+		 */
+		bus->clkstate = CLK_AVAIL;
+		bus->activity = true;
+		BUS_WAKE(bus);
+		WLAND_DBG(SDIO, TRACE, "CLKCTL: turned ON\n");
+	} else {
+
+		bus->clkstate = CLK_NONE;
+		bus->activity = false;
+		WLAND_DBG(SDIO, TRACE, "CLKCTL: turned OFF\n");
+
+	}
+
+	WLAND_DBG(SDIO, TRACE, "(%s): Done.\n", on ? " Open" : "Stop");
+
+	return 0;
+}
+
+int wland_chip_wake_up(struct wland_sdio *bus)
+{
+	int ret = 0;
+
+#ifdef	WLAND_POWER_MANAGER
+	u8 u8Val = 1;
+#endif
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	//Tx complete, check whether go to sleep.
+	if (!bus->activity && (bus->sdiodev->card_sleep)) {
+#ifdef	WLAND_POWER_MANAGER
+		if (!check_test_mode() ) {
+			WLAND_DBG(SDIO, TRACE,
+				"WIFI chip wake up <<<<<<<<< \n");
+			sdio_claim_host(bus->sdiodev->func);
+			ret = sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+				URSDIO_FUNC1_INT_TO_DEVICE, &u8Val);
+			sdio_release_host(bus->sdiodev->func);
+			if (ret) {
+				WLAND_ERR
+					("Write URSDIO_FUNC1_INT_TO_DEVICE failed!\n");
+			}
+			bus->sdiodev->card_sleep = false;
+			wland_sched_timeout(10);
+		}
+#endif
+		if (!sdio_htclk(bus, true)) {
+			WLAND_DBG(SDIO, TRACE, "WIFI chip waked up and MOD timer. \n");
+			wland_sdio_wd_timer(bus, bus->save_ms);
+		}
+	}
+	WLAND_DBG(SDIO, TRACE, "Done.\n");
+	return ret;
+}
+
+int wland_chip_goto_sleep(struct wland_sdio *bus)
+{
+	int ret = 0;
+
+#ifdef	WLAND_POWER_MANAGER
+	u8 u8Val = URSDIO_FUNC1_HOST_TX_FLAG;
+#endif
+	struct wland_sdio_dev *sdiodev = bus->sdiodev;
+	struct wland_bus *bus_if = sdiodev->bus_if;
+	struct wland_private *drvr = bus_if->drvr;
+	struct wland_if *ifp = drvr->iflist[0];
+	struct wland_cfg80211_info *cfg;
+	struct wland_cfg80211_connect_info *conn_info;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	if (bus_if->state == WLAND_BUS_DOWN) {
+#ifdef	WLAND_POWER_MANAGER
+		sdio_claim_host(bus->sdiodev->func);
+		ret = sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+			URSDIO_FUNC1_INT_PENDING, &u8Val);
+		sdio_release_host(bus->sdiodev->func);
+		if (ret) {
+			WLAND_ERR("Write URSDIO_FUNC1_INT_PENDING failed!\n");
+		}
+		bus->sdiodev->card_sleep = true;
+#endif
+		wland_sdio_wd_timer(bus, 0);
+		return ret;
+	}
+	cfg = wiphy_priv(ifp->vif->wdev.wiphy);
+	conn_info = &cfg->conn_info;
+
+	//Tx complete, check whether go to sleep.
+	if (bus->activity &&
+		!check_test_mode() &&
+		!test_bit(SCAN_STATUS_BUSY, &cfg->scan_status) &&
+		!test_bit(VIF_STATUS_CONNECTING, &ifp->vif->sme_state) &&
+		!timer_pending(&conn_info->connect_restorework_timeout)) {
+#ifdef	WLAND_POWER_MANAGER
+		if (!check_test_mode()){
+			WLAND_DBG(SDIO, TRACE,
+				"WIFI chip enter sleep. >>>>>>>>>>> \n");
+			sdio_claim_host(bus->sdiodev->func);
+			ret = sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+				URSDIO_FUNC1_INT_PENDING, &u8Val);
+			sdio_release_host(bus->sdiodev->func);
+			if (ret) {
+				WLAND_ERR
+					("Write URSDIO_FUNC1_INT_PENDING failed!\n");
+			}
+			bus->sdiodev->card_sleep = true;
+		}
+#endif
+		WLAND_DBG(SDIO, TRACE, "turn OFF clock and delete wd timer.\n");
+		sdio_htclk(bus, false);
+		wland_sdio_wd_timer(bus, 0);
+	}else{
+		BUS_WAKE(bus);
+		wland_sdio_wd_timer(bus, bus->save_ms);
+	}
+
+	WLAND_DBG(SDIO, TRACE, "Done.\n");
+	return ret;
+}
+
+/* Change idle/active SD state,Transition SD and backplane clock readiness */
+int wland_sdio_clkctl(struct wland_sdio *bus, uint target)
+{
+	int ret = 0;
+	uint oldstate = bus->clkstate;
+
+	WLAND_DBG(SDIO, TRACE, "=========>OldState(%d),ExpectState(%d),Enter\n",
+		bus->clkstate, target);
+	if (bus->sdiodev->bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("bus_if is down, can't operate sdio clock!\n");
+		ret = -1;
+		return ret;
+	}
+
+	/*
+	 * Early exit if we're already there
+	 */
+	if (bus->clkstate == target) {
+		if (target == CLK_AVAIL) {
+			BUS_WAKE(bus);
+			wland_sdio_wd_timer(bus, bus->save_ms);
+		}
+		return ret;
+	}
+
+	switch (target) {
+	case CLK_AVAIL:
+		//Request SDIO clock
+		/*
+		 * Make sure SD clock is available
+		 */
+		WLAND_DBG(SDIO, TRACE, "CLK_NONE --> CLK_AVAIL\n");
+		wland_chip_wake_up(bus);
+		break;
+
+	case CLK_NONE:
+		//Remove SDIO clock
+		/*
+		 * Now remove the SD clock
+		 */
+		WLAND_DBG(SDIO, TRACE, "CLK_AVAIL --> CLK_NONE\n");
+		wland_chip_goto_sleep(bus);
+		break;
+	}
+
+	WLAND_DBG(SDIO, TRACE, "=========>OldState(%d)--->NewState(%d),Done\n",
+		oldstate, bus->clkstate);
+
+	return ret;
+}
+
+static struct sk_buff *wland_pkt_buf_get_suitable_skb(struct wland_sdio *bus,
+	struct sk_buff *skb, u16 * len)
+{
+	struct sk_buff *skb2 = skb;
+	u16 base_len = *len;
+	u16 size = *len;
+	int ret = 0;
+
+	WLAND_DBG(SDIO, TRACE, "Enter, size=%d\n", size);
+
+	//for sdio must 4 bytes align
+	if (size & (ALIGNMENT - 1))
+		size = roundup(size, ALIGNMENT);
+
+	size = wland_get_align_size(bus, size);
+
+	if (!skb) {		// just get a suitable skb.
+		skb2 = wland_pkt_buf_get_skb(size + ALIGNMENT - 1);
+		if (!skb2) {
+			WLAND_ERR("couldn't allocate new %d-byte packet\n",
+				size + ALIGNMENT - 1);
+			ret = -ENOMEM;
+		} else {
+			wland_pkt_word_align(skb2);
+		}
+		goto done;
+	} else if (size - base_len >= 3) {
+		skb2 = wland_pkt_buf_get_skb(size);
+		if (!skb2) {
+			WLAND_ERR("couldn't allocate new %d-byte packet\n",
+				size);
+			ret = -ENOMEM;
+			goto done;
+		} else {
+			wland_pkt_word_align(skb2);
+		}
+	} else if ((size - base_len < 3)
+		&& !IS_ALIGNED((int) skb->data, ALIGNMENT)) {
+		skb2 = wland_pkt_buf_get_skb(size + ALIGNMENT - 1);
+		if (!skb2) {
+			WLAND_ERR("couldn't allocate new %d-byte packet\n",
+				size + ALIGNMENT - 1);
+			ret = -ENOMEM;
+			goto done;
+		} else {
+			wland_pkt_word_align(skb2);
+		}
+
+	}
+
+done:
+        if (skb2 ) {
+	       *len = size;
+		skb2->len = size;
+		WLAND_DBG(SDIO, TRACE, "Done.\n");
+		return skb2;
+        } else {
+                WLAND_DBG(SDIO, TRACE, "Done.\n");
+                return NULL;
+        }
+}
+
+/* Writes a HW/SW header into the packet and sends it. */
+
+/* Assumes: (a) header space already there, (b) caller holds lock */
+static int wland_sdio_txpkt(struct wland_sdio *bus, struct sk_buff *pkt)
+{
+	int ret = 0;
+	u8 *frame;
+	u16 len = 0, real_len = 0;
+	struct wland_bus *bus_if = dev_get_drvdata(bus->sdiodev->dev);
+
+	WLAND_DBG(SDIO, TRACE, "Enter(bus_state:%d)\n", bus_if->state);
+
+	if (bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("Bus state is down and reject the pkt!\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Add Header
+	 */
+	PKTPUSH(bus_if->osh, pkt, WID_HEADER_LEN);
+
+	/*
+	 * Hardware tag: 2 byte len followed by 2 byte ~len check (all LE)
+	 */
+	frame = (u8 *) (pkt->data);
+	len = pkt->len & CDC_DCMD_LEN_MASK;
+	if (pkt->len > CDC_DCMD_LEN_MASK) {
+		WLAND_ERR("pkt->len is over flow!\n");
+		wland_pkt_buf_free_skb(pkt);
+		return -EINVAL;
+	}
+	real_len = len;
+	len |= (PKT_TYPE_REQ << CDC_DCMD_LEN_SHIFT);
+	*(__le16 *) frame = cpu_to_le16(len);
+	len = real_len;
+
+	WLAND_DBG(SDIO, DEBUG, "pkt->len=%x, frame:%x, addr(pkt->data)=%p\n", len,
+		*(__le16 *) frame, pkt->data);
+
+	if (len & (ALIGNMENT - 1))
+		len = roundup(len, ALIGNMENT);
+
+	len = wland_get_align_size(bus, len);
+
+/*	 skb2 = wland_pkt_buf_get_suitable_skb(bus, pkt, &len);
+	 if(skb2 != pkt){
+	      memcpy(skb2->data, pkt->data, real_len);
+	      wland_pkt_buf_free_skb(pkt);
+	      pkt = skb2;
+	      WLAND_DBG(SDIO, TRACE, "Get new pkt!  pkt->len=%d, addr(pkt->data)=%p\n", len, pkt->data);
+	 }
+*/
+
+	WLAND_DBG(SDIO, TRACE,
+		"real_len=%d, len=%d, pkt->len=%d, pkt->data:0x%p\n", real_len,
+		len, pkt->len, pkt->data);
+	WLAND_DUMP(TX_MSDU, pkt->data, real_len, "MSDU len:%Zu\n", real_len);
+	ret = wland_sdio_send_pkt(bus, pkt, len);
+
+	/*
+	 * Add Header
+	 */
+	PKTPULL(bus_if->osh, pkt, WID_HEADER_LEN);
+
+	wland_txcomplete(bus->sdiodev->dev, pkt, (ret == 0));
+	return ret;
+}
+
+static uint wland_sdio_sendfromq(struct wland_sdio *bus)
+{
+	struct sk_buff *pkt;
+	uint cnt = 0;
+	unsigned long flags = 0;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	/*
+	 * Send frames until the limit or some other event
+	 */
+	dhd_os_sdlock_txq(bus, &flags);
+	pkt = wland_pktq_mdeq(&bus->txq);
+	dhd_os_sdunlock_txq(bus, &flags);
+	if (pkt == NULL) {
+		WLAND_ERR("pkt == NULL and go out.\n");
+		goto done;
+	}
+	atomic_dec(&bus->tx_dpc_tskcnt);
+
+	wland_sdio_txpkt(bus, pkt);
+	WLAND_DBG(BUS, TRACE,
+		"After wland_sdio_txpkt(), pktq len=%d, bus->tx_dpc_tskcnt=%d\n",
+		bus->txq.len, atomic_read(&bus->tx_dpc_tskcnt));
+
+	/*
+	 * Deflow-control stack if needed
+	 */
+	if ((bus->sdiodev->bus_if->state == WLAND_BUS_DATA) && bus->txoff
+		&& (bus->txq.len < TXLOW)) {
+		bus->txoff = false;
+
+		wland_txflowcontrol(bus->sdiodev->dev, false);
+	}
+
+done:
+	WLAND_DBG(BUS, TRACE, "Done\n");
+	return cnt;
+}
+
+static int wland_sdio_intr_set(struct wland_sdio_dev *sdiodev, bool enable)
+{
+	u8 val;
+	int ret;
+
+	WLAND_DBG(SDIO, TRACE, "Enter(interrupt %s)\n",
+		enable ? "enable" : "disable");
+
+	if (enable)
+		val = 0x07;
+	else
+		val = 0x00;
+
+	/*
+	 * set chip interrupt
+	 */
+	ret = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+		URSDIO_FUNC1_REGISTER_MASK, &val);
+	return ret;
+}
+
+static int wland_sdio_intr_get(struct wland_sdio_dev *sdiodev, u8 * intrstatus)
+{
+	int ret = 0;
+
+	if (!intrstatus)
+		return -EBADE;
+
+	if (sdiodev->bus_if->state == WLAND_BUS_DOWN) {
+		/*
+		 * disable interrupt
+		 */
+		*intrstatus = 0;
+		WLAND_ERR("Bus is down!\n");
+	} else {
+		ret = sdioh_request_byte(sdiodev, SDIOH_READ,
+			URSDIO_FUNC1_INT_STATUS, intrstatus);
+	}
+
+	WLAND_DBG(SDIO, TRACE, "Enter(interrupt status: 0x%x)\n",
+		(uint) * intrstatus);
+
+	return ret;
+}
+
+static void wland_sdio_bus_stop(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+	int ret;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	if (bus->watchdog_tsk) {
+		send_sig(SIGTERM, bus->watchdog_tsk, 1);
+		kthread_stop(bus->watchdog_tsk);
+		bus->watchdog_tsk = NULL;
+	}
+
+	bus_if->state = WLAND_BUS_DOWN;
+	/*
+	 * Turn off the backplane clock (only)
+	 */
+	ret = down_interruptible(&bus->txclk_sem);
+	if (ret)
+		WLAND_ERR("Can not request bus->txclk_sem.wland_sdio_bus_stop\n");
+
+	wland_sdio_clkctl(bus, CLK_NONE);
+	if (!ret)
+		up(&bus->txclk_sem);
+	/*
+	 * Clear the data packet queues
+	 */
+	wland_pktq_flush(&bus->txq, true, NULL, NULL);
+	wland_pktq_flush(&bus->rxq, true, NULL, NULL);
+
+	/*
+	 * Clear rx control and wake any waiters
+	 */
+	spin_lock_bh(&bus->rxctl_lock);
+	bus->rxlen = 0;
+	spin_unlock_bh(&bus->rxctl_lock);
+
+	dhd_os_ioctl_resp_wake(bus);
+	WLAND_DBG(SDIO, TRACE, "Done.\n");
+}
+
+static s32 wland_handle_mac_status(struct wland_private *drvr,
+	struct wland_event_msg *event_packet, u8 * pu8Buffer)
+{
+	u8 u8MsgType = 0, u8WidLen = 0, u8MacStatus, u8MsgID = 0;
+	u16 u16MsgLen = 0, u16WidID = WID_NIL;
+
+	/*
+	 * parse type
+	 */
+	u8MsgType = pu8Buffer[0];
+
+	/*
+	 * Check whether the received message type is 'I'
+	 */
+	if (WLAND_WID_MSG_MAC_STATUS != u8MsgType) {
+		WLAND_ERR("Received Message type incorrect.\n");
+		return -EBADE;
+	}
+
+	/*
+	 * Extract message ID
+	 */
+	u8MsgID = pu8Buffer[1];
+
+	/*
+	 * Extract message Length
+	 */
+	u16MsgLen = MAKE_WORD16(pu8Buffer[2], pu8Buffer[3]);
+
+	/*
+	 * Extract WID ID [expected to be = WID_STATUS]
+	 */
+	u16WidID = MAKE_WORD16(pu8Buffer[4], pu8Buffer[5]);
+
+	if (u16WidID != WID_STATUS) {
+		WLAND_ERR("Received Message wid incorrect.\n");
+		return -EBADE;
+	}
+
+	/*
+	 * Extract WID Length [expected to be = 1]
+	 */
+	u8WidLen = pu8Buffer[6];
+
+	/*
+	 * get the WID value [expected to be one of two values: either MAC_CONNECTED = (1) or MAC_DISCONNECTED = (0)]
+	 */
+	u8MacStatus = pu8Buffer[7];
+
+	WLAND_DBG(EVENT, TRACE,
+		"Received(u8MsgID:0x%x,u16MsgLen:0x%x,u16WidID:0x%x,u8WidLen:0x%x,u8MacStatus:0x%x)\n",
+		u8MsgID, u16MsgLen, u16WidID, u8WidLen, u8MacStatus);
+
+	event_packet->status = STATUS_SUCCESS;
+
+	if (u8MacStatus == MAC_CONNECTED) {
+		event_packet->event_code = WLAND_E_CONNECT_IND;
+		WLAND_DBG(EVENT, DEBUG, "MAC CONNECTED\n");
+	} else if (u8MacStatus == MAC_DISCONNECTED) {
+		WLAND_DBG(EVENT, DEBUG, "MAC_DISCONNECTED\n");
+		event_packet->event_code = WLAND_E_DISCONNECT_IND;
+	} else {
+		WLAND_ERR("Invalid MAC Status 0x%02x\n", u8MacStatus);
+		return -EBADE;
+	}
+
+	firmweh_push_event(drvr, event_packet, pu8Buffer);
+
+	return 0;
+}
+
+static s32 wland_handle_network_link_event(struct wland_private *drvr,
+	struct wland_event_msg *event_packet, u8 * pu8Buffer)
+{
+	u8 u8MsgType = 0, u8EventType = 0;
+	u16 u16EventLen = 0;
+	s32 ret = 0;
+
+	/*
+	 * parse type
+	 */
+	u8MsgType = pu8Buffer[0];
+
+	/*
+	 * Check whether the received message type is 'I'
+	 */
+	if (WLAND_WID_MSG_EVENT != u8MsgType) {
+		WLAND_ERR("Received Message type incorrect.\n");
+		return -EBADE;
+	}
+
+	/*
+	 * Extract event Type
+	 */
+	u8EventType = pu8Buffer[1];
+
+	/*
+	 * Extract event Length
+	 */
+	u16EventLen = MAKE_WORD16(pu8Buffer[2], pu8Buffer[3]);
+
+	WLAND_DBG(EVENT, DEBUG,
+		"Received(u8MsgType:0x%x, u8EventType:%d, u16EventLen:%d \n",
+		u8MsgType, u8EventType, u16EventLen);
+
+	event_packet->action = u8EventType;
+	switch (u8EventType) {
+		WLAND_DBG(EVENT, DEBUG, "u8EventType=%d\n", u8EventType);
+	case EVENT_AUTH_IND:
+		WLAND_DBG(EVENT, DEBUG, "EVENT_AUTH_IND\n");
+		event_packet->event_code = WLAND_E_CONNECT_IND;
+		event_packet->status = STATUS_SUCCESS;
+		break;
+	case EVENT_DEAUTH_IND:
+		WLAND_DBG(EVENT, DEBUG, "EVENT_DEAUTH_IND\n");
+		event_packet->event_code = WLAND_E_DISCONNECT_IND;
+		break;
+	case EVENT_ASSOC_IND:
+		WLAND_DBG(EVENT, DEBUG, "EVENT_ASSOC_IND\n");
+		event_packet->event_code = WLAND_E_CONNECT_IND;
+		event_packet->status = STATUS_SUCCESS;
+		memcpy(event_packet->addr, &pu8Buffer[16], ETH_ALEN);
+		break;
+	case EVENT_REASSOC_IND:
+		WLAND_DBG(EVENT, DEBUG, "EVENT_REASSOC_IND\n");
+		event_packet->event_code = WLAND_E_CONNECT_IND;
+		event_packet->status = STATUS_SUCCESS;
+		break;
+	case EVENT_DISASSOC_IND:
+		WLAND_DBG(EVENT, DEBUG, "EVENT_DISASSOC_IND\n");
+		event_packet->event_code = WLAND_E_DISCONNECT_IND;
+		break;
+	default: {
+		ret = -EBADE;
+		WLAND_ERR("Receive invalid event type!\n");
+		break;
+	}
+	}
+
+	firmweh_push_event(drvr, event_packet, pu8Buffer);
+
+	return ret;
+}
+
+/*
+ * wland_sdio_readframes() - just process skb as firmware event.
+ *
+ * If the packet buffer contains a firmware event message it will
+ * dispatch the event to a registered handler (using worker).
+ */
+struct sk_buff *wland_sdio_readframes(struct wland_sdio *bus)
+{
+	int ret = 0;
+	u8 size_l = 0, size_h = 0;
+	u16 rcv_len = 0;
+	u16 size = 0;
+	struct sk_buff *skb = NULL;
+	struct wland_bus *bus_if = dev_get_drvdata(bus->sdiodev->dev);
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	if (bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("Bus is down and go out!\n");
+		goto done;
+	}
+
+	ret = sdioh_request_byte(bus->sdiodev, SDIOH_READ,
+		URSDIO_FUNC1_RPKTLEN_LO, &size_l);
+	if (ret) {
+		WLAND_ERR("Read SDIO_AHB2SDIO_PKTLEN_L failed!\n");
+		goto done;
+	}
+	ret = sdioh_request_byte(bus->sdiodev, SDIOH_READ,
+				URSDIO_FUNC1_RPKTLEN_HI, &size_h);
+	if (ret) {
+		WLAND_ERR("Read SDIO_AHB2SDIO_PKTLEN_H failed!\n");
+		goto done;
+	}
+	size = (size_l | ((size_h & 0x7F) << 8)) * 4;
+
+	if ((size > WLAND_MAX_BUFSZ) || (size < FMW_HEADER_LEN)) {
+		WLAND_ERR("received buffer is invalid(size:%d) and go out.\n",
+			size);
+		goto done;
+	}
+
+	WLAND_DBG(SDIO, TRACE, "received buffer size:%d.\n", size);
+
+	skb =  dev_alloc_skb(size + NET_IP_ALIGN + WID_HEADER_LEN + 3);
+	if(!skb){
+		WLAND_ERR("dev_alloc_skb alloc skb failed \n");
+		goto done;
+	}
+
+	skb_reserve(skb, NET_IP_ALIGN);
+	//4byte align
+	wland_pkt_word_align(skb);
+
+	ret = wland_sdio_recv_pkt(bus, skb, size);
+	if (ret) {
+		WLAND_ERR("receive skb failed\n");
+		dev_kfree_skb(skb);
+		skb = NULL;
+		goto done;
+	}
+	rcv_len = (u16)(skb->data[0] | ((skb->data[1]&0x0f) << 8));
+	if(rcv_len > size){
+		WLAND_ERR("SDIO read payload_len invalid! \n");
+		dev_kfree_skb(skb);
+		skb = NULL;
+		goto done;
+	}
+	skb_put(skb, rcv_len);
+
+done:
+	WLAND_DBG(DEFAULT, TRACE, "Done\n");
+	return skb;
+}
+
+static int wland_sdio_process_rxframes(struct wland_sdio *bus)
+{
+	int ret = 0;
+	u8 rx_type, msg_type, *buf;
+	u16 size = 0, rx_len;
+	struct sk_buff *skb = NULL;	/* Packet for event or data frames */
+	struct wland_event_msg event_packet;
+	struct wland_bus *bus_if = dev_get_drvdata(bus->sdiodev->dev);
+	unsigned long flags = 0;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	if (bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("Bus down 3, ret\n");
+		return ret;
+	}
+
+	while (wland_pktq_mlen(&bus->rxq, ~bus->flowcontrol)) {
+		dhd_os_sdlock_rxq(bus, &flags);
+		skb = wland_pktq_mdeq(&bus->rxq);
+		dhd_os_sdunlock_rxq(bus, &flags);
+		atomic_dec(&bus->rx_dpc_tskcnt);
+		if (skb == NULL) {
+			break;
+		}
+
+		buf = PKTDATA(bus_if->osh, skb);
+		//WLAND_DUMP(SDIO, skb->data, skb->len, "RX Data, len:%Zu\n", skb->len);
+
+		/*
+		 * pull hdr from the skb
+		 */
+		size = skb->len;
+		rx_len = (u16) (buf[0] | ((buf[1] & 0x0F) << 8));
+		WLAND_DBG(SDIO, DEBUG, "size=%d, rx_len=%d, addr:%x\n", size, rx_len, (unsigned int)buf);
+		if (rx_len > size) {
+			WLAND_ERR("SDIO read payload_len invalid! \n");
+			wland_pkt_buf_free_skb(skb);
+			return -EIO;
+		}
+		rx_type = (u8) buf[1] >> 4;
+		//skb->len = rx_len;
+
+		if (rx_type == PKT_TYPE_CFG_RSP) {
+			msg_type = buf[2];
+
+			memset(&event_packet, 0, sizeof(event_packet));
+
+			/*
+			 * offset frame hdr
+			 */
+			event_packet.datalen = rx_len - WID_HEADER_LEN;
+
+			buf += WID_HEADER_LEN;
+
+			switch (msg_type) {
+			case WLAND_WID_MSG_RESP:
+				WLAND_DBG(EVENT, TRACE,
+					"Receive response(%s:total_len:%u,rx_len:%u,rx_type:%u)\n",
+					dev_name(bus->sdiodev->dev),
+					skb->len, rx_len, rx_type);
+				WLAND_DUMP(RX_WIDRSP, skb->data, skb->len,
+					"RX Data (WID_MSG_RESP), len:%Zu\n", skb->len);
+				spin_lock_bh(&bus->rxctl_lock);
+				bus->rxctl = bus->rxbuf;
+				bus->rxlen = rx_len;
+				memcpy(bus->rxctl, skb->data, rx_len);
+				spin_unlock_bh(&bus->rxctl_lock);
+				dhd_os_ioctl_resp_wake(bus);
+				wland_pkt_buf_free_skb(skb);
+				break;
+			case WLAND_WID_MSG_NETINFO:
+				WLAND_DBG(EVENT, TRACE,
+					"Receive info notify(%s:total_len:%u,rx_len:%u,rx_type:%u)\n",
+					dev_name(bus->sdiodev->dev),
+					skb->len, rx_len, rx_type);
+				WLAND_DUMP(RX_NETINFO, skb->data, skb->len,
+					"RX Data (WID_MSG_NETINFO), len:%Zu\n",
+					skb->len);
+				event_packet.event_code = WLAND_E_ESCAN_RESULT;
+				event_packet.status = STATUS_SUCCESS;
+				firmweh_push_event(bus_if->drvr, &event_packet, buf);
+				wland_pkt_buf_free_skb(skb);
+				break;
+			case WLAND_WID_MSG_EVENT:
+				WLAND_DBG(EVENT, DEBUG,
+					"Receive Network event(%s:total_len:%u,rx_len:%u,rx_type:%u)\n",
+					dev_name(bus->sdiodev->dev),
+					skb->len, rx_len, rx_type);
+				WLAND_DUMP(RX_NETEVENT, skb->data, skb->len,
+					"RX Data (WID_MSG_NETEVENT), len:%Zu\n",
+					skb->len);
+				wland_handle_network_link_event
+					(bus_if->drvr, &event_packet,buf);
+				wland_pkt_buf_free_skb(skb);
+				break;
+			case WLAND_WID_MSG_MAC_STATUS:
+				WLAND_DBG(EVENT, TRACE,
+					"Receive mac status notify(%s:total_len:%u,rx_len:%u,rx_type:%u)\n",
+					dev_name(bus->sdiodev->dev),
+					skb->len, rx_len, rx_type);
+				WLAND_DUMP(RX_MACSTAT, skb->data, skb->len,
+					"RX Data (WID_MSG_MAC_STATUS), len:%Zu\n",
+					skb->len);
+				wland_handle_mac_status(bus_if->drvr, &event_packet, buf);
+				wland_pkt_buf_free_skb(skb);
+				break;
+			default:
+				WLAND_ERR("receive invalid frames!\n");
+				wland_pkt_buf_free_skb(skb);
+				ret = -EBADE;
+				break;
+			}
+		} else {
+			WLAND_DBG(EVENT, TRACE, "MSDU data in.\n");
+			WLAND_DUMP(RX_MSDU, skb->data, skb->len,
+				"RX Data (BIN DATA), len:%Zu\n", skb->len);
+			PKTPULL(bus_if->osh, skb, WID_HEADER_LEN);
+			wland_rx_frames(bus->sdiodev->dev, skb);
+		}
+
+		WLAND_DBG(BUS, TRACE,
+			"Process rxframes, bus->rx_dpc_tskcnt=%d\n",
+			atomic_read(&bus->rx_dpc_tskcnt));
+	}
+	return ret;
+}
+
+static int wland_sdio_txctl_frames(struct wland_sdio *bus)
+{
+	int err = 0;
+	u16 payloadLen, nbytes;
+	u8 *payload = bus->ctrl_frame_buf;
+	struct sk_buff *pkt = NULL;
+
+	WLAND_DBG(DEFAULT, TRACE, "Enter\n");
+	nbytes = bus->ctrl_frame_len;
+	payloadLen = bus->ctrl_frame_len;
+
+	WLAND_DBG(DEFAULT, TRACE, "bus->ctrl_frame_len=%d\n",
+		bus->ctrl_frame_len);
+	pkt = wland_pkt_buf_get_suitable_skb(bus, NULL, &nbytes);
+	if (!pkt) {
+		WLAND_ERR("get pkt failed,len: %d\n", nbytes);
+		return -ENOMEM;
+	} else {
+		dhd_os_sdlock(bus);
+		memcpy(pkt->data, payload, payloadLen);
+		dhd_os_sdunlock(bus);
+	}
+
+	WLAND_DBG(DEFAULT, TRACE, "payloadLen:%d, nbytes:%d, pkt->data=%p\n",
+		payloadLen, nbytes, pkt->data);
+	WLAND_DUMP(TX_CTRL, pkt->data, nbytes, "TX ctrl nbytes:%Zu\n", nbytes);
+
+	err = wland_sdio_send_pkt(bus, pkt, nbytes);
+	wland_pkt_buf_free_skb(pkt);
+
+	dhd_os_sdlock(bus);
+	bus->ctrl_frame_stat = false;
+	if (!err)
+		bus->ctrl_frame_send_success= true;
+	else
+		bus->ctrl_frame_send_success= false;
+	dhd_os_sdunlock(bus);
+
+	WLAND_DBG(BUS, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
+
+static void wland_sdio_tx_dpc(struct wland_sdio *bus)
+{
+	int err = 0;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	if (bus->sdiodev->bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("Bus is down and go out.\n");
+		goto done;
+	}
+
+	while (wland_pktq_mlen(&bus->txq, ~bus->flowcontrol)) {
+		/* Send queued frames (limit 1 if rx may still be pending) */
+		WLAND_DBG(BUS, TRACE, "TXQ_len = %d, tx_dpc_tskcnt=%d\n",
+			wland_pktq_mlen(&bus->txq, ~bus->flowcontrol),
+			atomic_read(&bus->tx_dpc_tskcnt));
+		WLAND_DBG(BUS, TRACE, "******SendData.\n");
+		if (down_interruptible(&bus->txclk_sem)) {
+		    WLAND_ERR("Can not request bus->txclk_sem.1 \n");
+		    goto done;
+		}
+		wland_sdio_clkctl(bus, CLK_AVAIL);
+		if (bus->clkstate != CLK_AVAIL) {
+			WLAND_ERR("Can not request SDMMC clock and go out.\n");
+			up(&bus->txclk_sem);
+			goto done;
+		}
+		wland_sdio_sendfromq(bus);
+		up(&bus->txclk_sem);
+		}
+
+		if (bus->ctrl_frame_stat) {
+			if (down_interruptible(&bus->txclk_sem)) {
+			WLAND_ERR("Can not request bus->txclk_sem.2 \n");
+			goto done;
+		}
+		wland_sdio_clkctl(bus, CLK_AVAIL);
+		if (bus->clkstate != CLK_AVAIL) {
+			WLAND_ERR("Can not request clock and go out.\n");
+			up(&bus->txclk_sem);
+			goto done;
+		}
+		err = wland_sdio_txctl_frames(bus);
+		up(&bus->txclk_sem);
+		if (err < 0)
+			bus->sdcnt.tx_sderrs++;
+		dhd_os_wait_event_wakeup(bus);
+		atomic_dec(&bus->tx_dpc_tskcnt);
+		WLAND_DBG(BUS, TRACE,
+			"Processing TXCTL. bus->tx_dpc_tskcnt=%d\n",
+			atomic_read(&bus->tx_dpc_tskcnt));
+	}
+
+done:
+	WLAND_DBG(BUS, TRACE, "Done(bus->tx_dpc_tskcnt:%d)\n",
+		atomic_read(&bus->tx_dpc_tskcnt));
+	//dhd_os_sdunlock(bus);
+}
+
+static void wland_sdio_rx_dpc(struct wland_sdio *bus)
+{
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	if (bus->sdiodev->bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("Bus is down and go out.\n");
+		goto done;
+	}
+
+	wland_sdio_process_rxframes(bus);
+
+done:
+	WLAND_DBG(BUS, TRACE, "Done\n");
+}
+
+static struct pktq *wland_sdio_bus_gettxq(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio *bus = bus_if->bus_priv.sdio->bus;
+
+	return &bus->txq;
+}
+
+/* Conversion of 802.1D priority to precedence level */
+static uint prio2prec(u32 prio)
+{
+	return (prio == PRIO_8021D_NONE
+		|| prio == PRIO_8021D_BE) ? (prio ^ 2) : prio;
+}
+
+static int wland_sdio_bus_txdata(struct device *dev, struct sk_buff *pkt)
+{
+	uint prec;
+	int ret = -EBADE;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+	unsigned long flags = 0;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	/*
+	 * precondition: IS_ALIGNED((unsigned long)(pkt->data), 2)
+	 */
+	prec = prio2prec((pkt->priority & PRIOMASK));
+
+	/*
+	 * Check for existing queue, current flow-control, pending event, or pending clock
+	 */
+	WLAND_DBG(SDIO, TRACE, "deferring pktq len:%d,prec:%d.\n", bus->txq.len,
+		prec);
+
+	/*
+	 * Priority based enq
+	 */
+	dhd_os_sdlock_txq(bus, &flags);
+	if (!wland_prec_enq(bus->sdiodev->dev, &bus->txq, pkt, prec)) {
+		dhd_os_sdunlock_txq(bus, &flags);
+		wland_txcomplete(bus->sdiodev->dev, pkt, false);
+		WLAND_ERR("bus->txq is over flow!!!\n");
+		return -ENOSR;
+	} else {
+		ret = 0;
+	}
+
+	if (bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus has stop\n");
+		dhd_os_sdunlock_txq(bus, &flags);
+		return -1;
+	}
+
+	dhd_os_sdunlock_txq(bus, &flags);
+	WAKE_TX_WORK(bus);
+
+	if (bus->txq.len >= TXHI) {
+		bus->txoff = true;
+		wland_txflowcontrol(bus->sdiodev->dev, true);
+	}
+
+	WLAND_DBG(SDIO, TRACE, "TXDATA Wake up DPC work, pktq len:%d\n",
+		bus->txq.len);
+	WLAND_DBG(SDIO, TRACE,
+		"TX Data Wake up TX DPC work,  bus->tx_dpc_tskcnt:%d,  pktq len:%d\n",
+		atomic_read(&bus->tx_dpc_tskcnt), bus->txq.len);
+
+	return ret;
+}
+
+static int wland_sdio_bus_txctl(struct device *dev, u8 * msg, uint msglen)
+{
+	int ret = -1;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	/*
+	 * Need to lock here to protect txseq and SDIO tx calls
+	 */
+	dhd_os_sdlock(bus);
+
+	bus->ctrl_frame_stat = true;
+	bus->ctrl_frame_send_success = false;
+	/*
+	 * Send from dpc
+	 */
+	bus->ctrl_frame_buf = msg;
+	bus->ctrl_frame_len = msglen;
+	dhd_os_sdunlock(bus);
+	if (bus_if->state != WLAND_BUS_DATA) {
+		WLAND_ERR("bus has stop\n");
+		return -1;
+	}
+	WAKE_TX_WORK(bus);
+
+	WLAND_DBG(BUS, TRACE,
+		"TXCTL Wake up TX DPC work,  bus->tx_dpc_tskcnt:%d\n",
+		atomic_read(&bus->tx_dpc_tskcnt));
+	if (bus->ctrl_frame_stat)
+		dhd_os_wait_for_event(bus, &bus->ctrl_frame_stat);
+
+	if (!bus->ctrl_frame_stat && bus->ctrl_frame_send_success) {
+		WLAND_DBG(SDIO, DEBUG,
+			"ctrl_frame_stat == false, send success\n");
+		ret = 0;
+	} else if(!bus->ctrl_frame_stat && !bus->ctrl_frame_send_success){
+		WLAND_DBG(SDIO, INFO, "ctrl_frame_stat == true, send failed\n");
+		ret = -1;
+	}
+	if (ret)
+		bus->sdcnt.tx_ctlerrs++;
+	else
+		bus->sdcnt.tx_ctlpkts++;
+
+	return ret ? -EIO : 0;
+}
+
+static int wland_sdio_bus_rxctl(struct device *dev, u8 * msg, uint msglen)
+{
+	int timeleft;
+	uint rxlen = 0;
+	bool pending = false;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	/*
+	 * Wait until control frame is available
+	 */
+	timeleft = dhd_os_ioctl_resp_wait(bus, &bus->rxlen, &pending);
+
+	if (bus->rxlen > 0) {
+		spin_lock_bh(&bus->rxctl_lock);
+		rxlen = bus->rxlen;
+		memcpy(msg, bus->rxctl, min(msglen, rxlen));
+		bus->rxlen = 0;
+		spin_unlock_bh(&bus->rxctl_lock);
+	}
+
+	if (rxlen) {
+		WLAND_DBG(SDIO, TRACE,
+			"resumed on rxctl frame, got %d expected %d\n", rxlen,
+			msglen);
+	} else if (timeleft == 0) {
+		WLAND_ERR("resumed on timeout\n");
+	} else if (pending) {
+		WLAND_DBG(SDIO, DEBUG, "cancelled\n");
+		return -ERESTARTSYS;
+	} else {
+		WLAND_DBG(SDIO, DEBUG, "resumed for unknown reason\n");
+	}
+
+	if (rxlen)
+		bus->sdcnt.rx_ctlpkts++;
+	else
+		bus->sdcnt.rx_ctlerrs++;
+
+	return rxlen ? (int) rxlen : -ETIMEDOUT;
+}
+
+static int wland_sdio_bus_init(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+	int ret = 0;
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	/*
+	 * Start the watchdog timer
+	 */
+	bus->sdcnt.tickcnt = 0;
+
+	ret = wland_sdio_intr_register(bus->sdiodev);
+	if (ret != 0)
+		WLAND_ERR("intr register failed:%d\n", ret);
+
+	bus_if->state = WLAND_BUS_DATA;
+
+	WLAND_DBG(BUS, TRACE, "Done\n");
+	return ret;
+}
+
+/* sdio read and write worker */
+static void wland_sdio_TxWorker(struct work_struct *work)
+{
+	struct wland_sdio *bus = container_of(work, struct wland_sdio, TxWork);
+
+	WLAND_DBG(BUS, TRACE, "Enter\n");
+
+	if (atomic_read(&bus->tx_dpc_tskcnt) > 0) {
+		wland_sdio_tx_dpc(bus);
+
+	}
+}
+
+static void wland_sdio_RxWorker(struct work_struct *work)
+{
+	struct wland_sdio *bus = container_of(work, struct wland_sdio, RxWork);
+
+	if (atomic_read(&bus->rx_dpc_tskcnt) > 0) {
+		wland_sdio_rx_dpc(bus);
+
+	}
+}
+
+
+static int wland_sdio_watchdog_thread(void *data)
+{
+	struct wland_sdio *bus = (struct wland_sdio *) data;
+	struct sk_buff *pkt = NULL;
+	unsigned long flags = 0;
+
+	allow_signal(SIGTERM);
+
+	/*
+	 * Run until signal received
+	 */
+	while (1) {
+		if (kthread_should_stop()) {
+			wland_sdio_wd_timer(bus, 0);
+			WLAND_DBG(BUS, ERROR, "watchdog thread stoped.\n");
+			break;
+		}
+		if (!wait_for_completion_interruptible(&bus->watchdog_wait)) {
+			u8 intstatus = 0;
+
+			WLAND_DBG(BUS, TRACE,
+				"(bus->poll:%d,bus->polltick:%d,bus->pollrate:%d)\n",
+				bus->poll, bus->polltick, bus->pollrate);
+
+			SMP_RD_BARRIER_DEPENDS();
+
+			//In poll mode
+			/*
+			 * Poll period: check device if appropriate.
+			 */
+			if (bus->poll && (++bus->polltick >= bus->pollrate)) {
+				/*
+				 * Reset poll tick
+				 */
+				bus->polltick = 0;
+				WLAND_DBG(BUS, TRACE,
+					"(bus->intr:%d,bus->sdcnt.intrcount:%d,bus->sdcnt.lastintrs:%d)\n",
+					bus->intr, bus->sdcnt.intrcount,
+					bus->sdcnt.lastintrs);
+
+				/*
+				 * Check device if no interrupts
+				 */
+				if (!bus->intr
+					|| (bus->sdcnt.intrcount ==
+						bus->sdcnt.lastintrs)) {
+					sdio_claim_host(bus->sdiodev->func);
+					if (wland_sdio_intr_get(bus->sdiodev,
+							&intstatus) < 0) {
+						WLAND_ERR("read status failed!\n");
+					}
+
+					/*
+					 * If there is something, make like the ISR and schedule the DPC
+					 */
+					if (intstatus & I_AHB2SDIO) {
+						WLAND_DBG(BUS, TRACE,
+							"Frame Ind!\n");
+						bus->sdcnt.pollcnt++;
+						pkt = wland_sdio_readframes(bus);
+						sdio_release_host(bus->sdiodev->func);
+						if (pkt) {
+							dhd_os_sdlock_rxq(bus, &flags);
+							if(!wland_prec_enq(bus->sdiodev->dev,
+								&bus->rxq, pkt,
+								prio2prec((pkt->priority & PRIOMASK)))){
+								dhd_os_sdunlock_rxq(bus, &flags);
+								WLAND_ERR("bus->rxq is over flow!!!\n");
+								continue;
+							}
+							dhd_os_sdunlock_rxq(bus, &flags);
+							WAKE_RX_WORK(bus);
+							WLAND_DBG(BUS, TRACE,
+								"Watch dog wake up RX Work, bus->rx_dpc_tskcnt=%d\n",
+								atomic_read(&bus->rx_dpc_tskcnt));
+						}
+
+					} else
+						sdio_release_host(bus->sdiodev->func);
+
+				}
+
+				/*
+				 * Update interrupt tracking
+				 */
+				bus->sdcnt.lastintrs = bus->sdcnt.intrcount;
+			}
+
+			WLAND_DBG(BUS, TRACE,
+				"(bus->activity:%d,bus->idlecount:%d,bus->idletime:%d,bus->clkstate:%d)\n",
+				bus->activity, bus->idlecount, bus->idletime,
+				bus->clkstate);
+			/*
+			 * On idle timeout clear activity flag and/or turn off clock
+			 */
+			if ((bus->idletime > 0) && (bus->clkstate == CLK_AVAIL)) {
+				WLAND_DBG(BUS, TRACE,
+					"bus->idletime=%d, bus->idlecount=%d\n",
+					bus->idletime, bus->idlecount);
+				if (++bus->idlecount >= bus->idletime) {
+					if (down_interruptible(&bus->txclk_sem)) {
+						WLAND_ERR("Can not request bus->txclk_sem.watchdaothread \n");
+						continue;
+					}
+					wland_sdio_clkctl(bus, CLK_NONE);
+					up(&bus->txclk_sem);
+				} else {
+					if(!timer_pending(&bus->timer))
+						wland_sdio_wd_timer(bus, bus->save_ms);
+				}
+			}
+			flags = dhd_os_spin_lock(bus);
+			/*
+			 * Count the tick for reference
+			 */
+			bus->sdcnt.tickcnt++;
+
+			dhd_os_spin_unlock(bus, flags);
+
+		} else {
+			WLAND_DBG(BUS, INFO,
+				"<WDOG-TRD>watchdog thread no signal.\n");
+			continue;
+		}
+	}
+	return 0;
+}
+
+static void wland_bus_watchdog(ulong data)
+{
+	struct wland_sdio *bus = (struct wland_sdio *) data;
+
+	WLAND_DBG(BUS, TRACE, "=======*****=====>Enter\n");
+
+	if (bus->sdiodev->bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_DBG(BUS, TRACE,
+			"=======*****=====>(bus_if->state == WLAND_BUS_DOWN)\n");
+
+		/*
+		 * Clear rx control and wake any waiters
+		 */
+		dhd_os_ioctl_resp_wake(bus);
+		return;
+	}
+
+	if (bus->watchdog_tsk){
+		WLAND_DBG(BUS, TRACE, "Wake up watchdog thread!\n");
+		complete(&bus->watchdog_wait);
+	}
+}
+
+static void wland_sdioh_irqhandler(struct sdio_func *func)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(&func->dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+	u8 intstatus = 0;
+	uint prec;
+	struct sk_buff *pkt = NULL;
+	unsigned long flags = 0;
+
+	if (!bus_if) {
+		WLAND_ERR("bus is null pointer, exiting\n");
+		return;
+	}
+
+	if (bus_if->state == WLAND_BUS_DOWN) {
+		WLAND_ERR("bus is down. we have nothing to do\n");
+		return;
+	}
+
+	/*
+	 * Disable additional interrupts
+	 */
+	if (!bus->intr) {
+		WLAND_DBG(SDIO, INFO,
+			"isr w/o interrupt is disabled, so do nothing and return\n");
+		return;
+	}
+
+	/*
+	 * Count the interrupt call
+	 */
+	bus->sdcnt.intrcount++;
+
+	bus->intdis = true;
+
+	wland_sdio_intr_get(bus->sdiodev, &intstatus);
+
+	atomic_set(&bus->intstatus, intstatus);
+
+	WLAND_DBG(BUS, TRACE, "sdio_intstatus:%x\n", intstatus);
+
+	/*
+	 * On frame indication, read available frames
+	 */
+	if (intstatus & I_AHB2SDIO) {
+		pkt = wland_sdio_readframes(bus);
+	} else if (intstatus & I_ERROR) {
+		u8 val = I_ERROR;
+
+		sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+			URSDIO_FUNC1_INT_PENDING, &val);
+		WLAND_ERR("int_error!\n");
+	} else {
+		WLAND_DBG(BUS, DEBUG,
+			"No Interrupt(bus->clkstate:%d,bus->ctrl_frame_stat:%d).\n",
+			bus->clkstate, bus->ctrl_frame_stat);
+	}
+
+	if (pkt) {
+		prec = prio2prec((pkt->priority & PRIOMASK));
+		dhd_os_sdlock_rxq(bus, &flags);
+		if(!wland_prec_enq(bus->sdiodev->dev, &bus->rxq, pkt, prec)){
+			dhd_os_sdunlock_rxq(bus, &flags);
+			WLAND_ERR("bus->rxq is over flow!!!\n");
+			wland_pkt_buf_free_skb(pkt);
+			return;
+		}
+		dhd_os_sdunlock_rxq(bus, &flags);
+		WLAND_DBG(BUS, TRACE,
+				"IRQ Wake up RX Work, bus->rx_dpc_tskcnt=%d\n",
+				atomic_read(&bus->rx_dpc_tskcnt));
+		WLAND_DBG(BUS, TRACE,"rxq_len=%d\n", wland_pktq_mlen(&bus->rxq, ~bus->flowcontrol));
+		WAKE_RX_WORK(bus);
+	}
+	WLAND_DBG(SDIO, TRACE,
+		"IRQ schedule work,  bus->rx_dpc_tskcnt:%d, Done\n",
+		atomic_read(&bus->rx_dpc_tskcnt));
+}
+
+int wland_sdio_intr_register(struct wland_sdio_dev *sdiodev)
+{
+	int ret;
+
+	sdio_claim_host(sdiodev->func);
+	sdio_claim_irq(sdiodev->func, wland_sdioh_irqhandler);
+	ret = wland_sdio_intr_set(sdiodev, true);
+	sdio_release_host(sdiodev->func);
+
+	WLAND_DBG(SDIO, TRACE, "Enter(ret:%d)\n", ret);
+
+	return ret;
+}
+
+int wland_sdio_intr_unregister(struct wland_sdio_dev *sdiodev)
+{
+
+#ifdef WLAND_SDIO_SUPPORT
+	rda_mmc_set_sdio_irq(1, false);
+#endif /* WLAND_SDIO_SUPPORT    */
+
+	/*
+	 * disable interrupt
+	 */
+	sdio_claim_host(sdiodev->func);
+	wland_sdio_intr_set(sdiodev, false);
+	sdio_release_irq(sdiodev->func);
+	sdio_release_host(sdiodev->func);
+
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+	return 0;
+}
+
+void wland_sdio_wd_timer(struct wland_sdio *bus, uint wdtick)
+{
+	ulong flags;
+	uint timeout;
+
+	WLAND_DBG(BUS, TRACE, "------------>Enter(wdtick:%d)\n", wdtick);
+
+	if (!bus)
+		return;
+
+	if (wdtick)
+		dhd_os_wd_wake_lock(bus);
+
+	flags = dhd_os_spin_lock(bus);
+
+	/*
+	 * don't start the wd until fw is loaded
+	 */
+	if (bus->sdiodev->bus_if->state == WLAND_BUS_DOWN && wdtick) {
+		dhd_os_spin_unlock(bus, flags);
+		dhd_os_wd_wake_unlock(bus);
+		WLAND_DBG(BUS, INFO,
+			"------------>Done(bus_if->state == WLAND_BUS_DOWN)\n");
+		return;
+	}
+
+	/*
+	 * Totally stop the timer
+	 */
+	if (!wdtick) {
+		if (timer_pending(&bus->timer)) {
+			WLAND_DBG(BUS, TRACE, "delete timer bus->timer!\n");
+			del_timer_sync(&bus->timer);
+		}
+		bus->wd_timer_valid = false;
+		dhd_os_spin_unlock(bus, flags);
+		dhd_os_wd_wake_unlock(bus);
+		WLAND_DBG(BUS, TRACE, "Watchdog timer release!\n");
+		return;
+	}
+
+	if (wdtick) {
+		bus->save_ms = wdtick;
+		/*
+		 * Convert timeout in millsecond to jiffies
+		 */
+		timeout = msecs_to_jiffies(bus->save_ms);
+		bus->wd_timer_valid = true;
+		/*
+		 * Re arm the timer, at last watchdog period
+		 */
+		mod_timer(&bus->timer, jiffies + timeout);
+		WLAND_DBG(BUS, TRACE, "reset watch dog timer(timer bus->timer)! timeout=%d\n",
+			bus->save_ms);
+	}
+
+	dhd_os_spin_unlock(bus, flags);
+
+	WLAND_DBG(BUS, TRACE, "------------>Done(bus->save_ms:%d)\n",
+		bus->save_ms);
+}
+
+static struct wland_bus_ops wland_sdio_bus_ops = {
+	.stop = wland_sdio_bus_stop,
+	.init = wland_sdio_bus_init,
+	.txdata = wland_sdio_bus_txdata,
+	.txctl = wland_sdio_bus_txctl,
+	.rxctl = wland_sdio_bus_rxctl,
+	.gettxq = wland_sdio_bus_gettxq,
+};
+
+/* Detach and free everything */
+void wland_sdio_release(struct wland_sdio *bus)
+{
+	struct wland_bus *bus_if;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	if (!bus) {
+		WLAND_ERR("bus empty!\n");
+		return;
+	}
+
+	bus_if = dev_get_drvdata(bus->sdiodev->dev);
+	bus_if->state = WLAND_BUS_DOWN;
+	/*
+	 * De-register interrupt handler
+	 */
+	wland_sdio_intr_unregister(bus->sdiodev);
+
+	cancel_work_sync(&bus->TxWork);
+	if (bus->wland_txwq)
+		destroy_workqueue(bus->wland_txwq);
+	cancel_work_sync(&bus->RxWork);
+	if (bus->wland_rxwq)
+		destroy_workqueue(bus->wland_rxwq);
+
+	if (bus->sdiodev->dev)
+		wland_bus_detach(bus->sdiodev->dev);
+
+	if (bus->rxbuf) {
+		osl_free(bus_if->osh, bus->rxbuf, bus->rxblen);
+		bus->rxctl = bus->rxbuf = NULL;
+		bus->rxlen = 0;
+	}
+#ifdef CONFIG_HAS_WAKELOCK
+	bus->wakelock_counter = 0;
+	bus->wakelock_wd_counter = 0;
+	bus->wakelock_rx_timeout_enable = 0;
+	bus->wakelock_ctrl_timeout_enable = 0;
+
+	wake_lock_destroy(&bus->wl_wifi);
+	wake_lock_destroy(&bus->wl_rxwake);
+	wake_lock_destroy(&bus->wl_ctrlwake);
+	wake_lock_destroy(&bus->wl_wdwake);
+#endif /* CONFIG_HAS_WAKELOCK */
+
+	osl_free(bus_if->osh, bus, sizeof(struct wland_sdio));
+
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+}
+
+void *wland_sdio_probe(struct osl_info *osh, struct wland_sdio_dev *sdiodev)
+{
+	int ret;
+	struct wland_sdio *bus;
+	struct wland_bus *bus_if;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	/*
+	 * Allocate private bus interface state
+	 */
+	bus = osl_malloc(osh, sizeof(struct wland_sdio));
+	if (!bus)
+		goto fail;
+
+	memset(bus, '\0', sizeof(struct wland_sdio));
+
+	/*
+	 * pointer each other
+	 */
+	bus->sdiodev = sdiodev;
+	sdiodev->bus = bus;
+
+	bus_if = sdiodev->bus_if;
+
+	/*
+	 * attempt to attach to the chip
+	 */
+#ifdef WLAND_FPGA_SUPPORT
+	bus_if->chip = WLAND_VER_91_E;
+#else /*WLAND_FPGA_SUPPORT */
+	bus_if->chip = (rda_wlan_version() & CHIP_ID_MASK);
+#endif /*WLAND_FPGA_SUPPORT */
+
+	WLAND_ERR("--------------- Chipid: 0x%x(%s) ---------------\n",
+		bus_if->chip, wland_version_string[bus_if->chip]);
+
+	/*
+	 * Address of cores for new chips should be added here
+	 */
+	switch (bus_if->chip) {
+	case WLAND_VER_90_D:
+	case WLAND_VER_90_E:
+	case WLAND_VER_91:
+	case WLAND_VER_91_E:
+	case WLAND_VER_91_F:
+	case WLAND_VER_91_G:
+		break;
+	default:
+		WLAND_ERR("chipid 0x%x is not supported\n", bus_if->chip);
+		goto fail;
+	}
+
+	wland_pktq_init(&bus->txq, (PRIOMASK + 1), TXQLEN);
+	wland_pktq_init(&bus->rxq, (PRIOMASK + 1), TXQLEN);
+
+	/*
+	 * setup bus control parameters
+	 */
+	bus->txbound = WLAND_TXBOUND;
+	bus->rxbound = WLAND_RXBOUND;
+	bus->txminmax = WLAND_TXMINMAX;
+	/*
+	 * default sdio bus header length for tx packet
+	 */
+	bus->tx_hdrlen = FMW_HEADER_LEN;
+	bus->clkstate = CLK_SDONLY;
+	bus->idletime = WLAND_IDLE_INTERVAL;
+	bus->save_ms = WLAND_WD_POLL_MS;
+	/*
+	 * Set roundup accordingly
+	 */
+	bus->blocksize = sdiodev->func->cur_blksize;
+	/*
+	 * Set the poll and interrupt flags(default poll then intr)
+	 */
+	bus->intr = false;
+	bus->poll = true;
+	bus->intdis = false;
+	bus->polltick = 0;
+	bus->flowcontrol = 0;
+	bus->activity = false;
+
+	if (bus->poll)
+		bus->pollrate = 1;
+
+	/*
+	 * Assign bus interface call back,Attach chip version to sdio device
+	 */
+	bus_if->dev = sdiodev->dev;
+	bus_if->ops = &wland_sdio_bus_ops;
+	bus_if->state = WLAND_BUS_DOWN;
+
+	/*
+	 * disable/enable host interrupt
+	 */
+	rda_mmc_set_sdio_irq(1, bus->intdis);
+
+	INIT_WORK(&bus->TxWork, wland_sdio_TxWorker);
+	bus->wland_txwq = create_singlethread_workqueue("wland_txwq");
+	if (!bus->wland_txwq) {
+		WLAND_ERR("insufficient memory to create txworkqueue.\n");
+		goto fail;
+	}
+	INIT_WORK(&bus->RxWork, wland_sdio_RxWorker);
+	bus->wland_rxwq = create_singlethread_workqueue("wland_rxwq");
+	if (!bus->wland_rxwq) {
+		WLAND_ERR("insufficient memory to create rxworkqueue.\n");
+		goto fail;
+	}
+	spin_lock_init(&bus->rxctl_lock);
+	spin_lock_init(&bus->txqlock);
+	spin_lock_init(&bus->rxqlock);
+
+	sema_init(&bus->txclk_sem,1);
+
+	init_waitqueue_head(&bus->ctrl_wait);
+	init_waitqueue_head(&bus->dcmd_resp_wait);
+
+	/*
+	 * Initialize Wakelock stuff
+	 */
+	spin_lock_init(&bus->wakelock_spinlock);
+
+	bus->wakelock_counter = 0;
+	bus->wakelock_wd_counter = 0;
+	bus->wakelock_rx_timeout_enable = 0;
+	bus->wakelock_ctrl_timeout_enable = 0;
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&bus->wl_wifi, WAKE_LOCK_SUSPEND, "wlan_wake");
+	wake_lock_init(&bus->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
+	wake_lock_init(&bus->wl_ctrlwake, WAKE_LOCK_SUSPEND, "wlan_ctrl_wake");
+	wake_lock_init(&bus->wl_wdwake, WAKE_LOCK_SUSPEND, "wlan_wd_wake");
+#endif /* CONFIG_HAS_WAKELOCK */
+
+	/*
+	 * Set up the watchdog timer
+	 */
+	init_timer(&bus->timer);
+	bus->timer.data = (ulong) bus;
+	bus->timer.function = wland_bus_watchdog;
+
+	/*
+	 * Initialize watchdog thread
+	 */
+	init_completion(&bus->watchdog_wait);
+	bus->watchdog_tsk =
+		kthread_run(wland_sdio_watchdog_thread, bus, "wland_watchdog");
+	if (IS_ERR(bus->watchdog_tsk)) {
+		WLAND_ERR("watchdog thread failed to create!\n");
+		bus->watchdog_tsk = NULL;
+	}
+	/*
+	 * Initialize thread based operation and lock
+	 */
+	sema_init(&bus->sdsem, 1);
+
+	bus->threads_only = true;
+
+	/*
+	 * Initialize DPC thread
+	 */
+	atomic_set(&bus->tx_dpc_tskcnt, 0);
+	atomic_set(&bus->rx_dpc_tskcnt, 0);
+
+	/*
+	 * Attach to the common layer, reserve hdr space
+	 */
+	ret = wland_bus_attach(0, sdiodev->dev);
+	if (ret < 0) {
+		WLAND_ERR("bus_attach failed\n");
+		goto fail;
+	}
+
+	/*
+	 * Allocate buffers
+	 */
+	if (bus_if->drvr->maxctl) {
+		bus->rxblen =
+			roundup((bus_if->drvr->maxctl),
+			ALIGNMENT) + WLAND_SDALIGN;
+		bus->rxbuf = osl_malloc(osh, bus->rxblen);
+		if (!bus->rxbuf) {
+			WLAND_ERR("rxbuf malloc failed.\n");
+			goto fail;
+		}
+		memset(bus->rxbuf, '\0', bus->rxblen);
+	}
+
+	WLAND_DBG(SDIO, DEBUG, "(maxctl:%d)<====>(rxblen:%d)\n",
+		bus_if->drvr->maxctl, bus->rxblen);
+
+	wland_sdio_debugfs_create(bus_if->drvr);
+
+	/*
+	 * if firmware path present try to download and bring up bus
+	 */
+	ret = wland_bus_start(sdiodev->dev);
+	if (ret < 0) {
+		WLAND_ERR("Bus Start Failed\n");
+		goto fail;
+	}
+
+	WLAND_DBG(SDIO, TRACE, "SuccessFull Probe Done.\n");
+
+	return bus;
+
+fail:
+	wland_sdio_release(bus);
+
+	return NULL;
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.c
new file mode 100644
index 000000000000..17af283f4b1c
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.c
@@ -0,0 +1,1033 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/ieee80211.h>
+#include <linux/export.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/scatterlist.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/vmalloc.h>
+#include <asm/unaligned.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_p2p.h>
+#include <wland_trap.h>
+#include <wland_cfg80211.h>
+
+/* devices we support, null terminated */
+static const struct sdio_device_id wland_sdmmc_ids[] = {
+	{SDIO_DEVICE(SDIO_VENDOR_ID_RDAWLAN, SDIO_DEVICE_ID_RDA599X)},
+	{ /* end: all zeroes */ },
+};
+
+MODULE_DEVICE_TABLE(sdio, wland_sdmmc_ids);
+
+bool wland_pm_resume_error(struct wland_sdio_dev *sdiodev)
+{
+	bool is_err = false;
+
+#if 0
+#ifdef CONFIG_PM_SLEEP
+	is_err = atomic_read(&sdiodev->suspend);
+#endif /* CONFIG_PM_SLEEP */
+#endif
+	return is_err;
+}
+
+void wland_pm_resume_wait(struct wland_sdio_dev *sdiodev,
+	wait_queue_head_t * wq)
+{
+#if 0
+#ifdef CONFIG_PM_SLEEP
+	int retry = 0;
+
+	while (atomic_read(&sdiodev->suspend) && retry++ != 30)
+		wait_event_timeout(*wq, false, HZ / 100);
+#endif /* CONFIG_PM_SLEEP */
+#endif
+}
+
+int sdioh_request_byte(struct wland_sdio_dev *sdiodev, uint rw, uint regaddr,
+	u8 * byte)
+{
+	int err_ret;
+
+	WLAND_DBG(SDIO, TRACE, "rw=%d,addr=0x%05x\n", rw, regaddr);
+
+	wland_pm_resume_wait(sdiodev, &sdiodev->request_byte_wait);
+
+	if (wland_pm_resume_error(sdiodev))
+		return -EIO;
+
+	//sdio_claim_host(sdiodev->func);
+	if (SDIOH_WRITE == rw)	/* CMD52 Write */
+		sdio_writeb(sdiodev->func, *byte, regaddr, &err_ret);
+	else
+		*byte = sdio_readb(sdiodev->func, regaddr, &err_ret);
+	//sdio_release_host(sdiodev->func);
+
+	if (err_ret)
+		WLAND_ERR("Failed to %s :@0x%05x=%02x,Err: %d.\n",
+			rw ? "write" : "read", regaddr, *byte, err_ret);
+
+	return err_ret;
+}
+
+int sdioh_request_word(struct wland_sdio_dev *sdiodev, uint rw, uint addr,
+	u32 * word, uint nbytes)
+{
+	int err_ret = -EIO;
+
+	WLAND_DBG(SDIO, TRACE, "rw=%d, addr=0x%05x, nbytes=%d\n", rw, addr,
+		nbytes);
+
+	wland_pm_resume_wait(sdiodev, &sdiodev->request_word_wait);
+
+	if (wland_pm_resume_error(sdiodev))
+		return -EIO;
+
+	sdio_claim_host(sdiodev->func);
+	if (SDIOH_WRITE == rw) {	/* CMD52 Write */
+		if (nbytes == 4)
+			sdio_writel(sdiodev->func, *word, addr, &err_ret);
+		else if (nbytes == 2)
+			sdio_writew(sdiodev->func, (*word & 0xFFFF), addr,
+				&err_ret);
+		else
+			WLAND_ERR("Invalid nbytes: %d\n", nbytes);
+	} else {		/* CMD52 Read */
+		if (nbytes == 4)
+			*word = sdio_readl(sdiodev->func, addr, &err_ret);
+		else if (nbytes == 2)
+			*word = sdio_readw(sdiodev->func, addr,
+				&err_ret) & 0xFFFF;
+		else
+			WLAND_ERR("Invalid nbytes: %d\n", nbytes);
+	}
+	sdio_release_host(sdiodev->func);
+
+	if (err_ret)
+		WLAND_ERR("Failed to %s word, Err: 0x%08x\n",
+			rw ? "write" : "read", err_ret);
+
+	return err_ret;
+}
+
+int sdioh_request_bytes(struct wland_sdio_dev *sdiodev, uint rw, uint addr,
+	u8 * byte, uint nbyte)
+{
+	int err_ret = 0;
+	int bytes_left = 0, offset = 0, batch = 0;
+
+	WLAND_DBG(SDIO, TRACE, "%s: addr=0x%05x, lenght=%d\n",
+		rw ? "WRITE" : "READ", addr, nbyte);
+
+	wland_pm_resume_wait(sdiodev, &sdiodev->request_buffer_wait);
+
+	if (wland_pm_resume_error(sdiodev))
+		return -EIO;
+
+	//sdio_claim_host(sdiodev->func);
+	if (SDIOH_WRITE == rw) {
+		bytes_left = nbyte;
+		while (bytes_left > 0 && err_ret == 0) {
+			batch = (bytes_left >
+				sdiodev->func->cur_blksize) ? sdiodev->func->
+				cur_blksize : bytes_left;
+#ifdef WLAND_RDAPLATFORM_SUPPORT
+			{
+				u8 *packet_to_send = NULL;
+				struct page *pg = NULL;
+
+				packet_to_send = byte + offset;
+				if (((u32) packet_to_send >> PAGE_SHIFT) !=
+					(((u32) packet_to_send + batch - 1) >> PAGE_SHIFT) ||
+					(u32)packet_to_send & (ALIGNMENT -1)) {
+
+					pg = alloc_page(GFP_KERNEL);
+					if (!pg) {
+						err_ret = -1;
+						break;
+					}
+					memcpy(page_address(pg), packet_to_send, batch);
+					packet_to_send = page_address(pg);
+					WLAND_DBG(SDIO, DEBUG, "wlan data cross page boundary addr:%x size:%x \n",
+						(u32)(packet_to_send), batch);
+					err_ret = sdio_writesb(sdiodev->func, addr, packet_to_send, batch);
+					__free_page(pg);
+				} else
+					err_ret = sdio_writesb(sdiodev->func, addr, packet_to_send, batch);
+			}
+
+#else
+			err_ret =
+				sdio_writesb(sdiodev->func, addr, byte + offset,
+				batch);
+#endif
+			offset += batch;
+			bytes_left -= batch;
+		}
+	} else {
+		err_ret = sdio_readsb(sdiodev->func, byte, addr, nbyte);
+	}
+	//sdio_release_host(sdiodev->func);
+
+	if (err_ret)
+		WLAND_ERR("Failed to %s bytes, Err: 0x%08x\n",
+			(SDIOH_WRITE == rw) ? "write" : "read", err_ret);
+
+	return err_ret;
+}
+
+#ifdef WLAND_SDIO_FC_SUPPORT
+static int wland_sdio_flow_ctrl_90(struct wland_sdio_dev *sdiodev)
+{
+	int ret = 0;
+	u8 status = 0;
+	s32 int_sleep_count = 0, check_num = FLOW_CTRL_RXCMPL_RETRY_COUNT_90;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	if (sdiodev->bus_if->chip != WLAND_VER_90_D
+		&& sdiodev->bus_if->chip != WLAND_VER_90_E) {
+		ret = -1;
+		WLAND_ERR
+			("WIFI chip version not match(sdiodev->bus_if->chip=%d)\n",
+			sdiodev->bus_if->chip);
+		goto out;
+	}
+
+	while (true) {
+		sdio_claim_host(sdiodev->func);
+		ret = sdioh_request_byte(sdiodev, SDIOH_READ,
+			URSDIO_FUNC1_INT_PENDING, &status);
+		sdio_release_host(sdiodev->func);
+		if (status & I_RXCMPL)
+			WLAND_DBG(SDIO, TRACE,
+				"URSDIO_FUNC1_INT_PENDING:int_sleep_count=%d, status=%x \n",
+				int_sleep_count, status);
+
+		if (ret) {
+			WLAND_ERR("wland read URSDIO_FUNC1_INT_PENDING failed......ret = %d\n", ret);
+			return ret;
+		}
+
+		if ((status & I_RXCMPL) == 0) {
+			if (int_sleep_count >= check_num) {
+				status = I_RXCMPL;
+				sdio_claim_host(sdiodev->func);
+				ret = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+					URSDIO_FUNC1_INT_PENDING, &status);
+				sdio_release_host(sdiodev->func);
+				msleep(100);
+				WLAND_ERR
+					("flows ctrl RXCMPL failed, count:%d over, return back \n",
+					check_num);
+				break;
+			} else {
+				int_sleep_count++;
+				schedule();
+			}
+		} else {
+			status = I_RXCMPL;
+			sdio_claim_host(sdiodev->func);
+			ret = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+				URSDIO_FUNC1_INT_PENDING, &status);
+			sdio_release_host(sdiodev->func);
+			WLAND_DBG(SDIO, TRACE,
+				"clear flowctrl flag, int_sleep_count=%d\n",
+				int_sleep_count);
+			if (!ret)
+				break;
+		}
+	}
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+static int wland_sdio_flow_ctrl_91(struct wland_sdio_dev *sdiodev)
+{
+	int ret = 0;
+	u8 status = 0;
+	s32 int_sleep_count = 0, check_num = FLOW_CTRL_INT_SLEEP_RETRY_COUNT_91;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	if (sdiodev->bus_if->chip != WLAND_VER_91) {
+		ret = -1;
+		WLAND_ERR("WIFI chip version not match(sdiodev->bus_if->chip=%d)\n",
+			sdiodev->bus_if->chip);
+		goto out;
+	}
+
+	while (true) {
+		sdio_claim_host(sdiodev->func);
+		ret = sdioh_request_byte(sdiodev, SDIOH_READ,
+			URSDIO_FUNC1_INT_PENDING, &status);
+		sdio_release_host(sdiodev->func);
+		if (status & I_RXCMPL)
+			WLAND_DBG(SDIO, TRACE,
+				"URSDIO_FUNC1_INT_PENDING:int_sleep_count=%d, status=%x \n",
+				int_sleep_count, status);
+
+		if (ret) {
+			WLAND_ERR("wland read URSDIO_FUNC1_INT_PENDING failed......ret = %d\n", ret);
+			return ret;
+		}
+
+		if ((status & I_RXCMPL) == 0) {
+			if (int_sleep_count >= check_num) {
+				break;
+			} else {
+				int_sleep_count++;
+			}
+		} else {
+			status = I_SLEEP;
+			sdio_claim_host(sdiodev->func);
+			ret = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+				URSDIO_FUNC1_INT_PENDING, &status);
+			sdio_release_host(sdiodev->func);
+			WLAND_DBG(SDIO, TRACE,
+				"clear flowctrl flag, int_sleep_count=%d\n",
+				int_sleep_count);
+			if (!ret)
+				break;
+		}
+		if (int_sleep_count < 20)
+			udelay(10);
+		else
+			msleep(1);
+	}
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+static int wland_sdio_flow_ctrl_91e(struct wland_sdio_dev *sdiodev)
+{
+	int ret = 0;
+	u8 status = 0;
+	s32 int_sleep_count = 0, check_num = FLOW_CTRL_RXCMPL_RETRY_COUNT_91;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	if (sdiodev->bus_if->chip != WLAND_VER_91_E
+		&& sdiodev->bus_if->chip != WLAND_VER_91_F
+		&& sdiodev->bus_if->chip != WLAND_VER_91_G) {
+		ret = -1;
+		WLAND_ERR
+			("WIFI chip version not match(sdiodev->bus_if->chip=%d)\n",
+			sdiodev->bus_if->chip);
+		goto out;
+	}
+
+	while (true) {
+		sdio_claim_host(sdiodev->func);
+		ret = sdioh_request_byte(sdiodev, SDIOH_READ,
+			URSDIO_FUNC1_INT_PENDING, &status);
+		sdio_release_host(sdiodev->func);
+		if (status & I_RXCMPL)
+			WLAND_DBG(SDIO, TRACE,
+				"URSDIO_FUNC1_INT_PENDING:int_sleep_count=%d, status=%x \n",
+				int_sleep_count, status);
+
+		if (!ret) {
+			if ((status & I_RXCMPL) == 0) {
+				if (int_sleep_count >= check_num) {
+					status = I_RXCMPL;
+					sdio_claim_host(sdiodev->func);
+					ret = sdioh_request_byte(sdiodev,
+						SDIOH_WRITE,
+						URSDIO_FUNC1_INT_PENDING,
+						&status);
+					sdio_release_host(sdiodev->func);
+					WLAND_ERR
+						("flows ctrl RXCMPL failed, count:%d over, return back \n",
+						check_num);
+					ret = -1;
+					break;
+				} else {
+					int_sleep_count++;
+				}
+				if (int_sleep_count < 20) {
+					udelay(2);
+				} else {
+					WLAND_DBG(SDIO, DEBUG,"msleep(1)\n");
+					mdelay(1);
+				}
+			} else {
+				status = I_RXCMPL;
+				sdio_claim_host(sdiodev->func);
+				ret = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+					URSDIO_FUNC1_INT_PENDING, &status);
+				sdio_release_host(sdiodev->func);
+				WLAND_DBG(SDIO, TRACE,
+					"clear flowctrl flag, int_sleep_count=%d\n",
+					int_sleep_count);
+				if (!ret)
+					break;
+			}
+
+		} else {
+			WLAND_ERR("wland read URSDIO_FUNC1_INT_PENDING failed......ret = %d\n", ret);
+			return ret;
+		}
+	}
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+static int wland_sdio_flow_ctrl(struct wland_sdio_dev *sdiodev)
+{
+	int ret = 0;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	if (sdiodev->bus_if->chip == WLAND_VER_90_D
+		|| sdiodev->bus_if->chip == WLAND_VER_90_E) {
+		if ((ret = wland_sdio_flow_ctrl_90(sdiodev))) {
+			WLAND_ERR("wland_sdio_flow_ctrl_90 failed! \n");
+			goto out;
+		}
+	} else if (sdiodev->bus_if->chip == WLAND_VER_91) {
+		if ((ret = wland_sdio_flow_ctrl_91(sdiodev))) {
+			WLAND_ERR("wland_sdio_flow_ctrl_91 failed! \n");
+			goto out;
+		}
+	} else if (sdiodev->bus_if->chip == WLAND_VER_91_E
+		|| sdiodev->bus_if->chip == WLAND_VER_91_F
+		|| sdiodev->bus_if->chip == WLAND_VER_91_G) {
+		if ((ret = wland_sdio_flow_ctrl_91e(sdiodev))) {
+			WLAND_ERR("wland_sdio_flow_ctrl_91e failed! \n");
+			goto out;
+		}
+	} else {
+		ret = -1;
+		WLAND_ERR("wlan_sdio_flow_ctrl unkown version:%d\n",
+			sdiodev->bus_if->chip);
+	}
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+#endif /*WLAND_SDIO_FC_SUPPORT */
+
+int wland_sdio_send_pkt(struct wland_sdio *bus, struct sk_buff *pkt, uint count)
+{
+	int ret = 0;
+	u8 size_l = 0, size_h = 0;
+	u16 size = 0;
+	u8 *buf = pkt->data;
+
+	WLAND_DBG(SDIO, TRACE, "blockSize=%d, count=%d, pkt->len=%d, pkt->data=%p\n",
+		bus->blocksize, count, pkt->len, pkt->data);
+	//WLAND_DUMP(SDIO, pkt->data, count, "TX Data, len:%Zu\n", count);
+	if (check_test_mode() && check_sdio_init()) {
+		WLAND_DBG(SDIO, INFO, "In Test Mode and do not send pkt!\n");
+		return ret;
+	}
+#ifdef WLAND_SDIO_FC_SUPPORT
+	if ((ret = wland_sdio_flow_ctrl(bus->sdiodev))) {
+		WLAND_ERR("wland_sdio_flow_ctrl failed!\n");
+		goto out;
+	}
+#endif /*WLAND_SDIO_FC_SUPPORT */
+
+	size = count / 4;
+
+	size_l = size & 0xFF;
+	size_h = ((size >> 8) & 0x7F) | 0x80;	//0x80 flags means lenght higer bytes
+
+	sdio_claim_host(bus->sdiodev->func);
+	ret = sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+		URSDIO_FUNC1_SPKTLEN_LO, &size_l);
+	ret |= sdioh_request_byte(bus->sdiodev, SDIOH_WRITE,
+		URSDIO_FUNC1_SPKTLEN_HI, &size_h);
+	if (ret) {
+		WLAND_ERR(" sdioh_request_byte failed!\n");
+		sdio_release_host(bus->sdiodev->func);
+		goto out;
+	}
+	ret = sdioh_request_bytes(bus->sdiodev, SDIOH_WRITE,
+		URSDIO_FUNC1_FIFO_WR, buf, count);
+	sdio_release_host(bus->sdiodev->func);
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+int wland_sdio_recv_pkt(struct wland_sdio *bus, struct sk_buff *skbbuf,
+	uint size)
+{
+	int ret;		/* Return code from calls */
+
+	if ((!skbbuf) || (!size)) {
+		WLAND_ERR("skb empty!\n");
+		return -EINVAL;;
+	}
+
+	ret = sdioh_request_bytes(bus->sdiodev, SDIOH_READ,
+		URSDIO_FUNC1_FIFO_RD, skbbuf->data, size);
+	if (ret < 0) {
+		WLAND_ERR("SDIO read data failed! \n");
+		return ret;
+	}
+
+	//skbbuf->len = size;
+
+	WLAND_DBG(SDIO, TRACE, "Done(ret:%d,RxData,len:%d)\n", ret, size);
+	return ret;
+}
+
+static int wland_ops_sdio_probe(struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	struct wland_sdio_dev *sdiodev;
+	struct wland_bus *bus_if;
+	struct osl_info *osh;
+	int err = -ENODEV;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	WLAND_DBG(SDIO, INFO, "Class=%x\n", func->class);
+	WLAND_DBG(SDIO, INFO, "sdio vendor ID: 0x%04x\n", func->vendor);
+	WLAND_DBG(SDIO, INFO, "sdio device ID: 0x%04x\n", func->device);
+	WLAND_DBG(SDIO, INFO, "Function#: %d\n", func->num);
+
+	if (id->vendor != SDIO_VENDOR_ID_RDAWLAN) {
+		WLAND_ERR("Unmatch Vendor ID: 0x%x.\n", id->vendor);
+		return -ENODEV;
+	}
+
+	osh = osl_attach(func, SDIO_BUS, true);
+	if (!osh)
+		return -ENOMEM;
+
+	bus_if = osl_malloc(osh, sizeof(struct wland_bus));
+	if (!bus_if) {
+		osl_detach(osh);
+		return -ENOMEM;
+	}
+	memset(bus_if, '\0', sizeof(struct wland_bus));
+
+	sdiodev = osl_malloc(osh, sizeof(struct wland_sdio_dev));
+	if (!sdiodev) {
+		osl_free(osh, bus_if, sizeof(struct wland_bus));
+		osl_detach(osh);
+		return -ENOMEM;
+	}
+	memset(sdiodev, '\0', sizeof(struct wland_sdio_dev));
+
+	/*
+	 * initial sdiodev func parameters
+	 */
+	sdiodev->func = func;
+	sdiodev->bus_if = bus_if;
+
+	bus_if->bus_priv.sdio = sdiodev;
+	bus_if->osh = osh;
+
+	dev_set_drvdata(&func->dev, bus_if);
+
+	sdiodev->dev = &func->dev;
+
+	atomic_set(&sdiodev->suspend, false);
+	sdiodev->card_sleep = true;
+
+	init_waitqueue_head(&sdiodev->request_byte_wait);
+	init_waitqueue_head(&sdiodev->request_word_wait);
+	init_waitqueue_head(&sdiodev->request_buffer_wait);
+
+	WLAND_DBG(SDIO, TRACE, "F1 found, calling real sdio probe...\n");
+
+	err = wland_sdioh_attach(sdiodev);
+	if (err < 0)
+		goto fail;
+
+	/*
+	 * try to attach to the target device
+	 */
+	sdiodev->bus = wland_sdio_probe(osh, sdiodev);
+	if (!sdiodev->bus) {
+		WLAND_ERR("device attach failed\n");
+		goto fail;
+	}
+	WLAND_DBG(SDIO, TRACE, "Done,init completed success...\n");
+	return 0;
+fail:
+	wland_sdioh_detach(sdiodev);
+	dev_set_drvdata(&func->dev, NULL);
+	osl_free(osh, sdiodev, sizeof(struct wland_sdio_dev));
+	osl_free(osh, bus_if, sizeof(struct wland_bus));
+	osl_detach(osh);
+	return err;
+}
+
+static void wland_ops_sdio_remove(struct sdio_func *func)
+{
+	struct wland_bus *bus_if = NULL;
+	struct wland_sdio_dev *sdiodev = NULL;
+	struct osl_info *osh = NULL;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	bus_if = dev_get_drvdata(&func->dev);
+	if (bus_if) {
+		sdiodev = bus_if->bus_priv.sdio;
+		osh = bus_if->osh;
+	} else {
+		WLAND_ERR("bus_if == NULL and go out.\n");
+		goto out;
+	}
+	if (sdiodev == NULL || osh == NULL) {
+		WLAND_ERR("sdiodev == NULL || osh == NULL and go out.\n");
+		goto out;
+	}
+	WLAND_DBG(SDIO, TRACE, "SDIO-VID:0x%04x,SDIO-DID:0x%04x,Function:%d\n",
+		func->vendor, func->device, func->num);
+
+	sdiodev->bus_if->state = WLAND_BUS_DOWN;
+
+	if (sdiodev->bus) {
+		wland_sdio_release(sdiodev->bus);
+		sdiodev->bus = NULL;
+	}
+
+	wland_sdioh_detach(sdiodev);
+
+	dev_set_drvdata(&sdiodev->func->dev, NULL);
+
+	osl_free(osh, sdiodev, sizeof(struct wland_sdio_dev));
+	osl_free(osh, bus_if, sizeof(struct wland_bus));
+	osl_detach(osh);
+
+out:
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+}
+
+#ifdef CONFIG_PM
+static int wland_sdio_suspend(struct device *dev)
+{
+	int ret = 0;
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	mmc_pm_flag_t sdio_flags;
+
+	WLAND_DBG(SDIO, TRACE, "Enter.\n");
+	netif_device_detach(bus_if->drvr->iflist[0]->ndev);
+
+	sdio_flags = sdio_get_host_pm_caps(sdiodev->func);
+	if (!(sdio_flags & MMC_PM_KEEP_POWER)) {
+		WLAND_ERR("Host can't keep power while suspended\n");
+		return -EINVAL;
+	}
+
+	ret = sdio_set_host_pm_flags(sdiodev->func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		WLAND_ERR("Failed to set pm_flags\n");
+		return ret;
+	}
+
+	atomic_set(&sdiodev->suspend, true);
+
+	/*
+	 * Watchdog timer interface for pm ops
+	 */
+	while (sdiodev->card_sleep != true) {
+		if (down_interruptible(&sdiodev->bus->txclk_sem)) {
+			WLAND_ERR("Can not request bus->txclk_sem.wland_sdio_suspend\n");
+			continue;
+		}
+		wland_sdio_clkctl(sdiodev->bus, CLK_NONE);
+		up(&sdiodev->bus->txclk_sem);
+		wland_sched_timeout(50);
+	}
+
+	WLAND_DBG(SDIO, TRACE, "Done.\n");
+	return 0;
+}
+
+static int wland_sdio_resume(struct device *dev)
+{
+
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+	struct wland_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	netif_device_attach(bus_if->drvr->iflist[0]->ndev);
+
+	atomic_set(&sdiodev->suspend, false);
+
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+	return 0;
+}
+
+static const struct dev_pm_ops wland_sdio_pm_ops = {
+	.suspend = wland_sdio_suspend,
+	.resume = wland_sdio_resume,
+};
+#endif /* ifdef CONFIG_PM */
+
+static struct sdio_driver wland_sdmmc_driver = {
+	.probe = wland_ops_sdio_probe,
+	.remove = wland_ops_sdio_remove,
+	.name = WLAND_SDIO_NAME,
+	.id_table = wland_sdmmc_ids,
+	.drv = {
+#ifdef CONFIG_PM
+		.pm = &wland_sdio_pm_ops,
+#endif
+		.shutdown = &rda_wland_shutdown,
+	},
+};
+
+/*	Public entry points & extern's */
+int wland_sdioh_attach(struct wland_sdio_dev *sdiodev)
+{
+	int err_ret = 0;
+
+	WLAND_DBG(SDIO, TRACE, "Enter.\n");
+	sdio_claim_host(sdiodev->func);
+	err_ret = sdio_set_block_size(sdiodev->func, SDIO_FUNC1_BLOCKSIZE);
+	if (err_ret < 0) {
+		WLAND_ERR("Failed to set F1 blocksize.\n");
+		goto out;
+	}
+	/*
+	 * Enable Function 1
+	 */
+	err_ret = sdio_enable_func(sdiodev->func);
+	if (err_ret < 0)
+		WLAND_ERR("Failed to enable F1 Err: 0x%08x.\n", err_ret);
+out:
+	sdio_release_host(sdiodev->func);
+	WLAND_DBG(SDIO, TRACE, "Done.\n");
+	return err_ret;
+}
+
+void wland_sdioh_detach(struct wland_sdio_dev *sdiodev)
+{
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	/*
+	 * Disable Function 1
+	 */
+	sdio_claim_host(sdiodev->func);
+	sdio_disable_func(sdiodev->func);
+	sdio_release_host(sdiodev->func);
+
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+}
+
+void wland_sdio_register(void)
+{
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+
+	if (sdio_register_driver(&wland_sdmmc_driver)) {
+		WLAND_ERR("sdio_register_driver failed\n");
+		wland_registration_sem_up(false);
+	} else {
+		/*
+		 * disable sdio interrupt
+		 */
+		rda_mmc_set_sdio_irq(1, false);
+
+		/*
+		 * trigger sdio bus scan device
+		 */
+		rda_mmc_bus_scan(1);
+	}
+
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+}
+
+void wland_sdio_exit(void)
+{
+	WLAND_DBG(SDIO, TRACE, "Enter\n");
+	sdio_unregister_driver(&wland_sdmmc_driver);
+	WLAND_DBG(SDIO, TRACE, "Done\n");
+}
+
+//////////////////////////////////////////////////////////////////////////////////
+//                                                                              //
+//                     Linux OSI Relations Area                                 //
+//                                                                              //
+//////////////////////////////////////////////////////////////////////////////////
+
+void dhd_os_sdlock(struct wland_sdio *bus)
+{
+	if (bus->threads_only)
+		down(&bus->sdsem);
+}
+
+void dhd_os_sdunlock(struct wland_sdio *bus)
+{
+	if (bus->threads_only)
+		up(&bus->sdsem);
+}
+
+void dhd_os_sdlock_txq(struct wland_sdio *bus, unsigned long *flags)
+{
+	if (bus)
+		spin_lock_irqsave(&bus->txqlock, *flags);
+}
+
+void dhd_os_sdunlock_txq(struct wland_sdio *bus, unsigned long *flags)
+{
+	if (bus)
+		spin_unlock_irqrestore(&bus->txqlock, *flags);
+}
+
+void dhd_os_sdlock_rxq(struct wland_sdio *bus, unsigned long *flags)
+{
+	if (bus)
+		spin_lock_irqsave(&bus->rxqlock, *flags);
+}
+
+void dhd_os_sdunlock_rxq(struct wland_sdio *bus, unsigned long *flags)
+{
+	if (bus)
+		spin_unlock_irqrestore(&bus->rxqlock, *flags);
+}
+
+int dhd_os_ioctl_resp_wait(struct wland_sdio *bus, uint * condition,
+	bool * pending)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*
+	 * Convert timeout in millsecond to jiffies
+	 */
+	int timeout = msecs_to_jiffies(IOCTL_RESP_TIMEOUT);
+
+	/*
+	 * Wait until control frame is available
+	 */
+	add_wait_queue(&bus->dcmd_resp_wait, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	while (!(*condition) && (!signal_pending(current) && timeout))
+		timeout = schedule_timeout(timeout);
+
+	if (signal_pending(current))
+		*pending = true;
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&bus->dcmd_resp_wait, &wait);
+
+	return timeout;
+}
+
+void dhd_os_ioctl_resp_wake(struct wland_sdio *bus)
+{
+	if (waitqueue_active(&bus->dcmd_resp_wait))
+		wake_up(&bus->dcmd_resp_wait);
+}
+
+void dhd_os_wait_for_event(struct wland_sdio *bus, bool * lockvar)
+{
+	int timeout = msecs_to_jiffies(IOCTL_RESP_TIMEOUT);
+	wait_event_interruptible_timeout(bus->ctrl_wait, !(*lockvar),
+		timeout);
+}
+
+void dhd_os_wait_event_wakeup(struct wland_sdio *bus)
+{
+	if (waitqueue_active(&bus->ctrl_wait))
+		wake_up(&bus->ctrl_wait);
+}
+
+int dhd_os_wake_lock(struct wland_sdio *bus)
+{
+	ulong flags;
+	int ret = 0;
+
+	if (bus) {
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+#ifdef CONFIG_HAS_WAKELOCK
+		if (!bus->wakelock_counter) {
+			//wake_lock(&bus->wl_wifi);
+			WLAND_DBG(SDIO, TRACE, "wl_wifi locked.\n");
+		}
+#endif /*CONFIG_HAS_WAKELOCK */
+		bus->wakelock_counter++;
+		ret = bus->wakelock_counter;
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+int dhd_os_wake_lock_timeout(struct wland_sdio *bus)
+{
+	ulong flags;
+	int ret = 0;
+
+	if (bus) {
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+		ret = bus->wakelock_rx_timeout_enable >
+			bus->wakelock_ctrl_timeout_enable ?
+			bus->wakelock_rx_timeout_enable :
+			bus->wakelock_ctrl_timeout_enable;
+#ifdef CONFIG_HAS_WAKELOCK
+		if (bus->wakelock_rx_timeout_enable)
+			wake_lock_timeout(&bus->wl_rxwake,
+				msecs_to_jiffies
+				(bus->wakelock_rx_timeout_enable));
+		if (bus->wakelock_ctrl_timeout_enable)
+			wake_lock_timeout(&bus->wl_ctrlwake,
+				msecs_to_jiffies
+				(bus->wakelock_ctrl_timeout_enable));
+#endif /*CONFIG_HAS_WAKELOCK */
+		bus->wakelock_rx_timeout_enable = 0;
+		bus->wakelock_ctrl_timeout_enable = 0;
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+int dhd_os_wake_unlock(struct wland_sdio *bus)
+{
+	ulong flags;
+	int ret = 0;
+
+	dhd_os_wake_lock_timeout(bus);
+	if (bus) {
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+		if (bus->wakelock_counter) {
+			bus->wakelock_counter--;
+#ifdef CONFIG_HAS_WAKELOCK
+			if (!bus->wakelock_counter) {
+				//wake_unlock(&bus->wl_wifi);
+				WLAND_DBG(SDIO, TRACE, "wl_wifi unlock.\n");
+			}
+#endif /*CONFIG_HAS_WAKELOCK */
+			ret = bus->wakelock_counter;
+		}
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+int dhd_os_check_wakelock(struct wland_sdio *bus)
+{
+#ifdef CONFIG_HAS_WAKELOCK
+	if (!bus)
+		return 0;
+
+	/*
+	 * Indicate to the SD Host to avoid going to suspend if internal locks are up
+	 */
+	if (wake_lock_active(&bus->wl_wifi)
+		|| wake_lock_active(&bus->wl_wdwake))
+		return 1;
+#endif /*CONFIG_HAS_WAKELOCK */
+	return 0;
+}
+
+int dhd_os_wd_wake_lock(struct wland_sdio *bus)
+{
+	ulong flags;
+	int ret = 0;
+
+	if (bus) {
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+#ifdef CONFIG_HAS_WAKELOCK
+		/*
+		 * if wakelock_wd_counter was never used : lock it at once
+		 */
+		if (!bus->wakelock_wd_counter) {
+			wake_lock(&bus->wl_wdwake);
+			WLAND_DBG(SDIO, TRACE, "wl_wdwake lock.\n");
+		}
+#endif /*CONFIG_HAS_WAKELOCK */
+		bus->wakelock_wd_counter++;
+		ret = bus->wakelock_wd_counter;
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+int dhd_os_wd_wake_unlock(struct wland_sdio *bus)
+{
+	ulong flags;
+	int ret = 0;
+
+	if (bus) {
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+		if (bus->wakelock_wd_counter) {
+			bus->wakelock_wd_counter = 0;
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_unlock(&bus->wl_wdwake);
+			WLAND_DBG(SDIO, TRACE, "wl_wdwake unlock.\n");
+#endif /*CONFIG_HAS_WAKELOCK */
+		}
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+ulong dhd_os_spin_lock(struct wland_sdio * bus)
+{
+	ulong flags = 0;
+
+	if (bus)
+		spin_lock_irqsave(&bus->wakelock_spinlock, flags);
+
+	return flags;
+}
+
+void dhd_os_spin_unlock(struct wland_sdio *bus, ulong flags)
+{
+	if (bus)
+		spin_unlock_irqrestore(&bus->wakelock_spinlock, flags);
+}
+
+//////////////////////////////////////////////////////////////////////////////////
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.h
new file mode 100644
index 000000000000..202ab17db282
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_sdmmc.h
@@ -0,0 +1,311 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_SDMMC_H_
+#define _WLAND_SDMMC_H_
+
+#ifdef WLAND_SDIO_SUPPORT
+
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/ieee80211.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif /*CONFIG_HAS_WAKELOCK */
+
+#define WLAND_SDIO_NAME	                "wlandfmac_sdio"
+
+#define SDIO_FUNC_MAX_ERR	            10
+#define SDIO_FUNC1_BLOCKSIZE		    512
+
+#define SDIOH_READ                      0	/* Read request */
+#define SDIOH_WRITE                     1	/* Write request */
+
+/* SDIO Function1 Unique Registers */
+#define URSDIO_FUNC1_SPKTLEN_LO         0x00	/* SDIO2AHB Packet Length Register (LSB 8 bits) */
+#define URSDIO_FUNC1_SPKTLEN_HI         0x01	/* SDIO2AHB Packet Length Register (MSB 8 bits) */
+#define URSDIO_FUNC1_RPKTLEN_LO         0x02	/* AHB2SDIO Packet Length Register (LSB 8 bits) */
+#define URSDIO_FUNC1_RPKTLEN_HI         0x03	/* AHB2SDIO Packet Length Register (MSB 8 bits) */
+#define URSDIO_FUNC1_REGISTER_MASK      0x04	/* Function1 Mask Register */
+#define URSDIO_FUNC1_INT_PENDING        0x05	/* Function1 Interrupt Pending Register */
+#define URSDIO_FUNC1_INT_STATUS         0x06	/* Function1 Interrupt Status  Register */
+#define URSDIO_FUNC1_FIFO_WR            0x07	/* WR FIFO */
+#define URSDIO_FUNC1_FIFO_RD            0x08	/* RD FIFO */
+#define URSDIO_FUNC1_INT_TO_DEVICE      0x09	/* Function1 Interrupt to Device */
+
+#define   URSDIO_FUNC1_INT_AHB2SDIO  0x01
+#define   URSDIO_FUNC1_INT_ERROR     0x04
+#define   URSDIO_FUNC1_INT_SLEEP     0x10
+#define   URSDIO_FUNC1_INT_AWAKE     0x20
+#define   URSDIO_FUNC1_INT_RXCMPL    0x40
+#define   URSDIO_FUNC1_HOST_TX_FLAG  0x80
+
+/* intstatus Mask */
+#define I_AHB2SDIO                      BIT0	/* Indicates that data transfer from AHB to SD is
+						 * pending Cleared by Host by writing a 1. into
+						 * this register location */
+#define I_ERROR                         BIT2	/* Indicates that a system error has occurred in
+						 * the device and needs to be handled. */
+#define I_SLEEP                         BIT4
+#define I_AWAKE                         BIT5
+#define I_RXCMPL                        BIT6
+#define I_HOST_TXFLAG                   BIT7
+
+/* Packet alignment for most efficient SDIO (can change based on platform) */
+#define WLAND_SDALIGN	                (1 << 2)
+
+/* watchdog polling interval in ms */
+#define WLAND_WD_POLL_MS	            20
+
+#define TXQLEN		                    2048	/* bulk tx queue length */
+#define TXHI		                    (TXQLEN - 256)	/* turn on flow control above TXHI */
+#define TXLOW		                    (TXHI - 256)	/* turn off flow control below TXLOW */
+#define PRIOMASK	                    7
+#define TXRETRIES	                    1	/* # of retries for tx frames */
+#define WLAND_RXBOUND	                50	/* Default for max rx frames in one scheduling */
+#define WLAND_TXBOUND	                20	/* Default for max tx frames in one scheduling */
+#define WLAND_TXMINMAX	                1	/* Max tx frames if rx still pending */
+
+#define WLAND_IDLE_INTERVAL	            5
+
+/* clkstate */
+#define CLK_NONE	                    0
+#define CLK_SDONLY	                    1
+#define CLK_PENDING	                    2
+#define CLK_AVAIL	                    3
+
+/* Private data for SDIO bus interaction */
+struct wland_sdio {
+	struct wland_sdio_dev *sdiodev;	/* sdio device handler */
+	atomic_t intstatus;	/* Intstatus bits (events) pending */
+	uint blocksize;		/* Block size of SDIO transfers */
+
+	struct pktq txq;	/* Queue length used for flow-control */
+	struct pktq rxq;
+	u8 flowcontrol;		/* per prio flow control bitmask */
+
+	bool rxpending;		/* Data frame pending in dongle */
+	uint rxbound;		/* Rx frames to read before resched */
+	uint txbound;		/* Tx frames to send before resched */
+	uint txminmax;
+
+	u8 *rxbuf;		/* Buffer for receiving control packets */
+	uint rxblen;		/* Allocated length of rxbuf */
+	u8 *rxctl;		/* Aligned pointer into rxbuf */
+
+	uint rxlen;		/* Length of valid data in buffer */
+	spinlock_t rxctl_lock;
+	struct semaphore txclk_sem;
+
+	bool intr;		/* Use interrupts */
+	bool poll;		/* Use polling */
+	bool intdis;		/* Interrupts disabled by isr */
+
+	uint pollrate;		/* Ticks between device polls */
+	uint polltick;		/* Tick counter */
+
+	uint clkstate;		/* State of sd and backplane clock(s) */
+	bool activity;		/* Activity flag for clock down */
+	s32 idletime;		/* Control for activity timeout */
+	s32 idlecount;		/* Activity timeout counter */
+
+	u8 *ctrl_frame_buf;
+	uint ctrl_frame_len;
+	bool ctrl_frame_stat;
+	bool ctrl_frame_send_success;
+
+	spinlock_t txqlock;
+	spinlock_t rxqlock;
+	wait_queue_head_t ctrl_wait;
+	wait_queue_head_t dcmd_resp_wait;
+
+	struct timer_list timer;
+	bool wd_timer_valid;
+	uint save_ms;
+
+	struct completion watchdog_wait;
+	struct task_struct *watchdog_tsk;
+
+	bool threads_only;
+	struct semaphore sdsem;
+
+	struct workqueue_struct *wland_txwq;
+	struct work_struct TxWork;
+	struct workqueue_struct *wland_rxwq;
+	struct work_struct RxWork;
+
+	/*
+	 * common part for workqueue and thread
+	 */
+	atomic_t tx_dpc_tskcnt;	/* flag if need to schdule */
+	atomic_t rx_dpc_tskcnt;
+	atomic_t ipend;		/* Device interrupt is pending */
+
+	struct work_struct work_hang;
+
+	/*
+	 * Wakelocks
+	 */
+#if defined(CONFIG_HAS_WAKELOCK)
+	struct wake_lock wl_wifi;	/* Wifi wakelock */
+	struct wake_lock wl_rxwake;	/* Wifi rx wakelock */
+	struct wake_lock wl_ctrlwake;	/* Wifi ctrl wakelock */
+	struct wake_lock wl_wdwake;	/* Wifi wd wakelock */
+#endif				/*(CONFIG_HAS_WAKELOCK)*/
+
+	/*
+	 * net_device interface lock, prevent race conditions among net_dev interface
+	 * * calls and wifi_on or wifi_off
+	 */
+	struct mutex dhd_net_if_mutex;
+	struct mutex dhd_suspend_mutex;
+	spinlock_t wakelock_spinlock;
+	s32 wakelock_counter;
+	s32 wakelock_wd_counter;
+	s32 wakelock_rx_timeout_enable;
+	s32 wakelock_ctrl_timeout_enable;
+
+	bool txoff;		/* Transmit flow-controlled */
+	struct wland_sdio_count sdcnt;
+	u8 tx_hdrlen;		/* sdio bus header length for tx packet */
+
+	bool hang_was_sent;
+	int rxcnt_timeout;	/* counter rxcnt timeout to send HANG */
+	int txcnt_timeout;	/* counter txcnt timeout to send HANG */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif				/* CONFIG_HAS_EARLYSUSPEND  && defined(DHD_USE_EARLYSUSPEND) */
+
+#ifdef ARP_OFFLOAD_SUPPORT
+	u32 pend_ipaddr;
+#endif				/* ARP_OFFLOAD_SUPPORT */
+
+};
+
+struct wland_sdio_dev {
+	struct sdio_func *func;
+	struct device *dev;
+	struct wland_bus *bus_if;
+	struct wland_platform_data *pdata;
+	struct wland_sdio *bus;
+	atomic_t suspend;	/* suspend flag */
+	bool card_sleep;
+
+	/*
+	 * wait queue list
+	 */
+	wait_queue_head_t request_byte_wait;
+	wait_queue_head_t request_word_wait;
+	wait_queue_head_t request_buffer_wait;
+};
+
+static inline uint wland_get_align_size(struct wland_sdio *bus, uint count)
+{
+#ifdef WLAND_RDAPLATFORM_SUPPORT
+	uint block = 1, block_size = 512, base_len = count;
+
+	if (count <= block_size) {
+		if (count < 3) {
+			count = 4;
+		} else if (count & (count - 1)) {
+			do {
+				block <<= 1;
+			} while ((count >>= 1));
+			count = block;
+		}
+	} else if (count <= (3 * block_size)) {
+		if (count % block_size) {
+			block = (count / block_size + 1) * block_size;
+			count = block;
+		}
+	} else {
+		count = (3 * block_size);
+		WLAND_ERR("count of SDIO read/write is overflow!\n");
+	}
+	WLAND_DBG(SDIO, TRACE, "2^nByteAllignSize:%d, 4ByteAlignSize:%d\n",
+		count, base_len);
+#endif /*WLAND_RDAPLATFORM_SUPPORT */
+	return count;
+}
+
+/* Register/deregister interrupt handler. */
+extern int wland_sdio_intr_register(struct wland_sdio_dev *sdiodev);
+extern int wland_sdio_intr_unregister(struct wland_sdio_dev *sdiodev);
+
+extern void wland_sdio_wd_timer(struct wland_sdio *bus, uint wdtick);
+extern int wland_sdio_clkctl(struct wland_sdio *bus, uint target);
+extern void wland_pm_resume_wait(struct wland_sdio_dev *sdiodev,
+	wait_queue_head_t * wq);
+extern bool wland_pm_resume_error(struct wland_sdio_dev *sdiodev);
+
+/* attach, return handler on success, NULL if failed. */
+extern int wland_sdioh_attach(struct wland_sdio_dev *sdiodev);
+extern void wland_sdioh_detach(struct wland_sdio_dev *sdiodev);
+
+/* read or write one byte using cmd52  */
+extern int sdioh_request_byte(struct wland_sdio_dev *sdiodev, uint rw,
+	uint addr, u8 * byte);
+
+/* read or write 2/4 bytes using cmd52 */
+extern int sdioh_request_word(struct wland_sdio_dev *sdiodev, uint rw,
+	uint addr, u32 * word, uint nbyte);
+
+/* read or write bytes using cmd53     */
+extern int sdioh_request_bytes(struct wland_sdio_dev *sdiodev, uint rw,
+	uint addr, u8 * byte, uint nbyte);
+
+/* read or write skb buffer */
+extern int wland_sdio_recv_pkt(struct wland_sdio *bus, struct sk_buff *skbbuf,
+	uint size);
+extern int wland_sdio_send_pkt(struct wland_sdio *bus, struct sk_buff *skbbuf,
+	uint count);
+
+/* wland sdio probe or realse */
+extern void *wland_sdio_probe(struct osl_info *osh,
+	struct wland_sdio_dev *sdiodev);
+extern void wland_sdio_release(struct wland_sdio *bus);
+
+/* sdio interface */
+extern void wland_sdio_exit(void);
+extern void wland_sdio_register(void);
+
+/* linux osl */
+extern void dhd_os_sdlock(struct wland_sdio *bus);
+extern void dhd_os_sdunlock(struct wland_sdio *bus);
+extern void dhd_os_sdlock_txq(struct wland_sdio *bus, unsigned long *flags);
+extern void dhd_os_sdunlock_txq(struct wland_sdio *bus, unsigned long *flags);
+extern void dhd_os_sdlock_rxq(struct wland_sdio *bus, unsigned long *flags);
+extern void dhd_os_sdunlock_rxq(struct wland_sdio *bus, unsigned long *flags);
+extern int dhd_os_ioctl_resp_wait(struct wland_sdio *bus, uint * condition,
+	bool * pending);
+extern void dhd_os_ioctl_resp_wake(struct wland_sdio *bus);
+extern void dhd_os_wait_for_event(struct wland_sdio *bus, bool * lockvar);
+extern void dhd_os_wait_event_wakeup(struct wland_sdio *bus);
+
+extern int dhd_os_wake_lock(struct wland_sdio *bus);
+extern int dhd_os_wake_lock_timeout(struct wland_sdio *bus);
+extern int dhd_os_wake_unlock(struct wland_sdio *bus);
+extern int dhd_os_check_wakelock(struct wland_sdio *bus);
+extern int dhd_os_wd_wake_lock(struct wland_sdio *bus);
+extern int dhd_os_wd_wake_unlock(struct wland_sdio *bus);
+
+extern ulong dhd_os_spin_lock(struct wland_sdio *bus);
+extern void dhd_os_spin_unlock(struct wland_sdio *bus, ulong flags);
+extern void rda_wland_shutdown(struct device *dev);
+#endif /* WLAND_SDIO_SUPPORT */
+
+#endif /*_WLAND_SDMMC_H_*/
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.c
new file mode 100644
index 000000000000..b3c1921d05b3
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.c
@@ -0,0 +1,780 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+
+#include <wland_defs.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_bus.h>
+#include <wland_dbg.h>
+#include <wland_utils.h>
+#include <wland_wid.h>
+#include <wland_trap.h>
+#include <wland_trap_90.h>
+#include <wland_trap_91.h>
+#include <wland_trap_91e.h>
+#include <wland_trap_91f.h>
+#include <wland_trap_91g.h>
+#include "wland_sdmmc.h"
+#include <linux/firmware.h>
+#include <linux/crc16.h>
+
+/* local flag for path and init finished */
+static u8 sdio_patch_complete = 0;
+static u8 sdio_init_complete = 0;
+
+static s32 wland_set_core_init_patch(struct wland_private *priv,
+	const u32(*data)[2], u8 num)
+{
+	struct wland_proto *prot = priv->prot;
+	u8 *buf = prot->buf;
+	s32 err = 0, count = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	mutex_lock(&priv->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	for (count = 0; count < num; count++) {
+		/*
+		 * wid body
+		 */
+		wid = WID_MEMORY_ADDRESS;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 4;
+		memcpy(buf + 3, (u8 *) (&data[count][0]), 4);
+		/*
+		 * offset
+		 */
+		wid_msg_len += 7;
+		buf += 7;
+
+		/*
+		 * wid body
+		 */
+		wid = WID_MEMORY_ACCESS_32BIT;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 4;
+		memcpy(buf + 3, (u8 *) (&data[count][1]), 4);
+		/*
+		 * offset
+		 */
+		wid_msg_len += 7;
+		buf += 7;
+	}
+
+	err = wland_proto_cdc_data(priv, wid_msg_len);
+
+	if (err < 0)
+		WLAND_ERR("WID Result Failed\n");
+
+	mutex_unlock(&priv->proto_block);
+
+	WLAND_DBG(TRAP, TRACE, "Done(err:%d)\n", err);
+	return err;
+}
+
+static s32 wland_set_core_patch(struct wland_private *priv,
+	const u8(*patch)[2], u8 num)
+{
+	struct wland_proto *prot = priv->prot;
+	u8 *buf = prot->buf;
+	s32 err = 0, count = 0;
+	u16 wid_msg_len = FMW_HEADER_LEN;
+	enum wland_firmw_wid wid;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	mutex_lock(&priv->proto_block);
+
+	memset(prot->buf, '\0', sizeof(prot->buf));
+
+	for (count = 0; count < num; count++) {
+		/*
+		 * wid body
+		 */
+		wid = WID_PHY_ACTIVE_REG;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 1;
+		buf[3] = (u8) patch[count][0];
+		/*
+		 * offset
+		 */
+		wid_msg_len += 4;
+		buf += 4;
+
+		/*
+		 * wid body
+		 */
+		wid = WID_PHY_ACTIVE_REG_VAL;
+		buf[0] = (u8) (wid & 0x00FF);
+		buf[1] = (u8) ((wid & 0xFF00) >> 8);
+		buf[2] = 1;
+		buf[3] = (u8) patch[count][1];
+		/*
+		 * offset
+		 */
+		wid_msg_len += 4;
+		buf += 4;
+	}
+
+	err = wland_proto_cdc_data(priv, wid_msg_len);
+
+	if (err < 0){
+		err = 0; //Ignore error
+		WLAND_ERR("WID Result Failed\n");
+	}
+
+	mutex_unlock(&priv->proto_block);
+
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", err);
+
+	return err;
+}
+
+static s32 wland_write_sdio32_polling(struct wland_private *priv,
+	const u32(*data)[2], u32 size)
+{
+	int count = size, index = 0;
+	s32 ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	//each time write five init data
+	for (index = 0; index < count / 8; index++) {
+		ret = wland_set_core_init_patch(priv,
+			(const u32(*)[2]) &data[8 * index][0], 8);
+		if (ret < 0)
+			goto err;
+		WLAND_DBG(TRAP, TRACE, "index:%d\n", index);
+	}
+
+	if ((count % 8) > 0) {
+		ret = wland_set_core_init_patch(priv,
+			(const u32(*)[2]) &data[8 * index][0], count % 8);
+		if (ret < 0)
+			goto err;
+	}
+err:
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+static s32 wland_write_sdio8_polling(struct wland_private *priv,
+	const u8(*data)[2], u32 size)
+{
+	int count = size, index = 0;
+	s32 ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	//each time write five init data
+	for (index = 0; index < count / 8; index++) {
+		WLAND_DBG(TRAP, TRACE, "index:%d\n", index);
+		ret = wland_set_core_patch(priv,
+			(const u8(*)[2]) data[8 * index], 8);
+		if (ret < 0)
+			goto err;
+	}
+
+	if (count % 8 > 0) {
+		ret = wland_set_core_patch(priv,
+			(const u8(*)[2]) data[8 * index], count % 8);
+		if (ret < 0)
+			goto err;
+	}
+
+err:
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+#ifdef RDA_WLAND_FROM_FIRMWARE
+static s32 check_firmware_data(const struct firmware *fw_entry)
+{
+	return crc16(0, fw_entry->data, fw_entry->size);
+}
+
+static s32 wland_write_sdio_from_firmware(struct wland_private *priv,
+	const struct firmware *fw_entry, char *data_name, int bit_size)
+{
+	int ret = 0;
+	struct rda_device_firmware_head *rda_wland_firmware_head;
+	struct rda_firmware_data_type *rda_wland_firmware_data_type;
+	const u8 *rda_wland_firmware_data;
+	u32 num = 0;
+	u32 size = sizeof(struct rda_device_firmware_head);
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+	rda_wland_firmware_head =
+		(struct rda_device_firmware_head *) (fw_entry->data);
+	if (strcmp(rda_wland_firmware_head->firmware_type,
+			RDA_WLAND_FIRMWARE_NAME)
+		!= 0) {
+		WLAND_ERR("wland_write_sdio: firmware data error\n");
+		ret = -1;
+		goto err;
+	}
+	if (rda_wland_firmware_head->version != RDA_FIRMWARE_VERSION) {
+		printk("firmware data version error. version %d is needed\n",
+			RDA_FIRMWARE_VERSION);
+		ret = -1;
+		goto err;
+	}
+
+	rda_wland_firmware_data_type =
+		(struct rda_firmware_data_type *) (rda_wland_firmware_head + 1);
+
+	while (1) {
+		rda_wland_firmware_data =
+			(u8 *) (rda_wland_firmware_data_type + 1);
+
+		num++;
+		if (num > rda_wland_firmware_head->data_num) {
+			WLAND_ERR("error: could not find data %s\n", data_name);
+			ret = -1;
+			goto err;
+		}
+
+		size += (sizeof(struct rda_firmware_data_type) +
+			rda_wland_firmware_data_type->size);
+		if (size > (fw_entry->size - 2)) {
+			WLAND_ERR("error: could not find data %s\n", data_name);
+			ret = -1;
+			goto err;
+		}
+
+		if (strcmp(rda_wland_firmware_data_type->data_name,
+				data_name) == 0)
+			break;
+
+		rda_wland_firmware_data_type = (struct rda_firmware_data_type *)
+			(rda_wland_firmware_data +
+			rda_wland_firmware_data_type->size);
+	}
+
+	if (crc16(0, rda_wland_firmware_data,
+			rda_wland_firmware_data_type->size) !=
+		rda_wland_firmware_data_type->crc) {
+		printk("error: data %s crc error\n", data_name);
+		ret = -1;
+		goto err;
+	}
+
+	if (bit_size == 32)
+		ret = wland_write_sdio32_polling(priv,
+			(const u32(*)[2]) (rda_wland_firmware_data),
+			(rda_wland_firmware_data_type->size) / 8);
+	else if (bit_size == 8)
+		ret = wland_write_sdio8_polling(priv,
+			(const u8(*)[2]) (rda_wland_firmware_data),
+			(rda_wland_firmware_data_type->size) / 2);
+	else {
+		WLAND_ERR("wland_write_sdio failed: bit_size error!\n");
+		ret = -1;
+		goto err;
+	}
+
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+err:
+	return ret;
+}
+
+#else
+static inline s32 wland_write_sdio_polling_from_array(struct wland_private
+	*priv, const u8(*data)[2], int size, int bit_size)
+{
+	if (bit_size == 32)
+		return wland_write_sdio32_polling(priv, (const u32(*)[]) data,
+			size);
+	else if (bit_size == 8)
+		return wland_write_sdio8_polling(priv, data, size);
+	else {
+		WLAND_ERR("wland_write_sdio failed: bit_size error\n");
+		return -1;
+	}
+}
+#endif
+
+static s32 wland_sdio_core_patch_attach(const struct firmware *fw_entry,
+	struct wland_private *priv)
+{
+	s32 ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	if (priv->bus_if->chip == WLAND_VER_90_D)
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_90_D, 32);
+	else if (priv->bus_if->chip == WLAND_VER_90_E)
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_90_E, 32);
+	else if (priv->bus_if->chip == WLAND_VER_91) {
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_91, 32);
+		ret |= rda_write_data_to_wland(priv, fw_entry,
+			wifi_clock_switch_91, 32);
+	} else if (priv->bus_if->chip == WLAND_VER_91_E) {
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_91e, 32);
+		ret |= rda_write_data_to_wland(priv, fw_entry,
+			wifi_clock_switch_91e, 32);
+	} else if (priv->bus_if->chip == WLAND_VER_91_F) {
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_91f, 32);
+		ret |= rda_write_data_to_wland(priv, fw_entry,
+			wifi_clock_switch_91f, 32);
+	} else if (priv->bus_if->chip == WLAND_VER_91_G) {
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_32_91g, 32);
+		ret |= rda_write_data_to_wland(priv, fw_entry,
+			wifi_clock_switch_91g, 32);
+	} else {
+		WLAND_ERR("sdio_patch_core_32 failed,unknow chipid:0x%x",
+			priv->bus_if->chip);
+	}
+
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+
+	return ret;
+
+}
+
+static s32 wland_sdio_additional_patch_attach(const struct firmware *fw_entry,
+	struct wland_private *priv)
+{
+	s32 ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	if (priv->bus_if->chip == WLAND_VER_90_D) {
+		if (!check_test_mode()) {	//Normal mode
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_init_data_32_90_D ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_init_data_32_90_D, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_init_data_32_90_D failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_patch_data_90_8 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_patch_data_90_8, 8);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_patch_data_90_8 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_data_wake ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_data_wake, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_core_data_wake failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_notch_data_90_D ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_notch_data_90_D, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_notch_data_90_D failed!");
+				goto err;
+			}
+		} else {	//Test mode
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_patch_data_90_8 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_patch_data_90_8, 8);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_patch_data_90_8 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wlan_test_mode_digital32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wlan_test_mode_digital32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wlan_test_mode_digital32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_test_mode_agc_patch32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_test_mode_agc_patch32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_test_mode_agc_patch32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_test_mode_rx_notch_32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_test_mode_rx_notch_32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_test_mode_rx_notch_32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_notch_data_90_D ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_notch_data_90_D, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_notch_data_90_D failed!");
+				goto err;
+			}
+		}
+
+	} else if (priv->bus_if->chip == WLAND_VER_90_E) {
+		if (!check_test_mode()) {	//Normal mode
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_init_data_32_90_E ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_init_data_32_90_E, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_init_data_32_90_E failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_patch_data_90_8 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_patch_data_90_8, 8);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_patch_data_90_8 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_data_wake ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_data_wake, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_core_data_wake failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_notch_data_90_E ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_notch_data_90_E, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_notch_data_90_E failed!");
+				goto err;
+			}
+		} else {	//Test mode
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_core_patch_data_90_8 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_core_patch_data_90_8, 8);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_core_patch_data_90_8 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wlan_test_mode_digital32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wlan_test_mode_digital32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wlan_test_mode_digital32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_test_mode_agc_patch32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_test_mode_agc_patch32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_test_mode_agc_patch32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_test_mode_rx_notch_32_90 ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_test_mode_rx_notch_32_90, 32);
+			if (ret < 0) {
+				WLAND_ERR
+					("Write wifi_test_mode_rx_notch_32_90 failed!");
+				goto err;
+			}
+
+			WLAND_DBG(TRAP, TRACE,
+				"Writing patch: wifi_notch_data_90_E ...\n");
+			ret = rda_write_data_to_wland(priv, fw_entry,
+				wifi_notch_data_90_E, 32);
+			if (ret < 0) {
+				WLAND_ERR("Write wifi_notch_data_90_E failed!");
+				goto err;
+			}
+		}
+	} else if (priv->bus_if->chip == WLAND_VER_91) {
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_init_data_32_91 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_init_data_32_91, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_init_data_32_91 failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_AM_PM_data_32_91 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_AM_PM_data_32_91, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_AM_PM_data_32_91 failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_patch_data_91_8 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_91_8, 8);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_patch_data_91_8 failed!");
+			goto err;
+		}
+	} else if (priv->bus_if->chip == WLAND_VER_91_E) {
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_init_data_32_91e ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_init_data_32_91e, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_init_data_32_91e failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_AM_PM_data_32_91e ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_AM_PM_data_32_91e, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_AM_PM_data_32_91e failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_patch_data_91e_8 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_91e_8, 8);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_patch_data_91e_8 failed!");
+			goto err;
+		}
+	} else if (priv->bus_if->chip == WLAND_VER_91_F) {
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_init_data_32_91f ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_init_data_32_91f, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_init_data_32_91f failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_AM_PM_data_32_91f ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_AM_PM_data_32_91f, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_AM_PM_data_32_91f failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_patch_data_91f_8 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_91f_8, 8);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_patch_data_91f_8 failed!");
+			goto err;
+		}
+	} else if (priv->bus_if->chip == WLAND_VER_91_G) {
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_init_data_32_91g ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_init_data_32_91g, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_init_data_32_91g failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_AM_PM_data_32_91g ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_AM_PM_data_32_91g, 32);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_AM_PM_data_32_91g failed!");
+			goto err;
+		}
+
+		WLAND_DBG(TRAP, TRACE,
+			"Writing patch: wifi_core_patch_data_91g_8 ...\n");
+		ret = rda_write_data_to_wland(priv, fw_entry,
+			wifi_core_patch_data_91g_8, 8);
+		if (ret < 0) {
+			WLAND_ERR("Write wifi_core_patch_data_91g_8 failed!");
+			goto err;
+		}
+	} else {
+		WLAND_ERR
+			("wland_sdio_additional_patch_attach failed, unknow chipid:0x%x",
+			priv->bus_if->chip);
+	}
+
+err:
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+	return ret;
+}
+
+s32 wland_sdio_trap_attach(struct wland_private * priv)
+{
+	s32 ret = 0;
+	const struct firmware *fw_entry = NULL;
+
+	sdio_init_complete = 0;
+	sdio_patch_complete = 0;
+
+	if (priv->dev_mode) {
+		WLAND_ERR("*** Softap Mode ***\n");
+		return ret;
+	}
+#ifdef RDA_WLAND_FROM_FIRMWARE
+	WLAND_DBG(TRAP, TRACE, "wland_sdio_trap_attach: Request firmware\n");
+	ret = request_firmware(&fw_entry, RDA_WLAND_FIRMWARE_NAME,
+		(priv->bus_if->bus_priv.sdio)->dev);
+	if (ret) {
+		WLAND_ERR("Request firmware: request firmware failed\n");
+		return ret;
+	}
+	if (check_firmware_data(fw_entry)) {
+		WLAND_ERR("firmware data crc check error\n");
+		ret = -1;
+		goto err;
+	}
+#endif
+	WLAND_DBG(TRAP, DEBUG,
+		"Write core patch: wland_sdio_core_patch_attach\n");
+
+	ret = wland_sdio_core_patch_attach(fw_entry, priv);
+	if (ret < 0) {
+		WLAND_ERR("wland_sdio_core_patch_attach failed!\n");
+		goto err;
+	}
+
+	sdio_patch_complete = 1;
+
+	WLAND_DBG(TRAP, DEBUG,
+		"Write additional patch: wland_sdio_additional_patch_attach.\n");
+	ret = wland_sdio_additional_patch_attach(fw_entry, priv);
+	if (ret < 0) {
+		WLAND_ERR("wland_sdio_additional_patch_attach failed!\n");
+		goto err;
+	}
+	WLAND_DBG(TRAP, DEBUG, "Write additional patch finshed.\n");
+err:
+#ifdef RDA_WLAND_FROM_FIRMWARE
+	release_firmware(fw_entry);
+#endif
+	sdio_init_complete = 1;
+	return ret;
+}
+
+s32 wland_assoc_power_save(struct wland_private * priv)
+{
+	int ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+
+	if (priv->bus_if->chip == WLAND_VER_91) {
+		ret = wland_set_core_init_patch(priv,
+			wifi_assoc_power_save_data_32_91,
+			ARRAY_SIZE(wifi_assoc_power_save_data_32_91));
+	}
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+
+	return ret;
+}
+
+s32 wland_set_phy_timeout(struct wland_private * priv, u32 cipher_pairwise)
+{
+	int ret = 0;
+
+	WLAND_DBG(TRAP, TRACE, "Enter\n");
+	if (priv->bus_if->chip == WLAND_VER_90_D ||
+		priv->bus_if->chip == WLAND_VER_90_E) {
+		ret = wland_write_sdio32_polling(priv, wifi_phy_timeout_cfg_90,
+			ARRAY_SIZE(wifi_phy_timeout_cfg_90));
+	} else if (priv->bus_if->chip == WLAND_VER_91 ||
+		priv->bus_if->chip == WLAND_VER_91_E ||
+		priv->bus_if->chip == WLAND_VER_91_F) {
+		ret = wland_write_sdio32_polling(priv, wifi_phy_timeout_cfg_91e,
+			ARRAY_SIZE(wifi_phy_timeout_cfg_91e));
+	} else if (priv->bus_if->chip == WLAND_VER_91_G) {
+		if(cipher_pairwise == WLAN_CIPHER_SUITE_TKIP ||
+			cipher_pairwise == WLAN_CIPHER_SUITE_WEP40 ||
+			cipher_pairwise == WLAN_CIPHER_SUITE_WEP104) {
+			ret = wland_write_sdio32_polling(priv, wifi_phy_timeout_cfg_91g_tkip,
+			ARRAY_SIZE(wifi_phy_timeout_cfg_91g_tkip));
+		}
+	}
+	WLAND_DBG(TRAP, TRACE, "Done(ret:%d)\n", ret);
+
+	return ret;
+}
+
+u8 check_sdio_init(void)
+{
+	return sdio_init_complete;
+}
+
+u8 check_sdio_patch(void)
+{
+	return sdio_patch_complete;
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.h
new file mode 100644
index 000000000000..06367acf3ae1
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap.h
@@ -0,0 +1,63 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_TRAP_H_
+#define _WLAND_TRAP_H_
+#include <linux/kernel.h>
+
+#define RDA_WLAND_FIRMWARE_NAME "rda_wland.bin"
+#define RDA_FIRMWARE_VERSION 3
+#define RDA_FIRMWARE_TYPE_SIZE 16	//firmware type size
+#define RDA_FIRMWARE_DATA_NAME_SIZE 50	//firmware data_type size
+
+#pragma pack (push)
+#pragma pack(1)
+struct rda_device_firmware_head {
+	char firmware_type[RDA_FIRMWARE_TYPE_SIZE];
+	u32 version;
+	u32 data_num;
+};
+struct rda_firmware_data_type {
+	char data_name[RDA_FIRMWARE_DATA_NAME_SIZE];
+	u16 crc;
+	s8 chip_version;
+	u32 size;
+};
+
+#pragma pack (pop)
+
+/*get data from firmware*/
+//#define RDA_WLAND_FROM_FIRMWARE
+
+#ifdef RDA_WLAND_FROM_FIRMWARE
+#define rda_write_data_to_wland(CLIENT, FIRMWARE_DATA, DATA_NAME, BIT_SIZE) \
+	 wland_write_sdio_from_firmware(CLIENT, FIRMWARE_DATA, #DATA_NAME,\
+	 BIT_SIZE)
+#else
+#define rda_write_data_to_wland(CLIENT, FIRMWARE_DATA, ARRAY_DATA, BIT_SIZE) \
+	wland_write_sdio_polling_from_array(CLIENT, (const u8(*)[])ARRAY_DATA,\
+	ARRAY_SIZE(ARRAY_DATA), BIT_SIZE)
+#endif
+
+/* Flag sdio or patch init complete */
+extern u8 check_sdio_init(void);
+extern u8 check_sdio_patch(void);
+
+extern int wland_sdio_trap_attach(struct wland_private *priv);
+extern s32 wland_assoc_power_save(struct wland_private *priv);
+extern s32 wland_set_phy_timeout(struct wland_private *priv, u32 cipher_pairwise);
+
+#endif /*_WLAND_TRAP_H_ */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_90.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_90.h
new file mode 100644
index 000000000000..4b2a51ecf7d8
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_90.h
@@ -0,0 +1,1804 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_TRAP_90_H_
+#define _WLAND_TRAP_90_H_
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+//#define dig_access_pmu_cancel
+const u32 wifi_core_patch_data_32_90_D[][2] = {
+	{0x00108000, 0xEA03DF9C},
+	{0x00108004, 0xE59F101C},
+	{0x00108008, 0xE3A00040},
+	{0x0010800C, 0xE5C10038},
+	{0x00108010, 0xE1A0F00E},
+	{0x00108014, 0xEA03DF95},
+	{0x00108018, 0xE59F1008},
+	{0x0010801C, 0xE3A00040},
+	{0x00108020, 0xE5C10038},
+	{0x00108024, 0xE1A0F00E},
+	{0x00108028, 0x50300000},
+	{0x0010802C, 0xEB03D6F2},
+	{0x00108030, 0xE1A00B84},
+	{0x00108034, 0xE1B00BA0},
+	{0x00108038, 0x11A00B84},
+	{0x0010803C, 0x11A00BA0},
+	{0x00108040, 0x12600F80},
+	{0x00108044, 0x10804004},
+	{0x00108048, 0xE1A00124},
+	{0x0010804C, 0xE92D0011},
+	{0x00108050, 0xE51F4030},
+	{0x00108054, 0xE3A00020},
+	{0x00108058, 0xE5C40038},
+	{0x0010805C, 0xE8BD0011},
+	{0x00108060, 0xE1A0F00E},
+	{0x00108064, 0xEA03D3D2},
+	{0x00108068, 0xE3A00001},
+	{0x0010806C, 0xE1A0F00E},
+	{0x00108070, 0xEA03D6CD},
+	{0x00108074, 0xE3A00001},
+	{0x00108078, 0xE1A0F00E},
+	{0x0010807C, 0xEB03C786},
+	{0x00108080, 0xE51F0060},
+	{0x00108084, 0xE5D00038},
+	{0x00108088, 0xE3100080},
+	{0x0010808C, 0x1A000001},
+	{0x00108090, 0xE3A00001},
+	{0x00108094, 0xE1A0F00E},
+	{0x00108098, 0xE3A00000},
+	{0x0010809C, 0xE1A0F00E},
+	{0x001080A0, 0xEB03EADE},
+	{0x001080A4, 0xE51F0084},
+	{0x001080A8, 0xE5D00038},
+	{0x001080AC, 0xE3100080},
+	{0x001080B0, 0x1A000001},
+	{0x001080B4, 0xE3A00001},
+	{0x001080B8, 0xE1A0F00E},
+	{0x001080BC, 0xE3A00000},
+	{0x001080C0, 0xE1A0F00E},
+	{0x001080C4, 0xEB03D89D},
+	{0x001080C8, 0xE51F00A8},
+	{0x001080CC, 0xE3A01080},
+	{0x001080D0, 0xE5C01038},
+	{0x001080D4, 0xE1A0F00E},
+	{0x001080D8, 0xEB03D714},
+	{0x001080DC, 0xE51F10BC},
+	{0x001080E0, 0xE5D10038},
+	{0x001080E4, 0xE3100080},
+	{0x001080E8, 0x159F001C},
+	{0x001080EC, 0x059F0014},
+	{0x001080F0, 0xE59F100C},
+	{0x001080F4, 0xE581003C},
+	{0x001080F8, 0xE51F10D8},
+	{0x001080FC, 0xE1D101B4},
+	{0x00108100, 0xE1A0F00E},
+	{0x00108104, 0x30010000},
+	{0x00108108, 0x2E00A100},
+	{0x0010810C, 0x2E00A000},
+	{0x00108110, 0xEB03B485},
+	{0x00108114, 0x13100010},
+	{0x00108118, 0x13A00002},
+	{0x0010811C, 0x15C50067},
+	{0x00108120, 0xE1A0F00E},
+	{0x00108124, 0xEA03D804},
+	{0x00108128, 0xE51F1108},
+	{0x0010812C, 0xE5D10038},
+	{0x00108130, 0xE2000020},
+	{0x00108134, 0xE3500000},
+	{0x00108138, 0x1AFFFFFB},
+	{0x0010813C, 0xE3A01004},
+	{0x00108140, 0xE3A00B48},
+	{0x00108144, 0xE280FF45},
+	{0x00108148, 0xEA04020A},
+	{0x0010814C, 0x08BD4010},
+	{0x00108150, 0x0A000002},
+	{0x00108154, 0x13A00001},
+	{0x00108158, 0x18BD4010},
+	{0x0010815C, 0x1A000001},
+	{0x00108160, 0xE51FF004},
+	{0x00108164, 0x0000D470},
+	{0x00108168, 0xE51FF004},
+	{0x0010816C, 0x0000D2C0},
+	{0x00108170, 0xEA0402CF},
+	{0x00108174, 0xE59F600C},
+	{0x00108178, 0xE3A04000},
+	{0x0010817C, 0xE5C64000},
+	{0x00108180, 0xE59F6004},
+	{0x00108184, 0xE59FF004},
+	{0x00108188, 0x0010200B},
+	{0x0010818C, 0x0010121D},
+	{0x00108190, 0x00007634},
+	{0x00108194, 0xEAFFFFEC},
+	{0x00108198, 0xE1A00004},
+	{0x0010819C, 0xE1A00000},
+	{0x20040004, 0x0001018C},
+	{0x20040024, 0x00108000},
+	{0x20040008, 0x000101BC},
+	{0x20040028, 0x00108014},
+	{0x2004000C, 0x00012460},
+	{0x2004002C, 0x0010802C},
+	{0x20040010, 0x00013118},
+	{0x20040030, 0x00108064},
+	{0x20040014, 0x00012538},
+	{0x20040034, 0x00108070},
+	{0x20040018, 0x00016260},
+	{0x20040038, 0x0010807C},
+	{0x2004001C, 0x0000D524},
+	{0x2004003C, 0x001080A0},
+	{0x20040020, 0x00011E4C},
+	{0x20040040, 0x001080C4},
+	{0x20040100, 0x00012484},
+	{0x20040120, 0x001080D8},
+	{0x20040104, 0x0001AEF8},
+	{0x20040124, 0x00108110},
+	{0x20040108, 0x00012110},
+	{0x20040128, 0x00108124},
+	{0x2004010C, 0x0000791C},
+	{0x2004012C, 0x00108148},
+	{0x20040110, 0x00007630},
+	{0x20040130, 0x00108170},
+	{0x20040114, 0x00017158},
+	{0x20040134, 0x00108194},
+	{0x20040118, 0x00002594},
+	{0x20040138, 0x00108198},
+	{0x2004011C, 0x000172A4},
+	{0x2004013C, 0x0010819C},
+	{0x20040000, 0x0000FFFF},
+};
+
+const u32 wifi_core_patch_data_32_90_E[][2] = {
+#ifdef NORMAL_FIXED
+
+/*******************************************************************************
+* RDA5990E/F:
+*	  1. 
+*	  2. 802.1XEAPOL
+*	  3. MPLL
+*	  4. PM1
+*	  5. ACKPM1
+*	  6. (SSID)AP
+*	  7. SSIDAP
+*	  8. 
+*	  9. DSSS-OFDMPBCCChannel AgilityAP
+*		 
+*	  10.TKIPkey index1AP
+*		 WPA/WPA2APIP
+*		 ()
+*	  11.Wlan
+*	  12.BT/WIFI
+*
+* :
+*	  2012-11-21
+*
+******************************************************************************/
+	{0x00107FFC, 0x20121203},
+	{0x00108000, 0xEA04012F},
+	{0x00108004, 0x1A000001},
+	{0x00108008, 0xE8BD4010},
+	{0x0010800C, 0xEA000001},
+	{0x00108010, 0xE51FF004},
+	{0x00108014, 0x0000D4AC},
+	{0x00108018, 0xE51FF004},
+	{0x0010801C, 0x0000D654},
+	{0x00108020, 0xEA03EABA},
+	{0x00108024, 0xEB000003},
+	{0x00108028, 0xE3500000},
+	{0x0010802C, 0x0BFFFFF9},
+	{0x00108030, 0xE8BD4008},
+	{0x00108034, 0xE1A0F00E},
+	{0x00108038, 0xE51FF004},
+	{0x0010803C, 0x0000D6B4},
+	{0x00108040, 0x00000000},
+	{0x00108044, 0xEAFFFFEC},
+	{0x00108048, 0xEA040DFF},
+	{0x0010804C, 0xE3540000},
+	{0x00108050, 0x08BD8FF8},
+	{0x00108054, 0xE2440002},
+	{0x00108058, 0xE51FF004},
+	{0x0010805C, 0x0000484C},
+	{0x00108060, 0x00000000},
+	{0x00108064, 0x00000000},
+	{0x00108068, 0xE1A00004},
+	{0x0010806C, 0xE3A04000},
+	{0x00108070, 0x00001468},
+	{0x00108074, 0x00108070},
+	{0x00108078, 0xEA03EA36},
+	{0x0010807C, 0x0A000019},
+	{0x00108080, 0xE3E00006},
+	{0x00108084, 0xE3A015C0},
+	{0x00108088, 0xE5810000},
+	{0x0010808C, 0xE3A0000F},
+	{0x00108090, 0xEB000015},
+	{0x00108094, 0xE51F1028},
+	{0x00108098, 0xE5912000},
+	{0x0010809C, 0xE3822C80},
+	{0x001080A0, 0xE5812000},
+	{0x001080A4, 0xE1A01002},
+	{0x001080A8, 0xE3A00029},
+	{0x001080AC, 0xEB000012},
+	{0x001080B0, 0xE51F1044},
+	{0x001080B4, 0xE5912000},
+	{0x001080B8, 0xE3822CC0},
+	{0x001080BC, 0xE5812000},
+	{0x001080C0, 0xE1A01002},
+	{0x001080C4, 0xE3A00029},
+	{0x001080C8, 0xEB00000B},
+	{0x001080CC, 0xE51F1060},
+	{0x001080D0, 0xE5912000},
+	{0x001080D4, 0xE3C22CC0},
+	{0x001080D8, 0xE5812000},
+	{0x001080DC, 0xE1A01002},
+	{0x001080E0, 0xE3A00029},
+	{0x001080E4, 0xEB000004},
+	{0x001080E8, 0xE59FF014},
+	{0x001080EC, 0xE51FF004},
+	{0x001080F0, 0x00003784},
+	{0x001080F4, 0xE51FF004},
+	{0x001080F8, 0x000114B0},
+	{0x001080FC, 0xE51FF004},
+	{0x00108100, 0x0001BD58},
+	{0x00108104, 0x0000D7B0},
+	{0x00108108, 0xEA03C6DA},
+	{0x0010810C, 0x0A000019},
+	{0x00108110, 0xE3E00006},
+	{0x00108114, 0xE3A015C0},
+	{0x00108118, 0xE5810000},
+	{0x0010811C, 0xE3A0000F},
+	{0x00108120, 0xEBFFFFF1},
+	{0x00108124, 0xE51F10B8},
+	{0x00108128, 0xE5912000},
+	{0x0010812C, 0xE3822C80},
+	{0x00108130, 0xE5812000},
+	{0x00108134, 0xE1A01002},
+	{0x00108138, 0xE3A00029},
+	{0x0010813C, 0xEBFFFFEE},
+	{0x00108140, 0xE51F10D4},
+	{0x00108144, 0xE5912000},
+	{0x00108148, 0xE3822CC0},
+	{0x0010814C, 0xE5812000},
+	{0x00108150, 0xE1A01002},
+	{0x00108154, 0xE3A00029},
+	{0x00108158, 0xEBFFFFE7},
+	{0x0010815C, 0xE51F10F0},
+	{0x00108160, 0xE5912000},
+	{0x00108164, 0xE3C22CC0},
+	{0x00108168, 0xE5812000},
+	{0x0010816C, 0xE1A01002},
+	{0x00108170, 0xE3A00029},
+	{0x00108174, 0xEBFFFFE0},
+	{0x00108178, 0xE51FF004},
+	{0x0010817C, 0x000165B0},
+	{0x00108180, 0x00000000},
+	{0x00108184, 0x00000000},
+	{0x00108188, 0x00000000},
+	{0x0010818C, 0x00000000},
+	{0x00108190, 0x00000000},
+	{0x00108194, 0x00000000},
+	{0x00108198, 0x00000000},
+	{0x0010819C, 0x00000000},
+	{0x001081A0, 0x00000000},
+	{0x001081A4, 0x00108180},
+	{0x001081A8, 0xEA03D197},
+	{0x001081AC, 0xE92D40F8},
+	{0x001081B0, 0xE51F5014},
+	{0x001081B4, 0xE51FF004},
+	{0x001081B8, 0x00015730},
+	{0x001081BC, 0xEA03E13E},
+	{0x001081C0, 0xE59F0018},
+	{0x001081C4, 0xE5901038},
+	{0x001081C8, 0xE3110080},
+	{0x001081CC, 0x1A000001},
+	{0x001081D0, 0xE3A01003},
+	{0x001081D4, 0xE59FF008},
+	{0x001081D8, 0xE51FF004},
+	{0x001081DC, 0x0000FD18},
+	{0x001081E0, 0x50300000},
+	{0x001081E4, 0x0000FCC4},
+	{0x001081E8, 0xE1A00000},
+	{0x001081EC, 0x00000000},
+	{0x001081F0, 0x00000000},
+	{0x001081F4, 0x001081EC},
+	{0x001081F8, 0xEA0415B4},
+	{0x001081FC, 0xE2860018},
+	{0x00108200, 0xE3A02006},
+	{0x00108204, 0xE51F1018},
+	{0x00108208, 0xEB000003},
+	{0x0010820C, 0xE3500000},
+	{0x00108210, 0x01A07004},
+	{0x00108214, 0x0A000002},
+	{0x00108218, 0x1A000003},
+	{0x0010821C, 0xE51FF004},
+	{0x00108220, 0x00000160},
+	{0x00108224, 0xE51FF004},
+	{0x00108228, 0x00002BA0},
+	{0x0010822C, 0xE51FF004},
+	{0x00108230, 0x00002B8C},
+	{0x00108234, 0xE3A00002},
+	{0x00108238, 0x00000000},
+	{0x0010823C, 0x00108238},
+	{0x00108240, 0xEA03DFBB},
+	{0x00108244, 0xE5902834},
+	{0x00108248, 0xE51F1014},
+	{0x0010824C, 0xE5812000},
+	{0x00108250, 0xE3A01000},
+	{0x00108254, 0xE5801834},
+	{0x00108258, 0xE1A0F00E},
+	{0x0010825C, 0xEA03E040},
+	{0x00108260, 0xE51F002C},
+	{0x00108264, 0xE5900000},
+	{0x00108268, 0xE5810834},
+	{0x0010826C, 0xE1A0F00E},
+	{0x00108270, 0xE3500000},
+	{0x20040004, 0x00007B40},
+	{0x20040024, 0x00108000},
+	{0x20040008, 0x0000D534},
+	{0x20040028, 0x00108020},
+	{0x2004000C, 0x00017518},
+	{0x2004002C, 0x00108044},
+	{0x20040010, 0x00004848},
+	{0x20040030, 0x00108048},
+	{0x20040014, 0x00002520},
+	{0x20040034, 0x00108068},
+	{0x20040018, 0x00010000},
+	{0x20040038, 0x0010806C},
+	{0x2004001C, 0x0000D79C},
+	{0x2004003C, 0x00108078},
+	{0x20040020, 0x0001659C},
+	{0x20040040, 0x00108108},
+	{0x20040100, 0x00013B48},
+	{0x20040120, 0x001081A8},
+	{0x20040104, 0x0000FCC0},
+	{0x20040124, 0x001081BC},
+	{0x20040108, 0x00015090},
+	{0x20040128, 0x001081E8},
+	{0x2004010C, 0x00002B24},
+	{0x2004012C, 0x001081F8},
+	{0x20040110, 0x00001790},
+	{0x20040130, 0x00108234},
+	{0x20040114, 0x00010350},
+	{0x20040134, 0x00108240},
+	{0x20040118, 0x00010158},
+	{0x20040138, 0x0010825C},
+	{0x2004011C, 0x00004290},
+	{0x2004013C, 0x00108270},
+	{0x20040000, 0x0000FFFF},
+
+/*****************************************************************************/
+
+#elif defined WLAN_BIG_CURRENT_90E
+
+/*****************************************************************************/
+	{0x00107FFC, 0x20140312},
+	{0x00108000, 0xEA04012F},
+	{0x00108004, 0x1A000001},
+	{0x00108008, 0xE8BD4010},
+	{0x0010800C, 0xEA000001},
+	{0x00108010, 0xE51FF004},
+	{0x00108014, 0x0000D4AC},
+	{0x00108018, 0xE51FF004},
+	{0x0010801C, 0x0000D654},
+	{0x00108020, 0xEA03EABA},
+	{0x00108024, 0xEB000003},
+	{0x00108028, 0xE3500000},
+	{0x0010802C, 0x0BFFFFF9},
+	{0x00108030, 0xE8BD4008},
+	{0x00108034, 0xE1A0F00E},
+	{0x00108038, 0xE51FF004},
+	{0x0010803C, 0x0000D6B4},
+	{0x00108040, 0xE1A00004},
+	{0x00108044, 0xE3A04000},
+	{0x00108048, 0xEA03EA2A},
+	{0x0010804C, 0x0A000019},
+	{0x00108050, 0xE3E00006},
+	{0x00108054, 0xE3A015C0},
+	{0x00108058, 0xE5810000},
+	{0x0010805C, 0xE3A0000F},
+	{0x00108060, 0xEB000015},
+	{0x00108064, 0xE59F106C},
+	{0x00108068, 0xE5912000},
+	{0x0010806C, 0xE3822C80},
+	{0x00108070, 0xE5812000},
+	{0x00108074, 0xE1A01002},
+	{0x00108078, 0xE3A00029},
+	{0x0010807C, 0xEB000012},
+	{0x00108080, 0xE59F1050},
+	{0x00108084, 0xE5912000},
+	{0x00108088, 0xE3822CC0},
+	{0x0010808C, 0xE5812000},
+	{0x00108090, 0xE1A01002},
+	{0x00108094, 0xE3A00029},
+	{0x00108098, 0xEB00000B},
+	{0x0010809C, 0xE59F1034},
+	{0x001080A0, 0xE5912000},
+	{0x001080A4, 0xE3C22CC0},
+	{0x001080A8, 0xE5812000},
+	{0x001080AC, 0xE1A01002},
+	{0x001080B0, 0xE3A00029},
+	{0x001080B4, 0xEB000004},
+	{0x001080B8, 0xE59FF01C},
+	{0x001080BC, 0xE51FF004},
+	{0x001080C0, 0x00003784},
+	{0x001080C4, 0xE51FF004},
+	{0x001080C8, 0x000114B0},
+	{0x001080CC, 0xE51FF004},
+	{0x001080D0, 0x0001BD58},
+	{0x001080D4, 0x00001468},
+	{0x001080D8, 0x001080D4},
+	{0x001080DC, 0x0000D7B0},
+	{0x001080E0, 0xEA03C6D0},
+	{0x001080E4, 0x0A000019},
+	{0x001080E8, 0xE3E00006},
+	{0x001080EC, 0xE3A015C0},
+	{0x001080F0, 0xE5810000},
+	{0x001080F4, 0xE3A0000F},
+	{0x001080F8, 0xEBFFFFEF},
+	{0x001080FC, 0xE51F102C},
+	{0x00108100, 0xE5912000},
+	{0x00108104, 0xE3822C80},
+	{0x00108108, 0xE5812000},
+	{0x0010810C, 0xE1A01002},
+	{0x00108110, 0xE3A00029},
+	{0x00108114, 0xEBFFFFEC},
+	{0x00108118, 0xE51F1048},
+	{0x0010811C, 0xE5912000},
+	{0x00108120, 0xE3822CC0},
+	{0x00108124, 0xE5812000},
+	{0x00108128, 0xE1A01002},
+	{0x0010812C, 0xE3A00029},
+	{0x00108130, 0xEBFFFFE5},
+	{0x00108134, 0xE51F1064},
+	{0x00108138, 0xE5912000},
+	{0x0010813C, 0xE3C22CC0},
+	{0x00108140, 0xE5812000},
+	{0x00108144, 0xE1A01002},
+	{0x00108148, 0xE3A00029},
+	{0x0010814C, 0xEBFFFFDE},
+	{0x00108150, 0xE51FF004},
+	{0x00108154, 0x000165B0},
+	{0x00108158, 0xE1A00000},
+	{0x0010815C, 0xE1A00000},
+	{0x00108160, 0xE1A00000},
+	{0x00108164, 0xE1A00000},
+	{0x00108168, 0xE1A00000},
+	{0x0010816C, 0xE1A00000},
+	{0x00108170, 0xEA03D189},
+	{0x00108174, 0xE92D40F8},
+	{0x00108178, 0xE59F5024},
+	{0x0010817C, 0xE59FF024},
+	{0x00108180, 0x00000000},
+	{0x00108184, 0x00000000},
+	{0x00108188, 0x00000000},
+	{0x0010818C, 0x00000000},
+	{0x00108190, 0x00000000},
+	{0x00108194, 0x00000000},
+	{0x00108198, 0x00000000},
+	{0x0010819C, 0x00000000},
+	{0x001081A0, 0x00000000},
+	{0x001081A4, 0x00108180},
+	{0x001081A8, 0x00015730},
+	{0x001081AC, 0xEA03E13A},
+	{0x001081B0, 0xE59F0018},
+	{0x001081B4, 0xE5901038},
+	{0x001081B8, 0xE3110080},
+	{0x001081BC, 0x1A000001},
+	{0x001081C0, 0xE3A01003},
+	{0x001081C4, 0xE59FF008},
+	{0x001081C8, 0xE51FF004},
+	{0x001081CC, 0x0000FD18},
+	{0x001081D0, 0x50300000},
+	{0x001081D4, 0x0000FCC4},
+	{0x001081D8, 0xE1A00000},
+	{0x001081DC, 0xE1A00000},
+	{0x001081E0, 0xE1A00000},
+	{0x001081E4, 0xE1A00000},
+	{0x001081E8, 0xE1A00000},
+	{0x001081EC, 0x00000000},
+	{0x001081F0, 0x00000000},
+	{0x001081F4, 0x001081EC},
+	{0x001081F8, 0xEA0415B4},
+	{0x001081FC, 0xE2860018},
+	{0x00108200, 0xE3A02006},
+	{0x00108204, 0xE51F1018},
+	{0x00108208, 0xEB000003},
+	{0x0010820C, 0xE3500000},
+	{0x00108210, 0x01A07004},
+	{0x00108214, 0x0A000002},
+	{0x00108218, 0x1A000003},
+	{0x0010821C, 0xE51FF004},
+	{0x00108220, 0x00000160},
+	{0x00108224, 0xE51FF004},
+	{0x00108228, 0x00002BA0},
+	{0x0010822C, 0xE51FF004},
+	{0x00108230, 0x00002B8C},
+	{0x00108234, 0xE3A00002},
+	{0x00108238, 0xEA03DFB9},
+	{0x0010823C, 0xE5902834},
+	{0x00108240, 0xE59F1010},
+	{0x00108244, 0xE5812000},
+	{0x00108248, 0xE3A01000},
+	{0x0010824C, 0xE5801834},
+	{0x00108250, 0xE1A0F00E},
+	{0x00108254, 0x00000000},
+	{0x00108258, 0x00108254},
+	{0x0010825C, 0xEA03E040},
+	{0x00108260, 0xE51F0010},
+	{0x00108264, 0xE5900000},
+	{0x00108268, 0xE5810834},
+	{0x0010826C, 0xE1A0F00E},
+	{0x00108270, 0x00000000},
+	{0x00108274, 0x00108270},
+	{0x00108278, 0xEA03C6EE},
+	{0x0010827C, 0xE3500001},
+	{0x00108280, 0x1A00001A},
+	{0x00108284, 0xE92D0007},
+	{0x00108288, 0xE51F001C},
+	{0x0010828C, 0xE5901000},
+	{0x00108290, 0xE59F0050},
+	{0x00108294, 0xE5D02000},
+	{0x00108298, 0xE3520000},
+	{0x0010829C, 0x02811001},
+	{0x001082A0, 0x159F0044},
+	{0x001082A4, 0x15D02000},
+	{0x001082A8, 0x10811002},
+	{0x001082AC, 0xE51F0040},
+	{0x001082B0, 0xE3510F40},
+	{0x001082B4, 0x83A01000},
+	{0x001082B8, 0xE5801000},
+	{0x001082BC, 0x9A000007},
+	{0x001082C0, 0xE59F0020},
+	{0x001082C4, 0xE5D00000},
+	{0x001082C8, 0xE3500000},
+	{0x001082CC, 0x0A000003},
+	{0x001082D0, 0x13A00001},
+	{0x001082D4, 0xE3A01000},
+	{0x001082D8, 0xE3A02000},
+	{0x001082DC, 0xEB000005},
+	{0x001082E0, 0xE8BD0007},
+	{0x001082E4, 0xE59FF014},
+	{0x001082E8, 0x0010670D},
+	{0x001082EC, 0x00106046},
+	{0x001082F0, 0xE51FF004},
+	{0x001082F4, 0x00016770},
+	{0x001082F8, 0xE51FF004},
+	{0x001082FC, 0x00012DB0},
+	{0x00108300, 0x000166C4},
+	{0x00108304, 0xEA0401FB},
+	{0x00108308, 0xE3A00030},
+	{0x0010830C, 0xE59F100C},
+	{0x00108310, 0xEBFFFF6D},
+	{0x00108314, 0xE59F4000},
+	{0x00108318, 0xE59FF004},
+	{0x0010831C, 0x0010670C},
+	{0x00108320, 0x00000241},
+	{0x00108324, 0x00007B18},
+	{0x00108328, 0xEA03E128},
+	{0x0010832C, 0xE3A00030},
+	{0x00108330, 0xE59F100C},
+	{0x00108334, 0xEBFFFF64},
+	{0x00108338, 0xE2044001},
+	{0x0010833C, 0xE3540000},
+	{0x00108340, 0xE59FF000},
+	{0x00108344, 0x00000249},
+	{0x00108348, 0x0000FE88},
+	{0x0010834C, 0xEA03D8FA},
+	{0x00108350, 0xE3A00030},
+	{0x00108354, 0xE51F103C},
+	{0x00108358, 0xEBFFFF5B},
+	{0x0010835C, 0xE3A01003},
+	{0x00108360, 0xE51FF004},
+	{0x00108364, 0x00011F6C},
+	{0x20040004, 0x00007B40},
+	{0x20040024, 0x00108000},
+	{0x20040008, 0x0000D534},
+	{0x20040028, 0x00108020},
+	{0x2004000C, 0x00002520},
+	{0x2004002C, 0x00108040},
+	{0x20040010, 0x00010000},
+	{0x20040030, 0x00108044},
+	{0x20040014, 0x0000D79C},
+	{0x20040034, 0x00108048},
+	{0x20040018, 0x0001659C},
+	{0x20040038, 0x001080E0},
+	{0x2004001C, 0x00013B48},
+	{0x2004003C, 0x00108170},
+	{0x20040020, 0x0000FCC0},
+	{0x20040040, 0x001081AC},
+	{0x20040100, 0x00002B24},
+	{0x20040120, 0x001081F8},
+	{0x20040104, 0x00001790},
+	{0x20040124, 0x00108234},
+	{0x20040108, 0x00010350},
+	{0x20040128, 0x00108238},
+	{0x2004010C, 0x00010158},
+	{0x2004012C, 0x0010825C},
+	{0x20040110, 0x000166BC},
+	{0x20040130, 0x00108278},
+	{0x20040114, 0x00007B14},
+	{0x20040134, 0x00108304},
+	{0x20040118, 0x0000FE84},
+	{0x20040138, 0x00108328},
+	{0x2004011C, 0x00011F60},
+	{0x2004013C, 0x0010834C},
+	{0x20040000, 0x0000FFFF},
+
+/*****************************************************************************/
+
+#elif defined WLAN_FLOW_CTRL_90E
+
+/*****************************************************************************/
+	{0x00107FFC, 0x20140122},
+	{0x00108000, 0xEA04012F},
+	{0x00108004, 0x1A000001},
+	{0x00108008, 0xE8BD4010},
+	{0x0010800C, 0xEA000001},
+	{0x00108010, 0xE51FF004},
+	{0x00108014, 0x0000D4AC},
+	{0x00108018, 0xE51FF004},
+	{0x0010801C, 0x0000D654},
+	{0x00108020, 0xEA03EABA},
+	{0x00108024, 0xEB000003},
+	{0x00108028, 0xE3500000},
+	{0x0010802C, 0x0BFFFFF9},
+	{0x00108030, 0xE8BD4008},
+	{0x00108034, 0xE1A0F00E},
+	{0x00108038, 0xE51FF004},
+	{0x0010803C, 0x0000D6B4},
+	{0x00108040, 0x00000000},
+	{0x00108044, 0xEAFFFFEC},
+	{0x00108048, 0x0000484C},
+	{0x0010804C, 0x00000000},
+	{0x00108050, 0x00000000},
+	{0x00108054, 0x00000000},
+	{0x00108058, 0x00000000},
+	{0x0010805C, 0x00000000},
+	{0x00108060, 0x00000000},
+	{0x00108064, 0x00000000},
+	{0x00108068, 0xE1A00004},
+	{0x0010806C, 0xE3A04000},
+	{0x00108070, 0x00001468},
+	{0x00108074, 0x00108070},
+	{0x00108078, 0xEA03EA36},
+	{0x0010807C, 0x0A000019},
+	{0x00108080, 0xE3E00006},
+	{0x00108084, 0xE3A015C0},
+	{0x00108088, 0xE5810000},
+	{0x0010808C, 0xE3A0000F},
+	{0x00108090, 0xEB000015},
+	{0x00108094, 0xE51F1028},
+	{0x00108098, 0xE5912000},
+	{0x0010809C, 0xE3822C80},
+	{0x001080A0, 0xE5812000},
+	{0x001080A4, 0xE1A01002},
+	{0x001080A8, 0xE3A00029},
+	{0x001080AC, 0xEB000012},
+	{0x001080B0, 0xE51F1044},
+	{0x001080B4, 0xE5912000},
+	{0x001080B8, 0xE3822CC0},
+	{0x001080BC, 0xE5812000},
+	{0x001080C0, 0xE1A01002},
+	{0x001080C4, 0xE3A00029},
+	{0x001080C8, 0xEB00000B},
+	{0x001080CC, 0xE51F1060},
+	{0x001080D0, 0xE5912000},
+	{0x001080D4, 0xE3C22CC0},
+	{0x001080D8, 0xE5812000},
+	{0x001080DC, 0xE1A01002},
+	{0x001080E0, 0xE3A00029},
+	{0x001080E4, 0xEB000004},
+	{0x001080E8, 0xE59FF014},
+	{0x001080EC, 0xE51FF004},
+	{0x001080F0, 0x00003784},
+	{0x001080F4, 0xE51FF004},
+	{0x001080F8, 0x000114B0},
+	{0x001080FC, 0xE51FF004},
+	{0x00108100, 0x0001BD58},
+	{0x00108104, 0x0000D7B0},
+	{0x00108108, 0xEA03C6DA},
+	{0x0010810C, 0x0A000019},
+	{0x00108110, 0xE3E00006},
+	{0x00108114, 0xE3A015C0},
+	{0x00108118, 0xE5810000},
+	{0x0010811C, 0xE3A0000F},
+	{0x00108120, 0xEBFFFFF1},
+	{0x00108124, 0xE51F10B8},
+	{0x00108128, 0xE5912000},
+	{0x0010812C, 0xE3822C80},
+	{0x00108130, 0xE5812000},
+	{0x00108134, 0xE1A01002},
+	{0x00108138, 0xE3A00029},
+	{0x0010813C, 0xEBFFFFEE},
+	{0x00108140, 0xE51F10D4},
+	{0x00108144, 0xE5912000},
+	{0x00108148, 0xE3822CC0},
+	{0x0010814C, 0xE5812000},
+	{0x00108150, 0xE1A01002},
+	{0x00108154, 0xE3A00029},
+	{0x00108158, 0xEBFFFFE7},
+	{0x0010815C, 0xE51F10F0},
+	{0x00108160, 0xE5912000},
+	{0x00108164, 0xE3C22CC0},
+	{0x00108168, 0xE5812000},
+	{0x0010816C, 0xE1A01002},
+	{0x00108170, 0xE3A00029},
+	{0x00108174, 0xEBFFFFE0},
+	{0x00108178, 0xE51FF004},
+	{0x0010817C, 0x000165B0},
+	{0x00108180, 0x00000000},
+	{0x00108184, 0x00000000},
+	{0x00108188, 0x00000000},
+	{0x0010818C, 0x00000000},
+	{0x00108190, 0x00000000},
+	{0x00108194, 0x00000000},
+	{0x00108198, 0x00000000},
+	{0x0010819C, 0x00000000},
+	{0x001081A0, 0x00000000},
+	{0x001081A4, 0x00108180},
+	{0x001081A8, 0xEA03D197},
+	{0x001081AC, 0xE92D40F8},
+	{0x001081B0, 0xE51F5014},
+	{0x001081B4, 0xE51FF004},
+	{0x001081B8, 0x00015730},
+	{0x001081BC, 0xEA03E13E},
+	{0x001081C0, 0xE59F0018},
+	{0x001081C4, 0xE5901038},
+	{0x001081C8, 0xE3110080},
+	{0x001081CC, 0x1A000001},
+	{0x001081D0, 0xE3A01003},
+	{0x001081D4, 0xE59FF008},
+	{0x001081D8, 0xE51FF004},
+	{0x001081DC, 0x0000FD18},
+	{0x001081E0, 0x50300000},
+	{0x001081E4, 0x0000FCC4},
+	{0x001081E8, 0xE1A00000},
+	{0x001081EC, 0x00000000},
+	{0x001081F0, 0x00000000},
+	{0x001081F4, 0x001081EC},
+	{0x001081F8, 0xEA0415B4},
+	{0x001081FC, 0xE2860018},
+	{0x00108200, 0xE3A02006},
+	{0x00108204, 0xE51F1018},
+	{0x00108208, 0xEB000003},
+	{0x0010820C, 0xE3500000},
+	{0x00108210, 0x01A07004},
+	{0x00108214, 0x0A000002},
+	{0x00108218, 0x1A000003},
+	{0x0010821C, 0xE51FF004},
+	{0x00108220, 0x00000160},
+	{0x00108224, 0xE51FF004},
+	{0x00108228, 0x00002BA0},
+	{0x0010822C, 0xE51FF004},
+	{0x00108230, 0x00002B8C},
+	{0x00108234, 0xE3A00002},
+	{0x00108238, 0x00000000},
+	{0x0010823C, 0x00108238},
+	{0x00108240, 0xEA03DFBB},
+	{0x00108244, 0xE5902834},
+	{0x00108248, 0xE51F1014},
+	{0x0010824C, 0xE5812000},
+	{0x00108250, 0xE3A01000},
+	{0x00108254, 0xE5801834},
+	{0x00108258, 0xE1A0F00E},
+	{0x0010825C, 0xEA03E040},
+	{0x00108260, 0xE51F002C},
+	{0x00108264, 0xE5900000},
+	{0x00108268, 0xE5810834},
+	{0x0010826C, 0xE1A0F00E},
+	{0x00108270, 0xE3500000},
+	{0x00108274, 0xEA03E602},
+	{0x00108278, 0xE59F200C},
+	{0x0010827C, 0xE3A01010},
+	{0x00108280, 0xE5C21000},
+	{0x00108284, 0xE1A02000},
+	{0x00108288, 0xE59FF000},
+	{0x0010828C, 0x50300038},
+	{0x00108290, 0x0000EA6C},
+	{0x00108294, 0x00000000},
+	{0x00108298, 0x00108294},
+	{0x0010829C, 0xEA03C6F7},
+	{0x001082A0, 0xE3500001},
+	{0x001082A4, 0x1A00001A},
+	{0x001082A8, 0xE92D0007},
+	{0x001082AC, 0xE51F001C},
+	{0x001082B0, 0xE5901000},
+	{0x001082B4, 0xE59F0050},
+	{0x001082B8, 0xE5D02000},
+	{0x001082BC, 0xE3520000},
+	{0x001082C0, 0x02811001},
+	{0x001082C4, 0x159F0044},
+	{0x001082C8, 0x15D02000},
+	{0x001082CC, 0x10811002},
+	{0x001082D0, 0xE51F0040},
+	{0x001082D4, 0xE3510F40},
+	{0x001082D8, 0x83A01000},
+	{0x001082DC, 0xE5801000},
+	{0x001082E0, 0x9A000007},
+	{0x001082E4, 0xE59F0020},
+	{0x001082E8, 0xE5D00000},
+	{0x001082EC, 0xE3500000},
+	{0x001082F0, 0x0A000003},
+	{0x001082F4, 0x13A00001},
+	{0x001082F8, 0xE3A01000},
+	{0x001082FC, 0xE3A02000},
+	{0x00108300, 0xEB000005},
+	{0x00108304, 0xE8BD0007},
+	{0x00108308, 0xE59FF014},
+	{0x0010830C, 0x0010670D},
+	{0x00108310, 0x00106046},
+	{0x00108314, 0xE51FF004},
+	{0x00108318, 0x00016770},
+	{0x0010831C, 0xE51FF004},
+	{0x00108320, 0x00012DB0},
+	{0x00108324, 0x000166C4},
+	{0x20040004, 0x00007B40},
+	{0x20040024, 0x00108000},
+	{0x20040008, 0x0000D534},
+	{0x20040028, 0x00108020},
+	{0x2004000C, 0x00017518},
+	{0x2004002C, 0x00108044},
+	{0x20040010, 0x00002520},
+	{0x20040030, 0x00108068},
+	{0x20040014, 0x00010000},
+	{0x20040034, 0x0010806C},
+	{0x20040018, 0x0000D79C},
+	{0x20040038, 0x00108078},
+	{0x2004001C, 0x0001659C},
+	{0x2004003C, 0x00108108},
+	{0x20040020, 0x00013B48},
+	{0x20040040, 0x001081A8},
+	{0x20040100, 0x0000FCC0},
+	{0x20040120, 0x001081BC},
+	{0x20040104, 0x00015090},
+	{0x20040124, 0x001081E8},
+	{0x20040108, 0x00002B24},
+	{0x20040128, 0x001081F8},
+	{0x2004010C, 0x00001790},
+	{0x2004012C, 0x00108234},
+	{0x20040110, 0x00010350},
+	{0x20040130, 0x00108240},
+	{0x20040114, 0x00010158},
+	{0x20040134, 0x0010825C},
+	{0x20040118, 0x0000EA68},
+	{0x20040138, 0x00108274},
+	{0x2004011C, 0x000166BC},
+	{0x2004013C, 0x0010829C},
+	{0x20040000, 0x0000FFFF},
+
+/*****************************************************************************/
+
+#else
+
+/*******************************************************************************
+* RDA5990E/F:
+*	  1. 
+*	  2. 802.1XEAPOL
+*	  3. MPLL
+*	  4. PM1
+*	  5. ACKPM1
+*	  6. (SSID)AP
+*	  7. SSIDAP
+*	  8. 
+*	  9. DSSS-OFDMPBCCChannel AgilityAP
+*		 
+*	  10.TKIPkey index1AP
+*		 WPA/WPA2APIP
+*		 ()
+*	  11.
+*	  12.BT/WIFI
+*
+* :
+*	  2012-11-22
+*
+******************************************************************************/
+	{0x00107FFC, 0x20121121},
+	{0x00108000, 0xEA04012F},
+	{0x00108004, 0x1A000001},
+	{0x00108008, 0xE8BD4010},
+	{0x0010800C, 0xEA000001},
+	{0x00108010, 0xE51FF004},
+	{0x00108014, 0x0000D4AC},
+	{0x00108018, 0xE51FF004},
+	{0x0010801C, 0x0000D654},
+	{0x00108020, 0xEA040142},
+	{0x00108024, 0xE3A00030},
+	{0x00108028, 0xE59F1008},
+	{0x0010802C, 0xEB000032},
+	{0x00108030, 0xE59F4004},
+	{0x00108034, 0xE59FF004},
+	{0x00108038, 0x00000241},
+	{0x0010803C, 0x0010670C},
+	{0x00108040, 0x00007B18},
+	{0x00108044, 0xEA03E06F},
+	{0x00108048, 0xE3A00030},
+	{0x0010804C, 0xE59F100C},
+	{0x00108050, 0xEB000029},
+	{0x00108054, 0xE2044001},
+	{0x00108058, 0xE3540000},
+	{0x0010805C, 0xE59FF000},
+	{0x00108060, 0x00000249},
+	{0x00108064, 0x0000FE88},
+	{0x00108068, 0xE1A00004},
+	{0x0010806C, 0xE3A04000},
+	{0x00108070, 0x00001468},
+	{0x00108074, 0x00108070},
+	{0x00108078, 0xEA03EA36},
+	{0x0010807C, 0x0A000019},
+	{0x00108080, 0xE3E00006},
+	{0x00108084, 0xE3A015C0},
+	{0x00108088, 0xE5810000},
+	{0x0010808C, 0xE3A0000F},
+	{0x00108090, 0xEB000015},
+	{0x00108094, 0xE51F1028},
+	{0x00108098, 0xE5912000},
+	{0x0010809C, 0xE3822C80},
+	{0x001080A0, 0xE5812000},
+	{0x001080A4, 0xE1A01002},
+	{0x001080A8, 0xE3A00029},
+	{0x001080AC, 0xEB000012},
+	{0x001080B0, 0xE51F1044},
+	{0x001080B4, 0xE5912000},
+	{0x001080B8, 0xE3822CC0},
+	{0x001080BC, 0xE5812000},
+	{0x001080C0, 0xE1A01002},
+	{0x001080C4, 0xE3A00029},
+	{0x001080C8, 0xEB00000B},
+	{0x001080CC, 0xE51F1060},
+	{0x001080D0, 0xE5912000},
+	{0x001080D4, 0xE3C22CC0},
+	{0x001080D8, 0xE5812000},
+	{0x001080DC, 0xE1A01002},
+	{0x001080E0, 0xE3A00029},
+	{0x001080E4, 0xEB000004},
+	{0x001080E8, 0xE59FF014},
+	{0x001080EC, 0xE51FF004},
+	{0x001080F0, 0x00003784},
+	{0x001080F4, 0xE51FF004},
+	{0x001080F8, 0x000114B0},
+	{0x001080FC, 0xE51FF004},
+	{0x00108100, 0x0001BD58},
+	{0x00108104, 0x0000D7B0},
+	{0x00108108, 0xEA03C6DA},
+	{0x0010810C, 0x0A000019},
+	{0x00108110, 0xE3E00006},
+	{0x00108114, 0xE3A015C0},
+	{0x00108118, 0xE5810000},
+	{0x0010811C, 0xE3A0000F},
+	{0x00108120, 0xEBFFFFF1},
+	{0x00108124, 0xE51F10B8},
+	{0x00108128, 0xE5912000},
+	{0x0010812C, 0xE3822C80},
+	{0x00108130, 0xE5812000},
+	{0x00108134, 0xE1A01002},
+	{0x00108138, 0xE3A00029},
+	{0x0010813C, 0xEBFFFFEE},
+	{0x00108140, 0xE51F10D4},
+	{0x00108144, 0xE5912000},
+	{0x00108148, 0xE3822CC0},
+	{0x0010814C, 0xE5812000},
+	{0x00108150, 0xE1A01002},
+	{0x00108154, 0xE3A00029},
+	{0x00108158, 0xEBFFFFE7},
+	{0x0010815C, 0xE51F10F0},
+	{0x00108160, 0xE5912000},
+	{0x00108164, 0xE3C22CC0},
+	{0x00108168, 0xE5812000},
+	{0x0010816C, 0xE1A01002},
+	{0x00108170, 0xE3A00029},
+	{0x00108174, 0xEBFFFFE0},
+	{0x00108178, 0xE51FF004},
+	{0x0010817C, 0x000165B0},
+	{0x00108180, 0x00000000},
+	{0x00108184, 0x00000000},
+	{0x00108188, 0x00000000},
+	{0x0010818C, 0x00000000},
+	{0x00108190, 0x00000000},
+	{0x00108194, 0x00000000},
+	{0x00108198, 0x00000000},
+	{0x0010819C, 0x00000000},
+	{0x001081A0, 0x00000000},
+	{0x001081A4, 0x00108180},
+	{0x001081A8, 0xEA03D197},
+	{0x001081AC, 0xE92D40F8},
+	{0x001081B0, 0xE51F5014},
+	{0x001081B4, 0xE51FF004},
+	{0x001081B8, 0x00015730},
+	{0x001081BC, 0xEA03E13E},
+	{0x001081C0, 0xE59F0018},
+	{0x001081C4, 0xE5901038},
+	{0x001081C8, 0xE3110080},
+	{0x001081CC, 0x1A000001},
+	{0x001081D0, 0xE3A01003},
+	{0x001081D4, 0xE59FF008},
+	{0x001081D8, 0xE51FF004},
+	{0x001081DC, 0x0000FD18},
+	{0x001081E0, 0x50300000},
+	{0x001081E4, 0x0000FCC4},
+	{0x001081E8, 0xE1A00000},
+	{0x001081EC, 0x00000000},
+	{0x001081F0, 0x00000000},
+	{0x001081F4, 0x001081EC},
+	{0x001081F8, 0xEA0415B4},
+	{0x001081FC, 0xE2860018},
+	{0x00108200, 0xE3A02006},
+	{0x00108204, 0xE51F1018},
+	{0x00108208, 0xEB000003},
+	{0x0010820C, 0xE3500000},
+	{0x00108210, 0x01A07004},
+	{0x00108214, 0x0A000002},
+	{0x00108218, 0x1A000003},
+	{0x0010821C, 0xE51FF004},
+	{0x00108220, 0x00000160},
+	{0x00108224, 0xE51FF004},
+	{0x00108228, 0x00002BA0},
+	{0x0010822C, 0xE51FF004},
+	{0x00108230, 0x00002B8C},
+	{0x00108234, 0xE3A00002},
+	{0x00108238, 0x00000000},
+	{0x0010823C, 0x00108238},
+	{0x00108240, 0xEA03DFBB},
+	{0x00108244, 0xE5902834},
+	{0x00108248, 0xE51F1014},
+	{0x0010824C, 0xE5812000},
+	{0x00108250, 0xE3A01000},
+	{0x00108254, 0xE5801834},
+	{0x00108258, 0xE1A0F00E},
+	{0x0010825C, 0xEA03E040},
+	{0x00108260, 0xE51F002C},
+	{0x00108264, 0xE5900000},
+	{0x00108268, 0xE5810834},
+	{0x0010826C, 0xE1A0F00E},
+	{0x00108270, 0xEAFFFFEC},
+	{0x00108274, 0xEA03D8C4},
+	{0x00108278, 0xE3A00030},
+	{0x0010827C, 0xE59F1008},
+	{0x00108280, 0xEBFFFF9D},
+	{0x00108284, 0xE3A01003},
+	{0x00108288, 0xE59FF000},
+	{0x0010828C, 0x00000241},
+	{0x00108290, 0x00011F6C},
+	{0x20040004, 0x00007B40},
+	{0x20040024, 0x00108000},
+	{0x20040008, 0x00007B14},
+	{0x20040028, 0x00108020},
+	{0x2004000C, 0x0000FE84},
+	{0x2004002C, 0x00108044},
+	{0x20040010, 0x00002520},
+	{0x20040030, 0x00108068},
+	{0x20040014, 0x00010000},
+	{0x20040034, 0x0010806C},
+	{0x20040018, 0x0000D79C},
+	{0x20040038, 0x00108078},
+	{0x2004001C, 0x0001659C},
+	{0x2004003C, 0x00108108},
+	{0x20040020, 0x00013B48},
+	{0x20040040, 0x001081A8},
+	{0x20040100, 0x0000FCC0},
+	{0x20040120, 0x001081BC},
+	{0x20040104, 0x00015090},
+	{0x20040124, 0x001081E8},
+	{0x20040108, 0x00002B24},
+	{0x20040128, 0x001081F8},
+	{0x2004010C, 0x00001790},
+	{0x2004012C, 0x00108234},
+	{0x20040110, 0x00010350},
+	{0x20040130, 0x00108240},
+	{0x20040114, 0x00010158},
+	{0x20040134, 0x0010825C},
+	{0x20040118, 0x00017518},
+	{0x20040138, 0x00108270},
+	{0x2004011C, 0x00011F60},
+	{0x2004013C, 0x00108274},
+	{0x20040000, 0x0000FFFF},
+#endif
+};
+
+const u8 wifi_core_patch_data_90_8[][2] = {
+	{0x28, 0x1a},
+	{0x29, 0x0d},
+	{0x35, 0x1e},
+	{0x4c, 0x90},
+	{0x4d, 0x38},
+	{0x39, 0x07},
+	{0xe4, 0xf5},
+	{0x21, 0x00},		//default 0
+	{0x23, 0x10},
+	{0x48, 0x0e},
+	{0x25, 0x00},
+	{0x20, 0xa8},
+	{0x3f, 0x05},
+	{0x41, 0x37},
+	{0x42, 0x40},
+	{0xc5, 0x7c},
+	{0x5b, 0xa9},
+};
+
+//#define       WF_PAT_CFG_2012_04_15
+
+/*if define FORCE_WF, wf is not allow of any activity, antenna switch is also forced to bt*/
+//#define       FORCE_WF
+
+/*if define FORCE_WF_TX ,wf is not allow to do tx and pa is also disabled, but antenna is not forced*/
+//#define       FORCE_WF_TX
+
+/*if define FORCE_WF_RX ,wf is not allow to do rx but antenna is not forced*/
+//#define       FORCE_WF_RX
+
+/*if define FORCE_WF_RX_TX wf is not allow to do any tx and rx , pa disabled , but	antenna is not forced*/
+//#define       FORCE_WF_RX_TX
+
+//#define WF_PAT_CFG_2012_05_19
+#define WF_PAT_CFG_2013_04_08
+
+const u32 wifi_core_init_data_32_90_D[][2] = {
+#ifdef	 FORCE_WF_RX_TX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0x00000000},	// not grant to rx and tx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef	 FORCE_WF_RX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0xFF000F00},	//wf not grant to rx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef FORCE_WF_TX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0x00FF0033},	//wf not grant to tx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef WF_PAT_CFG_2012_05_19
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0xFFFF0F03},	//0xFFFF0F33
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef WF_PAT_CFG_2013_04_08
+	{0x50000800, 0x00000000},
+	{0x50000804, 0x00200000},	//ack as high
+	{0x50000838, 0x00101014},
+	{0x5000083C, 0x00333101},
+	{0x50000808, 0x75000013},
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFFF0111},
+	{0x50000814, 0xFFFF0111},
+	{0x50000818, 0x00FF0011},
+	{0x5000081C, 0xFF000100},
+	{0x50000820, 0xFF000100},
+	{0x50000824, 0x0000FEEE},
+	{0x50000828, 0x00100F10},
+	{0x50000834, 0x00000000},
+#endif
+
+#ifdef	FORCE_WF
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000838, 0xF8003f2A},
+	{0x5000083c, 0x00000003},
+	{0x50000808, 0xfe00001b},
+	{0x50000810, 0x00000000},
+	{0x50000814, 0x00000000},
+	{0x50000818, 0x00000000},
+	{0x5000081C, 0x00000000},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0xffffffff},
+	{0x50000828, 0x00100F10},
+#endif
+
+#ifdef WF_PAT_CFG_2012_04_15	/*pta config */
+	{0x50000800, 0xFC003E05},	//tx_pri hi bits ctrl&mgmt package
+	{0x50000804, 0x00000000},	//tx_pri hi bits                                                                                                                                                                                                                                as hi pri
+	{0x50000808, 0xA500001B},	//sig_mode and protect time
+	{0x5000080c, 0x000001C0},	//sigWire mode
+	{0x50000810, 0xFFCC0F01},	//Lut bt
+	{0x50000814, 0xFFFF0F33},	//Lut wf
+	{0x50000818, 0x00FF0001},	//antSel0 for wl_rx
+	{0x5000081C, 0xFF000F00},	//antSel1 for wl_tx
+	{0x50000820, 0xFF000F00},	//antSel2 for wl_pa
+	//{0x50000838,0xFFFFFFFF}, //rx_pri low bits as high pri
+	//{0x5000083C,0xFFFFFFFF}, //rx_pri high  bits as high pri
+#endif
+
+/*end pta config*/
+	{0x00106b6c, 0x00000002},	// scan channel 13
+	{0x30010004, 0x0000f77c},	//intn config
+	{0x30010010, 0x00007dff},	//intn config
+	//item111:ver_b_wf_dig_2011_10_09
+	{0x30010000, 0x780369AF},	//disable tports wait  100ms;
+	{0x30000010, 0x7000FFFF},	//wait 500ms;
+	{0x50090054, 0x00000001},	//enable update
+	{0x50090200, 0x00000000},
+	{0x50090204, 0x00000000},
+	{0x50090208, 0x00000002},
+	{0x5009020c, 0x00000004},
+	{0x50090210, 0x00000006},
+	{0x50090214, 0x00000008},
+	{0x50090218, 0x0000000a},
+	{0x5009021c, 0x00000040},
+	{0x50090220, 0x00000042},
+	{0x50090224, 0x00000044},
+	{0x50090228, 0x00000046},
+	{0x5009022c, 0x00000048},
+	{0x50090230, 0x0000004a},
+	{0x50090234, 0x00000080},
+	{0x50090238, 0x00000082},
+	{0x5009023c, 0x00000084},
+	{0x50090240, 0x00000086},
+	{0x50090244, 0x00000088},
+	{0x50090248, 0x0000008a},
+	{0x5009024c, 0x000000c0},
+	{0x50090250, 0x000000c2},
+	{0x50090254, 0x000000c4},
+	{0x50090258, 0x000000c6},
+	{0x5009025c, 0x000000c8},
+	{0x5009025c, 0x000000c8},
+	{0x50090260, 0x000000ca},
+	{0x50090264, 0x00000100},
+	{0x50090268, 0x00000102},
+	{0x5009026c, 0x00000104},
+	{0x50090270, 0x00000106},
+	{0x50090274, 0x00000108},
+	{0x50090278, 0x00000140},
+	{0x5009027c, 0x00000142},	//lna =0 end
+	{0x50090280, 0x00000080},
+	{0x50090284, 0x00000082},
+	{0x50090288, 0x00000084},
+	{0x5009028c, 0x00000086},
+	{0x50090290, 0x00000088},
+	{0x50090294, 0x0000008a},
+	{0x50090298, 0x000000c0},
+	{0x5009029c, 0x000000c2},
+	{0x500902a0, 0x000000c4},
+	{0x500902a4, 0x000000c6},
+	{0x500902a8, 0x000000c8},
+	{0x500902ac, 0x000000ca},
+	{0x500902b0, 0x00000100},
+	{0x500902b4, 0x00000102},
+	{0x500902b8, 0x00000104},
+	{0x500902bc, 0x00000106},
+	{0x500902c0, 0x00000108},
+	{0x500902c4, 0x00000140},
+	{0x500902c8, 0x00000142},
+	{0x500902cc, 0x00000144},
+	{0x500902d0, 0x00000146},
+	{0x500902d4, 0x00000148},
+	{0x500902d8, 0x00000180},
+	{0x500902dc, 0x00000182},
+	{0x500902e0, 0x00000184},
+	{0x500902e4, 0x000001c0},
+	{0x500902e8, 0x000001c2},
+	{0x500902ec, 0x000001c4},
+	{0x500902f0, 0x000001c6},
+	{0x500902f4, 0x000001c8},
+	{0x500902f8, 0x000001ca},
+	{0x500902fc, 0x000001cc},	// lna = 01  end
+	{0x50090300, 0x00000102},
+	{0x50090304, 0x00000104},
+	{0x50090308, 0x00000106},
+	{0x5009030c, 0x00000108},
+	{0x50090310, 0x00000140},
+	{0x50090314, 0x00000142},
+	{0x50090318, 0x00000144},
+	{0x5009031c, 0x00000146},
+	{0x50090320, 0x00000148},
+	{0x50090324, 0x00000180},
+	{0x50090328, 0x00000182},
+	{0x5009032c, 0x00000184},
+	{0x50090330, 0x000001c0},
+	{0x50090334, 0x000001c2},
+	{0x50090338, 0x000001c4},
+	{0x5009033c, 0x000001c6},
+	{0x50090340, 0x000001c8},
+	{0x50090344, 0x000001c9},
+	{0x50090348, 0x000001c9},
+	{0x5009034c, 0x000001c9},
+	{0x50090350, 0x000001c9},
+	{0x50090354, 0x000001c9},
+	{0x50090358, 0x000001c9},
+	{0x5009035c, 0x000001c9},
+	{0x50090360, 0x000001c9},
+	{0x50090364, 0x000001c9},
+	{0x50090368, 0x000001c9},
+	{0x5009036c, 0x000001c9},
+	{0x50090370, 0x000001c9},
+	{0x50090374, 0x000001c9},
+	{0x50090378, 0x000001c9},
+	{0x5009037c, 0x000001c9},
+	{0x50090054, 0x00000000},	//disable update
+
+	{0x5000050c, 0x00008000},	// for association power save
+
+	//{  0x50000808, 0x65000013 }, // disable prerx_priority;pta config
+	//{  0x50000810, 0xFFCD0F01 },  //rx beacon priority
+
+};
+
+const u32 wifi_core_init_data_32_90_E[][2] = {
+#ifdef	 FORCE_WF_RX_TX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0x00000000},	// not grant to rx and tx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef	 FORCE_WF_RX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0xFF000F00},	//wf not grant to rx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef FORCE_WF_TX
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0x00FF0033},	//wf not grant to tx
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef WF_PAT_CFG_2012_05_19
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000808, 0xA5000013},	//no pre_active protect
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFCC0F01},
+	{0x50000814, 0xFFFF0F03},	//0xFFFF0F33
+	{0x50000818, 0x00FF0001},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0FE},
+	{0x50000828, 0x00100F10},
+	{0x50000838, 0xFFFFFFFF},
+	{0x5000083C, 0xFFFFFFFF},
+#endif
+
+#ifdef WF_PAT_CFG_2013_04_08
+	{0x50000800, 0x00000000},
+	{0x50000804, 0x00200000},	//ack as high
+	{0x50000838, 0x00101014},
+	{0x5000083C, 0x00333101},
+	{0x50000808, 0x75000013},
+	{0x5000080c, 0x000001C0},
+	{0x50000810, 0xFFFF0111},
+	{0x50000814, 0xFFFF0111},
+	{0x50000818, 0x00FF0011},
+	{0x5000081C, 0xFF000100},
+	{0x50000820, 0xFF000100},
+	{0x50000824, 0x0000FEEE},
+	{0x50000828, 0x00100F10},
+	{0x50000834, 0x00000000},
+#endif
+
+#ifdef	FORCE_WF
+	{0x50000800, 0xFC003E05},
+	{0x50000804, 0x00000000},
+	{0x50000838, 0xF8003f2A},
+	{0x5000083c, 0x00000003},
+	{0x50000808, 0xfe00001b},
+	{0x50000810, 0x00000000},
+	{0x50000814, 0x00000000},
+	{0x50000818, 0x00000000},
+	{0x5000081C, 0x00000000},
+	{0x50000820, 0x00000000},
+	{0x50000824, 0xffffffff},
+	{0x50000828, 0x00100F10},
+#endif
+
+#ifdef WF_PAT_CFG_2012_04_15	/*pta config */
+	{0x50000800, 0xFC003E05},	//tx_pri hi bits ctrl&mgmt package
+	{0x50000804, 0x00000000},	//tx_pri hi bits                                                                                                                                                                                                                                as hi pri
+	{0x50000808, 0xA500001B},	//sig_mode and protect time
+	{0x5000080c, 0x000001C0},	//sigWire mode
+	{0x50000810, 0xFFCC0F01},	//Lut bt
+	{0x50000814, 0xFFFF0F33},	//Lut wf
+	{0x50000818, 0x00FF0001},	//antSel0 for wl_rx
+	{0x5000081C, 0xFF000F00},	//antSel1 for wl_tx
+	{0x50000820, 0xFF000F00},	//antSel2 for wl_pa
+	//{0x50000838,0xFFFFFFFF}, //rx_pri low bits as high pri
+	//{0x5000083C,0xFFFFFFFF}, //rx_pri high  bits as high pri
+#endif
+
+	{0x30010004, 0x0000f77c},	//intn config
+	{0x30010010, 0x00007dff},	//intn config
+	//item111:ver_b_wf_dig_2011_10_09
+	{0x30010000, 0x78036BAF},	//disable tports wait  100ms;
+	{0x30000010, 0x7000FFFF},	//wait 500ms;
+	{0x5000050c, 0x00008000},	// for association power save
+};
+
+const u32 wifi_notch_data_90_D[][2] = {
+	//ch 1
+	{0x001008d0, 0x50090040},
+	{0x001008d4, 0x057213a2},
+	{0x001008d8, 0x50090044},
+	{0x001008dc, 0x10000000},
+	//ch 2
+	{0x00100910, 0x50090040},
+	{0x00100914, 0x10000000},
+	{0x00100918, 0x50090044},
+	{0x0010091c, 0x10000000},
+	//ch 3
+	{0x00100950, 0x50090040},
+	{0x00100954, 0x10000000},
+	{0x00100958, 0x50090044},
+	{0x0010095c, 0x10000000},
+	//ch 4
+	{0x00100990, 0x50090040},
+	{0x00100994, 0x10000000},
+	{0x00100998, 0x50090044},
+	{0x0010099c, 0x10000000},
+	//ch 5
+	{0x001009d0, 0x50090040},
+	{0x001009d4, 0x056794b4},
+	{0x001009d8, 0x50090044},
+	{0x001009dc, 0x10000000},
+	//ch 6
+	{0x00100a10, 0x50090040},
+	{0x00100a14, 0x057c71de},	//Modified Accord To xiongzhi 0x077c71de----old
+	{0x00100a18, 0x50090044},
+	{0x00100a1c, 0x10000000},	//Modified Accord To xiongzhi 0x046d242e----old
+	//ch 7
+	{0x00100a50, 0x50090040},
+	{0x00100a54, 0x057e7140},
+	{0x00100a58, 0x50090044},
+	{0x00100a5c, 0x10000000},
+	//ch 8
+	{0x00100a90, 0x50090040},
+	{0x00100a94, 0x057c7e22},	//Modified Accord To xiongzhi 0x077c7e22----old
+	{0x00100a98, 0x50090044},
+	{0x00100a9c, 0x10000000},	//Modified Accord To xiongzhi 0x046d2bd2----old
+	//ch 9
+	{0x00100ad0, 0x50090040},
+	{0x00100ad4, 0x10000000},
+	{0x00100ad8, 0x50090044},
+	{0x00100adc, 0x10000000},
+	//ch 10
+	{0x00100b10, 0x50090040},
+	{0x00100b14, 0x10000000},
+	{0x00100b18, 0x50090044},
+	{0x00100b1c, 0x10000000},
+	//ch 11
+	{0x00100b50, 0x50090040},
+	{0x00100b54, 0x10000000},
+	{0x00100b58, 0x50090044},
+	{0x00100b5c, 0x10000000},
+	//ch 12
+	{0x00100b90, 0x50090040},
+	{0x00100b94, 0x05764310},
+	{0x00100b98, 0x50090044},
+	{0x00100b9c, 0x10000000},
+	//ch 13
+	{0x00100bd0, 0x50090040},
+	{0x00100bd4, 0x056794b4},
+	{0x00100bd8, 0x50090044},
+	{0x00100bdc, 0x10000000},
+	//ch 14
+	{0x00100c10, 0x50090040},
+	{0x00100c14, 0x0579c279},
+	{0x00100c18, 0x50090044},
+	{0x00100c1c, 0x0579cd87},
+};
+
+const u32 wifi_notch_data_90_E[][2] = {
+	// For Verion E
+	//ch 1
+	{0x001007CC, 0x50090040},
+	{0x001007D0, 0x057213a2},
+	{0x001007D4, 0x50090044},
+	{0x001007D8, 0x10000000},
+	//ch 2
+	{0x001007FC, 0x50090040},
+	{0x00100800, 0x10000000},
+	{0x00100804, 0x50090044},
+	{0x00100808, 0x10000000},
+	//ch 3
+	{0x0010082C, 0x50090040},
+	{0x00100830, 0x10000000},
+	{0x00100834, 0x50090044},
+	{0x00100838, 0x10000000},
+	//ch 4
+	{0x0010085C, 0x50090040},
+	{0x00100860, 0x10000000},
+	{0x00100864, 0x50090044},
+	{0x00100868, 0x10000000},
+	//ch 5
+	{0x0010088C, 0x50090040},
+	{0x00100890, 0x056794b4},
+	{0x00100894, 0x50090044},
+	{0x00100898, 0x10000000},
+	//ch 6
+	{0x001008BC, 0x50090040},
+	{0x001008C0, 0x057c71de},
+	{0x001008C4, 0x50090044},
+	{0x001008C8, 0x10000000},
+	//ch 7
+	{0x001008EC, 0x50090040},
+	{0x001008F0, 0x057e7140},
+	{0x001008F4, 0x50090044},
+	{0x001008F8, 0x10000000},
+	//ch 8
+	{0x0010091C, 0x50090040},
+	{0x00100920, 0x057c7e22},
+	{0x00100924, 0x50090044},
+	{0x00100928, 0x10000000},
+	//ch 9
+	{0x0010094C, 0x50090040},
+	{0x00100950, 0x10000000},
+	{0x00100954, 0x50090044},
+	{0x00100958, 0x10000000},
+	//ch 10
+	{0x0010097C, 0x50090040},
+	{0x00100980, 0x10000000},
+	{0x00100984, 0x50090044},
+	{0x00100988, 0x10000000},
+	//ch 11
+	{0x001009AC, 0x50090040},
+	{0x001009B0, 0x10000000},
+	{0x001009B4, 0x50090044},
+	{0x001009B8, 0x10000000},
+	//ch 12
+	{0x001009DC, 0x50090040},
+	{0x001009E0, 0x05764310},
+	{0x001009E4, 0x50090044},
+	{0x001009E8, 0x10000000},
+	//ch 13
+	{0x00100A0C, 0x50090040},
+	{0x00100A10, 0x056794b4},
+	{0x00100A14, 0x50090044},
+	{0x00100A18, 0x10000000},
+	//ch 14
+	{0x00100A3C, 0x50090040},
+	{0x00100A40, 0x0579c279},
+	{0x00100A44, 0x50090044},
+	{0x00100A4c, 0x0579cd87},
+};
+
+//common sdio clock open
+const u32 wifi_core_data_wake[][2] = {
+	{0x3001003c, 0x2e00a000},
+};
+#endif
+//sleep sdio switch
+const u32 wifi_core_data_sleep[][2] = {
+	{0x3001003c, 0x2e00a100},
+};
+
+const u32 wifi_phy_timeout_cfg_90[][2] = {
+	{0x50000634, 0x00001100},
+	{0x50000584, 0x00005BF8},
+};
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_test_mode_rx_notch_32_90[][2] = {
+	//item:notch_filter_5
+	{0x50090040, 0x076794b4},	//8m
+	{0x50090044, 0x10000000},
+	//item:notch_filter_6
+	{0x50090040, 0x057c71de},	//3m
+	{0x50090044, 0x10000000},	//7m
+	//item:notch_filter_7
+	{0x50090040, 0x077e7ec0},	//2m
+	{0x50090044, 0x077e7140},	//-2m
+	//item:notch_filter_8
+	{0x50090040, 0x057c7e22},	//3m
+	{0x50090044, 0x10000000},	//7m
+	//item:notch_filter_c
+	{0x50090040, 0x07764310},	//5m
+	{0x50090044, 0x10000000},
+	//item:notch_filter_e
+	{0x50090040, 0x0779c279},	//4m
+	{0x50090044, 0x0779cd87},	//-4m
+	//item:disable_notch
+	{0x50090040, 0x10000000},
+	{0x50090044, 0x10000000},
+};
+
+static const u32 wifi_test_mode_agc_patch32_90[][2] = {
+	{0x50000600, 0x0000501a},	//write 1a(52) to 28h hightolow
+	{0x50000600, 0x0000520d},	//write 0d(26) to 29h hightomid
+	{0x50000600, 0x00006a1e},	//35h reg coarse2 upper window from 0d to 1a for l
+	//;50000600H,32'h00009890;//4ch reg unlock upper threshold from 70 to 90
+	{0x50000600, 0x00009a38},	//4dh reg unlock lower threshold from 78 to 38
+	{0x50000600, 0x00007207},	//39h reg change vga gain ,9 -> 7 for big signal
+	{0x50000600, 0x0001c8f5},	//e4h reg change hpf coeff to f5
+	{0x50000600, 0x00004200},	//21h reg add fine gain 0db
+	{0x50000600, 0x00004610},	//23h reg change maxgain index as agc table
+	{0x50000600, 0x0000900e},	//48h reg unlock lower threshold change from 0a to
+	{0x50000600, 0x00004a00},	//25h reg pecket dection threshold
+	{0x50000600, 0x000040a8},	//20h reg add  fine itr2 98->a8
+	{0x50000600, 0x00007e05},	//3f reg rssi window for fine itr2 0->5
+	{0x50000600, 0x00008237},	//41 reg fine itr1 nextstate 4->3
+	{0x50000600, 0x00008440},	//42 reg fine itr2 nextstate 0->4 settle time 0->d
+	{0x50000600, 0x0000b6a9},	//5b reg change GreatN rssi avg count from 1 to 8
+};
+
+static const u32 wlan_test_mode_digital32_90[][2] = {
+	//item111:ver_D_wf_dig_20120208
+	{0x30010000, 0x780369AF},	//disable tports
+	//wait 100ms;
+	{0x30000010, 0x7000FFFF},
+	//item:agc_table_20110921
+	{0x50090054, 0x00000001},	//enable update
+	{0x50090200, 0x00000000},
+	{0x50090204, 0x00000000},
+	{0x50090208, 0x00000002},
+	{0x5009020c, 0x00000004},
+	{0x50090210, 0x00000006},
+	{0x50090214, 0x00000008},
+	{0x50090218, 0x0000000a},
+	{0x5009021c, 0x00000040},
+	{0x50090220, 0x00000042},
+	{0x50090224, 0x00000044},
+	{0x50090228, 0x00000046},
+	{0x5009022c, 0x00000048},
+	{0x50090230, 0x0000004a},
+	{0x50090234, 0x00000080},
+	{0x50090238, 0x00000082},
+	{0x5009023c, 0x00000084},
+	{0x50090240, 0x00000086},
+	{0x50090244, 0x00000088},
+	{0x50090248, 0x0000008a},
+	{0x5009024c, 0x000000c0},
+	{0x50090250, 0x000000c2},
+	{0x50090254, 0x000000c4},
+	{0x50090258, 0x000000c6},
+	{0x5009025c, 0x000000c8},
+	{0x50090260, 0x000000ca},
+	{0x50090264, 0x00000100},
+	{0x50090268, 0x00000102},
+	{0x5009026c, 0x00000104},
+	{0x50090270, 0x00000106},
+	{0x50090274, 0x00000108},
+	{0x50090278, 0x00000140},
+	{0x5009027c, 0x00000142},	//lna =0 end
+	{0x50090280, 0x00000080},
+	{0x50090284, 0x00000082},
+	{0x50090288, 0x00000084},
+	{0x5009028c, 0x00000086},
+	{0x50090290, 0x00000088},
+	{0x50090294, 0x0000008a},
+	{0x50090298, 0x000000c0},
+	{0x5009029c, 0x000000c2},
+	{0x500902a0, 0x000000c4},
+	{0x500902a4, 0x000000c6},
+	{0x500902a8, 0x000000c8},
+	{0x500902ac, 0x000000ca},
+	{0x500902b0, 0x00000100},
+	{0x500902b4, 0x00000102},
+	{0x500902b8, 0x00000104},
+	{0x500902bc, 0x00000106},
+	{0x500902c0, 0x00000108},
+	{0x500902c4, 0x00000140},
+	{0x500902c8, 0x00000142},
+	{0x500902cc, 0x00000144},
+	{0x500902d0, 0x00000146},
+	{0x500902d4, 0x00000148},
+	{0x500902d8, 0x00000180},
+	{0x500902dc, 0x00000182},
+	{0x500902e0, 0x00000184},
+	{0x500902e4, 0x000001c0},
+	{0x500902e8, 0x000001c2},
+	{0x500902ec, 0x000001c4},
+	{0x500902f0, 0x000001c6},
+	{0x500902f4, 0x000001c8},
+	{0x500902f8, 0x000001ca},
+	{0x500902fc, 0x000001cc},	// lna = 01  end
+	{0x50090300, 0x00000102},
+	{0x50090304, 0x00000104},
+	{0x50090308, 0x00000106},
+	{0x5009030c, 0x00000108},
+	{0x50090310, 0x00000140},
+	{0x50090314, 0x00000142},
+	{0x50090318, 0x00000144},
+	{0x5009031c, 0x00000146},
+	{0x50090320, 0x00000148},
+	{0x50090324, 0x00000180},
+	{0x50090328, 0x00000182},
+	{0x5009032c, 0x00000184},
+	{0x50090330, 0x000001c0},
+	{0x50090334, 0x000001c2},
+	{0x50090338, 0x000001c4},
+	{0x5009033c, 0x000001c6},
+	{0x50090340, 0x000001c8},
+	{0x50090344, 0x000001c9},
+	{0x50090348, 0x000001c9},
+	{0x5009034c, 0x000001c9},
+	{0x50090350, 0x000001c9},
+	{0x50090354, 0x000001c9},
+	{0x50090358, 0x000001c9},
+	{0x5009035c, 0x000001c9},
+	{0x50090360, 0x000001c9},
+	{0x50090364, 0x000001c9},
+	{0x50090368, 0x000001c9},
+	{0x5009036c, 0x000001c9},
+	{0x50090370, 0x000001c9},
+	{0x50090374, 0x000001c9},
+	{0x50090378, 0x000001c9},
+	{0x5009037c, 0x000001c9},
+	{0x50090054, 0x00000000},	//disable update
+	{0x50000808, 0x65000013},	// disable prerx_prio
+	//pta config
+	{0x50000810, 0xFFCD0F01},	//rx beacon priority
+};
+#endif
+
+#endif /*end of file */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91.h
new file mode 100644
index 000000000000..b23d673d61c1
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91.h
@@ -0,0 +1,774 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLAND_TRAP_91_H_
+#define _WLAND_TRAP_91_H_
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_core_patch_data_32_91[][2] = {
+	// add for pta
+	{0x50000828, 0x00100FFD},
+	{0x50000810, 0xFFFF0F0F},
+	{0x50000814, 0xFFFF0F0F},
+	{0x50000818, 0x00FF000F},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0F0},
+	// add for pta
+	{0x0010FFFC, 0x20131231},
+	{0x00110000, 0xEA03ECE7},
+	{0x00110004, 0xE59D0000},
+	{0x00110008, 0xE3C01008},
+	{0x0011000C, 0xE58D1000},
+	{0x00110010, 0xE3A00030},
+	{0x00110014, 0xEB000001},
+	{0x00110018, 0xE3A0100C},
+	{0x0011001C, 0xE59FF004},
+	{0x00110020, 0xE51FF004},
+	{0x00110024, 0x0001D33C},
+	{0x00110028, 0x00014C64},
+	{0x0011002C, 0xEA03E563},
+	{0x00110030, 0xE3130008},
+	{0x00110034, 0x159F0020},
+	{0x00110038, 0x1A000002},
+	{0x0011003C, 0xE3130004},
+	{0x00110040, 0x059F000C},
+	{0x00110044, 0x159F000C},
+	{0x00110048, 0xE5840008},
+	{0x0011004C, 0xE3A00010},
+	{0x00110050, 0xE59FF008},
+	{0x00110054, 0x00010140},
+	{0x00110058, 0x00010141},
+	{0x0011005C, 0x00010142},
+	{0x00110060, 0x00016AA0},
+	{0x00110064, 0xEA03CB40},
+	{0x00110068, 0xE1A02004},
+	{0x0011006C, 0xE1A02822},
+	{0x00110070, 0xE202207F},
+	{0x00110074, 0xE3520029},
+	{0x00110078, 0x1A000010},
+	{0x0011007C, 0xE1A04804},
+	{0x00110080, 0xE1A04824},
+	{0x00110084, 0xE59F003C},
+	{0x00110088, 0xE1540000},
+	{0x0011008C, 0x059F1040},
+	{0x00110090, 0xE59F0034},
+	{0x00110094, 0xE1540000},
+	{0x00110098, 0x059F1038},
+	{0x0011009C, 0xE59F002C},
+	{0x001100A0, 0xE1540000},
+	{0x001100A4, 0x059F1030},
+	{0x001100A8, 0xE3A027C0},
+	{0x001100AC, 0xE3A04028},
+	{0x001100B0, 0xE1A04804},
+	{0x001100B4, 0xE1824004},
+	{0x001100B8, 0xE1844001},
+	{0x001100BC, 0xE59F101C},
+	{0x001100C0, 0xE5814034},
+	{0x001100C4, 0xE59FF018},
+	{0x001100C8, 0x00009468},
+	{0x001100CC, 0x0000D468},
+	{0x001100D0, 0x00001468},
+	{0x001100D4, 0x00001F20},
+	{0x001100D8, 0x00001320},
+	{0x001100DC, 0x00001320},
+	{0x001100E0, 0x50090000},
+	{0x001100E4, 0x0001D364},
+	{0x001100E8, 0xEA03D7EB},
+	{0x001100EC, 0xE59F0010},
+	{0x001100F0, 0xE3A04003},
+	{0x001100F4, 0xE5804000},
+	{0x001100F8, 0xE59F4008},
+	{0x001100FC, 0xE5940000},
+	{0x00110100, 0xE59FF004},
+	{0x00110104, 0x50000228},
+	{0x00110108, 0x00100B08},
+	{0x0011010C, 0x0001A13C},
+	{0x00110110, 0xEA03ED23},
+	{0x00110114, 0xE3510000},
+	{0x00110118, 0xE51FF004},
+	{0x0011011C, 0x00014C84},
+	{0x00110120, 0xEA03FC88},
+	{0x00110124, 0xE1C510B8},
+	{0x00110128, 0xE3510015},
+	{0x0011012C, 0xBA00001D},
+	{0x00110130, 0xE59F2074},
+	{0x00110134, 0xE3A01020},
+	{0x00110138, 0xE5C21000},
+	{0x0011013C, 0xEB000019},
+	{0x00110140, 0xE59F2068},
+	{0x00110144, 0xE5921020},
+	{0x00110148, 0xE3110A80},
+	{0x0011014C, 0x1AFFFFFC},
+	{0x00110150, 0xE1D510B8},
+	{0x00110154, 0xE1A01221},
+	{0x00110158, 0xE2811030},
+	{0x0011015C, 0xE5C21000},
+	{0x00110160, 0xE5921020},
+	{0x00110164, 0xE3110A80},
+	{0x00110168, 0x1AFFFFFC},
+	{0x0011016C, 0xE1D510B8},
+	{0x00110170, 0xE201100F},
+	{0x00110174, 0xE351000A},
+	{0x00110178, 0xA2811037},
+	{0x0011017C, 0xB2811030},
+	{0x00110180, 0xE5C21000},
+	{0x00110184, 0xE5921020},
+	{0x00110188, 0xE3110A80},
+	{0x0011018C, 0x1AFFFFFC},
+	{0x00110190, 0xE3A0100D},
+	{0x00110194, 0xE5C21000},
+	{0x00110198, 0xE5921020},
+	{0x0011019C, 0xE3110A80},
+	{0x001101A0, 0x1AFFFFFC},
+	{0x001101A4, 0xE3A0100A},
+	{0x001101A8, 0xE59FF004},
+	{0x001101AC, 0x50300038},
+	{0x001101B0, 0x50060000},
+	{0x001101B4, 0x00010F00},
+	{0x001101B8, 0xEA040A9C},
+	{0x001101BC, 0xE59F2038},
+	{0x001101C0, 0xE1D210B0},
+	{0x001101C4, 0xE3510020},
+	{0x001101C8, 0xCA000002},
+	{0x001101CC, 0xE51F2028},
+	{0x001101D0, 0xE3A01010},
+	{0x001101D4, 0xE5C21000},
+	{0x001101D8, 0xE3560000},
+	{0x001101DC, 0xE59FF01C},
+	{0x001101E0, 0xE1A00000},
+	{0x001101E4, 0xE1A00000},
+	{0x001101E8, 0xE1A00000},
+	{0x001101EC, 0xE1A00000},
+	{0x001101F0, 0xE1A00000},
+	{0x001101F4, 0xE1A00000},
+	{0x001101F8, 0xE1A00000},
+	{0x001101FC, 0x00106310},
+	{0x00110200, 0x0000D748},
+	{0x00110204, 0xEA0403F6},
+	{0x00110208, 0xE5CD0018},
+	{0x0011020C, 0xE51F0018},
+	{0x00110210, 0xE1D010B0},
+	{0x00110214, 0xE3510020},
+	{0x00110218, 0xCA000002},
+	{0x0011021C, 0xE51F0078},
+	{0x00110220, 0xE3A01010},
+	{0x00110224, 0xE5C01000},
+	{0x00110228, 0xE59FF01C},
+	{0x0011022C, 0xE1A00000},
+	{0x00110230, 0xE1A00000},
+	{0x00110234, 0xE1A00000},
+	{0x00110238, 0xE1A00000},
+	{0x0011023C, 0xE1A00000},
+	{0x00110240, 0xE1A00000},
+	{0x00110244, 0xE1A00000},
+	{0x00110248, 0x50060000},
+	{0x0011024C, 0x0000F22C},
+	{0x00110250, 0xEA03FB4F},
+	{0x00110254, 0xE59F2014},
+	{0x00110258, 0xE3500000},
+	{0x0011025C, 0x03A01000},
+	{0x00110260, 0x13A01001},
+	{0x00110264, 0xE5C21000},
+	{0x00110268, 0xE3500000},
+	{0x0011026C, 0xE59FF000},
+	{0x00110270, 0x001102C0},
+	{0x00110274, 0x00011514},
+	{0x00110278, 0xEA03ED3C},
+	{0x0011027C, 0xE59D0000},
+	{0x00110280, 0xE3C01008},
+	{0x00110284, 0xE58D1000},
+	{0x00110288, 0xE3A00030},
+	{0x0011028C, 0xEBFFFF63},
+	{0x00110290, 0xE3A0100C},
+	{0x00110294, 0xE51FF004},
+	{0x00110298, 0x00014D88},
+	{0x0011029C, 0xEA03ED77},
+	{0x001102A0, 0xE3500000},
+	{0x001102A4, 0xE59FF00C},
+	{0x001102A8, 0xE1A00000},
+	{0x001102AC, 0xE1A00000},
+	{0x001102B0, 0xE1A00000},
+	{0x001102B4, 0xE1A00000},
+	{0x001102B8, 0x00014CC0},
+	{0x001102BC, 0xEA03EDDF},
+	{0x001102C0, 0xE59D0000},
+	{0x001102C4, 0xE3C01008},
+	{0x001102C8, 0xE58D1000},
+	{0x001102CC, 0xE3A00030},
+	{0x001102D0, 0xEBFFFF52},
+	{0x001102D4, 0xE3A0100C},
+	{0x001102D8, 0xE51FF004},
+	{0x001102DC, 0x00014B40},
+	{0x001102E0, 0xEA043462},
+	{0x001102E4, 0xE1A00000},
+	{0x001102E8, 0xE1A00000},
+	{0x001102EC, 0xE51FF004},
+	{0x001102F0, 0x00003158},
+	{0x001102F4, 0xEA041567},
+	{0x001102F8, 0xE5940004},
+	{0x001102FC, 0xE3800850},
+	{0x00110300, 0xE5840004},
+	{0x00110304, 0xE3A00000},
+	{0x00110308, 0xE51FF004},
+	{0x0011030C, 0x0000AD58},
+	{0x00110310, 0xEA04300D},
+	{0x00110314, 0xE59F0028},
+	{0x00110318, 0xE5840584},
+	{0x0011031C, 0xE59F0024},
+	{0x00110320, 0xE59F1024},
+	{0x00110324, 0xE5810000},
+	{0x00110328, 0xE59F1020},
+	{0x0011032C, 0xE3A00003},
+	{0x00110330, 0xE5810000},
+	{0x00110334, 0xE59F001C},
+	{0x00110338, 0xE59F1014},
+	{0x0011033C, 0xE5810000},
+	{0x00110340, 0xE59FF014},
+	{0x00110344, 0x0000FFFB},
+	{0x00110348, 0x00000030},
+	{0x0011034C, 0x5000020C},
+	{0x00110350, 0x50000200},
+	{0x00110354, 0x30000014},
+	{0x00110358, 0x25801B0A},
+	{0x0011035C, 0x000042DC},
+	{0x00110360, 0xEA040074},
+	{0x00110364, 0xE1A00000},
+	{0x00110368, 0xE51FF004},
+	{0x0011036C, 0x000101E0},
+	{0x00110370, 0xEA03EE04},
+	{0x00110374, 0xE3510000},
+	{0x00110378, 0xE51FF004},
+	{0x0011037C, 0x00014B60},
+	{0x00110380, 0xEA03ED76},
+	{0x00110384, 0xE3510000},
+	{0x00110388, 0xE51FF004},
+	{0x0011038C, 0x00014DA8},
+	{0x00110390, 0xEA03EDFD},
+	{0x00110394, 0xE3500000},
+	{0x00110398, 0xE51FF004},
+	{0x0011039C, 0x00014B9C},
+	{0x001103A0, 0xEA03ED6F},
+	{0x001103A4, 0xE3500000},
+	{0x001103A8, 0xE51FF004},
+	{0x001103AC, 0x00014DE4},
+	{0x001103B0, 0xEA03FEA3},
+	{0x001103B4, 0xE1A00000},
+	{0x001103B8, 0xE51FF004},
+	{0x001103BC, 0x00010924},
+	{0x001103C0, 0xEA0420C9},
+	{0x001103C4, 0xE59F103C},
+	{0x001103C8, 0x03A00000},
+	{0x001103CC, 0x05810000},
+	{0x001103D0, 0x0A000007},
+	{0x001103D4, 0xE5910000},
+	{0x001103D8, 0xE2800001},
+	{0x001103DC, 0xE3500002},
+	{0x001103E0, 0x35810000},
+	{0x001103E4, 0x3A000004},
+	{0x001103E8, 0xE3A00000},
+	{0x001103EC, 0xE5810000},
+	{0x001103F0, 0xEAFFFFFF},
+	{0x001103F4, 0xE51FF004},
+	{0x001103F8, 0x0000809C},
+	{0x001103FC, 0xE51FF004},
+	{0x00110400, 0x000080E0},
+	{0x00110404, 0x00000000},
+	{0x00110408, 0x00110404},
+	{0x0011040C, 0xEA03D8AA},
+	{0x00110410, 0xE5C51000},
+	{0x00110414, 0xE1A00001},
+	{0x00110418, 0xE3A01032},
+	{0x0011041C, 0xE1500001},
+	{0x00110420, 0x3A000003},
+	{0x00110424, 0xE3A00001},
+	{0x00110428, 0xE3A02000},
+	{0x0011042C, 0xE3A01000},
+	{0x00110430, 0xE59FF004},
+	{0x00110434, 0xE51FF004},
+	{0x00110438, 0x0001A1AC},
+	{0x0011043C, 0x0001A1A4},
+	{0x00110440, 0xEA0438AC},
+	{0x00110444, 0xE1A000A0},
+	{0x00110448, 0xE51FF004},
+	{0x0011044C, 0x00002190},
+	{0x00110450, 0xEA04389C},
+	{0x00110454, 0xE3A00002},
+	{0x00110458, 0xE51FF004},
+	{0x0011045C, 0x000021E0},
+	{0x00110460, 0xEA041C47},
+	{0x00110464, 0xE3A03000},
+	{0x00110468, 0xE5D11000},
+	{0x0011046C, 0xE5802010},
+	{0x00110470, 0xE5803044},
+	{0x00110474, 0xE3510001},
+	{0x00110478, 0x13A01003},
+	{0x0011047C, 0x03A01009},
+	{0x00110480, 0xE5A01014},
+	{0x00110484, 0xE5803034},
+	{0x00110488, 0xE51FF004},
+	{0x0011048C, 0x00009364},
+	{0x20040004, 0x00014C60},
+	{0x20040024, 0x00110000},
+	{0x20040008, 0x00016A9C},
+	{0x20040028, 0x0011002C},
+	{0x2004000C, 0x0001D360},
+	{0x2004002C, 0x00110064},
+	{0x20040010, 0x0001A138},
+	{0x20040030, 0x001100E8},
+	{0x20040014, 0x00014C80},
+	{0x20040034, 0x00110110},
+	{0x20040018, 0x00010EFC},
+	{0x20040038, 0x00110120},
+	{0x2004001C, 0x0000D744},
+	{0x2004003C, 0x001101B8},
+	{0x20040020, 0x0000F228},
+	{0x20040040, 0x00110204},
+	{0x20040100, 0x00011510},
+	{0x20040120, 0x00110250},
+	{0x20040104, 0x00014D84},
+	{0x20040124, 0x00110278},
+	{0x20040108, 0x00014CBC},
+	{0x20040128, 0x0011029C},
+	{0x2004010C, 0x00014B3C},
+	{0x2004012C, 0x001102BC},
+	{0x20040110, 0x00003154},
+	{0x20040130, 0x001102E0},
+	{0x20040114, 0x0000AD54},
+	{0x20040134, 0x001102F4},
+	{0x20040118, 0x000042D8},
+	{0x20040138, 0x00110310},
+	{0x2004011C, 0x0001018C},
+	{0x2004013C, 0x00110360},
+	{0x20040140, 0x00014B5C},
+	{0x20040180, 0x00110370},
+	{0x20040144, 0x00014DA4},
+	{0x20040184, 0x00110380},
+	{0x20040148, 0x00014B98},
+	{0x20040188, 0x00110390},
+	{0x2004014C, 0x00014DE0},
+	{0x2004018C, 0x001103A0},
+	{0x20040150, 0x00010920},
+	{0x20040190, 0x001103B0},
+	{0x20040154, 0x00008098},
+	{0x20040194, 0x001103C0},
+	{0x20040158, 0x0001A160},
+	{0x20040198, 0x0011040C},
+	{0x2004015C, 0x0000218C},
+	{0x2004019C, 0x00110440},
+	{0x20040160, 0x000021DC},
+	{0x200401A0, 0x00110450},
+	{0x20040164, 0x00009340},
+	{0x200401A4, 0x00110460},
+	{0x20040000, 0x03FFFEFF},
+};
+
+#define SET_CHANNEL_MEM_TABLE_BASE 0x00107C98
+#define SET_CHANNEL_RF_TABLE_BASE 0x00107F38
+static const u32 wifi_clock_switch_91[][2] = {
+	//channel 1
+	{SET_CHANNEL_MEM_TABLE_BASE, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x04, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x08, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x0C, 0x2222CFCF},
+
+	//channel 2
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x30, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x34, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x38, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x3C, 0x2222CFCF},
+
+	//channel 3
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x60, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x64, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x68, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x6C, 0x2222CFCF},
+
+	//channel 4
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x90, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x94, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x98, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x9C, 0x2222CFCF},
+
+	//channel 5
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xC0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xC4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xC8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xCC, 0x2222CFCF},
+
+	//channel 6
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xF0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xF4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xF8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0xFC, 0x2222CFCF},
+
+	//channel 7
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x120, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x124, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x128, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x12C, 0x2222CFCF},
+
+	//channel 8
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x150, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x154, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x158, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x15C, 0x2222CFCF},
+
+	//channel 9
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x180, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x184, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x188, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x18C, 0x2222CFCF},
+
+	//channel 10
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1B0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1B4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1B8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1BC, 0x2222CFCF},
+
+	//channel 11
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1E0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1E4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1E8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x1EC, 0x2222CFCF},
+
+	//channel 12
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x210, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x214, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x218, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x21C, 0x2222CFCF},
+
+	//channel 13
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x240, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x244, 0x304199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x248, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE + 0x24C, 0x2222CFCF},
+
+	//channel 1
+	{SET_CHANNEL_RF_TABLE_BASE, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x04, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x08, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x0C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x10, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x14, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x18, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1C, 0x00000000},
+
+	//channel 2
+	{SET_CHANNEL_RF_TABLE_BASE + 0x40, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x44, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x48, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x4C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x50, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x54, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x58, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x5C, 0x00000000},
+
+	//channel 3
+	{SET_CHANNEL_RF_TABLE_BASE + 0x80, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x84, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x88, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x8C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x90, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x94, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x98, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x9C, 0x00000000},
+
+	//channel 4
+	{SET_CHANNEL_RF_TABLE_BASE + 0xC0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xC4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xC8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xCC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xD0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xD4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xD8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0xDC, 0x00000000},
+
+	//channel 5
+	{SET_CHANNEL_RF_TABLE_BASE + 0x100, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x104, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x108, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x10C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x110, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x114, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x118, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x11C, 0x00000000},
+
+	//channel 6
+	{SET_CHANNEL_RF_TABLE_BASE + 0x140, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x144, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x148, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x14C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x150, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x154, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x158, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x15C, 0x00000000},
+
+	//channel 7
+	{SET_CHANNEL_RF_TABLE_BASE + 0x180, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x184, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x188, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x18C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x190, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x194, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x198, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x19C, 0x00000000},
+
+	//channel 8
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1CC, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x1DC, 0x00000000},
+
+	//channel 9
+	{SET_CHANNEL_RF_TABLE_BASE + 0x200, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x204, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x208, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x20C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x210, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x214, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x218, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x21C, 0x00000000},
+
+	//channel 10
+	{SET_CHANNEL_RF_TABLE_BASE + 0x240, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x244, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x248, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x24C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x250, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x254, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x258, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x25C, 0x00000000},
+
+	//channel 11
+	{SET_CHANNEL_RF_TABLE_BASE + 0x280, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x284, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x288, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x28C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x290, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x294, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x298, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x29C, 0x00000000},
+
+	//channel 12
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2CC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x2DC, 0x00000000},
+
+	//channel 13
+	{SET_CHANNEL_RF_TABLE_BASE + 0x300, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x304, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x308, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x30C, 0x00000B08},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x310, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x314, 0x0000AA12},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x318, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE + 0x31C, 0x00000000},
+};
+
+static const u8 wifi_core_patch_data_91_8[][2] = {
+	{0x28, 0x1a},
+	{0x29, 0x0d},
+	{0x25, 0x07},
+	{0x08, 0x43},
+	{0x26, 0x35},
+	{0x3e, 0x64},
+	{0x3f, 0x00},
+	{0x45, 0x75},
+	{0x46, 0x73},
+	{0x50, 0x58},
+
+	{0x30, 0xf6},
+
+	{0x74, 0x01},
+	{0x75, 0x40},
+
+	{0x74, 0xD4},
+	{0x75, 0x47},
+
+	{0x74, 0xff},
+	{0x75, 0x4b},
+
+	{0x74, 0x3D},
+	{0x75, 0x4c},
+
+	{0x74, 0x01},
+	{0x75, 0x50},
+
+	{0x74, 0x99},
+	{0x75, 0x57},
+
+	{0x74, 0xff},
+	{0x75, 0x5b},
+
+	{0x74, 0x33},
+	{0x75, 0x5D},
+
+	{0x74, 0xE4},
+	{0x75, 0x61},
+
+	{0x30, 0xF7},
+
+};
+
+static const u32 wifi_core_init_data_32_91[][2] = {
+	{0x500002a8, 0x00000001},
+	{0x50000080, 0x0003FEF7},
+	{0x5000050c, 0x00003900},
+	{0x30010010, 0x00007DFF},
+
+	{0x50090060, 0x000001B4},
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+
+	{0x500900AC, 0x00000A00},
+	{0x50090054, 0x00000001},
+	{0x50090200, 0x00000180},
+	{0x50090204, 0x00000180},
+	{0x50090208, 0x00000180},
+	{0x5009020c, 0x00000180},
+	{0x50090210, 0x00000180},
+	{0x50090214, 0x00000180},
+	{0x50090218, 0x00000188},
+	{0x5009021c, 0x00000190},
+	{0x50090220, 0x00000200},
+	{0x50090224, 0x00000208},
+	{0x50090228, 0x00000210},
+	{0x5009022c, 0x00000280},
+	{0x50090230, 0x00000288},
+	{0x50090234, 0x00000290},
+	{0x50090238, 0x00000300},
+	{0x5009023c, 0x00000308},
+	{0x50090240, 0x00000310},
+	{0x50090244, 0x00000380},
+	{0x50090248, 0x00000388},
+	{0x5009024c, 0x00000390},
+	{0x50090250, 0x00000400},
+	{0x50090254, 0x00000408},
+	{0x50090258, 0x00000410},
+	{0x5009025c, 0x00000480},
+	{0x50090260, 0x00000488},
+	{0x50090264, 0x00000490},
+	{0x50090268, 0x00000500},
+	{0x5009026c, 0x00000508},
+	{0x50090270, 0x00000510},
+	{0x50090274, 0x00000580},
+	{0x50090278, 0x00000588},
+	{0x5009027c, 0x00000590},
+	{0x50090280, 0x00000290},
+	{0x50090284, 0x00000300},
+	{0x50090288, 0x00000308},
+	{0x5009028c, 0x00000310},
+	{0x50090290, 0x00000380},
+	{0x50090294, 0x00000388},
+	{0x50090298, 0x00000390},
+	{0x5009029c, 0x00000400},
+	{0x500902a0, 0x00000408},
+	{0x500902a4, 0x00000410},
+	{0x500902a8, 0x00000480},
+	{0x500902ac, 0x00000488},
+	{0x500902b0, 0x00000490},
+	{0x500902b4, 0x00000500},
+	{0x500902b8, 0x00000508},
+	{0x500902bc, 0x00000510},
+	{0x500902c0, 0x00000580},
+	{0x500902c4, 0x00000588},
+	{0x500902c8, 0x00000590},
+	{0x500902cc, 0x00000600},
+	{0x500902d0, 0x00000608},
+	{0x500902d4, 0x00000610},
+	{0x500902d8, 0x00000680},
+	{0x500902dc, 0x00000688},
+	{0x500902e0, 0x00000690},
+	{0x500902e4, 0x00000700},
+	{0x500902e8, 0x00000708},
+	{0x500902ec, 0x00000710},
+	{0x500902f0, 0x00000780},
+	{0x500902f4, 0x00000788},
+	{0x500902f8, 0x00000790},
+	{0x500902fc, 0x00000798},
+	{0x50090300, 0x00000500},
+	{0x50090304, 0x00000508},
+	{0x50090308, 0x00000510},
+	{0x5009030c, 0x00000580},
+	{0x50090310, 0x00000588},
+	{0x50090314, 0x00000590},
+	{0x50090318, 0x00000600},
+	{0x5009031c, 0x00000608},
+	{0x50090320, 0x00000610},
+	{0x50090324, 0x00000680},
+	{0x50090328, 0x00000688},
+	{0x5009032c, 0x00000690},
+	{0x50090330, 0x00000700},
+	{0x50090334, 0x00000708},
+	{0x50090338, 0x00000710},
+	{0x5009033c, 0x00000780},
+	{0x50090340, 0x00000780},
+	{0x50090344, 0x00000780},
+	{0x50090348, 0x00000780},
+	{0x5009034c, 0x00000780},
+	{0x50090350, 0x00000780},
+	{0x50090354, 0x00000780},
+	{0x50090358, 0x00000780},
+	{0x5009035c, 0x00000780},
+	{0x50090360, 0x00000780},
+	{0x50090364, 0x00000780},
+	{0x50090368, 0x00000780},
+	{0x5009036c, 0x00000780},
+	{0x50090370, 0x00000780},
+	{0x50090374, 0x00000780},
+	{0x50090378, 0x00000780},
+	{0x5009037c, 0x00000780},
+	{0x50090054, 0x00000000},
+};
+
+static const u32 wifi_core_AM_PM_data_32_91[][2] = {
+	{0x50090054, 0x00000000},
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	{0x50090090, 0x00000000},	//item0:theta0=7_B=0_r0=2
+	{0x50090094, 0x00A01401},
+	{0x50090098, 0x02907412},
+	{0x5009009C, 0x05D12438},
+	{0x500900A0, 0x0A522872},
+	{0x500900A4, 0xFFF380C1},
+	{0x50090078, 0x02B05400},	//item0:G0=-3.5_r0=2.5
+	{0x5009007C, 0x06D15840},
+	{0x50090080, 0x0B927885},
+	{0x50090084, 0x11A3DCD7},
+	{0x50090088, 0x1975A540},
+	{0x5009008C, 0xFFF7FDC9},
+	{0x500900A8, 0x9C4001A7},
+};
+#endif
+
+static const u32 wifi_assoc_power_save_data_32_91[][2] = {
+	{0x5000050c, 0x00003900}	// for association power save
+};
+
+#endif
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91e.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91e.h
new file mode 100644
index 000000000000..619f22966742
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91e.h
@@ -0,0 +1,1147 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_TRAP_91_E_H_
+#define _WLAND_TRAP_91_E_H_
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_core_patch_data_32_91e[][2] = {
+	// add for pta
+	{0x50000828, 0x00100FFD},
+	{0x50000810, 0xFFFF0F0F},
+	{0x50000814, 0xFFFF0F0F},
+	{0x50000818, 0x00FF000F},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0F0},
+	{0x50090044, 0xE6AD6CB0},	//mode
+	{0x50090040, 0xBA9D5EC4},	//agc value
+	{0x001075EC, 0x00000002},	//disable ht
+	// add for pta
+#if 1
+	{0x0010FFFC, 0x20160301},
+	{0x00110000, 0xEA03FA67},
+	{0x00110004, 0xE51FF004},
+	{0x00110008, 0x000116B4},
+	{0x0011000C, 0xEA03C0BF},
+	{0x00110010, 0xE200007F},
+	{0x00110014, 0xE3500028},
+	{0x00110018, 0x1A00000B},
+	{0x0011001C, 0xE1A01801},
+	{0x00110020, 0xE1A01821},
+	{0x00110024, 0xE59F0024},
+	{0x00110028, 0xE1510000},
+	{0x0011002C, 0x059F1024},
+	{0x00110030, 0x03A00028},
+	{0x00110034, 0x059FF028},
+	{0x00110038, 0xE59F0014},
+	{0x0011003C, 0xE1510000},
+	{0x00110040, 0x059F1014},
+	{0x00110044, 0x03A00028},
+	{0x00110048, 0x059FF014},
+	{0x0011004C, 0xE59FF00C},
+	{0x00110050, 0x00001F20},
+	{0x00110054, 0x00001320},
+	{0x00110058, 0x00004F20},
+	{0x0011005C, 0x00004320},
+	{0x00110060, 0x0001FD10},
+	{0x00110064, 0x0001FD18},
+	{0x00110068, 0xEA0410ED},
+	{0x0011006C, 0xE5940004},
+	{0x00110070, 0xE3C008F0},
+	{0x00110074, 0xE5840004},
+	{0x00110078, 0xE3A00064},
+	{0x0011007C, 0xE5840630},
+	{0x00110080, 0xE3A00D44},
+	{0x00110084, 0xE5840634},
+	{0x00110088, 0xE59F0004},
+	{0x0011008C, 0xE5840584},
+	{0x00110090, 0xE59FF000},
+	{0x00110094, 0x00007BF8},
+	{0x00110098, 0x0000BCB4},
+	{0x0011009C, 0xEA040609},
+	{0x001100A0, 0xE59F2018},
+	{0x001100A4, 0xE1D210B0},
+	{0x001100A8, 0xE59F200C},
+	{0x001100AC, 0xE3A01010},
+	{0x001100B0, 0xE5C21000},
+	{0x001100B4, 0xE3560000},
+	{0x001100B8, 0xE59FF004},
+	{0x001100BC, 0x50300038},
+	{0x001100C0, 0x00106B1C},
+	{0x001100C4, 0x0000E878},
+	{0x001100C8, 0xEA03FE7A},
+	{0x001100CC, 0xE5CD0018},
+	{0x001100D0, 0xE51F0018},
+	{0x001100D4, 0xE1D010B0},
+	{0x001100D8, 0xE1A00000},
+	{0x001100DC, 0xE1A00000},
+	{0x001100E0, 0xE51F002C},
+	{0x001100E4, 0xE3A01010},
+	{0x001100E8, 0xE5C01000},
+	{0x001100EC, 0xE59FF000},
+	{0x001100F0, 0x50060000},
+	{0x001100F4, 0x000106E0},
+	{0x001100F8, 0xEA042EFA},
+	{0x001100FC, 0xE59F0028},
+	{0x00110100, 0xE5840584},
+	{0x00110104, 0xE59F0024},
+	{0x00110108, 0xE59F1024},
+	{0x0011010C, 0xE5810000},
+	{0x00110110, 0xE59F1020},
+	{0x00110114, 0xE3A00003},
+	{0x00110118, 0xE5810000},
+	{0x0011011C, 0xE59F001C},
+	{0x00110120, 0xE59F1014},
+	{0x00110124, 0xE5810000},
+	{0x00110128, 0xE59FF014},
+	{0x0011012C, 0x0000FFFB},
+	{0x00110130, 0x00000030},
+	{0x00110134, 0x5000020C},
+	{0x00110138, 0x50000200},
+	{0x0011013C, 0x30000014},
+	{0x00110140, 0x25801B0A},
+	{0x00110144, 0x00004510},
+	{0x00110148, 0xEA041E5A},
+	{0x0011014C, 0xE59F14F4},
+	{0x00110150, 0x03A00000},
+	{0x00110154, 0x05810000},
+	{0x00110158, 0x0A00000C},
+	{0x0011015C, 0xE5910000},
+	{0x00110160, 0xE2800001},
+	{0x00110164, 0xE3500002},
+	{0x00110168, 0x35810000},
+	{0x0011016C, 0x3A000009},
+	{0x00110170, 0xE3A00000},
+	{0x00110174, 0xE5810000},
+	{0x00110178, 0xE3A04001},
+	{0x0011017C, 0xE59F14C8},
+	{0x00110180, 0xE5C10000},
+	{0x00110184, 0xE59F14C4},
+	{0x00110188, 0xE5C14000},
+	{0x0011018C, 0xEAFFFFFF},
+	{0x00110190, 0xE51FF004},
+	{0x00110194, 0x000087E0},
+	{0x00110198, 0xE51FF004},
+	{0x0011019C, 0x00008824},
+	{0x001101A0, 0x00000000},
+	{0x001101A4, 0xEA0437FA},
+	{0x001101A8, 0xE1A000A0},
+	{0x001101AC, 0xE51FF004},
+	{0x001101B0, 0x000021BC},
+	{0x001101B4, 0xEA0437E7},
+	{0x001101B8, 0xE3A00002},
+	{0x001101BC, 0xE51FF004},
+	{0x001101C0, 0x00002218},
+	{0x001101C4, 0xEA0418E0},
+	{0x001101C8, 0xE3A03000},
+	{0x001101CC, 0xE5D11000},
+	{0x001101D0, 0xE5802010},
+	{0x001101D4, 0xE5803044},
+	{0x001101D8, 0xE3510001},
+	{0x001101DC, 0x13A01003},
+	{0x001101E0, 0x03A01009},
+	{0x001101E4, 0xE5A01014},
+	{0x001101E8, 0xE5803034},
+	{0x001101EC, 0xE51FF004},
+	{0x001101F0, 0x00009E64},
+	{0x001101F4, 0xEA03F900},
+	{0x001101F8, 0xE51FF004},
+	{0x001101FC, 0x00011DF4},
+	{0x00110200, 0xEA041F21},
+	{0x00110204, 0xE3A015C0},
+	{0x00110208, 0xE3E00007},
+	{0x0011020C, 0xE5810000},
+	{0x00110210, 0xE3A01001},
+	{0x00110214, 0xE3A0003F},
+	{0x00110218, 0xEB000007},
+	{0x0011021C, 0xE59F105C},
+	{0x00110220, 0xE3A00026},
+	{0x00110224, 0xEB000004},
+	{0x00110228, 0xE3A01000},
+	{0x0011022C, 0xE3A0003F},
+	{0x00110230, 0xEB000001},
+	{0x00110234, 0xE59F4008},
+	{0x00110238, 0xE59FF008},
+	{0x0011023C, 0xE51FF004},
+	{0x00110240, 0x0001FD08},
+	{0x00110244, 0x001077D4},
+	{0x00110248, 0x0000857C},
+	{0x0011024C, 0xEA042E07},
+	{0x00110250, 0xE3A01001},
+	{0x00110254, 0xE3A0003F},
+	{0x00110258, 0xEBFFFFF7},
+	{0x0011025C, 0xE59F1018},
+	{0x00110260, 0xE3A00026},
+	{0x00110264, 0xEBFFFFF4},
+	{0x00110268, 0xE3A01000},
+	{0x0011026C, 0xE3A0003F},
+	{0x00110270, 0xEBFFFFF1},
+	{0x00110274, 0xE59F0008},
+	{0x00110278, 0xE59FF008},
+	{0x0011027C, 0x00008058},
+	{0x00110280, 0x00008088},
+	{0x00110284, 0xFFFFFC09},
+	{0x00110288, 0x00004A30},
+	{0x0011028C, 0xEA042F50},
+	{0x00110290, 0xE3A01001},
+	{0x00110294, 0xE3A0003F},
+	{0x00110298, 0xEBFFFFE7},
+	{0x0011029C, 0xE51F1028},
+	{0x001102A0, 0xE3A00026},
+	{0x001102A4, 0xEBFFFFE4},
+	{0x001102A8, 0xE3A01000},
+	{0x001102AC, 0xE3A0003F},
+	{0x001102B0, 0xEBFFFFE1},
+	{0x001102B4, 0xE51F0038},
+	{0x001102B8, 0xE51FF004},
+	{0x001102BC, 0x0000454C},
+	{0x001102C0, 0xEA03EFF5},
+	{0x001102C4, 0xE3A01001},
+	{0x001102C8, 0xE3A0003F},
+	{0x001102CC, 0xEBFFFFDA},
+	{0x001102D0, 0xE51F1058},
+	{0x001102D4, 0xE3A00026},
+	{0x001102D8, 0xEBFFFFD7},
+	{0x001102DC, 0xE3A01000},
+	{0x001102E0, 0xE3A0003F},
+	{0x001102E4, 0xEBFFFFD4},
+	{0x001102E8, 0xE3A015C0},
+	{0x001102EC, 0xE3E00007},
+	{0x001102F0, 0xE5810000},
+	{0x001102F4, 0xE3A01003},
+	{0x001102F8, 0xE51FF004},
+	{0x001102FC, 0x000142EC},
+	{0x00110300, 0xEA04131A},
+	{0x00110304, 0xE3A01002},
+	{0x00110308, 0xE5C41000},
+	{0x0011030C, 0xE3A01001},
+	{0x00110310, 0xE51FF004},
+	{0x00110314, 0x0000B69C},
+	{0x00110318, 0xEA03F8E4},
+	{0x0011031C, 0xE5951828},
+	{0x00110320, 0xE1A01821},
+	{0x00110324, 0xE3C11CF0},
+	{0x00110328, 0xE51FF004},
+	{0x0011032C, 0x00011F88},
+	{0x00110330, 0xEA03E1E7},
+	{0x00110334, 0xE2800002},
+	{0x00110338, 0xE5D01000},
+	{0x0011033C, 0xE51FF004},
+	{0x00110340, 0x00017B94},
+	{0x00110344, 0xEA03CF9B},
+	{0x00110348, 0xE3A00001},
+	{0x0011034C, 0xE3A02000},
+	{0x00110350, 0xE51FF004},
+	{0x00110354, 0x0001C4D8},
+	{0x00110358, 0xEA043804},
+	{0x0011035C, 0xE20210FF},
+	{0x00110360, 0xE59F00D4},
+	{0x00110364, 0xE5902000},
+	{0x00110368, 0xE0811002},
+	{0x0011036C, 0xE5801000},
+	{0x00110370, 0xE59F00CC},
+	{0x00110374, 0xE5902000},
+	{0x00110378, 0xE2822001},
+	{0x0011037C, 0xE5802000},
+	{0x00110380, 0xE3520008},
+	{0x00110384, 0x1A000027},
+	{0x00110388, 0xE3A02000},
+	{0x0011038C, 0xE5802000},
+	{0x00110390, 0xE59F00A4},
+	{0x00110394, 0xE5802000},
+	{0x00110398, 0xE1A011A1},
+	{0x0011039C, 0xE59F00A8},
+	{0x001103A0, 0xE5801000},
+	{0x001103A4, 0xE3510080},
+	{0x001103A8, 0xB59F00A4},
+	{0x001103AC, 0xBA00000F},
+	{0x001103B0, 0xE35100D8},
+	{0x001103B4, 0xC59F0098},
+	{0x001103B8, 0xCA00000C},
+	{0x001103BC, 0xE35100D3},
+	{0x001103C0, 0xC59F0090},
+	{0x001103C4, 0xCA000009},
+	{0x001103C8, 0xE35100CE},
+	{0x001103CC, 0xC59F0088},
+	{0x001103D0, 0xCA000006},
+	{0x001103D4, 0xE35100C9},
+	{0x001103D8, 0xC59F0080},
+	{0x001103DC, 0xCA000003},
+	{0x001103E0, 0xE35100C4},
+	{0x001103E4, 0xC59F0078},
+	{0x001103E8, 0xCA000000},
+	{0x001103EC, 0xE59F0074},
+	{0x001103F0, 0xE59F103C},
+	{0x001103F4, 0xE5912000},
+	{0x001103F8, 0xE1520000},
+	{0x001103FC, 0x0A000009},
+	{0x00110400, 0xE5810000},
+	{0x00110404, 0xE20010FF},
+	{0x00110408, 0xE3A00025},
+	{0x0011040C, 0xEB000006},
+	{0x00110410, 0xE59F101C},
+	{0x00110414, 0xE5912000},
+	{0x00110418, 0xE1A02422},
+	{0x0011041C, 0xE20210FF},
+	{0x00110420, 0xE3A00023},
+	{0x00110424, 0xEB000000},
+	{0x00110428, 0xE59FF03C},
+	{0x0011042C, 0xE51FF004},
+	{0x00110430, 0x0001FC34},
+	{0x00110434, 0x00110438},
+	{0x00110438, 0x00001600},
+	{0x0011043C, 0x00110440},
+	{0x00110440, 0x00000000},
+	{0x00110444, 0x00110448},
+	{0x00110448, 0x00000000},
+	{0x0011044C, 0x00110450},
+	{0x00110450, 0x00000000},
+	{0x00110454, 0x0000000F},
+	{0x00110458, 0x0000030A},
+	{0x0011045C, 0x00000709},
+	{0x00110460, 0x00000A07},
+	{0x00110464, 0x00000E05},
+	{0x00110468, 0x00001600},
+	{0x0011046C, 0x000023A8},
+	{0x00110470, 0xEA03E309},
+	{0x00110474, 0xE51F0044},
+	{0x00110478, 0xE51F104C},
+	{0x0011047C, 0xE5810000},
+	{0x00110480, 0xE3A00016},
+	{0x00110484, 0xE51FF004},
+	{0x00110488, 0x0001784C},
+	{0x0011048C, 0xEA03EBCE},
+	{0x00110490, 0xE51FF004},
+	{0x00110494, 0x00015558},
+	{0x00110498, 0xEA03FA6B},
+	{0x0011049C, 0x059FF020},
+	{0x001104A0, 0xE2044001},
+	{0x001104A4, 0xE3540000},
+	{0x001104A8, 0x059FF014},
+	{0x001104AC, 0xE3A00000},
+	{0x001104B0, 0xE59F1194},
+	{0x001104B4, 0xE5C10000},
+	{0x001104B8, 0xEBFBC81A},
+	{0x001104BC, 0xE59FF000},
+	{0x001104C0, 0xE1A00000},
+	{0x001104C4, 0x00011A24},
+	{0x001104C8, 0xEA03DA66},
+	{0x001104CC, 0xE3570006},
+	{0x001104D0, 0x059FF014},
+	{0x001104D4, 0xE5D40011},
+	{0x001104D8, 0xE3500006},
+	{0x001104DC, 0x0A000000},
+	{0x001104E0, 0xE59FF00C},
+	{0x001104E4, 0xE3570006},
+	{0x001104E8, 0xE59FF000},
+	{0x001104EC, 0x00019B4C},
+	{0x001104F0, 0x00019B30},
+	{0x001104F4, 0x00019F40},
+	{0x001104F8, 0xEA0437B7},
+	{0x001104FC, 0x159FF014},
+	{0x00110500, 0xE59F014C},
+	{0x00110504, 0xE5D00000},
+	{0x00110508, 0xE3500001},
+	{0x0011050C, 0x059FF004},
+	{0x00110510, 0x151FF004},
+	{0x00110514, 0x0000261C},
+	{0x00110518, 0x00002630},
+	{0x0011051C, 0xEA03E03A},
+	{0x00110520, 0xE3A01000},
+	{0x00110524, 0xE3A00025},
+	{0x00110528, 0xEBFFFFBF},
+	{0x0011052C, 0xE3A01016},
+	{0x00110530, 0xE3A00023},
+	{0x00110534, 0xEBFFFFBC},
+	{0x00110538, 0xE59F1008},
+	{0x0011053C, 0xE3A02000},
+	{0x00110540, 0xE3A00001},
+	{0x00110544, 0xE59FF000},
+	{0x00110548, 0x0010149A},
+	{0x0011054C, 0x00018434},
+	{0x00110550, 0xEA0420AD},
+	{0x00110554, 0xE1A04000},
+	{0x00110558, 0xE1A05001},
+	{0x0011055C, 0xE51F0130},
+	{0x00110560, 0xE5900000},
+	{0x00110564, 0xE20010FF},
+	{0x00110568, 0xE3A00025},
+	{0x0011056C, 0xEBFFFFAE},
+	{0x00110570, 0xE51F0144},
+	{0x00110574, 0xE5900000},
+	{0x00110578, 0xE1A00420},
+	{0x0011057C, 0xE20010FF},
+	{0x00110580, 0xE3A00023},
+	{0x00110584, 0xEBFFFFA8},
+	{0x00110588, 0xE1A01005},
+	{0x0011058C, 0xE51FF004},
+	{0x00110590, 0x0000829C},
+	{0x00110594, 0xEA03F987},
+	{0x00110598, 0xE1A04000},
+	{0x0011059C, 0xE3540000},
+	{0x001105A0, 0x0A00000D},
+	{0x001105A4, 0xE59F1058},
+	{0x001105A8, 0xE3A0003C},
+	{0x001105AC, 0xEB000011},
+	{0x001105B0, 0xE3A0003C},
+	{0x001105B4, 0xE3A01000},
+	{0x001105B8, 0xEB00000C},
+	{0x001105BC, 0xE59F003C},
+	{0x001105C0, 0xE3500C80},
+	{0x001105C4, 0x8A000000},
+	{0x001105C8, 0x9A000001},
+	{0x001105CC, 0xE51FF004},
+	{0x001105D0, 0x00011F7C},
+	{0x001105D4, 0xE51FF004},
+	{0x001105D8, 0x000121A0},
+	{0x001105DC, 0xE51FF004},
+	{0x001105E0, 0x00012214},
+	{0x001105E4, 0x00011EF4},
+	{0x001105E8, 0x00000341},
+	{0x001105EC, 0x00000141},
+	{0x001105F0, 0xE51FF004},
+	{0x001105F4, 0x0001FCCC},
+	{0x001105F8, 0xE51FF004},
+	{0x001105FC, 0x00013714},
+	{0x00110600, 0x00000000},
+	{0x00110604, 0x00110600},
+	{0x00110608, 0xEA03E285},
+	{0x0011060C, 0xE1A02000},
+	{0x00110610, 0xE5D0000D},
+	{0x00110614, 0xE1810400},
+	{0x00110618, 0xE1CD01B0},
+	{0x0011061C, 0xE1A00002},
+	{0x00110620, 0xE59F1014},
+	{0x00110624, 0xE5D0000E},
+	{0x00110628, 0xE5C10000},
+	{0x0011062C, 0xE59F100C},
+	{0x00110630, 0xE5810000},
+	{0x00110634, 0xE28D0004},
+	{0x00110638, 0xE59FF004},
+	{0x0011063C, 0x00107002},
+	{0x00110640, 0x50000508},
+	{0x00110644, 0x00017C00},
+	{0x00110648, 0x001101A0},
+	{0x0011064C, 0x001077D7},
+	{0x00110650, 0x001077D8},
+	{0x00110654, 0x001077D6},
+	{0x20040004, 0x00011660},
+	{0x20040024, 0x00110000},
+	{0x20040008, 0x0001FD0C},
+	{0x20040028, 0x0011000C},
+	{0x2004000C, 0x0000BCB0},
+	{0x2004002C, 0x00110068},
+	{0x20040010, 0x0000E874},
+	{0x20040030, 0x0011009C},
+	{0x20040014, 0x000106DC},
+	{0x20040034, 0x001100C8},
+	{0x20040018, 0x0000450C},
+	{0x20040038, 0x001100F8},
+	{0x2004001C, 0x000087DC},
+	{0x2004003C, 0x00110148},
+	{0x20040020, 0x000021B8},
+	{0x20040040, 0x001101A4},
+	{0x20040100, 0x00002214},
+	{0x20040120, 0x001101B4},
+	{0x20040104, 0x00009E40},
+	{0x20040124, 0x001101C4},
+	{0x20040108, 0x00011DF0},
+	{0x20040128, 0x001101F4},
+	{0x2004010C, 0x00008578},
+	{0x2004012C, 0x00110200},
+	{0x20040110, 0x00004A2C},
+	{0x20040130, 0x0011024C},
+	{0x20040114, 0x00004548},
+	{0x20040134, 0x0011028C},
+	{0x20040118, 0x000142E8},
+	{0x20040138, 0x001102C0},
+	{0x2004011C, 0x0000B694},
+	{0x2004013C, 0x00110300},
+	{0x20040140, 0x00011F84},
+	{0x20040180, 0x00110318},
+	{0x20040144, 0x00017B90},
+	{0x20040184, 0x00110330},
+	{0x20040148, 0x0001C4D4},
+	{0x20040188, 0x00110344},
+	{0x2004014C, 0x00002344},
+	{0x2004018C, 0x00110358},
+	{0x20040150, 0x00017848},
+	{0x20040190, 0x00110470},
+	{0x20040154, 0x00015550},
+	{0x20040194, 0x0011048C},
+	{0x20040158, 0x00011AE8},
+	{0x20040198, 0x00110498},
+	{0x2004015C, 0x00019B2C},
+	{0x2004019C, 0x001104C8},
+	{0x20040160, 0x00002618},
+	{0x200401A0, 0x001104F8},
+	{0x20040164, 0x00018430},
+	{0x200401A4, 0x0011051C},
+	{0x20040168, 0x00008298},
+	{0x200401A8, 0x00110550},
+	{0x2004016C, 0x00011F74},
+	{0x200401AC, 0x00110594},
+	{0x20040170, 0x00017BF0},
+	{0x200401B0, 0x00110608},
+	{0x20040000, 0x1FFFFFFF},
+#endif
+};
+
+#define SET_CHANNEL_MEM_TABLE_BASE_91E 0x001086AC
+#define SET_CHANNEL_RF_TABLE_BASE_91E 0x0010894C
+static const u32 wifi_clock_switch_91e[][2] = {
+	//channel 1
+	{SET_CHANNEL_MEM_TABLE_BASE_91E, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x04, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x08, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x0C, 0x2222CFCF},
+
+	//channel 2
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x30, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x34, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x38, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x3C, 0x2222CFCF},
+
+	//channel 3
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x60, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x64, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x68, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x6C, 0x2222CFCF},
+
+	//channel 4
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x90, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x94, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x98, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x9C, 0x2222CFCF},
+
+	//channel 5
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xC0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xC4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xC8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xCC, 0x2222CFCF},
+
+	//channel 6
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xF0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xF4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xF8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0xFC, 0x2222CFCF},
+
+	//channel 7
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x120, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x124, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x128, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x12C, 0x2222CFCF},
+
+	//channel 8
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x150, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x154, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x158, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x15C, 0x2222CFCF},
+
+	//channel 9
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x180, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x184, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x188, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x18C, 0x2222CFCF},
+
+	//channel 10
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1B0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1B4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1B8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1BC, 0x2222CFCF},
+
+	//channel 11
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1E0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1E4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1E8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x1EC, 0x2222CFCF},
+
+	//channel 12
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x210, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x214, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x218, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x21C, 0x2222CFCF},
+
+	//channel 13
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x240, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x244, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x248, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91E + 0x24C, 0x2222CFCF},
+
+	//channel 1
+	{SET_CHANNEL_RF_TABLE_BASE_91E, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x04, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x08, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x0C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x10, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x14, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x18, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1C, 0x00000000},
+
+	//channel 2
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x40, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x44, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x48, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x4C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x50, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x54, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x58, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x5C, 0x00000000},
+
+	//channel 3
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x80, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x84, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x88, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x8C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x90, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x94, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x98, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x9C, 0x00000000},
+
+	//channel 4
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xC0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xC4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xC8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xCC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xD0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xD4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xD8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0xDC, 0x00000000},
+
+	//channel 5
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x100, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x104, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x108, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x10C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x110, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x114, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x118, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x11C, 0x00000000},
+
+	//channel 6
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x140, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x144, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x148, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x14C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x150, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x154, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x158, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x15C, 0x00000000},
+
+	//channel 7
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x180, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x184, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x188, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x18C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x190, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x194, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x198, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x19C, 0x00000000},
+
+	//channel 8
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1CC, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x1DC, 0x00000000},
+
+	//channel 9
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x200, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x204, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x208, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x20C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x210, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x214, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x218, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x21C, 0x00000000},
+
+	//channel 10
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x240, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x244, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x248, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x24C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x250, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x254, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x258, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x25C, 0x00000000},
+
+	//channel 11
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x280, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x284, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x288, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x28C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x290, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x294, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x298, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x29C, 0x00000000},
+
+	//channel 12
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2CC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x2DC, 0x00000000},
+
+	//channel 13
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x300, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x304, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x308, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x30C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x310, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x314, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x318, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91E + 0x31C, 0x00000000},
+};
+
+static const u8 wifi_core_patch_data_91e_8[][2] = {
+	{0x28, 0x1a},
+	{0x29, 0x0d},
+	{0x23, 0x16},
+	{0x25, 0x00},
+	{0x08, 0x43},
+	//rx patch
+	{0x26, 0x35},
+	{0x3e, 0x64},
+	{0x3f, 0x00},
+	{0x45, 0x75},
+	{0x46, 0x73},
+	{0x50, 0x58},
+	{0x57, 0xdb},
+	{0xc5, 0x7c},
+	{0x30, 0xf6},
+
+	{0x54, 0xb4},
+	{0x55, 0xb4},
+	{0x56, 0xb4},
+
+	{0xA0, 0x7f},
+	{0x74, 0x01},
+	{0x75, 0x40},
+
+	{0x12, 0x04},
+	{0x1C, 0x2D},
+	{0x0D, 0x59},
+	{0x17, 0x75},
+	{0x74, 0xD4},
+	{0x75, 0x47},
+
+	{0x74, 0xFF},
+	{0x75, 0x4B},
+
+	{0x74, 0x3D},
+	{0x75, 0x4C},
+
+	{0x74, 0x01},
+	{0x75, 0x50},
+
+	{0x74, 0x99},
+	{0x75, 0x57},
+
+	{0x74, 0xFF},
+	{0x75, 0x5B},
+
+	{0x74, 0x33},
+	{0x75, 0x5D},
+
+	{0x74, 0xE4},
+	{0x75, 0x61},
+
+	{0x30, 0xF7},
+};
+#endif
+
+static const u32 wifi_core_init_data_32_91e_tm[][2] = {
+	{0x500002a8, 0x00000001},
+	{0x50000080, 0x0003FEF7},
+	{0x00100018, 0x000A3243},	// flow ctrl , WPS supported, proakis
+	{0x0010001C, 0xFFFF0001},
+	{0x30010010, 0x00007DF8},
+
+	{0x50090060, 0x000001B4},
+	//item:rda5991_verE_wf_tx_pn9
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	{0x500900A8, 0x9c400180},
+	{0x5009008C, 0xFc07fdc9},
+	//PHY:phy rx timeout enable
+	{0x0010216c, 0x50000634},
+	{0x00102170, 0x00001100},
+	{0x00102174, 0x50000584},
+	{0x00102178, 0x00007bf8},
+
+	{0x50090054, 0x00000001},
+	{0x50090200, 0x00000100},
+	{0x50090204, 0x00000100},
+	{0x50090208, 0x00000100},
+	{0x5009020c, 0x00000100},
+	{0x50090210, 0x00000108},
+	{0x50090214, 0x00000110},
+	{0x50090218, 0x00000180},
+	{0x5009021c, 0x00000188},
+	{0x50090220, 0x00000190},
+	{0x50090224, 0x00000200},
+	{0x50090228, 0x00000208},
+	{0x5009022c, 0x00000210},
+	{0x50090230, 0x00000280},
+	{0x50090234, 0x00000288},
+	{0x50090238, 0x00000304},
+	{0x5009023c, 0x0000030C},
+	{0x50090240, 0x00000314},
+	{0x50090244, 0x00000384},
+	{0x50090248, 0x0000038C},
+	{0x5009024c, 0x00000394},
+	{0x50090250, 0x00000404},
+	{0x50090254, 0x0000040C},
+	{0x50090258, 0x00000414},
+	{0x5009025c, 0x00000484},
+	{0x50090260, 0x0000048C},
+	{0x50090264, 0x00000500},
+	{0x50090268, 0x00000508},
+	{0x5009026c, 0x00000510},
+	{0x50090270, 0x00000580},
+	{0x50090274, 0x00000588},
+	{0x50090278, 0x00000590},
+	{0x5009027c, 0x00000600},
+	{0x50090280, 0x00000288},
+	{0x50090284, 0x00000290},
+	{0x50090288, 0x00000304},
+	{0x5009028c, 0x0000030C},
+	{0x50090290, 0x00000314},
+	{0x50090294, 0x00000384},
+	{0x50090298, 0x0000038C},
+	{0x5009029c, 0x00000394},
+	{0x500902a0, 0x00000404},
+	{0x500902a4, 0x0000040C},
+	{0x500902a8, 0x00000414},
+	{0x500902ac, 0x00000484},
+	{0x500902b0, 0x0000048C},
+	{0x500902b4, 0x00000500},
+	{0x500902b8, 0x00000508},
+	{0x500902bc, 0x00000510},
+	{0x500902c0, 0x00000580},
+	{0x500902c4, 0x00000588},
+	{0x500902c8, 0x00000590},
+	{0x500902cc, 0x00000600},
+	{0x500902d0, 0x00000608},
+	{0x500902d4, 0x00000610},
+	{0x500902d8, 0x00000680},
+	{0x500902dc, 0x00000688},
+	{0x500902e0, 0x00000690},
+	{0x500902e4, 0x00000700},
+	{0x500902e8, 0x00000708},
+	{0x500902ec, 0x00000710},
+	{0x500902f0, 0x00000780},
+	{0x500902f4, 0x00000780},
+	{0x500902f8, 0x00000780},
+	{0x500902fc, 0x00000780},
+	{0x50090300, 0x00000500},
+	{0x50090304, 0x00000508},
+	{0x50090308, 0x00000510},
+	{0x5009030c, 0x00000580},
+	{0x50090310, 0x00000588},
+	{0x50090314, 0x00000590},
+	{0x50090318, 0x00000600},
+	{0x5009031c, 0x00000608},
+	{0x50090320, 0x00000610},
+	{0x50090324, 0x00000680},
+	{0x50090328, 0x00000688},
+	{0x5009032c, 0x00000690},
+	{0x50090330, 0x00000700},
+	{0x50090334, 0x00000708},
+	{0x50090338, 0x00000710},
+	{0x5009033c, 0x00000780},
+	{0x50090340, 0x00000780},
+	{0x50090344, 0x00000780},
+	{0x50090348, 0x00000780},
+	{0x5009034c, 0x00000780},
+	{0x50090350, 0x00000780},
+	{0x50090354, 0x00000780},
+	{0x50090358, 0x00000780},
+	{0x5009035c, 0x00000780},
+	{0x50090360, 0x00000780},
+	{0x50090364, 0x00000780},
+	{0x50090368, 0x00000780},
+	{0x5009036c, 0x00000780},
+	{0x50090370, 0x00000780},
+	{0x50090374, 0x00000780},
+	{0x50090378, 0x00000780},
+	{0x5009037c, 0x00000780},
+	{0x50090054, 0x00000000},
+};
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_core_init_data_32_91e[][2] = {
+	{0x500002a8, 0x00000001},
+	{0x50000080, 0x0003FEF7},
+	{0x00100018, 0x000A3243},	// flow ctrl , WPS supported, proakis
+	{0x0010001C, 0xFFFF0001},
+	{0x30010010, 0x00007DF9},
+
+	{0x50090060, 0x000001B4},
+	//item:rda5991_verE_wf_tx_pn9
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	{0x500900A8, 0x9c400180},
+	{0x5009008C, 0xFc07fdc9},
+	//PHY:phy rx timeout enable
+	{0x0010216c, 0x50000634},
+	{0x00102170, 0x00001100},
+	{0x00102174, 0x50000584},
+	{0x00102178, 0x00007bf8},
+
+#ifdef CHINA_VERSION		/*Low SNR */
+	//new agc table 20140825
+	{0X50090054, 0X00000001},
+	{0X50090200, 0X00000100},
+	{0X50090204, 0X00000100},
+	{0X50090208, 0X00000100},
+	{0X5009020c, 0X00000100},
+	{0X50090210, 0X00000100},
+	{0X50090214, 0X00000108},
+	{0X50090218, 0X00000110},
+	{0X5009021c, 0X00000180},
+	{0X50090220, 0X00000188},
+	{0X50090224, 0X00000190},
+	{0X50090228, 0X00000200},
+	{0X5009022c, 0X00000208},
+	{0X50090230, 0X00000210},
+	{0X50090234, 0X00000280},
+	{0X50090238, 0X00000288},
+	{0X5009023c, 0X00000290},
+	{0X50090240, 0X00000304},
+	{0X50090244, 0X0000030C},
+	{0X50090248, 0X00000314},
+	{0X5009024c, 0X00000384},
+	{0X50090250, 0X0000038C},
+	{0X50090254, 0X00000404},
+	{0X50090258, 0X0000040C},
+	{0X5009025c, 0X00000414},
+	{0X50090260, 0X00000484},
+	{0X50090264, 0X0000048C},
+	{0X50090268, 0X00000500},
+	{0X5009026c, 0X00000508},
+	{0X50090270, 0X00000510},
+	{0X50090274, 0X00000580},
+	{0X50090278, 0X00000588},
+	{0X5009027c, 0X00000590},
+	{0X50090280, 0X00000280},
+	{0X50090284, 0X00000288},
+	{0X50090288, 0X00000290},
+	{0X5009028c, 0X00000304},
+	{0X50090290, 0X0000030C},
+	{0X50090294, 0X00000314},
+	{0X50090298, 0X00000384},
+	{0X5009029c, 0X0000038C},
+	{0X500902a0, 0X00000404},
+	{0X500902a4, 0X0000040C},
+	{0X500902a8, 0X00000414},
+	{0X500902ac, 0X00000484},
+	{0X500902b0, 0X0000048C},
+	{0X500902b4, 0X00000500},
+	{0X500902b8, 0X00000508},
+	{0X500902bc, 0X00000510},
+	{0X500902c0, 0X00000580},
+	{0X500902c4, 0X00000588},
+	{0X500902c8, 0X00000590},
+	{0X500902cc, 0X00000600},
+	{0X500902d0, 0X00000608},
+	{0X500902d4, 0X00000610},
+	{0X500902d8, 0X00000680},
+	{0X500902dc, 0X00000688},
+	{0X500902e0, 0X00000690},
+	{0X500902e4, 0X00000700},
+	{0X500902e8, 0X00000700},
+	{0X500902ec, 0X00000700},
+	{0X500902f0, 0X00000700},
+	{0X500902f4, 0X00000700},
+	{0X500902f8, 0X00000700},
+	{0X500902fc, 0X00000700},
+	{0X50090300, 0X00000500},
+	{0X50090304, 0X00000508},
+	{0X50090308, 0X00000510},
+	{0X5009030c, 0X00000580},
+	{0X50090310, 0X00000588},
+	{0X50090314, 0X00000590},
+	{0X50090318, 0X00000600},
+	{0X5009031c, 0X00000608},
+	{0X50090320, 0X00000610},
+	{0X50090324, 0X00000680},
+	{0X50090328, 0X00000688},
+	{0X5009032c, 0X00000690},
+	{0X50090330, 0X00000700},
+	{0X50090334, 0X00000700},
+	{0X50090338, 0X00000700},
+	{0X5009033c, 0X00000700},
+	{0X50090340, 0X00000700},
+	{0X50090344, 0X00000700},
+	{0X50090348, 0X00000700},
+	{0X5009034c, 0X00000700},
+	{0X50090350, 0X00000700},
+	{0X50090354, 0X00000700},
+	{0X50090358, 0X00000700},
+	{0X5009035c, 0X00000700},
+	{0X50090360, 0X00000700},
+	{0X50090364, 0X00000700},
+	{0X50090368, 0X00000700},
+	{0X5009036c, 0X00000700},
+	{0X50090370, 0X00000700},
+	{0X50090374, 0X00000700},
+	{0X50090378, 0X00000700},
+	{0X5009037c, 0X00000700},
+	{0X50090054, 0X00000000},
+#else /*High SNR */
+	//agc table 20141224
+	{0x50090054, 0x00000001},
+	{0x50090200, 0x00000100},
+	{0x50090204, 0x00000100},
+	{0x50090208, 0x00000100},
+	{0x5009020c, 0x00000100},
+	{0x50090210, 0x00000108},
+	{0x50090214, 0x00000110},
+	{0x50090218, 0x00000180},
+	{0x5009021c, 0x00000188},
+	{0x50090220, 0x00000190},
+	{0x50090224, 0x00000200},
+	{0x50090228, 0x00000208},
+	{0x5009022c, 0x00000210},
+	{0x50090230, 0x00000280},
+	{0x50090234, 0x00000288},
+	{0x50090238, 0x00000304},
+	{0x5009023c, 0x0000030C},
+	{0x50090240, 0x00000314},
+	{0x50090244, 0x00000384},
+	{0x50090248, 0x0000038C},
+	{0x5009024c, 0x00000394},
+	{0x50090250, 0x00000404},
+	{0x50090254, 0x0000040C},
+	{0x50090258, 0x00000414},
+	{0x5009025c, 0x00000484},
+	{0x50090260, 0x0000048C},
+	{0x50090264, 0x00000500},
+	{0x50090268, 0x00000508},
+	{0x5009026c, 0x00000510},
+	{0x50090270, 0x00000580},
+	{0x50090274, 0x00000588},
+	{0x50090278, 0x00000590},
+	{0x5009027c, 0x00000600},
+	{0x50090280, 0x00000288},
+	{0x50090284, 0x00000290},
+	{0x50090288, 0x00000304},
+	{0x5009028c, 0x0000030C},
+	{0x50090290, 0x00000314},
+	{0x50090294, 0x00000384},
+	{0x50090298, 0x0000038C},
+	{0x5009029c, 0x00000394},
+	{0x500902a0, 0x00000404},
+	{0x500902a4, 0x0000040C},
+	{0x500902a8, 0x00000414},
+	{0x500902ac, 0x00000484},
+	{0x500902b0, 0x0000048C},
+	{0x500902b4, 0x00000500},
+	{0x500902b8, 0x00000508},
+	{0x500902bc, 0x00000510},
+	{0x500902c0, 0x00000580},
+	{0x500902c4, 0x00000588},
+	{0x500902c8, 0x00000590},
+	{0x500902cc, 0x00000600},
+	{0x500902d0, 0x00000608},
+	{0x500902d4, 0x00000610},
+	{0x500902d8, 0x00000680},
+	{0x500902dc, 0x00000688},
+	{0x500902e0, 0x00000690},
+	{0x500902e4, 0x00000700},
+	{0x500902e8, 0x00000708},
+	{0x500902ec, 0x00000710},
+	{0x500902f0, 0x00000780},
+	{0x500902f4, 0x00000780},
+	{0x500902f8, 0x00000780},
+	{0x500902fc, 0x00000780},
+	{0x50090300, 0x00000500},
+	{0x50090304, 0x00000508},
+	{0x50090308, 0x00000510},
+	{0x5009030c, 0x00000580},
+	{0x50090310, 0x00000588},
+	{0x50090314, 0x00000590},
+	{0x50090318, 0x00000600},
+	{0x5009031c, 0x00000608},
+	{0x50090320, 0x00000610},
+	{0x50090324, 0x00000680},
+	{0x50090328, 0x00000688},
+	{0x5009032c, 0x00000690},
+	{0x50090330, 0x00000700},
+	{0x50090334, 0x00000708},
+	{0x50090338, 0x00000710},
+	{0x5009033c, 0x00000780},
+	{0x50090340, 0x00000780},
+	{0x50090344, 0x00000780},
+	{0x50090348, 0x00000780},
+	{0x5009034c, 0x00000780},
+	{0x50090350, 0x00000780},
+	{0x50090354, 0x00000780},
+	{0x50090358, 0x00000780},
+	{0x5009035c, 0x00000780},
+	{0x50090360, 0x00000780},
+	{0x50090364, 0x00000780},
+	{0x50090368, 0x00000780},
+	{0x5009036c, 0x00000780},
+	{0x50090370, 0x00000780},
+	{0x50090374, 0x00000780},
+	{0x50090378, 0x00000780},
+	{0x5009037c, 0x00000780},
+	{0x50090054, 0x00000000},
+#endif /*CHINA_VERSION */
+
+};
+
+static const u32 wifi_core_AM_PM_data_32_91e[][2] = {
+	{0x50090054, 0x00000000},
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	//item0:theta0=7_B=0_r0=2_for_verE
+	{0x50090090, 0x00000000},
+	{0x50090094, 0x00A01401},
+	{0x50090098, 0x02907412},
+	{0x5009009C, 0x05D12438},
+	{0x500900A0, 0x0A522872},
+	{0x500900A4, 0xFFF380C1},
+	//item0:G0=-3.5_r0=2.5_for_verE
+	{0x50090078, 0x02B05400},
+	{0x5009007C, 0x06D15840},
+	{0x50090080, 0x0B927885},
+	{0x50090084, 0x11A3DCD7},
+	{0x50090088, 0x1975A540},
+	{0x5009008C, 0xFc07fdc9},
+	{0x500900A8, 0x9c400180},
+
+};
+#endif
+
+const u32 wifi_phy_timeout_cfg_91e[][2] = {
+	{0x50000634, 0x00001100},
+	{0x50000584, 0x00007BF8},
+};
+
+#endif /*_WLAND_TRAP_91_E_H_*/
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91f.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91f.h
new file mode 100644
index 000000000000..76523c8e8229
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91f.h
@@ -0,0 +1,826 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __WLAND_TRAP_91_F_H__
+#define __WLAND_TRAP_91_F_H__
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_core_patch_data_32_91f[][2] = {
+	// add for pta
+	{0x50000828, 0x00100FFD},
+	{0x50000810, 0xFFFF0F0F},
+	{0x50000814, 0xFFFF0F0F},
+	{0x50000818, 0x00FF000F},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0F0},
+	{0x50090044, 0xE6AD6CB0},	//mode
+	{0x50090040, 0xBA9D5EC4},	//agc value
+	{0x0010c470, 0x00000002},	//disable ht
+	// add for pta
+#if 1
+	{0x0010FFFC, 0x20141018},
+	{0x00110000, 0xEA040522},
+	{0x00110004, 0xE3A02002},
+	{0x00110008, 0xE5C42000},
+	{0x0011000C, 0xE3A02001},
+	{0x00110010, 0xE51FF004},
+	{0x00110014, 0x0000EB7C},
+	{0x00110018, 0xEA04036B},
+	{0x0011001C, 0xE3A00060},
+	{0x00110020, 0xE5840630},
+	{0x00110024, 0xE59F0040},
+	{0x00110028, 0xE5840080},
+	{0x0011002C, 0xE3A00000},
+	{0x00110030, 0xE59F14B0},
+	{0x00110034, 0xE5C10000},
+	{0x00110038, 0xE59F14AC},
+	{0x0011003C, 0xE5C10334},
+	{0x00110040, 0xE59FF028},
+	{0x00110044, 0xE1A00000},
+	{0x00110048, 0xE1A00000},
+	{0x0011004C, 0xE1A00000},
+	{0x00110050, 0xE1A00000},
+	{0x00110054, 0xE1A00000},
+	{0x00110058, 0xE1A00000},
+	{0x0011005C, 0xE1A00000},
+	{0x00110060, 0xE1A00000},
+	{0x00110064, 0xE1A00000},
+	{0x00110068, 0xE1A00000},
+	{0x0011006C, 0x0003FFF7},
+	{0x00110070, 0x0000F26C},
+	{0x00110074, 0xEA0411E3},
+	{0x00110078, 0xE59F1470},
+	{0x0011007C, 0x03A00000},
+	{0x00110080, 0x05810000},
+	{0x00110084, 0x0A00000C},
+	{0x00110088, 0xE5910000},
+	{0x0011008C, 0xE2800001},
+	{0x00110090, 0xE3500002},
+	{0x00110094, 0x35810000},
+	{0x00110098, 0x3A000009},
+	{0x0011009C, 0xE3A00000},
+	{0x001100A0, 0xE5810000},
+	{0x001100A4, 0xE3A04001},
+	{0x001100A8, 0xE59F1444},
+	{0x001100AC, 0xE5C10000},
+	{0x001100B0, 0xE59F1440},
+	{0x001100B4, 0xE5C14000},
+	{0x001100B8, 0xEAFFFFFF},
+	{0x001100BC, 0xE51FF004},
+	{0x001100C0, 0x0000B8E8},
+	{0x001100C4, 0xE51FF004},
+	{0x001100C8, 0x0000B92C},
+	{0x001100CC, 0x00000000},
+	{0x001100D0, 0xEA0412DD},
+	{0x001100D4, 0xE3A015C0},
+	{0x001100D8, 0xE3E00007},
+	{0x001100DC, 0xE5810000},
+	{0x001100E0, 0xE3A01001},
+	{0x001100E4, 0xE3A0003F},
+	{0x001100E8, 0xEB000007},
+	{0x001100EC, 0xE59F105C},
+	{0x001100F0, 0xE3A00026},
+	{0x001100F4, 0xEB000004},
+	{0x001100F8, 0xE3A01000},
+	{0x001100FC, 0xE3A0003F},
+	{0x00110100, 0xEB000001},
+	{0x00110104, 0xE59F4008},
+	{0x00110108, 0xE59FF008},
+	{0x0011010C, 0xE51FF004},
+	{0x00110110, 0x00025CA8},
+	{0x00110114, 0x0010C670},
+	{0x00110118, 0x0000B55C},
+	{0x0011011C, 0xEA042927},
+	{0x00110120, 0xE3A01001},
+	{0x00110124, 0xE3A0003F},
+	{0x00110128, 0xEBFFFFF7},
+	{0x0011012C, 0xE59F1018},
+	{0x00110130, 0xE3A00026},
+	{0x00110134, 0xEBFFFFF4},
+	{0x00110138, 0xE3A01000},
+	{0x0011013C, 0xE3A0003F},
+	{0x00110140, 0xEBFFFFF1},
+	{0x00110144, 0xE59F0008},
+	{0x00110148, 0xE59FF008},
+	{0x0011014C, 0x00008058},
+	{0x00110150, 0x00008088},
+	{0x00110154, 0xFFFFFC09},
+	{0x00110158, 0x00005C80},
+	{0x0011015C, 0xEA042A52},
+	{0x00110160, 0xE3A01001},
+	{0x00110164, 0xE3A0003F},
+	{0x00110168, 0xEBFFFFE7},
+	{0x0011016C, 0xE51F1028},
+	{0x00110170, 0xE3A00026},
+	{0x00110174, 0xEBFFFFE4},
+	{0x00110178, 0xE3A01000},
+	{0x0011017C, 0xE3A0003F},
+	{0x00110180, 0xEBFFFFE1},
+	{0x00110184, 0xE51F0038},
+	{0x00110188, 0xE51FF004},
+	{0x0011018C, 0x00005814},
+	{0x00110190, 0xEA03DAFC},
+	{0x00110194, 0xE3A01001},
+	{0x00110198, 0xE3A0003F},
+	{0x0011019C, 0xEBFFFFDA},
+	{0x001101A0, 0xE51F1058},
+	{0x001101A4, 0xE3A00026},
+	{0x001101A8, 0xEBFFFFD7},
+	{0x001101AC, 0xE3A01000},
+	{0x001101B0, 0xE3A0003F},
+	{0x001101B4, 0xEBFFFFD4},
+	{0x001101B8, 0xE3A015C0},
+	{0x001101BC, 0xE3E00007},
+	{0x001101C0, 0xE5810000},
+	{0x001101C4, 0xE3A01003},
+	{0x001101C8, 0xE51FF004},
+	{0x001101CC, 0x000195A0},
+	{0x001101D0, 0xEA043623},
+	{0x001101D4, 0xE20210FF},
+	{0x001101D8, 0xE59F00D4},
+	{0x001101DC, 0xE5902000},
+	{0x001101E0, 0xE0811002},
+	{0x001101E4, 0xE5801000},
+	{0x001101E8, 0xE59F00CC},
+	{0x001101EC, 0xE5902000},
+	{0x001101F0, 0xE2822001},
+	{0x001101F4, 0xE5802000},
+	{0x001101F8, 0xE3520008},
+	{0x001101FC, 0x1A000027},
+	{0x00110200, 0xE3A02000},
+	{0x00110204, 0xE5802000},
+	{0x00110208, 0xE59F00A4},
+	{0x0011020C, 0xE5802000},
+	{0x00110210, 0xE1A011A1},
+	{0x00110214, 0xE59F00A8},
+	{0x00110218, 0xE5801000},
+	{0x0011021C, 0xE3510080},
+	{0x00110220, 0xB59F00A4},
+	{0x00110224, 0xBA00000F},
+	{0x00110228, 0xE35100D8},
+	{0x0011022C, 0xC59F0098},
+	{0x00110230, 0xCA00000C},
+	{0x00110234, 0xE35100D3},
+	{0x00110238, 0xC59F0090},
+	{0x0011023C, 0xCA000009},
+	{0x00110240, 0xE35100CE},
+	{0x00110244, 0xC59F0088},
+	{0x00110248, 0xCA000006},
+	{0x0011024C, 0xE35100C9},
+	{0x00110250, 0xC59F0080},
+	{0x00110254, 0xCA000003},
+	{0x00110258, 0xE35100C4},
+	{0x0011025C, 0xC59F0078},
+	{0x00110260, 0xCA000000},
+	{0x00110264, 0xE59F0074},
+	{0x00110268, 0xE59F103C},
+	{0x0011026C, 0xE5912000},
+	{0x00110270, 0xE1520000},
+	{0x00110274, 0x0A000009},
+	{0x00110278, 0xE5810000},
+	{0x0011027C, 0xE20010FF},
+	{0x00110280, 0xE3A00025},
+	{0x00110284, 0xEB000006},
+	{0x00110288, 0xE59F101C},
+	{0x0011028C, 0xE5912000},
+	{0x00110290, 0xE1A02422},
+	{0x00110294, 0xE20210FF},
+	{0x00110298, 0xE3A00023},
+	{0x0011029C, 0xEB000000},
+	{0x001102A0, 0xE59FF03C},
+	{0x001102A4, 0xE51FF004},
+	{0x001102A8, 0x00025BD4},
+	{0x001102AC, 0x001102B0},
+	{0x001102B0, 0x00001600},
+	{0x001102B4, 0x001102B8},
+	{0x001102B8, 0x00000000},
+	{0x001102BC, 0x001102C0},
+	{0x001102C0, 0x00000000},
+	{0x001102C4, 0x001102C8},
+	{0x001102C8, 0x00000000},
+	{0x001102CC, 0x0000030A},
+	{0x001102D0, 0x0000030A},
+	{0x001102D4, 0x00000709},
+	{0x001102D8, 0x00000A07},
+	{0x001102DC, 0x00000E07},
+	{0x001102E0, 0x00000F07},
+	{0x001102E4, 0x000029A4},
+	{0x001102E8, 0xEA03CC8B},
+	{0x001102EC, 0xE3A00000},
+	{0x001102F0, 0xE51F104C},
+	{0x001102F4, 0xE5810000},
+	{0x001102F8, 0xE1A00000},
+	{0x001102FC, 0xE1A00000},
+	{0x00110300, 0xE1A00000},
+	{0x00110304, 0xE59F0004},
+	{0x00110308, 0xE59FF004},
+	{0x0011030C, 0x00000009},
+	{0x00110310, 0x00000016},
+	{0x00110314, 0x0001D0BC},
+	{0x00110318, 0xEA03D5BF},
+	{0x0011031C, 0xE51FF004},
+	{0x00110320, 0x0001AC20},
+	{0x00110324, 0xEA03E724},
+	{0x00110328, 0x059FF020},
+	{0x0011032C, 0xE2044001},
+	{0x00110330, 0xE3540000},
+	{0x00110334, 0x059FF014},
+	{0x00110338, 0xE3A00000},
+	{0x0011033C, 0xE59F11B0},
+	{0x00110340, 0xE5C10000},
+	{0x00110344, 0xEBFBCA6A},
+	{0x00110348, 0xE59FF000},
+	{0x0011034C, 0xE1A00000},
+	{0x00110350, 0x000165CC},
+	{0x00110354, 0xEA04355B},
+	{0x00110358, 0x159FF014},
+	{0x0011035C, 0xE59F0198},
+	{0x00110360, 0xE5D00000},
+	{0x00110364, 0xE3500001},
+	{0x00110368, 0x059FF004},
+	{0x0011036C, 0x151FF004},
+	{0x00110370, 0x00002DE8},
+	{0x00110374, 0x00002DFC},
+	{0x00110378, 0xEA03DC45},
+	{0x0011037C, 0xE59F017C},
+	{0x00110380, 0xE5901000},
+	{0x00110384, 0xE3510000},
+	{0x00110388, 0x1A00000D},
+	{0x0011038C, 0xE3A01001},
+	{0x00110390, 0xE5801000},
+	{0x00110394, 0xE3A01000},
+	{0x00110398, 0xE3A0003F},
+	{0x0011039C, 0xEBFFFF5A},
+	{0x001103A0, 0xE59F1050},
+	{0x001103A4, 0xE3A00030},
+	{0x001103A8, 0xEBFFFF57},
+	{0x001103AC, 0xE3A01F7C},
+	{0x001103B0, 0xE3A0000F},
+	{0x001103B4, 0xEBFFFF54},
+	{0x001103B8, 0xE3A01000},
+	{0x001103BC, 0xE3A0003F},
+	{0x001103C0, 0xEBFFFF51},
+	{0x001103C4, 0xE59F0030},
+	{0x001103C8, 0xE5D00000},
+	{0x001103CC, 0xE3500000},
+	{0x001103D0, 0x1A000005},
+	{0x001103D4, 0xE59F004C},
+	{0x001103D8, 0xE3500000},
+	{0x001103DC, 0x03A00000},
+	{0x001103E0, 0xE1A00000},
+	{0x001103E4, 0xE1A00000},
+	{0x001103E8, 0xE1A00000},
+	{0x001103EC, 0x13A00001},
+	{0x001103F0, 0xE3500000},
+	{0x001103F4, 0xE59FF008},
+	{0x001103F8, 0x00000141},
+	{0x001103FC, 0x001015C6},
+	{0x00110400, 0x00000000},
+	{0x00110404, 0x0001926C},
+	{0x00110408, 0xEA03F898},
+	{0x0011040C, 0xE3550000},
+	{0x00110410, 0x03A02001},
+	{0x00110414, 0x13A02000},
+	{0x00110418, 0xE59F00E4},
+	{0x0011041C, 0xE5802000},
+	{0x00110420, 0xE1A02005},
+	{0x00110424, 0xE59FF000},
+	{0x00110428, 0x00000000},
+	{0x0011042C, 0x000121A8},
+	{0x00110430, 0xEA03B92F},
+	{0x00110434, 0xE3A00001},
+	{0x00110438, 0xE3A02000},
+	{0x0011043C, 0xE51FF004},
+	{0x00110440, 0x00021F74},
+	{0x00110444, 0xEA03DA78},
+	{0x00110448, 0xE3A00004},
+	{0x0011044C, 0xEB000000},
+	{0x00110450, 0xE59FF004},
+	{0x00110454, 0xE51FF004},
+	{0x00110458, 0x00012880},
+	{0x0011045C, 0x00019A68},
+	{0x00110460, 0xEA03CBEC},
+	{0x00110464, 0xE3A00000},
+	{0x00110468, 0xE3500001},
+	{0x0011046C, 0xE51FF004},
+	{0x00110470, 0x0001D4B0},
+	{0x00110474, 0xEA03CA0F},
+	{0x00110478, 0xE3A01000},
+	{0x0011047C, 0xE3A00025},
+	{0x00110480, 0xEBFFFF87},
+	{0x00110484, 0xE3A01016},
+	{0x00110488, 0xE3A00023},
+	{0x0011048C, 0xEBFFFF84},
+	{0x00110490, 0xE51F109C},
+	{0x00110494, 0xE3A02000},
+	{0x00110498, 0xE3A00001},
+	{0x0011049C, 0xE51FF004},
+	{0x001104A0, 0x0001DC38},
+	{0x001104A4, 0xEA041486},
+	{0x001104A8, 0xE1A04000},
+	{0x001104AC, 0xE1A05001},
+	{0x001104B0, 0xE51F020C},
+	{0x001104B4, 0xE5900000},
+	{0x001104B8, 0xE20010FF},
+	{0x001104BC, 0xE3A00025},
+	{0x001104C0, 0xEBFFFF77},
+	{0x001104C4, 0xE51F0220},
+	{0x001104C8, 0xE5900000},
+	{0x001104CC, 0xE1A00420},
+	{0x001104D0, 0xE20010FF},
+	{0x001104D4, 0xE3A00023},
+	{0x001104D8, 0xEBFFFF71},
+	{0x001104DC, 0xE1A01005},
+	{0x001104E0, 0xE51FF004},
+	{0x001104E4, 0x0000B28C},
+	{0x001104E8, 0x0010001E},
+	{0x001104EC, 0x0010CAC4},
+	{0x001104F0, 0x001100CC},
+	{0x001104F4, 0x0010C673},
+	{0x001104F8, 0x0010C674},
+	{0x001104FC, 0x0010C672},
+	{0x00110500, 0x00110400},
+	{0x00110504, 0x00110428},
+	{0x20040004, 0x0000EB74},
+	{0x20040024, 0x00110000},
+	{0x20040008, 0x0000F268},
+	{0x20040028, 0x00110018},
+	{0x2004000C, 0x0000B8E4},
+	{0x2004002C, 0x00110074},
+	{0x20040010, 0x0000B558},
+	{0x20040030, 0x001100D0},
+	{0x20040014, 0x00005C7C},
+	{0x20040034, 0x0011011C},
+	{0x20040018, 0x00005810},
+	{0x20040038, 0x0011015C},
+	{0x2004001C, 0x0001959C},
+	{0x2004003C, 0x00110190},
+	{0x20040020, 0x00002940},
+	{0x20040040, 0x001101D0},
+	{0x20040100, 0x0001D0B8},
+	{0x20040120, 0x001102E8},
+	{0x20040104, 0x0001AC18},
+	{0x20040124, 0x00110318},
+	{0x20040108, 0x00016690},
+	{0x20040128, 0x00110324},
+	{0x2004010C, 0x00002DE4},
+	{0x2004012C, 0x00110354},
+	{0x20040110, 0x00019260},
+	{0x20040130, 0x00110378},
+	{0x20040114, 0x000121A4},
+	{0x20040134, 0x00110408},
+	{0x20040118, 0x00021F70},
+	{0x20040138, 0x00110430},
+	{0x2004011C, 0x00019A60},
+	{0x2004013C, 0x00110444},
+	{0x20040140, 0x0001D4AC},
+	{0x20040180, 0x00110460},
+	{0x20040144, 0x0001DC34},
+	{0x20040184, 0x00110474},
+	{0x20040148, 0x0000B288},
+	{0x20040188, 0x001104A4},
+	{0x20040000, 0x0007FFFF},
+#endif
+
+};
+
+#define SET_CHANNEL_MEM_TABLE_BASE_91F 0x0010D7B0
+#define SET_CHANNEL_RF_TABLE_BASE_91F 0x0010DA50
+static const u32 wifi_clock_switch_91f[][2] = {
+
+	//channel 1
+	{SET_CHANNEL_MEM_TABLE_BASE_91F, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x04, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x08, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x0C, 0x2222CFCF},
+
+	//channel 2
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x30, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x34, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x38, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x3C, 0x2222CFCF},
+
+	//channel 3
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x60, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x64, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x68, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x6C, 0x2222CFCF},
+
+	//channel 4
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x90, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x94, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x98, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x9C, 0x2222CFCF},
+
+	//channel 5
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xC0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xC4, 0x304199C4},	//diffrent with 91e
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xC8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xCC, 0x2222CFCF},
+
+	//channel 6
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xF0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xF4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xF8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0xFC, 0x2222CFCF},
+
+	//channel 7
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x120, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x124, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x128, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x12C, 0x2222CFCF},
+
+	//channel 8
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x150, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x154, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x158, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x15C, 0x2222CFCF},
+
+	//channel 9
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x180, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x184, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x188, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x18C, 0x2222CFCF},
+
+	//channel 10
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1B0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1B4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1B8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1BC, 0x2222CFCF},
+
+	//channel 11
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1E0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1E4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1E8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x1EC, 0x2222CFCF},
+
+	//channel 12
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x210, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x214, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x218, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x21C, 0x2222CFCF},
+
+	//channel 13
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x240, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x244, 0x304199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x248, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91F + 0x24C, 0x2222CFCF},
+
+	//channel 1
+	{SET_CHANNEL_RF_TABLE_BASE_91F, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x04, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x08, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x0C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x10, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x14, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x18, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1C, 0x00000000},
+
+	//channel 2
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x40, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x44, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x48, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x4C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x50, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x54, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x58, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x5C, 0x00000000},
+
+	//channel 3
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x80, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x84, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x88, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x8C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x90, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x94, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x98, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x9C, 0x00000000},
+
+	//channel 4
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xC0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xC4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xC8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xCC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xD0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xD4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xD8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0xDC, 0x00000000},
+
+	//channel 5
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x100, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x104, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x108, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x10C, 0x00000B08},	//diff with 91e
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x110, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x114, 0x0000AA12},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x118, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x11C, 0x00000000},
+
+	//channel 6
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x140, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x144, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x148, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x14C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x150, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x154, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x158, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x15C, 0x00000000},
+
+	//channel 7
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x180, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x184, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x188, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x18C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x190, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x194, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x198, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x19C, 0x00000000},
+
+	//channel 8
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1CC, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x1DC, 0x00000000},
+
+	//channel 9
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x200, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x204, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x208, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x20C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x210, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x214, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x218, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x21C, 0x00000000},
+
+	//channel 10
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x240, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x244, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x248, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x24C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x250, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x254, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x258, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x25C, 0x00000000},
+
+	//channel 11
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x280, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x284, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x288, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x28C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x290, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x294, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x298, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x29C, 0x00000000},
+
+	//channel 12
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2CC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x2DC, 0x00000000},
+
+	//channel 13
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x300, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x304, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x308, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x30C, 0x00000B08},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x310, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x314, 0x0000AA12},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x318, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91F + 0x31C, 0x00000000},
+
+};
+
+static const u8 wifi_core_patch_data_91f_8[][2] = {
+	{0x28, 0x1a},
+	{0x29, 0x0d},
+	{0x23, 0x07},
+	{0x25, 0x00},
+	{0xca, 0x4f},
+	//{0x83, 0x60},
+	//{0x87, 0xd9},
+	{0x08, 0x43},
+	//rx patch
+	{0x26, 0x35},
+	{0x3e, 0x64},
+	{0x3f, 0x00},
+	{0x45, 0x75},
+	{0x46, 0x73},
+	{0x50, 0x58},
+	{0x57, 0xdb},
+	{0xc5, 0x7c},
+	{0x30, 0xf6},
+	{0x54, 0xb4},
+	{0x55, 0xb4},
+	{0x56, 0xb4},
+
+	{0xA0, 0x7f},
+	{0x74, 0x01},
+	{0x75, 0x40},
+
+	{0x12, 0x04},
+	{0x1C, 0x2D},
+	{0x0D, 0x59},
+	{0x17, 0x75},
+	{0x74, 0xD4},
+	{0x75, 0x47},
+
+	{0x74, 0xFF},
+	{0x75, 0x4B},
+
+	{0x74, 0x3D},
+	{0x75, 0x4C},
+
+	{0x74, 0x01},
+	{0x75, 0x50},
+
+	{0x74, 0x99},
+	{0x75, 0x57},
+
+	{0x74, 0xFF},
+	{0x75, 0x5B},
+
+	{0x74, 0x33},
+	{0x75, 0x5D},
+
+	{0x74, 0xE4},
+	{0x75, 0x61},
+
+	{0x30, 0xF7},
+};
+
+static const u32 wifi_core_init_data_32_91f[][2] = {
+	{0x500002a8, 0x00000001},
+	{0x50000080, 0x0003FEF7},
+#if 0
+	{0x00100018, 0x000A3243},	// flow ctrl , WPS supported, proakis
+	{0x0010001C, 0xFFFF0001},
+#endif
+	{0x30010010, 0x00007DFF},
+
+	{0x50090060, 0x000001B4},
+	//item:rda5991_verE_wf_tx_pn9
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	{0x500900A8, 0x9c400180},
+	{0x5009008C, 0xFc07fdc9},
+	//PHY:phy rx timeout enable
+#if 1
+	{0x0010b644, 0x50000634},
+	{0x0010b648, 0x00001100},
+	{0x0010b64c, 0x50000584},
+	{0x0010b650, 0x00007bf8},
+#endif
+	//new agc table 20140825
+	{0X50090054, 0X00000001},
+	{0X50090200, 0X00000100},
+	{0X50090204, 0X00000100},
+	{0X50090208, 0X00000100},
+	{0X5009020c, 0X00000100},
+	{0X50090210, 0X00000100},
+	{0X50090214, 0X00000108},
+	{0X50090218, 0X00000110},
+	{0X5009021c, 0X00000180},
+	{0X50090220, 0X00000188},
+	{0X50090224, 0X00000190},
+	{0X50090228, 0X00000200},
+	{0X5009022c, 0X00000208},
+	{0X50090230, 0X00000210},
+	{0X50090234, 0X00000280},
+	{0X50090238, 0X00000288},
+	{0X5009023c, 0X00000290},
+	{0X50090240, 0X00000304},
+	{0X50090244, 0X0000030C},
+	{0X50090248, 0X00000314},
+	{0X5009024c, 0X00000384},
+	{0X50090250, 0X0000038C},
+	{0X50090254, 0X00000404},
+	{0X50090258, 0X0000040C},
+	{0X5009025c, 0X00000414},
+	{0X50090260, 0X00000484},
+	{0X50090264, 0X0000048C},
+	{0X50090268, 0X00000500},
+	{0X5009026c, 0X00000508},
+	{0X50090270, 0X00000510},
+	{0X50090274, 0X00000580},
+	{0X50090278, 0X00000588},
+	{0X5009027c, 0X00000590},
+	{0X50090280, 0X00000280},
+	{0X50090284, 0X00000288},
+	{0X50090288, 0X00000290},
+	{0X5009028c, 0X00000304},
+	{0X50090290, 0X0000030C},
+	{0X50090294, 0X00000314},
+	{0X50090298, 0X00000384},
+	{0X5009029c, 0X0000038C},
+	{0X500902a0, 0X00000404},
+	{0X500902a4, 0X0000040C},
+	{0X500902a8, 0X00000414},
+	{0X500902ac, 0X00000484},
+	{0X500902b0, 0X0000048C},
+	{0X500902b4, 0X00000500},
+	{0X500902b8, 0X00000508},
+	{0X500902bc, 0X00000510},
+	{0X500902c0, 0X00000580},
+	{0X500902c4, 0X00000588},
+	{0X500902c8, 0X00000590},
+	{0X500902cc, 0X00000600},
+	{0X500902d0, 0X00000608},
+	{0X500902d4, 0X00000610},
+	{0X500902d8, 0X00000680},
+	{0X500902dc, 0X00000688},
+	{0X500902e0, 0X00000690},
+	{0X500902e4, 0X00000700},
+	{0X500902e8, 0X00000700},
+	{0X500902ec, 0X00000700},
+	{0X500902f0, 0X00000700},
+	{0X500902f4, 0X00000700},
+	{0X500902f8, 0X00000700},
+	{0X500902fc, 0X00000700},
+	{0X50090300, 0X00000500},
+	{0X50090304, 0X00000508},
+	{0X50090308, 0X00000510},
+	{0X5009030c, 0X00000580},
+	{0X50090310, 0X00000588},
+	{0X50090314, 0X00000590},
+	{0X50090318, 0X00000600},
+	{0X5009031c, 0X00000608},
+	{0X50090320, 0X00000610},
+	{0X50090324, 0X00000680},
+	{0X50090328, 0X00000688},
+	{0X5009032c, 0X00000690},
+	{0X50090330, 0X00000700},
+	{0X50090334, 0X00000700},
+	{0X50090338, 0X00000700},
+	{0X5009033c, 0X00000700},
+	{0X50090340, 0X00000700},
+	{0X50090344, 0X00000700},
+	{0X50090348, 0X00000700},
+	{0X5009034c, 0X00000700},
+	{0X50090350, 0X00000700},
+	{0X50090354, 0X00000700},
+	{0X50090358, 0X00000700},
+	{0X5009035c, 0X00000700},
+	{0X50090360, 0X00000700},
+	{0X50090364, 0X00000700},
+	{0X50090368, 0X00000700},
+	{0X5009036c, 0X00000700},
+	{0X50090370, 0X00000700},
+	{0X50090374, 0X00000700},
+	{0X50090378, 0X00000700},
+	{0X5009037c, 0X00000700},
+	{0X50090054, 0X00000000},
+};
+
+static const u32 wifi_core_AM_PM_data_32_91f[][2] = {
+	{0x50090054, 0x00000000},
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	//item0:theta0=7_B=0_r0=2_for_verE
+	{0x50090090, 0x00000000},
+	{0x50090094, 0x00A01401},
+	{0x50090098, 0x02907412},
+	{0x5009009C, 0x05D12438},
+	{0x500900A0, 0x0A522872},
+	{0x500900A4, 0xFFF380C1},
+	//item0:G0=-3.5_r0=2.5_for_verE
+	{0x50090078, 0x02B05400},
+	{0x5009007C, 0x06D15840},
+	{0x50090080, 0x0B927885},
+	{0x50090084, 0x11A3DCD7},
+	{0x50090088, 0x1975A540},
+	{0x5009008C, 0xFc07fdc9},
+	{0x500900A8, 0x9c400180},
+
+};
+#endif
+const u32 wifi_phy_timeout_cfg_91f[][2] = {
+	{0x50000634, 0x00001100},
+	{0x50000584, 0x00007BF8},
+};
+
+#endif
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91g.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91g.h
new file mode 100644
index 000000000000..fa2043f69f84
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_trap_91g.h
@@ -0,0 +1,806 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __WLAND_TRAP_91_G_H__
+#define __WLAND_TRAP_91_G_H__
+
+#ifndef RDA_WLAND_FROM_FIRMWARE
+static const u32 wifi_core_patch_data_32_91g[][2] = {
+	// add for pta
+	{0x50000828, 0x00100FFD},
+	{0x50000810, 0xFFFF0F0F},
+	{0x50000814, 0xFFFF0F0F},
+	{0x50000818, 0x00FF000F},
+	{0x5000081C, 0xFF000F00},
+	{0x50000820, 0xFF000F00},
+	{0x50000824, 0x0000F0F0},
+	{0x50090044, 0xE6AD6CB0},//mode
+	{0x50090040, 0xBA9D5EC4},//agc value
+	{0x0010a944, 0x00000002},//disable ht
+	{0x00100018, 0x000A3203},
+	{0x0010001C, 0x00010000},
+	{0x00100020, 0x00000100},
+	{0x00100028, 0x00041400},
+	{0x0010FFFC, 0x20160301},
+	{0x00110000, 0xEA03B86D},
+	{0x00110004, 0xE5D02000},
+	{0x00110008, 0xE5D01001},
+	{0x0011000C, 0xE51FF004},
+	{0x00110010, 0x00021E50},
+	{0x00110014, 0xEA04048F},
+	{0x00110018, 0xE3A03000},
+	{0x0011001C, 0xE5D11000},
+	{0x00110020, 0xE5802010},
+	{0x00110024, 0xE5803044},
+	{0x00110028, 0xE3510001},
+	{0x0011002C, 0x13A01003},
+	{0x00110030, 0x03A01009},
+	{0x00110034, 0xE5801014},
+	{0x00110038, 0xE3A03001},
+	{0x0011003C, 0xE5803048},
+	{0x00110040, 0xE51FF004},
+	{0x00110044, 0x0000EDF8},
+	{0x00110048, 0xEA03FDF7},
+	{0x0011004C, 0xE3A05001},
+	{0x00110050, 0xE1C45DB8},
+	{0x00110054, 0xE3A050C8},
+	{0x00110058, 0xE51FF004},
+	{0x0011005C, 0x00010870},
+	{0x00110060, 0xEA040D08},
+	{0x00110064, 0xE3500019},
+	{0x00110068, 0xE51FF004},
+	{0x0011006C, 0x0000CC40},
+	{0x00110070, 0xEA03FA64},
+	{0x00110074, 0xE3540019},
+	{0x00110078, 0xE51FF004},
+	{0x0011007C, 0x000116E0},
+	{0x00110080, 0xEA03FB98},
+	{0x00110084, 0xE3540019},
+	{0x00110088, 0xE51FF004},
+	{0x0011008C, 0x00011220},
+	{0x00110090, 0xEA0434E8},
+	{0x00110094, 0xE20210FF},
+	{0x00110098, 0xE59F00D4},
+	{0x0011009C, 0xE5902000},
+	{0x001100A0, 0xE0811002},
+	{0x001100A4, 0xE5801000},
+	{0x001100A8, 0xE59F00CC},
+	{0x001100AC, 0xE5902000},
+	{0x001100B0, 0xE2822001},
+	{0x001100B4, 0xE5802000},
+	{0x001100B8, 0xE3520008},
+	{0x001100BC, 0x1A000027},
+	{0x001100C0, 0xE3A02000},
+	{0x001100C4, 0xE5802000},
+	{0x001100C8, 0xE59F00A4},
+	{0x001100CC, 0xE5802000},
+	{0x001100D0, 0xE1A011A1},
+	{0x001100D4, 0xE59F00A8},
+	{0x001100D8, 0xE5801000},
+	{0x001100DC, 0xE3510080},
+	{0x001100E0, 0xB59F00A4},
+	{0x001100E4, 0xBA00000F},
+	{0x001100E8, 0xE35100D8},
+	{0x001100EC, 0xC59F0098},
+	{0x001100F0, 0xCA00000C},
+	{0x001100F4, 0xE35100D3},
+	{0x001100F8, 0xC59F0090},
+	{0x001100FC, 0xCA000009},
+	{0x00110100, 0xE35100CE},
+	{0x00110104, 0xC59F0088},
+	{0x00110108, 0xCA000006},
+	{0x0011010C, 0xE35100C9},
+	{0x00110110, 0xC59F0080},
+	{0x00110114, 0xCA000003},
+	{0x00110118, 0xE35100C4},
+	{0x0011011C, 0xC59F0078},
+	{0x00110120, 0xCA000000},
+	{0x00110124, 0xE59F0074},
+	{0x00110128, 0xE59F103C},
+	{0x0011012C, 0xE5912000},
+	{0x00110130, 0xE1520000},
+	{0x00110134, 0x0A000009},
+	{0x00110138, 0xE5810000},
+	{0x0011013C, 0xE20010FF},
+	{0x00110140, 0xE3A00025},
+	{0x00110144, 0xEB000006},
+	{0x00110148, 0xE59F101C},
+	{0x0011014C, 0xE5912000},
+	{0x00110150, 0xE1A02422},
+	{0x00110154, 0xE20210FF},
+	{0x00110158, 0xE3A00023},
+	{0x0011015C, 0xEB000000},
+	{0x00110160, 0xE59FF03C},
+	{0x00110164, 0xE51FF004},
+	{0x00110168, 0x00029E9C},
+	{0x0011016C, 0x00110170},
+	{0x00110170, 0x00001600},
+	{0x00110174, 0x00110178},
+	{0x00110178, 0x00000000},
+	{0x0011017C, 0x00110180},
+	{0x00110180, 0x00000000},
+	{0x00110184, 0x00110188},
+	{0x00110188, 0x00000000},
+	{0x0011018C, 0x0000000F},
+	{0x00110190, 0x0000030A},
+	{0x00110194, 0x00000709},
+	{0x00110198, 0x00000A07},
+	{0x0011019C, 0x00000E05},
+	{0x001101A0, 0x00001600},
+	{0x001101A4, 0x00002D50},
+	{0x001101A8, 0xEA03BFAB},
+	{0x001101AC, 0xE51F0044},
+	{0x001101B0, 0xE51F104C},
+	{0x001101B4, 0xE5810000},
+	{0x001101B8, 0xE3A00016},
+	{0x001101BC, 0xE51FF004},
+	{0x001101C0, 0x000202FC},
+	{0x001101C4, 0xEA03BCAC},
+	{0x001101C8, 0xE3A01000},
+	{0x001101CC, 0xE3A00025},
+	{0x001101D0, 0xEBFFFFE3},
+	{0x001101D4, 0xE3A01016},
+	{0x001101D8, 0xE3A00023},
+	{0x001101DC, 0xEBFFFFE0},
+	{0x001101E0, 0xE59F1008},
+	{0x001101E4, 0xE3A02000},
+	{0x001101E8, 0xE3A00001},
+	{0x001101EC, 0xE59FF000},
+	{0x001101F0, 0x001013E8},
+	{0x001101F4, 0x00020F14},
+	{0x001101F8, 0xEA040D32},
+	{0x001101FC, 0xE1A04000},
+	{0x00110200, 0xE1A05001},
+	{0x00110204, 0xE51F00A0},
+	{0x00110208, 0xE5900000},
+	{0x0011020C, 0xE20010FF},
+	{0x00110210, 0xE3A00025},
+	{0x00110214, 0xEBFFFFD2},
+	{0x00110218, 0xE51F00B4},
+	{0x0011021C, 0xE5900000},
+	{0x00110220, 0xE1A00420},
+	{0x00110224, 0xE20010FF},
+	{0x00110228, 0xE3A00023},
+	{0x0011022C, 0xEBFFFFCC},
+	{0x00110230, 0xE1A01005},
+	{0x00110234, 0xE51FF004},
+	{0x00110238, 0x0000CD30},
+	{0x0011023C, 0xEA03DACE},
+	{0x00110240, 0xE51FF004},
+	{0x00110244, 0x0001970C},
+	{0x00110248, 0xEA041293},
+	{0x0011024C, 0x1A000000},
+	{0x00110250, 0xE59FF004},
+	{0x00110254, 0xE51FF004},
+	{0x00110258, 0x0000B848},
+	{0x0011025C, 0x0000B7FC},
+	{0x00110260, 0xEA041311},
+	{0x00110264, 0xE51FF004},
+	{0x00110268, 0x0000B620},
+	{0x0011026C, 0xEA03DA77},
+	{0x00110270, 0xE3500000},
+	{0x00110274, 0x0A00001D},
+	{0x00110278, 0xE3A0003F},
+	{0x0011027C, 0xE3A01001},
+	{0x00110280, 0xEB000014},
+	{0x00110284, 0xE59F1070},
+	{0x00110288, 0xE3A0003C},
+	{0x0011028C, 0xEB00000F},
+	{0x00110290, 0xE3A0003F},
+	{0x00110294, 0xE3A01000},
+	{0x00110298, 0xEB00000E},
+	{0x0011029C, 0xE3A0003F},
+	{0x001102A0, 0xE3A01001},
+	{0x001102A4, 0xEB00000B},
+	{0x001102A8, 0xE3A01000},
+	{0x001102AC, 0xE3A0003C},
+	{0x001102B0, 0xEB000008},
+	{0x001102B4, 0xE3A0003F},
+	{0x001102B8, 0xE3A01000},
+	{0x001102BC, 0xEB000005},
+	{0x001102C0, 0xE59F0030},
+	{0x001102C4, 0xE3500C80},
+	{0x001102C8, 0x8A000004},
+	{0x001102CC, 0x9A000005},
+	{0x001102D0, 0xE51FF004},
+	{0x001102D4, 0x0001AEE8},
+	{0x001102D8, 0xE51FF004},
+	{0x001102DC, 0x00029FAC},
+	{0x001102E0, 0xE51FF004},
+	{0x001102E4, 0x00019894},
+	{0x001102E8, 0xE51FF004},
+	{0x001102EC, 0x00019AC0},
+	{0x001102F0, 0xE51FF004},
+	{0x001102F4, 0x00019B34},
+	{0x001102F8, 0x00000000},
+	{0x001102FC, 0x001102F8},
+	{0x00110300, 0xEA03BF14},
+	{0x00110304, 0xE1A02000},
+	{0x00110308, 0xE5D0000D},
+	{0x0011030C, 0xE1810400},
+	{0x00110310, 0xE1CD01B0},
+	{0x00110314, 0xE1A00002},
+	{0x00110318, 0xE59F1014},
+	{0x0011031C, 0xE5D0000E},
+	{0x00110320, 0xE5C10000},
+	{0x00110324, 0xE59F100C},
+	{0x00110328, 0xE5810000},
+	{0x0011032C, 0xE28D0004},
+	{0x00110330, 0xE59FF004},
+	{0x00110334, 0x0010A362},
+	{0x00110338, 0x50000508},
+	{0x0011033C, 0x000206BC},
+	{0x20040004, 0x00021E48},
+	{0x20040024, 0x00110000},
+	{0x20040008, 0x0000EDD4},
+	{0x20040028, 0x00110014},
+	{0x2004000C, 0x00010868},
+	{0x2004002C, 0x00110048},
+	{0x20040010, 0x0000CC3C},
+	{0x20040030, 0x00110060},
+	{0x20040014, 0x000116DC},
+	{0x20040034, 0x00110070},
+	{0x20040018, 0x0001121C},
+	{0x20040038, 0x00110080},
+	{0x2004001C, 0x00002CEC},
+	{0x2004003C, 0x00110090},
+	{0x20040020, 0x000202F8},
+	{0x20040040, 0x001101A8},
+	{0x20040100, 0x00020F10},
+	{0x20040120, 0x001101C4},
+	{0x20040104, 0x0000CD2C},
+	{0x20040124, 0x001101F8},
+	{0x20040108, 0x00019700},
+	{0x20040128, 0x0011023C},
+	{0x2004010C, 0x0000B7F8},
+	{0x2004012C, 0x00110248},
+	{0x20040110, 0x0000B618},
+	{0x20040130, 0x00110260},
+	{0x20040114, 0x0001988C},
+	{0x20040134, 0x0011026C},
+	{0x20040118, 0x000206AC},
+	{0x20040138, 0x00110300},
+	{0x20040000, 0x00007FFF},
+};
+
+#define SET_CHANNEL_MEM_TABLE_BASE_91G 0x0010c088
+#define SET_CHANNEL_RF_TABLE_BASE_91G 0x0010c328
+static const u32 wifi_clock_switch_91g[][2] = {
+
+	//channel 1
+	{SET_CHANNEL_MEM_TABLE_BASE_91G, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x04, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x08, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x0C, 0x2222CFCF},
+
+	//channel 2
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x30, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x34, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x38, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x3C, 0x2222CFCF},
+
+	//channel 3
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x60, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x64, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x68, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x6C, 0x2222CFCF},
+
+	//channel 4
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x90, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x94, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x98, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x9C, 0x2222CFCF},
+
+	//channel 5
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xC0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xC4, 0x304199C4},	//diffrent with 91e
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xC8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xCC, 0x2222CFCF},
+
+	//channel 6
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xF0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xF4, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xF8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0xFC, 0x2222CFCF},
+
+	//channel 7
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x120, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x124, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x128, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x12C, 0x2222CFCF},
+
+	//channel 8
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x150, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x154, 0x204199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x158, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x15C, 0x2222CFCF},
+
+	//channel 9
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x180, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x184, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x188, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x18C, 0x2222CFCF},
+
+	//channel 10
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1B0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1B4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1B8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1BC, 0x2222CFCF},
+
+	//channel 11
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1E0, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1E4, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1E8, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x1EC, 0x2222CFCF},
+
+	//channel 12
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x210, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x214, 0x604199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x218, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x21C, 0x2222CFCF},
+
+	//channel 13
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x240, 0x50090048},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x244, 0x304199C4},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x248, 0x50000654},
+	{SET_CHANNEL_MEM_TABLE_BASE_91G + 0x24C, 0x2222CFCF},
+
+	//channel 1
+	{SET_CHANNEL_RF_TABLE_BASE_91G, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x04, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x08, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x0C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x10, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x14, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x18, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1C, 0x00000000},
+
+	//channel 2
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x40, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x44, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x48, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x4C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x50, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x54, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x58, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x5C, 0x00000000},
+
+	//channel 3
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x80, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x84, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x88, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x8C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x90, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x94, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x98, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x9C, 0x00000000},
+
+	//channel 4
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xC0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xC4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xC8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xCC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xD0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xD4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xD8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0xDC, 0x00000000},
+
+	//channel 5
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x100, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x104, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x108, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x10C, 0x00000B08},	//diff with 91e
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x110, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x114, 0x0000AA12},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x118, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x11C, 0x00000000},
+
+	//channel 6
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x140, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x144, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x148, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x14C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x150, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x154, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x158, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x15C, 0x00000000},
+
+	//channel 7
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x180, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x184, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x188, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x18C, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x190, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x194, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x198, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x19C, 0x00000000},
+
+	//channel 8
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1CC, 0x00000908},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x1DC, 0x00000000},
+
+	//channel 9
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x200, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x204, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x208, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x20C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x210, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x214, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x218, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x21C, 0x00000000},
+
+	//channel 10
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x240, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x244, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x248, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x24C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x250, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x254, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x258, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x25C, 0x00000000},
+
+	//channel 11
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x280, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x284, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x288, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x28C, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x290, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x294, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x298, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x29C, 0x00000000},
+
+	//channel 12
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2C0, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2C4, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2C8, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2CC, 0x00000808},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2D0, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2D4, 0x0000AA00},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2D8, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x2DC, 0x00000000},
+
+	//channel 13
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x300, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x304, 0x00000001},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x308, 0x00000038},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x30C, 0x00000B08},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x310, 0x0000003E},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x314, 0x0000AA12},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x318, 0x0000003F},
+	{SET_CHANNEL_RF_TABLE_BASE_91G + 0x31C, 0x00000000},
+
+};
+
+static const u8 wifi_core_patch_data_91g_8[][2] = {
+	{0x28, 0x1a},
+	{0x29, 0x0d},
+	{0x23, 0x16},
+	{0x25, 0x00},
+	//{0xca, 0x47},
+	//{0x83, 0x60},
+	//{0x87, 0xd9},
+	{0x08, 0x43},
+	//rx patch
+	{0x26, 0x35},
+	{0x3e, 0x64},
+	{0x3f, 0x00},
+	{0x45, 0x75},
+	{0x46, 0x73},
+	{0x50, 0x58},
+	{0x57, 0xdb},
+	{0xc5, 0x7c},
+	{0x30, 0xf6},
+	{0x54, 0xb4},
+	{0x55, 0xb4},
+	{0x56, 0xb4},
+
+	{0xA0, 0x7f},
+	{0x74, 0x01},
+	{0x75, 0x40},
+
+	{0x12, 0x04},
+	{0x1C, 0x2D},
+	{0x0D, 0x59},
+	{0x17, 0x75},
+	{0x74, 0xD4},
+	{0x75, 0x47},
+
+	{0x74, 0xFF},
+	{0x75, 0x4B},
+
+	{0x74, 0x3D},
+	{0x75, 0x4C},
+
+	{0x74, 0x01},
+	{0x75, 0x50},
+
+	{0x74, 0x99},
+	{0x75, 0x57},
+
+	{0x74, 0xFF},
+	{0x75, 0x5B},
+
+	{0x74, 0x33},
+	{0x75, 0x5D},
+
+	{0x74, 0xE4},
+	{0x75, 0x61},
+
+	{0x30, 0xF7},
+};
+
+static const u32 wifi_core_init_data_32_91g[][2] = {
+	{0x500002a8, 0x00000001},
+	{0x50000080, 0x0003FEF7},
+	//{0x00100018, 0x000A3203},
+	//{0x0010001C, 0xFFFF0001},
+	{0x30010010, 0x00007DFF},
+
+	{0x50090060, 0x000001B4},
+	//item:rda5991_verE_wf_tx_pn9
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	{0x500900A8, 0x9c400180},
+	{0x5009008C, 0xFc07fdc9},
+	//PHY:phy rx timeout enable
+
+	//{0x00109b18, 0x50000634},
+	//{0x00109b1C, 0x00001100},
+	{0x00109b20, 0x50000584},
+	{0x00109b24, 0x00007bf8},
+
+#ifdef G_CHINA_VERSION		/*Low SNR */
+	//new agc table 20140825
+	{0X50090054, 0X00000001},
+	{0X50090200, 0X00000100},
+	{0X50090204, 0X00000100},
+	{0X50090208, 0X00000100},
+	{0X5009020c, 0X00000100},
+	{0X50090210, 0X00000100},
+	{0X50090214, 0X00000108},
+	{0X50090218, 0X00000110},
+	{0X5009021c, 0X00000180},
+	{0X50090220, 0X00000188},
+	{0X50090224, 0X00000190},
+	{0X50090228, 0X00000200},
+	{0X5009022c, 0X00000208},
+	{0X50090230, 0X00000210},
+	{0X50090234, 0X00000280},
+	{0X50090238, 0X00000288},
+	{0X5009023c, 0X00000290},
+	{0X50090240, 0X00000304},
+	{0X50090244, 0X0000030C},
+	{0X50090248, 0X00000314},
+	{0X5009024c, 0X00000384},
+	{0X50090250, 0X0000038C},
+	{0X50090254, 0X00000404},
+	{0X50090258, 0X0000040C},
+	{0X5009025c, 0X00000414},
+	{0X50090260, 0X00000484},
+	{0X50090264, 0X0000048C},
+	{0X50090268, 0X00000500},
+	{0X5009026c, 0X00000508},
+	{0X50090270, 0X00000510},
+	{0X50090274, 0X00000580},
+	{0X50090278, 0X00000588},
+	{0X5009027c, 0X00000590},
+	{0X50090280, 0X00000280},
+	{0X50090284, 0X00000288},
+	{0X50090288, 0X00000290},
+	{0X5009028c, 0X00000304},
+	{0X50090290, 0X0000030C},
+	{0X50090294, 0X00000314},
+	{0X50090298, 0X00000384},
+	{0X5009029c, 0X0000038C},
+	{0X500902a0, 0X00000404},
+	{0X500902a4, 0X0000040C},
+	{0X500902a8, 0X00000414},
+	{0X500902ac, 0X00000484},
+	{0X500902b0, 0X0000048C},
+	{0X500902b4, 0X00000500},
+	{0X500902b8, 0X00000508},
+	{0X500902bc, 0X00000510},
+	{0X500902c0, 0X00000580},
+	{0X500902c4, 0X00000588},
+	{0X500902c8, 0X00000590},
+	{0X500902cc, 0X00000600},
+	{0X500902d0, 0X00000608},
+	{0X500902d4, 0X00000610},
+	{0X500902d8, 0X00000680},
+	{0X500902dc, 0X00000688},
+	{0X500902e0, 0X00000690},
+	{0X500902e4, 0X00000700},
+	{0X500902e8, 0X00000700},
+	{0X500902ec, 0X00000700},
+	{0X500902f0, 0X00000700},
+	{0X500902f4, 0X00000700},
+	{0X500902f8, 0X00000700},
+	{0X500902fc, 0X00000700},
+	{0X50090300, 0X00000500},
+	{0X50090304, 0X00000508},
+	{0X50090308, 0X00000510},
+	{0X5009030c, 0X00000580},
+	{0X50090310, 0X00000588},
+	{0X50090314, 0X00000590},
+	{0X50090318, 0X00000600},
+	{0X5009031c, 0X00000608},
+	{0X50090320, 0X00000610},
+	{0X50090324, 0X00000680},
+	{0X50090328, 0X00000688},
+	{0X5009032c, 0X00000690},
+	{0X50090330, 0X00000700},
+	{0X50090334, 0X00000700},
+	{0X50090338, 0X00000700},
+	{0X5009033c, 0X00000700},
+	{0X50090340, 0X00000700},
+	{0X50090344, 0X00000700},
+	{0X50090348, 0X00000700},
+	{0X5009034c, 0X00000700},
+	{0X50090350, 0X00000700},
+	{0X50090354, 0X00000700},
+	{0X50090358, 0X00000700},
+	{0X5009035c, 0X00000700},
+	{0X50090360, 0X00000700},
+	{0X50090364, 0X00000700},
+	{0X50090368, 0X00000700},
+	{0X5009036c, 0X00000700},
+	{0X50090370, 0X00000700},
+	{0X50090374, 0X00000700},
+	{0X50090378, 0X00000700},
+	{0X5009037c, 0X00000700},
+	{0X50090054, 0X00000000},
+#else /*High SNR */
+	//agc table 20141224
+	{0x50090054, 0x00000001},
+	{0x50090200, 0x00000100},
+	{0x50090204, 0x00000100},
+	{0x50090208, 0x00000100},
+	{0x5009020c, 0x00000100},
+	{0x50090210, 0x00000108},
+	{0x50090214, 0x00000110},
+	{0x50090218, 0x00000180},
+	{0x5009021c, 0x00000188},
+	{0x50090220, 0x00000190},
+	{0x50090224, 0x00000200},
+	{0x50090228, 0x00000208},
+	{0x5009022c, 0x00000210},
+	{0x50090230, 0x00000280},
+	{0x50090234, 0x00000288},
+	{0x50090238, 0x00000304},
+	{0x5009023c, 0x0000030C},
+	{0x50090240, 0x00000314},
+	{0x50090244, 0x00000384},
+	{0x50090248, 0x0000038C},
+	{0x5009024c, 0x00000394},
+	{0x50090250, 0x00000404},
+	{0x50090254, 0x0000040C},
+	{0x50090258, 0x00000414},
+	{0x5009025c, 0x00000484},
+	{0x50090260, 0x0000048C},
+	{0x50090264, 0x00000500},
+	{0x50090268, 0x00000508},
+	{0x5009026c, 0x00000510},
+	{0x50090270, 0x00000580},
+	{0x50090274, 0x00000588},
+	{0x50090278, 0x00000590},
+	{0x5009027c, 0x00000600},
+	{0x50090280, 0x00000288},
+	{0x50090284, 0x00000290},
+	{0x50090288, 0x00000304},
+	{0x5009028c, 0x0000030C},
+	{0x50090290, 0x00000314},
+	{0x50090294, 0x00000384},
+	{0x50090298, 0x0000038C},
+	{0x5009029c, 0x00000394},
+	{0x500902a0, 0x00000404},
+	{0x500902a4, 0x0000040C},
+	{0x500902a8, 0x00000414},
+	{0x500902ac, 0x00000484},
+	{0x500902b0, 0x0000048C},
+	{0x500902b4, 0x00000500},
+	{0x500902b8, 0x00000508},
+	{0x500902bc, 0x00000510},
+	{0x500902c0, 0x00000580},
+	{0x500902c4, 0x00000588},
+	{0x500902c8, 0x00000590},
+	{0x500902cc, 0x00000600},
+	{0x500902d0, 0x00000608},
+	{0x500902d4, 0x00000610},
+	{0x500902d8, 0x00000680},
+	{0x500902dc, 0x00000688},
+	{0x500902e0, 0x00000690},
+	{0x500902e4, 0x00000700},
+	{0x500902e8, 0x00000708},
+	{0x500902ec, 0x00000710},
+	{0x500902f0, 0x00000780},
+	{0x500902f4, 0x00000780},
+	{0x500902f8, 0x00000780},
+	{0x500902fc, 0x00000780},
+	{0x50090300, 0x00000500},
+	{0x50090304, 0x00000508},
+	{0x50090308, 0x00000510},
+	{0x5009030c, 0x00000580},
+	{0x50090310, 0x00000588},
+	{0x50090314, 0x00000590},
+	{0x50090318, 0x00000600},
+	{0x5009031c, 0x00000608},
+	{0x50090320, 0x00000610},
+	{0x50090324, 0x00000680},
+	{0x50090328, 0x00000688},
+	{0x5009032c, 0x00000690},
+	{0x50090330, 0x00000700},
+	{0x50090334, 0x00000708},
+	{0x50090338, 0x00000710},
+	{0x5009033c, 0x00000780},
+	{0x50090340, 0x00000780},
+	{0x50090344, 0x00000780},
+	{0x50090348, 0x00000780},
+	{0x5009034c, 0x00000780},
+	{0x50090350, 0x00000780},
+	{0x50090354, 0x00000780},
+	{0x50090358, 0x00000780},
+	{0x5009035c, 0x00000780},
+	{0x50090360, 0x00000780},
+	{0x50090364, 0x00000780},
+	{0x50090368, 0x00000780},
+	{0x5009036c, 0x00000780},
+	{0x50090370, 0x00000780},
+	{0x50090374, 0x00000780},
+	{0x50090378, 0x00000780},
+	{0x5009037c, 0x00000780},
+	{0x50090054, 0x00000000},
+#endif /*G_CHINA_VERSION */
+};
+
+static const u32 wifi_core_AM_PM_data_32_91g[][2] = {
+	{0x50090054, 0x00000000},
+	{0x50090068, 0xEB3FF7FF},
+	{0x50090070, 0x1403DBFF},
+	{0x500900B0, 0x00400000},
+	//item0:theta0=7_B=0_r0=2_for_verE
+	{0x50090090, 0x00000000},
+	{0x50090094, 0x00A01401},
+	{0x50090098, 0x02907412},
+	{0x5009009C, 0x05D12438},
+	{0x500900A0, 0x0A522872},
+	{0x500900A4, 0xFFF380C1},
+	//item0:G0=-3.5_r0=2.5_for_verE
+	{0x50090078, 0x02B05400},
+	{0x5009007C, 0x06D15840},
+	{0x50090080, 0x0B927885},
+	{0x50090084, 0x11A3DCD7},
+	{0x50090088, 0x1975A540},
+	{0x5009008C, 0xFc07fdc9},
+	{0x500900A8, 0x9c400180},
+
+};
+#endif
+const u32 wifi_phy_timeout_cfg_91g_tkip[][2] = {
+	{0x00109b18, 0x50000634},
+	{0x00109b1C, 0x00002700},
+	{0x50000634, 0x00002700},
+	{0x50000584, 0x00007BF8},
+};
+
+#endif
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.c
new file mode 100644
index 000000000000..4378b07679b4
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.c
@@ -0,0 +1,1499 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef WLAND_USB_SUPPORT
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+#include <linux/usb.h>
+#include <linux/vmalloc.h>
+
+#include "wland_utils.h"
+#include "wland_bus.h"
+#include "wland_dbg.h"
+#include "wland_usb.h"
+
+static void wland_usb_rx_refill(struct wland_usbdev_info *devinfo,
+	struct wland_usbreq *req);
+
+static struct usb_device_id wland_usb_devid_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_RDAMICRO, USB_DEVICE_ID_RDA599X)},
+	/*
+	 * special entry for device with firmware loaded and running
+	 */
+	{USB_DEVICE(USB_VENDOR_ID_RDAMICRO, USB_DEVICE_ID_BCMFW)},
+	{}
+};
+
+static struct wland_usbdev_info *wland_usb_get_businfo(struct device *dev)
+{
+	struct wland_bus *bus_if = dev_get_drvdata(dev);
+
+	return bus_if->bus_priv.usb->devinfo;
+}
+
+static int wland_usb_ioctl_resp_wait(struct wland_usbdev_info *devinfo)
+{
+	return wait_event_timeout(devinfo->ioctl_resp_wait,
+		devinfo->ctl_completed, msecs_to_jiffies(IOCTL_RESP_TIMEOUT));
+}
+
+static void wland_usb_ioctl_resp_wake(struct wland_usbdev_info *devinfo)
+{
+	if (waitqueue_active(&devinfo->ioctl_resp_wait))
+		wake_up(&devinfo->ioctl_resp_wait);
+}
+
+static void wland_usb_ctl_complete(struct wland_usbdev_info *devinfo, int type,
+	int status)
+{
+	WLAND_DBG(USB, TRACE, "Enter, status=%d\n", status);
+
+	if (unlikely(devinfo == NULL))
+		return;
+
+	if (type == WLAND_USB_CBCTL_READ) {
+		if (status == 0)
+			devinfo->bus_pub.stats.rx_ctlpkts++;
+		else
+			devinfo->bus_pub.stats.rx_ctlerrs++;
+	} else if (type == WLAND_USB_CBCTL_WRITE) {
+		if (status == 0)
+			devinfo->bus_pub.stats.tx_ctlpkts++;
+		else
+			devinfo->bus_pub.stats.tx_ctlerrs++;
+	}
+
+	devinfo->ctl_urb_status = status;
+	devinfo->ctl_completed = true;
+
+	wland_usb_ioctl_resp_wake(devinfo);
+}
+
+static void wland_usb_ctlread_complete(struct urb *urb)
+{
+	struct wland_usbdev_info *devinfo =
+		(struct wland_usbdev_info *) urb->context;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	devinfo->ctl_urb_actual_length = urb->actual_length;
+
+	wland_usb_ctl_complete(devinfo, WLAND_USB_CBCTL_READ, urb->status);
+}
+
+static void wland_usb_ctlwrite_complete(struct urb *urb)
+{
+	struct wland_usbdev_info *devinfo =
+		(struct wland_usbdev_info *) urb->context;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	wland_usb_ctl_complete(devinfo, WLAND_USB_CBCTL_WRITE, urb->status);
+}
+
+static int wland_usb_send_ctl(struct wland_usbdev_info *devinfo, u8 * buf,
+	int len)
+{
+	int ret;
+	u16 size;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo == NULL || buf == NULL || len == 0
+		|| devinfo->ctl_urb == NULL)
+		return -EINVAL;
+
+	size = len;
+	devinfo->ctl_write.wLength = cpu_to_le16p(&size);
+	devinfo->ctl_urb->transfer_buffer_length = size;
+	devinfo->ctl_urb_status = 0;
+	devinfo->ctl_urb_actual_length = 0;
+
+	usb_fill_control_urb(devinfo->ctl_urb,
+		devinfo->usbdev,
+		devinfo->ctl_out_pipe,
+		(u8 *) & devinfo->ctl_write,
+		buf,
+		size, (usb_complete_t) wland_usb_ctlwrite_complete, devinfo);
+
+	ret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);
+	if (ret < 0)
+		WLAND_ERR("usb_submit_urb failed %d\n", ret);
+
+	return ret;
+}
+
+static int wland_usb_recv_ctl(struct wland_usbdev_info *devinfo, u8 * buf,
+	int len)
+{
+	int ret;
+	u16 size;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if ((devinfo == NULL) || (buf == NULL) || (len == 0)
+		|| (devinfo->ctl_urb == NULL))
+		return -EINVAL;
+
+	size = len;
+	devinfo->ctl_read.wLength = cpu_to_le16p(&size);
+	devinfo->ctl_urb->transfer_buffer_length = size;
+
+	devinfo->ctl_read.bRequestType =
+		USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+	devinfo->ctl_read.bRequest = 1;
+
+	usb_fill_control_urb(devinfo->ctl_urb,
+		devinfo->usbdev,
+		devinfo->ctl_in_pipe,
+		(u8 *) & devinfo->ctl_read,
+		buf,
+		size, (usb_complete_t) wland_usb_ctlread_complete, devinfo);
+
+	ret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);
+	if (ret < 0)
+		WLAND_ERR("usb_submit_urb failed %d\n", ret);
+
+	return ret;
+}
+
+static int wland_usb_bus_tx_ctlpkt(struct device *dev, u8 * buf, u32 len)
+{
+	int err = 0, timeout = 0;
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo->bus_pub.state != USB_STATE_UP)
+		return -EIO;
+
+	if (test_and_set_bit(0, &devinfo->ctl_op))
+		return -EIO;
+
+	devinfo->ctl_completed = false;
+
+	err = wland_usb_send_ctl(devinfo, buf, len);
+	if (err) {
+		WLAND_ERR("fail %d bytes: %d\n", err, len);
+		clear_bit(0, &devinfo->ctl_op);
+		return err;
+	}
+
+	timeout = wland_usb_ioctl_resp_wait(devinfo);
+	clear_bit(0, &devinfo->ctl_op);
+	if (!timeout) {
+		WLAND_ERR("Txctl wait timed out\n");
+		err = -EIO;
+	}
+	return err;
+}
+
+static int wland_usb_bus_rx_ctlpkt(struct device *dev, u8 * buf, u32 len)
+{
+	int err = 0, timeout = 0;
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo->bus_pub.state != USB_STATE_UP)
+		return -EIO;
+
+	if (test_and_set_bit(0, &devinfo->ctl_op))
+		return -EIO;
+
+	devinfo->ctl_completed = false;
+
+	err = wland_usb_recv_ctl(devinfo, buf, len);
+	if (err) {
+		WLAND_ERR("fail %d bytes: %d\n", err, len);
+		clear_bit(0, &devinfo->ctl_op);
+		return err;
+	}
+
+	timeout = wland_usb_ioctl_resp_wait(devinfo);
+	err = devinfo->ctl_urb_status;
+
+	clear_bit(0, &devinfo->ctl_op);
+
+	if (!timeout) {
+		WLAND_ERR("rxctl wait timed out\n");
+		err = -EIO;
+	}
+
+	if (!err)
+		return devinfo->ctl_urb_actual_length;
+	else
+		return err;
+}
+
+static struct wland_usbreq *wland_usb_deq(struct wland_usbdev_info *devinfo,
+	struct list_head *q, int *counter)
+{
+	unsigned long flags;
+	struct wland_usbreq *req;
+
+	spin_lock_irqsave(&devinfo->qlock, flags);
+	if (list_empty(q)) {
+		spin_unlock_irqrestore(&devinfo->qlock, flags);
+		return NULL;
+	}
+	req = list_entry(q->next, struct wland_usbreq, list);
+	list_del_init(q->next);
+	if (counter)
+		(*counter)--;
+	spin_unlock_irqrestore(&devinfo->qlock, flags);
+
+	return req;
+}
+
+static void wland_usb_enq(struct wland_usbdev_info *devinfo,
+	struct list_head *q, struct wland_usbreq *req, int *counter)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&devinfo->qlock, flags);
+	list_add_tail(&req->list, q);
+	if (counter)
+		(*counter)++;
+	spin_unlock_irqrestore(&devinfo->qlock, flags);
+}
+
+static struct wland_usbreq *wland_usbdev_qinit(struct list_head *q, int qsize)
+{
+	int i;
+	struct wland_usbreq *req, *reqs;
+
+	reqs = kcalloc(qsize, sizeof(struct wland_usbreq), GFP_ATOMIC);
+
+	if (reqs == NULL)
+		return NULL;
+
+	req = reqs;
+
+	for (i = 0; i < qsize; i++) {
+		req->urb = usb_alloc_urb(0, GFP_ATOMIC);
+		if (!req->urb)
+			goto fail;
+
+		INIT_LIST_HEAD(&req->list);
+		list_add_tail(&req->list, q);
+		req++;
+	}
+	return reqs;
+fail:
+	WLAND_ERR("fail!\n");
+	while (!list_empty(q)) {
+		req = list_entry(q->next, struct wland_usbreq, list);
+
+		if (req && req->urb)
+			usb_free_urb(req->urb);
+		list_del(q->next);
+	}
+	return NULL;
+}
+
+static void wland_usb_free_q(struct list_head *q, bool pending)
+{
+	struct wland_usbreq *req, *next;
+	int i = 0;
+
+	list_for_each_entry_safe(req, next, q, list) {
+		if (!req->urb) {
+			WLAND_ERR("bad req\n");
+			break;
+		}
+		i++;
+		if (pending) {
+			usb_kill_urb(req->urb);
+		} else {
+			usb_free_urb(req->urb);
+			list_del_init(&req->list);
+		}
+	}
+}
+
+static void wland_usb_del_fromq(struct wland_usbdev_info *devinfo,
+	struct wland_usbreq *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&devinfo->qlock, flags);
+	list_del_init(&req->list);
+	spin_unlock_irqrestore(&devinfo->qlock, flags);
+}
+
+static void wland_usb_tx_complete(struct urb *urb)
+{
+	unsigned long flags;
+	struct wland_usbreq *req = (struct wland_usbreq *) urb->context;
+	struct wland_usbdev_info *devinfo = req->devinfo;
+
+	WLAND_DBG(USB, TRACE, "Enter, urb->status=%d, skb=%p\n", urb->status,
+		req->skb);
+
+	wland_usb_del_fromq(devinfo, req);
+
+	wland_txcomplete(devinfo->dev, req->skb, urb->status == 0);
+
+	req->skb = NULL;
+
+	wland_usb_enq(devinfo, &devinfo->tx_freeq, req, &devinfo->tx_freecount);
+
+	spin_lock_irqsave(&devinfo->tx_flowblock_lock, flags);
+	if (devinfo->tx_freecount > devinfo->tx_high_watermark
+		&& devinfo->tx_flowblock) {
+		wland_txflowcontrol(devinfo->dev, false);
+
+		devinfo->tx_flowblock = false;
+	}
+	spin_unlock_irqrestore(&devinfo->tx_flowblock_lock, flags);
+}
+
+static void wland_usb_rx_complete(struct urb *urb)
+{
+	struct wland_usbreq *req = (struct wland_usbreq *) urb->context;
+	struct wland_usbdev_info *devinfo = req->devinfo;
+	struct sk_buff *skb;
+
+	WLAND_DBG(USB, TRACE, "Enter, urb->status=%d\n", urb->status);
+
+	wland_usb_del_fromq(devinfo, req);
+
+	skb = req->skb;
+	req->skb = NULL;
+
+	/*
+	 * zero lenght packets indicate usb "failure". Do not refill
+	 */
+	if (urb->status != 0 || !urb->actual_length) {
+		wland_pkt_buf_free_skb(skb);
+		wland_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);
+		return;
+	}
+
+	if (devinfo->bus_pub.state == USB_STATE_UP) {
+		skb_put(skb, urb->actual_length);
+		wland_rx_frames(devinfo->dev, skb);
+		wland_usb_rx_refill(devinfo, req);
+	} else {
+		wland_pkt_buf_free_skb(skb);
+		wland_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);
+	}
+}
+
+static void wland_usb_rx_refill(struct wland_usbdev_info *devinfo,
+	struct wland_usbreq *req)
+{
+	struct sk_buff *skb;
+	int ret;
+
+	if (!req || !devinfo)
+		return;
+
+	skb = dev_alloc_skb(devinfo->bus_pub.bus_mtu);
+	if (!skb) {
+		wland_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);
+		return;
+	}
+
+	req->skb = skb;
+
+	usb_fill_bulk_urb(req->urb,
+		devinfo->usbdev,
+		devinfo->rx_pipe,
+		skb->data, skb_tailroom(skb), wland_usb_rx_complete, req);
+
+	req->devinfo = devinfo;
+
+	wland_usb_enq(devinfo, &devinfo->rx_postq, req, NULL);
+
+	ret = usb_submit_urb(req->urb, GFP_ATOMIC);
+
+	if (ret) {
+		wland_usb_del_fromq(devinfo, req);
+		wland_pkt_buf_free_skb(req->skb);
+		req->skb = NULL;
+		wland_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);
+	}
+}
+
+static void wland_usb_rx_fill_all(struct wland_usbdev_info *devinfo)
+{
+	struct wland_usbreq *req;
+
+	if (devinfo->bus_pub.state != USB_STATE_UP) {
+		WLAND_ERR("bus is not up=%d\n", devinfo->bus_pub.state);
+		return;
+	}
+
+	while ((req = wland_usb_deq(devinfo, &devinfo->rx_freeq, NULL)) != NULL) {
+		wland_usb_rx_refill(devinfo, req);
+	}
+}
+
+static void wland_usb_state_change(struct wland_usbdev_info *devinfo, int state)
+{
+	struct wland_bus *bcmf_bus = devinfo->bus_pub.bus;
+	int old_state;
+
+	WLAND_DBG(USB, TRACE, "Enter, current state=%d, new state=%d\n",
+		devinfo->bus_pub.state, state);
+
+	if (devinfo->bus_pub.state == state)
+		return;
+
+	old_state = devinfo->bus_pub.state;
+	devinfo->bus_pub.state = state;
+
+	/*
+	 * update state of upper layer
+	 */
+	if (state == USB_STATE_DOWN) {
+		WLAND_DBG(USB, TRACE, "DBUS is down\n");
+		bcmf_bus->state = WLAND_BUS_DOWN;
+	} else if (state == USB_STATE_UP) {
+		WLAND_DBG(USB, TRACE, "DBUS is up\n");
+		bcmf_bus->state = WLAND_BUS_DATA;
+	} else {
+		WLAND_DBG(USB, TRACE, "DBUS current state=%d\n", state);
+	}
+}
+
+static void wland_usb_intr_complete(struct urb *urb)
+{
+	struct wland_usbdev_info *devinfo =
+		(struct wland_usbdev_info *) urb->context;
+	int err;
+
+	WLAND_DBG(USB, TRACE, "Enter, urb->status=%d\n", urb->status);
+
+	if (devinfo == NULL)
+		return;
+
+	if (unlikely(urb->status)) {
+		if (urb->status == -ENOENT ||
+			urb->status == -ESHUTDOWN || urb->status == -ENODEV) {
+			wland_usb_state_change(devinfo, USB_STATE_DOWN);
+		}
+	}
+
+	if (devinfo->bus_pub.state == USB_STATE_DOWN) {
+		WLAND_ERR("intr cb when DBUS down, ignoring\n");
+		return;
+	}
+
+	if (devinfo->bus_pub.state == USB_STATE_UP) {
+		err = usb_submit_urb(devinfo->intr_urb, GFP_ATOMIC);
+		if (err)
+			WLAND_ERR("usb_submit_urb, err=%d\n", err);
+	}
+}
+
+static int wland_usb_bus_tx(struct device *dev, struct sk_buff *skb)
+{
+	struct wland_usbreq *req;
+	int ret;
+	unsigned long flags;
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(dev);
+
+	WLAND_DBG(USB, TRACE, "Enter, skb=%p\n", skb);
+
+	if (devinfo->bus_pub.state != USB_STATE_UP) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	req = wland_usb_deq(devinfo, &devinfo->tx_freeq,
+		&devinfo->tx_freecount);
+	if (!req) {
+		WLAND_ERR("no req to send\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	req->skb = skb;
+	req->devinfo = devinfo;
+
+	usb_fill_bulk_urb(req->urb, devinfo->usbdev, devinfo->tx_pipe,
+		skb->data, skb->len, wland_usb_tx_complete, req);
+
+	req->urb->transfer_flags |= URB_ZERO_PACKET;
+
+	wland_usb_enq(devinfo, &devinfo->tx_postq, req, NULL);
+
+	ret = usb_submit_urb(req->urb, GFP_ATOMIC);
+	if (ret) {
+		WLAND_ERR("wland_usb_bus_tx usb_submit_urb FAILED\n");
+		wland_usb_del_fromq(devinfo, req);
+		req->skb = NULL;
+		wland_usb_enq(devinfo, &devinfo->tx_freeq, req,
+			&devinfo->tx_freecount);
+		goto fail;
+	}
+
+	spin_lock_irqsave(&devinfo->tx_flowblock_lock, flags);
+	if (devinfo->tx_freecount < devinfo->tx_low_watermark
+		&& !devinfo->tx_flowblock) {
+		wland_txflowcontrol(dev, true);
+		devinfo->tx_flowblock = true;
+	}
+	spin_unlock_irqrestore(&devinfo->tx_flowblock_lock, flags);
+	return 0;
+
+fail:
+	return ret;
+}
+
+static int wland_usb_bus_up(struct device *dev)
+{
+	u16 ifnum;
+	int ret;
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo->bus_pub.state == USB_STATE_UP)
+		return 0;
+
+	/*
+	 * Success, indicate devinfo is fully up
+	 */
+	wland_usb_state_change(devinfo, USB_STATE_UP);
+
+	if (devinfo->intr_urb) {
+		usb_fill_int_urb(devinfo->intr_urb,
+			devinfo->usbdev,
+			devinfo->intr_pipe,
+			&devinfo->intr,
+			devinfo->intr_size,
+			(usb_complete_t) wland_usb_intr_complete,
+			devinfo, devinfo->interval);
+
+		ret = usb_submit_urb(devinfo->intr_urb, GFP_ATOMIC);
+		if (ret) {
+			WLAND_ERR("USB_SUBMIT_URB failed with status %d\n",
+				ret);
+			return -EINVAL;
+		}
+	}
+
+	if (devinfo->ctl_urb) {
+		devinfo->ctl_in_pipe = usb_rcvctrlpipe(devinfo->usbdev, 0);
+		devinfo->ctl_out_pipe = usb_sndctrlpipe(devinfo->usbdev, 0);
+
+		ifnum = IFDESC(devinfo->usbdev, CONTROL_IF).bInterfaceNumber;
+
+		/*
+		 * CTL Write
+		 */
+		devinfo->ctl_write.bRequestType =
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+		devinfo->ctl_write.bRequest = 0;
+		devinfo->ctl_write.wValue = cpu_to_le16(0);
+		devinfo->ctl_write.wIndex = cpu_to_le16p(&ifnum);
+
+		/*
+		 * CTL Read
+		 */
+		devinfo->ctl_read.bRequestType =
+			USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
+		devinfo->ctl_read.bRequest = 1;
+		devinfo->ctl_read.wValue = cpu_to_le16(0);
+		devinfo->ctl_read.wIndex = cpu_to_le16p(&ifnum);
+	}
+	wland_usb_rx_fill_all(devinfo);
+	return 0;
+}
+
+static void wland_usb_bus_down(struct device *dev)
+{
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo == NULL)
+		return;
+
+	if (devinfo->bus_pub.state == USB_STATE_DOWN)
+		return;
+
+	wland_usb_state_change(devinfo, USB_STATE_DOWN);
+
+	if (devinfo->intr_urb)
+		usb_kill_urb(devinfo->intr_urb);
+
+	if (devinfo->ctl_urb)
+		usb_kill_urb(devinfo->ctl_urb);
+
+	if (devinfo->bulk_urb)
+		usb_kill_urb(devinfo->bulk_urb);
+
+	wland_usb_free_q(&devinfo->tx_postq, true);
+	wland_usb_free_q(&devinfo->rx_postq, true);
+}
+
+static void wland_usb_sync_complete(struct urb *urb)
+{
+	struct wland_usbdev_info *devinfo =
+		(struct wland_usbdev_info *) urb->context;
+
+	devinfo->ctl_completed = true;
+
+	wland_usb_ioctl_resp_wake(devinfo);
+}
+
+static bool wland_usb_dl_cmd(struct wland_usbdev_info *devinfo, u8 cmd,
+	void *buffer, int buflen)
+{
+	int ret = 0;
+	char *tmpbuf;
+	u16 size;
+
+	if ((!devinfo) || (devinfo->ctl_urb == NULL))
+		return false;
+
+	tmpbuf = kmalloc(buflen, GFP_ATOMIC);
+
+	if (!tmpbuf)
+		return false;
+
+	size = buflen;
+	devinfo->ctl_urb->transfer_buffer_length = size;
+
+	devinfo->ctl_read.wLength = cpu_to_le16p(&size);
+	devinfo->ctl_read.bRequestType =
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+	devinfo->ctl_read.bRequest = cmd;
+
+	usb_fill_control_urb(devinfo->ctl_urb,
+		devinfo->usbdev,
+		usb_rcvctrlpipe(devinfo->usbdev, 0),
+		(u8 *) & devinfo->ctl_read,
+		tmpbuf,
+		size, (usb_complete_t) wland_usb_sync_complete, devinfo);
+
+	devinfo->ctl_completed = false;
+
+	ret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);
+	if (ret < 0) {
+		WLAND_ERR("usb_submit_urb failed %d\n", ret);
+		kfree(tmpbuf);
+		return false;
+	}
+
+	ret = wland_usb_ioctl_resp_wait(devinfo);
+	memcpy(buffer, tmpbuf, buflen);
+	kfree(tmpbuf);
+	return ret;
+}
+
+static bool wland_usb_dlneeded(struct wland_usbdev_info *devinfo)
+{
+	struct bootrom_id_le id;
+	u32 chipid;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo == NULL)
+		return false;
+
+	/*
+	 * Check if firmware downloaded already by querying runtime ID
+	 */
+	id.chip = cpu_to_le32(0xDEAD);
+
+	wland_usb_dl_cmd(devinfo, DL_GETVER, &id, sizeof(id));
+
+	chipid = le32_to_cpu(id.chip);
+
+	WLAND_DBG(USB, TRACE, "chip %d.\n", chipid);
+
+	if (chipid == WLAND_POSTBOOT_ID) {
+		WLAND_DBG(USB, TRACE, "firmware already downloaded\n");
+		wland_usb_dl_cmd(devinfo, DL_RESETCFG, &id, sizeof(id));
+		return false;
+	} else {
+		devinfo->bus_pub.devid = chipid;
+	}
+	return true;
+}
+
+static int wland_usb_resetcfg(struct wland_usbdev_info *devinfo)
+{
+	struct bootrom_id_le id;
+	u32 loop_cnt = 0;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	do {
+		mdelay(USB_RESET_GETVER_SPINWAIT);
+		loop_cnt++;
+		id.chip = cpu_to_le32(0xDEAD);	/* Get the ID */
+		wland_usb_dl_cmd(devinfo, DL_GETVER, &id, sizeof(id));
+		if (id.chip == cpu_to_le32(WLAND_POSTBOOT_ID))
+			break;
+	} while (loop_cnt < USB_RESET_GETVER_LOOP_CNT);
+
+	if (id.chip == cpu_to_le32(WLAND_POSTBOOT_ID)) {
+		WLAND_DBG(USB, TRACE, "postboot chip 0x%x.\n",
+			le32_to_cpu(id.chip));
+
+		wland_usb_dl_cmd(devinfo, DL_RESETCFG, &id, sizeof(id));
+		return 0;
+	} else {
+		WLAND_ERR("Cannot talk to chip. Firmware is not UP, %d ms\n",
+			USB_RESET_GETVER_SPINWAIT * loop_cnt);
+		return -EINVAL;
+	}
+}
+
+static int wland_usb_dl_send_bulk(struct wland_usbdev_info *devinfo,
+	void *buffer, int len)
+{
+	int ret;
+
+	if ((devinfo == NULL) || (devinfo->bulk_urb == NULL))
+		return -EINVAL;
+
+	/*
+	 * Prepare the URB
+	 */
+	usb_fill_bulk_urb(devinfo->bulk_urb,
+		devinfo->usbdev,
+		devinfo->tx_pipe,
+		buffer, len, (usb_complete_t) wland_usb_sync_complete, devinfo);
+
+	devinfo->bulk_urb->transfer_flags |= URB_ZERO_PACKET;
+
+	devinfo->ctl_completed = false;
+
+	ret = usb_submit_urb(devinfo->bulk_urb, GFP_ATOMIC);
+	if (ret) {
+		WLAND_ERR("usb_submit_urb failed %d\n", ret);
+		return ret;
+	}
+	ret = wland_usb_ioctl_resp_wait(devinfo);
+	return (ret == 0);
+}
+
+static int wland_usb_fw_download(struct wland_usbdev_info *devinfo)
+{
+	int devid;
+	struct rdl_state_le state;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (devinfo == NULL) {
+		WLAND_ERR("No Device Info!\n");
+		return -ENODEV;
+	}
+
+	devid = devinfo->bus_pub.devid;
+
+	if (devid == USB_DEVICE_ID_RDA599X) {
+		WLAND_ERR("Unmatch Device Id!\n");
+		return -EINVAL;
+	}
+
+	devinfo->bus_pub.state = USB_STATE_DL_DONE;
+
+	/*
+	 * Check we are runnable
+	 */
+	wland_usb_dl_cmd(devinfo, DL_GETSTATE, &state,
+		sizeof(struct rdl_state_le));
+
+	/*
+	 * Start the image
+	 */
+	if (state.state == cpu_to_le32(DL_RUNNABLE)) {
+		if (!wland_usb_dl_cmd(devinfo, DL_GO, &state,
+				sizeof(struct rdl_state_le)))
+			return -ENODEV;
+		if (wland_usb_resetcfg(devinfo))
+			return -ENODEV;
+	} else {
+		WLAND_ERR("Dongle not runnable\n");
+		return -EINVAL;
+	}
+
+	WLAND_DBG(USB, TRACE, "Exit.\n");
+
+	return 0;
+}
+
+static void wland_usb_detach(struct wland_usbdev_info *devinfo)
+{
+	WLAND_DBG(USB, TRACE, "Enter, devinfo %p\n", devinfo);
+
+	/*
+	 * free the URBS
+	 */
+	wland_usb_free_q(&devinfo->rx_freeq, false);
+	wland_usb_free_q(&devinfo->tx_freeq, false);
+
+	usb_free_urb(devinfo->intr_urb);
+	usb_free_urb(devinfo->ctl_urb);
+	usb_free_urb(devinfo->bulk_urb);
+
+	kfree(devinfo->tx_reqs);
+	kfree(devinfo->rx_reqs);
+}
+
+static struct wland_usb_dev *wland_usb_attach(struct wland_usbdev_info *devinfo,
+	int nrxq, int ntxq)
+{
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	devinfo->bus_pub.nrxq = nrxq;
+	devinfo->rx_low_watermark = nrxq / 2;
+	devinfo->bus_pub.devinfo = devinfo;
+	devinfo->bus_pub.ntxq = ntxq;
+	devinfo->bus_pub.state = USB_STATE_DOWN;
+
+	/*
+	 * flow control when too many tx urbs posted
+	 */
+	devinfo->tx_low_watermark = ntxq / 4;
+	devinfo->tx_high_watermark = devinfo->tx_low_watermark * 3;
+	devinfo->bus_pub.bus_mtu = USB_MAX_PKT_SIZE;
+
+	/*
+	 * Initialize other structure content
+	 */
+	init_waitqueue_head(&devinfo->ioctl_resp_wait);
+
+	/*
+	 * Initialize the spinlocks
+	 */
+	spin_lock_init(&devinfo->qlock);
+	spin_lock_init(&devinfo->tx_flowblock_lock);
+
+	INIT_LIST_HEAD(&devinfo->rx_freeq);
+	INIT_LIST_HEAD(&devinfo->rx_postq);
+
+	INIT_LIST_HEAD(&devinfo->tx_freeq);
+	INIT_LIST_HEAD(&devinfo->tx_postq);
+
+	devinfo->tx_flowblock = false;
+
+	devinfo->rx_reqs = wland_usbdev_qinit(&devinfo->rx_freeq, nrxq);
+	if (!devinfo->rx_reqs)
+		goto error;
+
+	devinfo->tx_reqs = wland_usbdev_qinit(&devinfo->tx_freeq, ntxq);
+	if (!devinfo->tx_reqs)
+		goto error;
+
+	devinfo->tx_freecount = ntxq;
+
+	devinfo->intr_urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!devinfo->intr_urb) {
+		WLAND_ERR("usb_alloc_urb (intr) failed\n");
+		goto error;
+	}
+
+	devinfo->ctl_urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!devinfo->ctl_urb) {
+		WLAND_ERR("usb_alloc_urb (ctl) failed\n");
+		goto error;
+	}
+
+	devinfo->bulk_urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!devinfo->bulk_urb) {
+		WLAND_ERR("usb_alloc_urb (bulk) failed\n");
+		goto error;
+	}
+
+	if (!wland_usb_dlneeded(devinfo))
+		return &devinfo->bus_pub;
+
+	WLAND_DBG(USB, TRACE, "Start fw downloading\n");
+
+	if (wland_usb_fw_download(devinfo))
+		goto error;
+
+	WLAND_DBG(USB, TRACE, "Exit.\n");
+
+	return &devinfo->bus_pub;
+
+error:
+	WLAND_ERR("failed!\n");
+	wland_usb_detach(devinfo);
+	return NULL;
+}
+
+static struct wland_bus_ops wland_usb_bus_ops = {
+	.txdata = wland_usb_bus_tx,
+	.init = wland_usb_bus_up,
+	.stop = wland_usb_bus_down,
+	.txctl = wland_usb_bus_tx_ctlpkt,
+	.rxctl = wland_usb_bus_rx_ctlpkt,
+};
+
+static int wland_usb_probe(struct usb_interface *intf,
+	const struct usb_device_id *id)
+{
+#if 1
+	int ep, ret = 0, num_of_eps;
+	u8 endpoint_num;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct wland_usbdev_info *devinfo;
+	struct wland_bus *bus = NULL;
+	struct wland_usb_dev *bus_pub = NULL;
+	struct device *dev = NULL;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	devinfo = kzalloc(sizeof(*devinfo), GFP_ATOMIC);
+	if (devinfo == NULL)
+		return -ENOMEM;
+
+	devinfo->usbdev = usb;
+	devinfo->dev = &usb->dev;
+
+	usb_set_intfdata(intf, devinfo);
+
+	/*
+	 * Check that the device supports only one configuration
+	 */
+	if (usb->descriptor.bNumConfigurations != 1) {
+		ret = -1;
+		goto fail;
+	}
+
+	if (usb->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) {
+		ret = -1;
+		goto fail;
+	}
+
+	/*
+	 * Only the BDC interface configuration is supported:
+	 *      Device class: USB_CLASS_VENDOR_SPEC
+	 *      if0 class:    USB_CLASS_VENDOR_SPEC
+	 *      if0/ep0: control
+	 *      if0/ep1: bulk in
+	 *      if0/ep2: bulk out (ok if swapped with bulk in)
+	 */
+	if (CONFIGDESC(usb)->bNumInterfaces != 1) {
+		ret = -1;
+		goto fail;
+	}
+
+	/*
+	 * Check interface
+	 */
+	if (IFDESC(usb, CONTROL_IF).bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
+		IFDESC(usb, CONTROL_IF).bInterfaceSubClass != 2 ||
+		IFDESC(usb, CONTROL_IF).bInterfaceProtocol != 0xff) {
+		WLAND_ERR
+			("invalid control interface: class %d, subclass %d, proto %d\n",
+			IFDESC(usb, CONTROL_IF).bInterfaceClass, IFDESC(usb,
+				CONTROL_IF).bInterfaceSubClass, IFDESC(usb,
+				CONTROL_IF).bInterfaceProtocol);
+		ret = -1;
+		goto fail;
+	}
+
+	/*
+	 * Check control endpoint
+	 */
+	endpoint = &IFEPDESC(usb, CONTROL_IF, 0);
+
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
+		USB_ENDPOINT_XFER_INT) {
+		WLAND_ERR("invalid control endpoint %d\n",
+			endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);
+		ret = -1;
+		goto fail;
+	}
+
+	endpoint_num = endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	devinfo->intr_pipe = usb_rcvintpipe(usb, endpoint_num);
+	devinfo->rx_pipe = 0;
+	devinfo->rx_pipe2 = 0;
+	devinfo->tx_pipe = 0;
+	num_of_eps = IFDESC(usb, BULK_IF).bNumEndpoints - 1;
+
+	/*
+	 * Check data endpoints and get pipes
+	 */
+	for (ep = 1; ep <= num_of_eps; ep++) {
+		endpoint = &IFEPDESC(usb, BULK_IF, ep);
+
+		if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
+			USB_ENDPOINT_XFER_BULK) {
+			WLAND_ERR("invalid data endpoint %d\n", ep);
+			ret = -1;
+			goto fail;
+		}
+
+		endpoint_num =
+			endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+
+		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
+			USB_DIR_IN) {
+			if (!devinfo->rx_pipe) {
+				devinfo->rx_pipe =
+					usb_rcvbulkpipe(usb, endpoint_num);
+			} else {
+				devinfo->rx_pipe2 =
+					usb_rcvbulkpipe(usb, endpoint_num);
+			}
+		} else {
+			devinfo->tx_pipe = usb_sndbulkpipe(usb, endpoint_num);
+		}
+	}
+
+	/*
+	 * Allocate interrupt URB and data buffer
+	 */
+	/*
+	 * RNDIS says 8-byte intr, our old drivers used 4-byte
+	 */
+	if (IFEPDESC(usb, CONTROL_IF, 0).wMaxPacketSize == cpu_to_le16(16))
+		devinfo->intr_size = 8;
+	else
+		devinfo->intr_size = 4;
+
+	devinfo->interval = IFEPDESC(usb, CONTROL_IF, 0).bInterval;
+
+	if (usb->speed == USB_SPEED_HIGH)
+		WLAND_DBG(USB, TRACE,
+			"Rdamicro high speed USB wireless device detected\n");
+	else
+		WLAND_DBG(USB, TRACE,
+			"Rdamicro full speed USB wireless device detected\n");
+
+	dev = devinfo->dev;
+
+	bus_pub = wland_usb_attach(devinfo, WLAND_USB_NRXQ, WLAND_USB_NTXQ);
+	if (!bus_pub)
+		goto fail;
+
+	bus = kzalloc(sizeof(struct wland_bus), GFP_ATOMIC);
+	if (!bus)
+		goto fail2;
+
+	bus->dev = dev;
+	bus_pub->bus = bus;
+	bus->bus_priv.usb = bus_pub;
+
+	dev_set_drvdata(dev, bus);
+
+	bus->ops = &wland_usb_bus_ops;
+	bus->chip = bus_pub->devid;
+
+	/*
+	 * Attach to the common driver interface
+	 */
+	ret = wland_bus_attach(0, dev);
+	if (ret < 0) {
+		WLAND_ERR("bus_attach failed\n");
+		goto fail1;
+	}
+
+	ret = wland_bus_start(dev);
+	if (ret < 0) {
+		WLAND_ERR("chip is not responding\n");
+		goto fail1;
+	}
+	/*
+	 * Success
+	 */
+	return 0;
+fail1:
+	kfree(bus);
+fail2:
+	wland_usb_detach(devinfo);
+fail:
+	WLAND_ERR("failed with errno %d\n", ret);
+	kfree(devinfo);
+	usb_set_intfdata(intf, NULL);
+	return ret;
+#else
+	struct usb_host_interface *iface_desc;
+
+	wlan_private *priv = NULL;
+	wlan_event *event = NULL;
+	int i;
+	wlan_usb_card *cardP = NULL;
+	int ret = 0;
+	u8 mac_addr[ETH_ALEN];
+
+	WLAND_DBG(KERN_INFO, "USB Probe\n");
+
+	cardP = kzalloc(sizeof(wlan_usb_card), GFP_KERNEL);
+	if (!cardP) {
+		WLAND_ERR("Allocating USB card failed.\n");
+		return -ENOMEM;
+	}
+
+	usbdev = interface_to_usbdev(intf);
+
+	cardP->usbdev = usbdev;
+	cardP->dev = &usbdev->dev;
+
+	usb_set_intfdata(intf, cardP);
+
+	/*
+	 * Check that the device supports only one configuration
+	 */
+	if (usbdev->descriptor.bNumConfigurations != 1) {
+		WLAND_ERR("USB No.Configuration(%d) != 1\n",
+			usbdev->descriptor.bNumConfigurations);
+		ret = -1;
+		goto fail;
+	}
+
+	iface_desc = intf->cur_altsetting;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		struct usb_endpoint_descriptor *endpoint;
+		u8 endpoint_num;
+
+		endpoint = &iface_desc->endpoint[i].desc;
+		endpoint_num =
+			endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+
+		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
+			USB_DIR_IN) {
+			cardP->rx_pipe = usb_rcvbulkpipe(usbdev, endpoint_num);
+		} else {
+			cardP->tx_pipe = usb_sndbulkpipe(usbdev, endpoint_num);;
+		}
+	}
+
+	if (usbdev->speed == USB_SPEED_HIGH)
+		WLAND_DBG(KERN_INFO, "RDA high speed USB wireless device\n");
+	else
+		WLAND_DBG(KERN_INFO, "RDA full speed USB wireless device\n");
+
+	cardP->rx_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!cardP->rx_urb) {
+		WLAND_ERR("Alloc Rx URB failed\n");
+		goto dealloc;
+	}
+
+	cardP->tx_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!cardP->tx_urb) {
+		WLAND_ERR("Alloc Tx URB failed\n");
+		goto dealloc;
+	}
+
+	priv = cardP->priv;
+
+	/*
+	 * Attach and link in the cfg80211
+	 */
+	if (unlikely(wl_cfg80211_attach(priv))) {
+		WLAND_ERR("Attach CFG80211 failed\n");
+		return 0;
+	} else {
+		WLAND_DBG(KERN_INFO, "Attach CFG80211 success\n");
+	}
+
+	mac_addr[0] = 0x00;
+	mac_addr[1] = 0xc0;
+	mac_addr[2] = 0x52;
+
+	mac_addr[3] = 0x5E;
+	mac_addr[4] = 0x59;
+	mac_addr[5] = 0x95;
+
+	memcpy(priv->netDev->dev_addr, mac_addr, ETH_ALEN);
+
+	return 0;
+#endif
+}
+
+static void wland_usb_disconnect(struct usb_interface *intf)
+{
+	struct wland_usbdev_info *devinfo =
+		(struct wland_usbdev_info *) usb_get_intfdata(intf);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (!devinfo)
+		return;
+
+	wland_bus_detach(devinfo->dev);
+	kfree(devinfo->bus_pub.bus);
+	wland_usb_detach(devinfo);
+	kfree(devinfo);
+
+	WLAND_DBG(USB, TRACE, "Exit\n");
+}
+
+/* only need to signal the bus being down and update the state. */
+static int wland_usb_suspend(struct usb_interface *intf, pm_message_t state)
+{
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(&usb->dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	devinfo->bus_pub.state = USB_STATE_SLEEP;
+
+	wland_bus_detach(&usb->dev);
+
+	return 0;
+}
+
+/* (re-) start the bus. */
+static int wland_usb_resume(struct usb_interface *intf)
+{
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(&usb->dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (!wland_bus_attach(0, devinfo->dev)) {
+		return wland_bus_start(&usb->dev);
+	}
+
+	return 0;
+}
+
+static int wland_usb_reset_resume(struct usb_interface *intf)
+{
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct wland_usbdev_info *devinfo = wland_usb_get_businfo(&usb->dev);
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (!wland_usb_fw_download(devinfo))
+		return wland_usb_resume(intf);
+
+	return -EIO;
+}
+
+MODULE_DEVICE_TABLE(usb, wland_usb_devid_table);
+
+static struct usb_driver wland_usbdrvr = {
+	.name = KBUILD_MODNAME,
+	.probe = wland_usb_probe,
+	.disconnect = wland_usb_disconnect,
+	.id_table = wland_usb_devid_table,
+	.suspend = wland_usb_suspend,
+	.resume = wland_usb_resume,
+	.reset_resume = wland_usb_reset_resume,
+	.supports_autosuspend = 1,
+	.disable_hub_initiated_lpm = 1,
+};
+
+static int wland_usb_reset_device(struct device *dev, void *notused)
+{
+	/*
+	 * device past is the usb interface so we need to use parent here.
+	 */
+	struct wland_bus *bus_if = dev_get_drvdata(dev->parent);
+	struct wland_private *drvr = bus_if->drvr;
+	u8 val = 1;
+
+	if (drvr == NULL)
+		return;
+
+	if (drvr->iflist[0])
+		wland_fil_iovar_data_set(drvr->iflist[0], "TERMINATED", &val,
+			sizeof(u8));
+
+	return 0;
+}
+
+void wland_usb_exit(void)
+{
+	struct device_driver *drv = &wland_usbdrvr.drvwrap.driver;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	driver_for_each_device(drv, NULL, NULL, wland_usb_reset_device);
+
+	usb_deregister(&wland_usbdrvr);
+
+	WLAND_DBG(USB, TRACE, "Exit\n");
+}
+
+void wland_usb_register(void)
+{
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (usb_register(&wland_usbdrvr) < 0) {
+		wland_registration_sem_up(false);
+	}
+
+	WLAND_DBG(USB, TRACE, "Exit\n")
+}
+
+#ifdef  0			/* OLD WEXT INTERFACE */
+
+//a callback for rx_urb
+static void wlan_usb_receive(struct urb *urb)
+{
+	wlan_usb_card *cardp = (wlan_usb_card *) urb->context;
+	struct sk_buff *skb = cardp->rx_skb;
+	wlan_private *priv = (wlan_private *) cardp->priv;
+	int recvlength = urb->actual_length;
+	wlan_rx_packet_node *rx_node = NULL;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	if (recvlength) {
+		if (urb->status || recvlength < PACKET_HEADER_LEN) {
+			WLAND_ERR("RX URB failed1: %d\n", urb->status);
+			kfree_skb(skb);
+			skb = NULL;
+			goto next_recv;
+		}
+
+		skb_put(skb, recvlength);
+		rx_node = kzalloc(sizeof(wlan_rx_packet_node), GFP_ATOMIC);
+		if (!rx_node) {
+			kfree_skb(skb);
+			skb = NULL;
+			goto next_recv;
+		}
+
+		WLAND_DBG(USB, TRACE, "Recv length = 0x%d\n", recvlength);
+		rx_node->Skb = skb;
+
+		spin_lock(&priv->RxLock);
+		list_add_tail(&rx_node->List, &priv->RxQueue);
+		spin_unlock(&priv->RxLock);
+
+		complete(&priv->RxThread.comp);
+	} else if (urb->status) {
+		kfree_skb(skb);
+		skb = NULL;
+		WLAND_ERR("RX URB failed2:%d\n", urb->status);
+	}
+
+next_recv:
+	if (!priv->CardRemoved)
+		wlan_usb_submit_rx_urb(cardp);
+	else if (skb)
+		kfree_skb(skb);
+
+	WLAND_DBG(USB, TRACE, "Done\n");
+}
+
+int wlan_usb_submit_rx_urb(wlan_usb_card * cardp)
+{
+	struct sk_buff *skb;
+	int ret = -1;
+
+	if (!(skb = dev_alloc_skb(WLAND_MAX_BUFSZ + NET_IP_ALIGN +
+				PACKET_HEADER_LEN))) {
+		WLAND_ERR("No free skb \n");
+		goto rx_ret;
+	}
+
+	skb_reserve(skb, NET_IP_ALIGN);
+	cardp->rx_skb = skb;
+
+	/*
+	 * Fill the receive configuration URB and initialise the Rx call back
+	 */
+	usb_fill_bulk_urb(cardp->rx_urb,
+		cardp->usbdev,
+		cardp->rx_pipe,
+		skb->data, WLAND_MAX_BUFSZ, wlan_usb_receive, cardp);
+
+	cardp->rx_urb->transfer_flags |= URB_ZERO_PACKET;
+
+	if ((ret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC))) {
+		WLAND_ERR("Submit Rx URB failed: %d\n", ret);
+		kfree_skb(skb);
+		cardp->rx_skb = NULL;
+		ret = -1;
+	} else {
+		WLAND_DBG(USB, TRACE, "Submit Rx URB success\n");
+		ret = 0;
+	}
+
+rx_ret:
+	return ret;
+}
+
+static void wlan_usb_write_bulk_callback(struct urb *urb)
+{
+	wlan_usb_card *cardp = (wlan_usb_card *) urb->context;
+	wlan_private *priv = (wlan_private *) cardp->priv;
+
+	/*
+	 * handle the transmission complete validations
+	 */
+	if (urb->status == 0) {
+		WLAND_DBG(USB, TRACE, "URB status is successful\n",
+			urb->actual_length);
+	} else {
+		/*
+		 * print the failure status number for debug
+		 */
+		WLAND_ERR("URB in failure status: %d\n", urb->status);
+	}
+	if (priv) {
+		priv->UsbTxStatus = WLAN_USB_TX_SEND_COMPLETE;
+		wake_up_interruptible(&priv->UsbSendDone);
+	}
+}
+
+int usb_send_packet(wlan_usb_card * cardp, u8 * payload, u16 nb)
+{
+	int ret;
+	wlan_private *priv = (wlan_private *) cardp->priv;
+
+	WLAND_DBG(USB, TRACE, "Enter\n");
+
+	/*
+	 * check if device is removed
+	 */
+	if (priv->CardRemoved) {
+		WLAND_ERR("Device removed\n");
+		ret = -ENODEV;
+		goto tx_ret;
+	}
+
+	usb_fill_bulk_urb(cardp->tx_urb,
+		cardp->usbdev,
+		cardp->tx_pipe,
+		payload, nb, wlan_usb_write_bulk_callback, cardp);
+
+	cardp->tx_urb->transfer_flags |= URB_ZERO_PACKET;
+
+	if ((ret = usb_submit_urb(cardp->tx_urb, GFP_ATOMIC))) {
+		WLAND_ERR("usb_submit_urb failed: %d\n", ret);
+		priv->UsbTxStatus = WLAN_USB_TX_IDLE;
+	} else {
+		WLAND_DBG(USB, TRACE, "usb_submit_urb success\n");
+		ret = 0;
+		priv->UsbTxStatus = WLAN_USB_TX_SENDING;
+		wait_event_interruptible(priv->UsbSendDone,
+			(priv->UsbTxStatus == WLAN_USB_TX_SEND_COMPLETE));
+	}
+
+tx_ret:
+	WLAND_DBG(USB, TRACE, "Done\n");
+	return ret;
+}
+
+#endif /* OLD WEXT INTERFACE */
+
+#endif /* WLAND_USB_SUPPORT */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.h
new file mode 100644
index 000000000000..5fbe86fc4c4d
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_usb.h
@@ -0,0 +1,186 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_USB_H_
+#define _WLAND_USB_H_
+
+#ifdef WLAND_USB_SUPPORT
+
+#define PACKET_HEADER_LEN           (2)
+
+/* define the usd op mode read or write */
+#define WLAND_USB_CBCTL_WRITE	    0
+#define WLAND_USB_CBCTL_READ	    1
+
+#define USB_RESET_GETVER_SPINWAIT	100	/* in unit of ms */
+#define USB_RESET_GETVER_LOOP_CNT	10
+
+#define WLAND_POSTBOOT_ID		    0xA123	/* ID to detect if dongle has boot up */
+#define WLAND_USB_NRXQ	            50
+#define WLAND_USB_NTXQ	            50
+
+#define CONFIGDESC(usb)             (&((usb)->actconfig)->desc)
+#define IFPTR(usb, idx)             ((usb)->actconfig->interface[(idx)])
+#define IFALTS(usb, idx)            (IFPTR((usb), (idx))->altsetting[0])
+#define IFDESC(usb, idx)             IFALTS((usb), (idx)).desc
+#define IFEPDESC(usb, idx, ep)      (IFALTS((usb), (idx)).endpoint[(ep)]).desc
+
+#define CONTROL_IF                  0
+#define BULK_IF                     0
+
+#define USB_MAX_PKT_SIZE	        1600
+
+/* Control messages: bRequest values */
+#define DL_GETSTATE	                0	/* returns the rdl_state_t struct */
+#define DL_CHECK_CRC	            1	/* currently unused */
+#define DL_GO		                2	/* execute downloaded image */
+#define DL_START	                3	/* initialize dl state */
+#define DL_REBOOT	                4	/* reboot the device in 2 seconds */
+#define DL_GETVER	                5	/* returns the bootrom_id_t struct */
+#define DL_GO_PROTECTED	            6	/* execute the downloaded code and set reset
+					 * event to occur in 2 seconds.  It is the
+					 * responsibility of the downloaded code to clear this event
+					 */
+#define DL_EXEC		                7	/* jump to a supplied address */
+#define DL_RESETCFG	                8	/* To support single enum on dongle - Not used by bootloader */
+#define DL_DEFER_RESP_OK            9	/* Potentially defer the response to setup if resp unavailable */
+
+/* states */
+#define DL_WAITING	                0	/* waiting to rx first pkt */
+#define DL_READY	                1	/* hdr was good, waiting for more of the compressed image */
+#define DL_BAD_HDR	                2	/* hdr was corrupted */
+#define DL_BAD_CRC	                3	/* compressed image was corrupted */
+#define DL_RUNNABLE	                4	/* download was successful,waiting for go cmd */
+#define DL_START_FAIL	            5	/* failed to initialize correctly */
+
+struct rdl_state_le {
+	__le32 state;
+	__le32 bytes;
+};
+
+struct bootrom_id_le {
+	__le32 chip;		/* Chip id */
+	__le32 ramsize;		/* Size of  RAM */
+	__le32 remapbase;	/* Current remap base address */
+	__le32 boardtype;	/* Type of board */
+	__le32 boardrev;	/* Board revision */
+};
+
+enum wlan_usb_tx_status {
+	WLAN_USB_TX_IDLE = 0,
+	WLAN_USB_TX_SENDING,
+	WLAN_USB_TX_SEND_COMPLETE
+};
+
+struct wlan_usb_card {
+	struct usb_device *usbdev;
+	struct device *dev;
+	struct urb *rx_urb, *tx_urb;
+	struct sk_buff *rx_skb;
+	uint tx_pipe;
+	uint rx_pipe;
+	wlan_private *priv;
+};
+
+struct intr_transfer_buf {
+	u32 notification;
+	u32 reserved;
+};
+
+struct wland_usbdev_info {
+	struct wland_usb_dev bus_pub;	/* MUST BE FIRST */
+	spinlock_t qlock;
+	struct list_head rx_freeq;
+	struct list_head rx_postq;
+	struct list_head tx_freeq;
+	struct list_head tx_postq;
+
+	uint rx_pipe, tx_pipe, intr_pipe, rx_pipe2;
+
+	int rx_low_watermark;
+	int tx_low_watermark;
+	int tx_high_watermark;
+	int tx_freecount;
+	bool tx_flowblock;
+	spinlock_t tx_flowblock_lock;
+
+	struct wland_usbreq *tx_reqs;
+	struct wland_usbreq *rx_reqs;
+
+	struct usb_device *usbdev;
+	struct device *dev;
+
+	int ctl_in_pipe, ctl_out_pipe;
+
+	struct urb *ctl_urb;	/* URB for control endpoint */
+	struct usb_ctrlrequest ctl_write;
+	struct usb_ctrlrequest ctl_read;
+
+	u32 ctl_urb_actual_length;
+	int ctl_urb_status;
+	int ctl_completed;
+
+	wait_queue_head_t ioctl_resp_wait;
+
+	ulong ctl_op;
+
+	struct urb *bulk_urb;	/* used for FW download       */
+	struct urb *intr_urb;	/* URB for interrupt endpoint */
+	int intr_size;		/* Size of interrupt message  */
+	int interval;		/* Interrupt polling interval */
+	struct intr_transfer_buf intr;	/* Data buffer for interrupt endpoint */
+};
+
+enum wland_usb_state {
+	USB_STATE_DOWN,
+	USB_STATE_DL_FAIL,
+	USB_STATE_DL_DONE,
+	USB_STATE_UP,
+	USB_STATE_SLEEP
+};
+
+struct wland_stats {
+	u32 tx_ctlpkts;
+	u32 tx_ctlerrs;
+	u32 rx_ctlpkts;
+	u32 rx_ctlerrs;
+};
+
+struct wland_usb_dev {
+	struct wland_bus *bus;
+	struct wland_usbdev_info *devinfo;
+	enum wland_usb_state state;
+	struct wland_stats stats;
+	int ntxq, nrxq, rxsize;
+	u32 bus_mtu;
+	int devid;
+};
+
+/* IO Request Block (IRB) */
+struct wland_usbreq {
+	struct list_head list;
+	struct wland_usbdev_info *devinfo;
+	struct urb *urb;
+	struct sk_buff *skb;
+};
+
+#ifdef WLAND_USB_SUPPORT
+extern void wland_usb_exit(void);
+extern void wland_usb_register(void);
+#endif /*WLAND_USB_SUPPORT */
+
+#endif /* WLAND_USB_SUPPORT */
+#endif /* _WLAND_USB_H_       */
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_utils.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_utils.c
new file mode 100644
index 000000000000..3073fa799407
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_utils.c
@@ -0,0 +1,698 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linuxver.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+
+#include <wland_defs.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_bus.h>
+#include <wland_dbg.h>
+#include <wland_utils.h>
+
+void wland_pkt_align(struct sk_buff *p, int len, int align)
+{
+	uint datalign;
+
+	datalign = (unsigned long) (p->data);
+	datalign = roundup(datalign, (align)) - datalign;
+	if (datalign)
+		skb_pull(p, datalign);
+	__skb_trim(p, len);
+}
+
+EXPORT_SYMBOL(wland_pkt_align);
+
+struct sk_buff *wland_pkt_buf_get_skb(uint len)
+{
+	struct sk_buff *skb;
+
+	skb = __dev_alloc_skb(len, GFP_ATOMIC);
+	if (skb) {
+		skb_put(skb, len);
+		skb->priority = 0;
+		memset(skb->data, 0, len);
+	}
+	return skb;
+}
+
+EXPORT_SYMBOL(wland_pkt_buf_get_skb);
+
+/* Free the driver packet. Free the tag if present */
+void wland_pkt_buf_free_skb(struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (!skb)
+		return;
+	WARN_ON(skb->next);
+
+	while (skb) {
+		nskb = skb->next;
+		skb->next = NULL;
+		if (skb->destructor) {
+			/*
+			 * cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists
+			 */
+			dev_kfree_skb_any(skb);
+		} else {
+			/*
+			 * can free immediately (even in_irq()) if destructor does not exist
+			 */
+			dev_kfree_skb(skb);
+		}
+		skb = nskb;
+	}
+}
+
+EXPORT_SYMBOL(wland_pkt_buf_free_skb);
+
+/*
+ * osl multiple-precedence packet queue
+ * hi_prec is always >= the number of the highest non-empty precedence
+ */
+struct sk_buff *wland_pktq_penq(struct pktq *pq, int prec, struct sk_buff *p)
+{
+	struct sk_buff_head *q;
+
+	if (pktq_full(pq) || pktq_pfull(pq, prec))
+		return NULL;
+
+	q = &pq->q[prec].skblist;
+	skb_queue_tail(q, p);
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (u8) prec;
+
+	return p;
+}
+
+EXPORT_SYMBOL(wland_pktq_penq);
+
+struct sk_buff *wland_pktq_penq_head(struct pktq *pq, int prec,
+	struct sk_buff *p)
+{
+	struct sk_buff_head *q;
+
+	if (pktq_full(pq) || pktq_pfull(pq, prec))
+		return NULL;
+
+	q = &pq->q[prec].skblist;
+	skb_queue_head(q, p);
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (u8) prec;
+
+	return p;
+}
+
+EXPORT_SYMBOL(wland_pktq_penq_head);
+
+struct sk_buff *wland_pktq_pdeq(struct pktq *pq, int prec)
+{
+	struct sk_buff_head *q = &pq->q[prec].skblist;
+	struct sk_buff *p = skb_dequeue(q);
+
+	if (p == NULL)
+		return NULL;
+
+	pq->len--;
+	return p;
+}
+
+EXPORT_SYMBOL(wland_pktq_pdeq);
+
+/*
+ * precedence based dequeue with match function. Passing a NULL pointer
+ * for the match function parameter is considered to be a wildcard so
+ * any packet on the queue is returned. In that case it is no different
+ * from wland_pktq_pdeq() above.
+ */
+struct sk_buff *wland_pktq_pdeq_match(struct pktq *pq, int prec,
+	bool(*match_fn) (struct sk_buff * skb, void *arg), void *arg)
+{
+	struct sk_buff_head *q = &pq->q[prec].skblist;
+	struct sk_buff *p, *next;
+
+	skb_queue_walk_safe(q, p, next) {
+		if (match_fn == NULL || match_fn(p, arg)) {
+			skb_unlink(p, q);
+			pq->len--;
+			return p;
+		}
+	}
+	return NULL;
+}
+
+EXPORT_SYMBOL(wland_pktq_pdeq_match);
+
+struct sk_buff *wland_pktq_pdeq_tail(struct pktq *pq, int prec)
+{
+	struct sk_buff_head *q = &pq->q[prec].skblist;
+	struct sk_buff *p = skb_dequeue_tail(q);
+
+	if (p == NULL)
+		return NULL;
+
+	pq->len--;
+	return p;
+}
+
+EXPORT_SYMBOL(wland_pktq_pdeq_tail);
+
+void wland_pktq_pflush(struct pktq *pq, int prec, bool dir,
+	bool(*fn) (struct sk_buff *, void *), void *arg)
+{
+	struct sk_buff_head *q;
+	struct sk_buff *p, *next;
+
+	q = &pq->q[prec].skblist;
+
+	skb_queue_walk_safe(q, p, next) {
+		if (fn == NULL || (*fn) (p, arg)) {
+			skb_unlink(p, q);
+			wland_pkt_buf_free_skb(p);
+			pq->len--;
+		}
+	}
+}
+
+EXPORT_SYMBOL(wland_pktq_pflush);
+
+void wland_pktq_flush(struct pktq *pq, bool dir, bool(*fn) (struct sk_buff *,
+		void *), void *arg)
+{
+	int prec;
+
+	for (prec = 0; prec < pq->num_prec; prec++)
+		wland_pktq_pflush(pq, prec, dir, fn, arg);
+}
+
+EXPORT_SYMBOL(wland_pktq_flush);
+
+void wland_pktq_init(struct pktq *pq, int num_prec, int max_len)
+{
+	int prec;
+
+	/*
+	 * pq is variable size; only zero out what's requested
+	 */
+	memset(pq, 0, offsetof(struct pktq,
+			q) + (sizeof(struct pktq_prec) * num_prec));
+
+	pq->num_prec = (u16) num_prec;
+	pq->max = (u16) max_len;
+
+	for (prec = 0; prec < num_prec; prec++) {
+		pq->q[prec].max = pq->max;
+		skb_queue_head_init(&pq->q[prec].skblist);
+	}
+}
+
+EXPORT_SYMBOL(wland_pktq_init);
+
+struct sk_buff *wland_pktq_peek_tail(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (!skb_queue_empty(&pq->q[prec].skblist))
+			break;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return skb_peek_tail(&pq->q[prec].skblist);
+}
+
+EXPORT_SYMBOL(wland_pktq_peek_tail);
+
+/* Return sum of lengths of a specific set of precedences */
+int wland_pktq_mlen(struct pktq *pq, uint prec_bmp)
+{
+	int prec, len = 0;
+
+	for (prec = 0; prec <= pq->hi_prec; prec++)
+		if (prec_bmp & (1 << prec))
+			len += pq->q[prec].skblist.qlen;
+
+	return len;
+}
+
+EXPORT_SYMBOL(wland_pktq_mlen);
+
+/* Priority dequeue from a specific set of precedences */
+struct sk_buff *wland_pktq_mdeq(struct pktq *pq)
+{
+	struct sk_buff_head *q;
+	struct sk_buff *p;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	prec = 0;
+
+	q = &pq->q[prec].skblist;
+	p = skb_dequeue(q);
+	if (p == NULL)
+		return NULL;
+
+	pq->len--;
+
+	return p;
+}
+
+EXPORT_SYMBOL(wland_pktq_mdeq);
+
+/* pretty hex print a contiguous buffer */
+static void prhex(int level, const char *msg, u8 * buf, uint nbytes)
+{
+#define CHUNK_SIZE  64
+	char line[3 * CHUNK_SIZE + 10], *p;
+	int len = sizeof(line), nchar, chunk = CHUNK_SIZE;
+	uint i;
+
+	if (msg && (msg[0] != '\0'))
+		printk("%s:%s [begin]\n", wland_dbgarea(level), msg);
+
+	p = line;
+	for (i = 0; i < nbytes; i++) {
+		if (i % chunk == 0) {
+			nchar = snprintf(p, len, " %04d: ", i);	/* line prefix */
+			p += nchar;
+			len -= nchar;
+		}
+
+		if (len > 0) {
+			nchar = snprintf(p, len, "%02x ", buf[i]);
+			p += nchar;
+			len -= nchar;
+		}
+
+		if (i % chunk == (chunk - 1)) {
+			printk("%s:%s\n", wland_dbgarea(level), line);	/* flush line */
+			p = line;
+			len = sizeof(line);
+		}
+	}
+
+	/*
+	 * flush last partial line
+	 */
+	if (p != line)
+		printk("%s:%s\n", wland_dbgarea(level), line);
+
+	if (msg && (msg[0] != '\0'))
+		printk("%s:%s [end]\n", wland_dbgarea(level), msg);
+}
+
+void wland_dbg_hex_dump(int level, const void *data, size_t size,
+	const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	if (data && size) {
+		va_start(args, fmt);
+
+		vaf.fmt = fmt;
+		vaf.va = &args;
+#ifndef DEBUG
+		printk("[RDAWLAN_DUMP]:%pV", &vaf);
+#endif /* DEBUG */
+		va_end(args);
+
+#ifdef DEBUG
+		prhex(level,
+			"=======================Hex Data=======================",
+			(u8 *) data, size);
+#else /* DEBUG */
+		print_hex_dump_bytes("[RDAWLAN_DUMP]", "DATA", data, size);
+#endif /* DEBUG */
+	}
+}
+
+EXPORT_SYMBOL(wland_dbg_hex_dump);
+
+/* This function extracts the beacon period field from the beacon or probe   */
+
+/* response frame.                                                           */
+u16 get_beacon_period(u8 * data)
+{
+	u16 bcn_per = 0;
+
+	bcn_per = data[0];
+	bcn_per |= (data[1] << 8);
+
+	return bcn_per;
+}
+
+EXPORT_SYMBOL(get_beacon_period);
+
+/* This function extracts the 'frame type' bits from the MAC header of the   */
+
+/* input frame.                                                              */
+
+/* Returns the value in the LSB of the returned value.                       */
+u8 get_type(u8 * header)
+{
+	return ((u8) (header[0] & 0x0C));
+}
+
+EXPORT_SYMBOL(get_type);
+
+/* This function extracts the 'frame type and sub type' bits from the MAC    */
+
+/* header of the input frame.                                                */
+
+/* Returns the value in the LSB of the returned value.                       */
+u8 get_sub_type(u8 * header)
+{
+	return ((u8) (header[0] & 0xFC));
+}
+
+EXPORT_SYMBOL(get_sub_type);
+
+/* This function extracts the 'to ds' bit from the MAC header of the input   */
+
+/* frame.                                                                    */
+
+/* Returns the value in the LSB of the returned value.                       */
+u8 get_to_ds(u8 * header)
+{
+	return (header[1] & 0x01);
+}
+
+EXPORT_SYMBOL(get_to_ds);
+
+/* This function extracts the 'from ds' bit from the MAC header of the input */
+
+/* frame.                                                                    */
+
+/* Returns the value in the LSB of the returned value.                       */
+u8 get_from_ds(u8 * header)
+{
+	return ((header[1] & 0x02) >> 1);
+}
+
+EXPORT_SYMBOL(get_from_ds);
+
+/* This function extracts the MAC Address in 'address1' field of the MAC     */
+
+/* header and updates the MAC Address in the allocated 'addr' variable.      */
+void get_address1(u8 * pu8msa, u8 * addr)
+{
+	memcpy(addr, pu8msa + 4, 6);
+}
+
+EXPORT_SYMBOL(get_address1);
+
+/* This function extracts the MAC Address in 'address2' field of the MAC     */
+
+/* header and updates the MAC Address in the allocated 'addr' variable.      */
+void get_address2(u8 * pu8msa, u8 * addr)
+{
+	memcpy(addr, pu8msa + 10, 6);
+}
+
+EXPORT_SYMBOL(get_address2);
+
+/* This function extracts the MAC Address in 'address3' field of the MAC     */
+
+/* header and updates the MAC Address in the allocated 'addr' variable.      */
+void get_address3(u8 * pu8msa, u8 * addr)
+{
+	memcpy(addr, pu8msa + 16, 6);
+}
+
+EXPORT_SYMBOL(get_address3);
+
+/* This function extracts the BSSID from the incoming WLAN packet based on   */
+
+/* the 'from ds' bit, and updates the MAC Address in the allocated 'addr'    */
+
+/* variable.                                                                 */
+void get_BSSID(u8 * data, u8 * bssid)
+{
+	if (get_from_ds(data) == 1)
+		get_address2(data, bssid);
+	else if (get_to_ds(data) == 1)
+		get_address1(data, bssid);
+	else
+		get_address3(data, bssid);
+}
+
+EXPORT_SYMBOL(get_BSSID);
+
+/* This function extracts the SSID from a beacon/probe response frame        */
+void get_ssid(u8 * data, u8 * ssid, u8 * p_ssid_len)
+{
+	u8 len = 0;
+	u8 i = 0;
+	u8 j = 0;
+
+	len = data[MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN +
+		CAP_INFO_LEN + 1];
+	j = MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN + CAP_INFO_LEN +
+		2;
+
+	/*
+	 * If the SSID length field is set wrongly to a value greater than the
+	 */
+	/*
+	 * allowed maximum SSID length limit, reset the length to 0
+	 */
+	if (len >= MAX_SSID_LEN)
+		len = 0;
+
+	for (i = 0; i < len; i++, j++)
+		ssid[i] = data[j];
+
+	ssid[len] = '\0';
+
+	*p_ssid_len = len;
+}
+
+EXPORT_SYMBOL(get_ssid);
+
+/* This function extracts the capability info field from the beacon or probe */
+
+/* response frame.                                                           */
+u16 get_cap_info(u8 * data)
+{
+	u16 cap_info = 0;
+	u16 index = MAC_HDR_LEN;
+	u8 st = BEACON;
+
+	st = get_sub_type(data);
+
+	/*
+	 * Location of the Capability field is different for Beacon and
+	 */
+	/*
+	 * Association frames.
+	 */
+	if ((st == BEACON) || (st == PROBE_RSP))
+		index += TIME_STAMP_LEN + BEACON_INTERVAL_LEN;
+
+	cap_info = data[index];
+	cap_info |= (data[index + 1] << 8);
+
+	return cap_info;
+}
+
+EXPORT_SYMBOL(get_cap_info);
+
+/* This function extracts the capability info field from the Association */
+
+/* response frame.                                                           		 */
+u16 get_assoc_resp_cap_info(u8 * data)
+{
+	u16 cap_info = 0;
+
+	cap_info = data[0];
+	cap_info |= (data[1] << 8);
+
+	return cap_info;
+}
+
+EXPORT_SYMBOL(get_assoc_resp_cap_info);
+
+/* This funcion extracts the association status code from the incoming       */
+
+/* association response frame and returns association status code            */
+u16 get_asoc_status(u8 * data)
+{
+	u16 asoc_status = 0;
+
+	asoc_status = data[3];
+	asoc_status = (asoc_status << 8) | data[2];
+
+	return asoc_status;
+}
+
+EXPORT_SYMBOL(get_asoc_status);
+
+/* This function extracts association ID from the incoming association       */
+
+/* response frame							                                     */
+u16 get_asoc_id(u8 * data)
+{
+	u16 asoc_id = 0;
+
+	asoc_id = data[4];
+	asoc_id |= (data[5] << 8);
+
+	return asoc_id;
+}
+
+EXPORT_SYMBOL(get_asoc_id);
+
+u8 *get_tim_elm(u8 * pu8msa, u16 u16RxLen, u16 u16TagParamOffset)
+{
+	u16 u16index = u16TagParamOffset;
+
+    /*************************************************************************/
+	/*
+	 * Beacon Frame - Frame Body
+	 */
+	/*
+	 * ---------------------------------------------------------------------
+	 */
+	/*
+	 * |Timestamp |BeaconInt |CapInfo |SSID |SupRates |DSParSet |TIM elm   |
+	 */
+	/*
+	 * ---------------------------------------------------------------------
+	 */
+	/*
+	 * |8         |2         |2       |2-34 |3-10     |3        |4-256     |
+	 */
+	/*
+	 * ---------------------------------------------------------------------
+	 */
+	/*
+	 */
+
+    /*************************************************************************/
+
+	/*
+	 * Search for the TIM Element Field and return if the element is found
+	 */
+	while (u16index < (u16RxLen - FCS_LEN)) {
+		if (pu8msa[u16index] == ITIM) {
+			return (&pu8msa[u16index]);
+		} else {
+			u16index += (IE_HDR_LEN + pu8msa[u16index + 1]);
+		}
+	}
+
+	return NULL;
+}
+
+EXPORT_SYMBOL(get_tim_elm);
+
+u8 get_current_channel(u8 * pu8msa, u16 u16RxLen)
+{
+	u16 index =
+		MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN +
+		CAP_INFO_LEN;
+
+	while (index < (u16RxLen - FCS_LEN)) {
+		if (pu8msa[index] == IDSPARMS)
+			return (pu8msa[index + 2]);
+		else
+			/*
+			 * Increment index by length information and header
+			 */
+			index += pu8msa[index + 1] + IE_HDR_LEN;
+	}
+
+	/*
+	 * Return current channel information from the MIB, if beacon/probe
+	 */
+	/*
+	 * response frame does not contain the DS parameter set IE
+	 */
+	return 0;		/* no MIB here */
+}
+
+EXPORT_SYMBOL(get_current_channel);
+
+u8 *get_data_rate(u8 * pu8msa, u16 u16RxLen, u8 type, u8 * rate_size)
+{
+	u16 index =
+		MAC_HDR_LEN + TIME_STAMP_LEN + BEACON_INTERVAL_LEN +
+		CAP_INFO_LEN;
+
+	while (index < (u16RxLen - FCS_LEN)) {
+		if (pu8msa[index] == type) {
+			if (rate_size)
+				*rate_size = pu8msa[index + 1];
+			return (&pu8msa[index + 2]);
+		} else {
+			/*
+			 * Increment index by length information and header
+			 */
+			index += pu8msa[index + 1] + IE_HDR_LEN;
+		}
+	}
+
+	/*
+	 * Return current channel information from the MIB, if beacon/probe
+	 */
+	/*
+	 * response frame does not contain the DS parameter set IE
+	 */
+	return NULL;		/* no MIB here */
+}
+
+EXPORT_SYMBOL(get_data_rate);
+
+u8 num_2_char(u8 num)
+{
+	if (num >= 0 && num <= 9) {
+		return '0' + num;
+	} else {
+		return 'a' + (num - 0x0a);
+	}
+}
+
+EXPORT_SYMBOL(num_2_char);
+
+void num_2_str(u8 num, u8 * str)
+{
+	*str = num_2_char((num >> 4) & 0x0f);
+	*(str + 1) = num_2_char(num & 0x0f);
+}
+
+EXPORT_SYMBOL(num_2_str);
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.c b/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.c
new file mode 100644
index 000000000000..a8273fe65a9e
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.c
@@ -0,0 +1,508 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linuxver.h>
+#include <linux_osl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/debugfs.h>
+#include <net/cfg80211.h>
+#include <net/rtnetlink.h>
+#include <linux/mmc/sdio_func.h>
+#include <wland_defs.h>
+#include <wland_utils.h>
+#include <wland_fweh.h>
+#include <wland_dev.h>
+#include <wland_dbg.h>
+#include <wland_wid.h>
+#include <wland_bus.h>
+#include <wland_sdmmc.h>
+#include <wland_trap.h>
+#include <wland_p2p.h>
+#include <wland_cfg80211.h>
+
+int wland_proto_hdrpush(struct wland_private *drvr, s32 ifidx,
+	struct sk_buff *pktbuf)
+{
+	WLAND_DBG(DCMD, TRACE, "ifidx:%d,Enter\n", ifidx);
+
+#if 0
+	struct bdc_header *h;
+
+	/*
+	 * Push BDC header used to convey priority for buses that don't
+	 */
+	PKTPUSH(dhd->osh, pktbuf, BDC_HEADER_LEN);
+
+	h = (struct bdc_header *) PKTDATA(dhd->osh, pktbuf);
+
+	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
+	if (PKTSUMNEEDED(pktbuf))
+		h->flags |= BDC_FLAG_SUM_NEEDED;
+
+	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
+	h->flags2 = 0;
+	h->dataOffset = 0;
+
+	BDC_SET_IF_IDX(h, ifidx);
+#endif /* BDC */
+
+	return 0;
+}
+
+int wland_proto_hdrpull(struct wland_private *drvr, s32 * ifidx,
+	struct sk_buff *pktbuf)
+{
+	WLAND_DBG(EVENT, TRACE, "Enter(pktbuf->len:%d)\n", pktbuf->len);
+
+	/*
+	 * Pop BDC header used to convey priority for buses that don't
+	 */
+	if (PKTLEN(drvr->bus_if->osh, pktbuf) <= FMW_HEADER_LEN) {
+		WLAND_ERR("rx data too short (%d <= %d)\n", pktbuf->len,
+			FMW_HEADER_LEN);
+		return -EBADE;
+	}
+
+	if (ifidx)
+		*ifidx = 0;
+#if 0
+	*ifidx = pktbuf->data[3];
+	if (*ifidx >= WLAND_MAX_IFS) {
+		WLAND_ERR("rx data ifnum out of range (%d)\n", *ifidx);
+		return -EBADE;
+	}
+	/*
+	 * The ifidx is the idx to map to matching netdev/ifp. When receiving
+	 * * events this is easy because it contains the bssidx which maps
+	 * * 1-on-1 to the netdev/ifp. But for data frames the ifidx is rcvd.
+	 * * bssidx 1 is used for p2p0 and no data can be received or
+	 * * transmitted on it. Therefor bssidx is ifidx + 1 if ifidx > 0
+	 */
+	if (*ifidx)
+		(*ifidx)++;
+
+	//////////////////////////////////////////////
+	struct bdc_header *h;
+	u8 data_offset = 0;
+
+	h = (struct bdc_header *) PKTDATA(dhd->osh, pktbuf);
+
+	if (!ifidx) {
+		/*
+		 * for tx packet, skip the analysis
+		 */
+		data_offset = h->dataOffset;
+		PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
+		goto exit;
+	}
+
+	if ((*ifidx = BDC_GET_IF_IDX(h)) >= WLAND_MAX_IFS) {
+		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
+				__FUNCTION__, *ifidx));
+		return BCME_ERROR;
+	}
+
+	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) !=
+		BDC_PROTO_VER) {
+		DHD_ERROR(("%s: non-BDC packet received, flags = 0x%x\n",
+				wland_ifname(dhd, *ifidx), h->flags));
+		if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) ==
+			BDC_PROTO_VER_1)
+			h->dataOffset = 0;
+		else
+			return BCME_ERROR;
+	}
+
+	if (h->flags & BDC_FLAG_SUM_GOOD) {
+		DHD_ERROR(
+			("%s: BDC packet received with good rx-csum, flags 0x%x\n",
+				wland_ifname(dhd, *ifidx), h->flags));
+		PKTSETSUMGOOD(pktbuf, true);
+	}
+
+	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
+	data_offset = h->dataOffset;
+	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
+
+	if (PKTLEN(dhd->osh, pktbuf) < (u32) (data_offset << 2)) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
+				PKTLEN(dhd->osh, pktbuf), (data_offset * 4)));
+		return BCME_ERROR;
+	}
+#endif /* BDC */
+
+	if (pktbuf->len == 0)
+		return -ENODATA;
+
+	return 0;
+}
+
+int wland_sendpkt(struct wland_if *ifp, struct sk_buff *pktbuf)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct ethhdr *eh = (struct ethhdr *) (pktbuf->data);
+	bool multicast = is_multicast_ether_addr(eh->h_dest);
+	bool pae = eh->h_proto == htons(ETH_P_PAE);
+
+	WLAND_DBG(DCMD, TRACE,
+		"Enter(tx_proto:0x%X, is_multicast:%d, pae:%d)\n",
+		ntohs(eh->h_proto), multicast, pae);
+
+	/*
+	 * Update multicast statistic
+	 */
+	drvr->tx_multicast += ! !multicast;
+	if (pae)
+		atomic_inc(&ifp->pend_8021x_cnt);
+
+	/*
+	 * If the protocol uses a data header, apply it
+	 */
+	wland_proto_hdrpush(drvr, ifp->bssidx, pktbuf);
+
+	/*
+	 * Update multicast statistic
+	 */
+	if (pktbuf->len >= ETH_ALEN) {
+		struct ethhdr *eh = (struct ethhdr *) (pktbuf->data);
+
+		WLAND_DBG(DCMD, TRACE, "dest: %pM\n", eh->h_dest);
+		WLAND_DBG(DCMD, TRACE, "source: %pM\n", eh->h_source);
+		if (is_multicast_ether_addr(eh->h_dest)) {
+			WLAND_DBG(DCMD, DEBUG, "%pM is multicast ether addr\n",
+				eh->h_dest);
+		}
+		if (ntohs(eh->h_proto) == ETH_P_PAE) {
+			WLAND_DBG(DCMD, DEBUG, "eh->h_proto == ETH_P_PAE\n");
+		}
+	}
+
+	/*
+	 * Use bus module to send data frame
+	 */
+	return wland_bus_txdata(drvr->bus_if, pktbuf);
+}
+
+/* setup chip */
+int wland_preinit_cmds(struct wland_if *ifp)
+{
+	int err = 0;
+	u32 u32Val = 0;
+	u8 u8Val = 0;
+
+	/*
+	 * add for qos
+	 */
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_bus *bus_if = drvr->bus_if;
+
+#ifdef WLAND_POWER_MANAGER
+	struct wland_sdio_dev *sdiodev = drvr->bus_if->bus_priv.sdio;
+#endif
+
+	if (!ifp) {
+		WLAND_ERR("ifp Empty!\n");
+		return -ENODEV;
+	}
+
+	WLAND_DBG(DCMD, DEBUG, "Enter\n");
+
+	if (check_test_mode()) {
+		WLAND_DBG(DCMD, INFO, "In test mode and do nothing.\n");
+		goto done;
+	}
+	err = wland_fil_get_cmd_data(ifp, WID_SYS_FW_VER, &u32Val,
+		sizeof(u32Val));
+	if (err < 0) {
+		WLAND_ERR("Retreiving version information failed!\n");
+		return -EINVAL;
+	}
+	WLAND_DBG(DCMD, DEBUG, "FirmWareVer:0x%x \n", u32Val);
+
+	err = wland_fil_set_cmd_data(ifp, WID_MAC_ADDR, ifp->mac_addr,
+		ETH_ALEN);
+	if (err < 0) {
+		WLAND_ERR("set cur_etheraddr failed\n");
+		goto done;
+	}
+
+	WLAND_DBG(DCMD, DEBUG, "#########Set MAC Address(" MACDBG ")\n",
+		MAC2STRDBG(ifp->mac_addr));
+
+	err = wland_fil_get_cmd_data(ifp, WID_MAC_ADDR, ifp->mac_addr,
+		ETH_ALEN);
+	if (err < 0) {
+		WLAND_ERR("Retreiving cur_etheraddr failed, %d\n", err);
+		goto done;
+	}
+
+	WLAND_DBG(DCMD, DEBUG, "#########Get MAC Address(" MACDBG ")\n",
+		MAC2STRDBG(ifp->mac_addr));
+
+	memcpy(ifp->drvr->mac, ifp->mac_addr, ETH_ALEN);
+
+	u8Val = G_AUTO_PREAMBLE;
+	err = wland_fil_set_cmd_data(ifp, WID_PREAMBLE, &u8Val, sizeof(u8Val));
+	if (err < 0) {
+		WLAND_ERR("set preamble failed, %d\n", err);
+		goto done;
+	}
+#if 0
+	u8Val = 0;
+	err = wland_fil_set_cmd_data(ifp, WID_PTA_MODE, &u8Val, sizeof(u8Val));
+	if (err < 0) {
+		WLAND_ERR("set pta mode failed, %d\n", err);
+		goto done;
+	}
+
+	err = wland_fil_set_cmd_data(ifp, WID_PTA_BLOCK_BT, &u8Val,
+		sizeof(u8Val));
+	if (err < 0) {
+		WLAND_ERR("set pta block bt failed, %d\n", err);
+		goto done;
+	}
+#endif
+
+	err = wland_set_scan_timeout(ifp);
+	if (err < 0) {
+		WLAND_ERR("set_scan_timeout failed, %d\n", err);
+		goto done;
+	}
+
+	u8Val = WIFI_LISTEN_INTERVAL;
+	err = wland_fil_set_cmd_data(ifp, WID_LISTEN_INTERVAL, &u8Val,
+		sizeof(u8Val));
+	if (err < 0) {
+		WLAND_ERR("set_listen_interval failed, %d\n", err);
+		goto done;
+	}
+
+	if (bus_if->chip == WLAND_VER_90_D || bus_if->chip == WLAND_VER_90_E) {
+		u8Val = WIFI_LINK_LOSS_THRESHOLD_90;
+		err = wland_fil_set_cmd_data(ifp, WID_LINK_LOSS_THRESHOLD,
+			&u8Val, sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("set_link_loss_threshold failed, %d\n", err);
+			goto done;
+		}
+	} else if (bus_if->chip == WLAND_VER_91) {
+		u8Val = WIFI_LINK_LOSS_THRESHOLD_91;
+		err = wland_fil_set_cmd_data(ifp, WID_LINK_LOSS_THRESHOLD,
+			&u8Val, sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("set_link_loss_threshold failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0x30;
+		err = wland_fil_set_cmd_data(ifp, WID_POWER_SAVE, &u8Val,
+			sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("Set WID_POWER_SAVE failed, %d\n", err);
+			goto done;
+		}
+
+	} else if (bus_if->chip == WLAND_VER_91_E) {
+		u8Val = WIFI_LINK_LOSS_THRESHOLD_91;
+		err = wland_fil_set_cmd_data(ifp, WID_LINK_LOSS_THRESHOLD,
+			&u8Val, sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("set_link_loss_threshold failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0x30;
+		err = wland_fil_set_cmd_data(ifp, WID_POWER_SAVE, &u8Val,
+			sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("Set WID_POWER_SAVE failed, %d\n", err);
+			goto done;
+		}
+	} else if (bus_if->chip == WLAND_VER_91_F) {
+		u8Val = WIFI_LINK_LOSS_THRESHOLD_91;
+		err = wland_fil_set_cmd_data(ifp, WID_LINK_LOSS_THRESHOLD,
+			&u8Val, sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("set_link_loss_threshold failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0x30;
+		err = wland_fil_set_cmd_data(ifp, WID_POWER_SAVE, &u8Val,
+			sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("Set WID_POWER_SAVE failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0;
+		err = wland_fil_set_cmd_data(ifp, WID_QOS_ENABLE, &u8Val,
+			sizeof(u8Val));
+		if (err) {
+			WLAND_ERR("Set WID_QOS_ENABLE failed! \n");
+			goto done;
+		}
+	} else if (bus_if->chip == WLAND_VER_91_G) {
+		u8Val = WIFI_LINK_LOSS_THRESHOLD_91;
+		err = wland_fil_set_cmd_data(ifp, WID_LINK_LOSS_THRESHOLD,
+			&u8Val, sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("set_link_loss_threshold failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0x30;
+		err = wland_fil_set_cmd_data(ifp, WID_POWER_SAVE, &u8Val,
+			sizeof(u8Val));
+		if (err < 0) {
+			WLAND_ERR("Set WID_POWER_SAVE failed, %d\n", err);
+			goto done;
+		}
+		u8Val = 0;
+		err = wland_fil_set_cmd_data(ifp, WID_QOS_ENABLE, &u8Val,
+			sizeof(u8Val));
+		if (err) {
+			WLAND_ERR("wland_set_qos_enable failed! \n");
+			goto done;
+		}
+	}
+#ifdef WLAND_POWER_MANAGER
+	if (ifp->drvr->sleep_flags & WLAND_SLEEP_ENABLE) {
+		u8Val = MAX_FAST_PS;
+		err = wland_fil_set_cmd_data(ifp, WID_POWER_MANAGEMENT, &u8Val,
+			sizeof(u8Val));
+		if (err < 0)
+			goto done;
+	}
+	if (ifp->drvr->sleep_flags & WLAND_SLEEP_PREASSO) {
+		u32Val = WIFI_PREASSO_SLEEP;
+		err = wland_fil_set_cmd_data(ifp, WID_PREASSO_SLEEP, &u32Val,
+			sizeof(u32Val));
+		if (err < 0)
+			goto done;
+	}
+	u8Val = 1;
+	sdio_claim_host(sdiodev->func);
+	err = sdioh_request_byte(sdiodev, SDIOH_WRITE,
+		URSDIO_FUNC1_INT_TO_DEVICE, &u8Val);
+	sdio_release_host(sdiodev->func);
+	if (err) {
+		WLAND_ERR("Write URSDIO_FUNC1_INT_TO_DEVICE failed!\n");
+	}
+#endif /* WLAND_POWER_MANAGER */
+done:
+	WLAND_DBG(DCMD, DEBUG, "Done(err:%d)\n", err);
+	return err;
+}
+
+int wland_start_chip(struct wland_if *ifp, u8 device_role)
+{
+	struct wland_private *drvr = ifp->drvr;
+	struct wland_sdio_dev *sdiodev = drvr->bus_if->bus_priv.sdio;
+	struct wland_sdio *bus = sdiodev->bus;
+	int err = -ENODEV;
+
+	WLAND_DBG(DCMD, DEBUG, "Enter\n");
+	if (!ifp) {
+		WLAND_ERR("ifp Empty!\n");
+		goto fail;
+	}
+
+	err = wland_bus_active(sdiodev->dev);
+	if (err < 0) {
+		WLAND_ERR("active bus failed!\n");
+		goto fail;
+	}
+
+	/*
+	 * sta mode
+	 */
+	if ((device_role == 0) || (device_role == 0xA0)) {
+		drvr->dev_mode = false;
+		/*
+		 * set up
+		 */
+		if (device_role & 0xA0)
+			drvr->p2p_enable = true;
+		else
+			drvr->p2p_enable = false;
+	} else {		/* softap mode */
+
+		u8 val = MAC_ROLE_AP;
+
+		drvr->dev_mode = true;
+		/*
+		 * set up
+		 */
+		if (device_role & 0xA0)
+			drvr->p2p_enable = true;
+		else
+			drvr->p2p_enable = false;
+
+		err = wland_fil_set_cmd_data(ifp, WID_MAC_ROLE, &val,
+			sizeof(u8));
+		if (err < 0) {
+			WLAND_ERR("set preamble failed, %d\n", err);
+			goto fail;
+		}
+	}
+
+	/*
+	 * soft ap mac different with sta mac address
+	 */
+	if (drvr->dev_mode) {
+		/*
+		 * revert six bit of the byte
+		 */
+		ifp->mac_addr[5] ^= (1 << (5));
+		memcpy(ifp->ndev->dev_addr, ifp->mac_addr, ETH_ALEN);
+	}
+
+	WLAND_DBG(DCMD, DEBUG, "Enter(device_role:0x%x)\n", device_role);
+
+#ifdef WLAND_FPGA_SUPPORT
+	WLAND_DBG(DCMD, TRACE, "FPGA Mode Enter\n");
+#else /*WLAND_FPGA_SUPPORT */
+	WLAND_DBG(DCMD, DEBUG, "%s PATCH Enter\n",
+		check_test_mode()? "Test_mode" : "Nomal_mode");
+	err = wland_sdio_trap_attach(drvr);
+	if (err < 0) {
+		WLAND_ERR("sdio_trap_attach failed!\n");
+		goto fail;
+	}
+#endif /* WLAND_FPGA_SUPPORT */
+
+	if (!check_test_mode()) {
+		bus->intr = true;
+		bus->poll = false;
+#ifdef WLAND_SDIO_SUPPORT
+		rda_mmc_set_sdio_irq(1, true);
+#endif /*WLAND_SDIO_SUPPORT */
+	}
+
+	err = wland_preinit_cmds(ifp);
+	if (err < 0)
+		WLAND_ERR("preinit cmds failed!\n");
+
+fail:
+	WLAND_DBG(DCMD, TRACE, "Done(err:%d)\n", err);
+
+	return err;
+}
diff --git a/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.h b/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.h
new file mode 100644
index 000000000000..ba7293f27fb7
--- /dev/null
+++ b/drivers/net/wireless/rdaw80211/rdawlan/wland_wid.h
@@ -0,0 +1,814 @@
+
+/*
+ * Copyright (c) 2014 Rdamicro Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _WLAND_WID_H_
+#define _WLAND_WID_H_
+
+#define MAX_STRING_LEN                          (256)
+#define MAX_CMD_LEN                             (MAX_STRING_LEN)
+#define WLAN_MAX_WID_LEN                        (MAX_CMD_LEN - 2)
+
+#define FWS_HANGER_MAXITEMS	                    16
+
+#define WLAND_FWS_MAC_DESC_TABLE_SIZE			16
+
+#define WLAND_FWS_PSQ_PREC_COUNT		        ((FWS_FIFO_COUNT + 1) * 2)
+#define WLAND_FWS_PSQ_LEN				        256
+
+#define BRCMF_FWS_RET_OK_NOSCHEDULE	            0
+#define BRCMF_FWS_RET_OK_SCHEDULE	            1
+
+/*******************************************************************************
+ * WID message type
+ ******************************************************************************/
+#define WLAND_WID_MSG_QUERY						'Q'	/* Hex---0x51 */
+#define WLAND_WID_MSG_WRITE						'W'	/* Hex---0x57 */
+#define WLAND_WID_MSG_RESP						'R'	/* Hex---0x52 */
+#define WLAND_WID_MSG_NETINFO					'N'	/* Hex---0x4E */
+#define WLAND_WID_MSG_MAC_STATUS				'I'	/* Hex---0x49 */
+#define WLAND_WID_MSG_EVENT					    'E'	/* Hex---0x4E */
+
+/**
+ * NETWORK_EVENT_TYPE_T - Network Event type
+ */
+typedef enum {
+
+    /**
+     * EVENT_SCAN_COMPLETE - Scan complete
+     *
+     * This event should be used when host triggered scan complete.
+     */
+	EVENT_SCAN_COMPLETE = 0,
+
+    /**
+     * EVENT_SCAN_NOT_FOUND - Scan for join but no BSS found.
+     *
+     * This event should be used when BSS scaned for join not found.
+     */
+	EVENT_SCAN_NOT_FOUND,
+
+    /**
+     * EVENT_JOIN - Join the BSS
+     *
+     * This event should be used when join a (I)BSS (Rx Beacon).
+     */
+	EVENT_JOIN,
+
+    /**
+     * EVENT_JOIN_TIMED_OUT - Join timed out
+     *
+     * This event should be used when join a (I)BSS timed out.
+     */
+	EVENT_JOIN_TIMED_OUT,
+
+    /**
+     * EVENT_AUTH - Authentication
+     *
+     * This event should be used when authentication has been completed.
+     */
+	EVENT_AUTH,
+
+    /**
+     * EVENT_AUTH_TIMED_OUT - Authentication timed out
+     */
+	EVENT_AUTH_TIMED_OUT,
+
+    /**
+     * EVENT_DEAUTH - Authentication lost
+     *
+     * This event should be called when authentication is lost either due
+     * to receiving deauthenticate frame from the AP or when sending that
+     * frame to the current AP.
+     */
+	EVENT_DEAUTH,
+
+    /**
+     * EVENT_ASSOC - Association completed
+     *
+     * This event needs to be delivered when the firmware completes IEEE
+     * 802.11 association or reassociation.
+     */
+	EVENT_ASSOC,
+
+    /**
+     * EVENT_ASSOC_TIMED_OUT - Association timed out
+     */
+	EVENT_ASSOC_TIMED_OUT,
+
+    /**
+     * EVENT_DISASSOC - Association lost
+     *
+     * This event should be called when association is lost either due to
+     * receiving deauthenticate or disassociate frame from the AP or when
+     * sending either of these frames to the current AP.
+     */
+	EVENT_DISASSOC,
+
+    /**
+     * EVENT_MICHAEL_MIC_FAILURE - Michael MIC (TKIP) detected
+     *
+     * This event must be delivered when a Michael MIC error is detected by
+     * the firmware. Additional data for event processing is
+     * provided with network_event_data_t::michael_mic_failure.
+     */
+	EVENT_MICHAEL_MIC_FAILURE,
+
+	EVENT_AUTH_IND,
+	EVENT_DEAUTH_IND,
+	EVENT_ASSOC_IND,
+	EVENT_REASSOC_IND,
+	EVENT_DISASSOC_IND,
+
+	NUM_EVENT_TYPE
+} NETWORK_EVENT_TYPE_T;
+
+/*******************************************************************************
+ * IO codes that are interpreted by dongle firmware
+ ******************************************************************************/
+
+/* G_PREAMBLE type */
+#define G_SHORT_PREAMBLE                        0
+#define G_LONG_PREAMBLE                         1
+#define G_AUTO_PREAMBLE                         2
+
+/* WID Data Types */
+enum wid_type {
+	WID_CHAR = 0,
+	WID_SHORT = 1,
+	WID_INT = 2,
+	WID_STR = 3,
+	WID_BIN = 4,
+	WID_UNKNOW = 5
+};
+
+enum wland_pkt_type {
+	PKT_TYPE_REQ = 1,	/* data    to   firmware */
+	PKT_TYPE_IND = 2,	/* data    from frimware */
+	PKT_TYPE_CFG_RSP = 3,	/* cfg rsp from frimware */
+	PKT_TYPE_CFG_REQ = 4,	/* cfg req to   firmware */
+	PKT_TYPE_ASYNC = 5
+};
+
+/* WLAN Identifiers */
+enum wland_firmw_wid {
+	WID_NIL = -1,
+	WID_BSS_TYPE = 0x0000,
+	WID_CURRENT_TX_RATE = 0x0001,
+	WID_CURRENT_CHANNEL = 0x0002,
+	WID_PREAMBLE = 0x0003,
+	WID_11G_OPERATING_MODE = 0x0004,
+	WID_STATUS = 0x0005,
+	WID_11G_PROT_MECH = 0x0006,
+
+#ifdef MAC_HW_UNIT_TEST_MODE
+	WID_GOTO_SLEEP = 0x0007,
+#else /* MAC_HW_UNIT_TEST_MODE */
+	WID_SCAN_TYPE = 0x0007,
+#endif /* MAC_HW_UNIT_TEST_MODE */
+
+	WID_PRIVACY_INVOKED = 0x0008,
+	WID_KEY_ID = 0x0009,
+	WID_QOS_ENABLE = 0x000A,
+	WID_POWER_MANAGEMENT = 0x000B,
+	WID_802_11I_MODE = 0x000C,
+	WID_AUTH_TYPE = 0x000D,
+	WID_SITE_SURVEY = 0x000E,
+	WID_LISTEN_INTERVAL = 0x000F,
+	WID_DTIM_PERIOD = 0x0010,
+	WID_ACK_POLICY = 0x0011,
+	WID_RESET = 0x0012,
+	WID_PCF_MODE = 0x0013,
+	WID_CFP_PERIOD = 0x0014,
+	WID_BCAST_SSID = 0x0015,
+
+#ifdef MAC_HW_UNIT_TEST_MODE
+	WID_PHY_TEST_PATTERN = 0x0016,
+#else /* MAC_HW_UNIT_TEST_MODE */
+	WID_DISCONNECT = 0x0016,
+#endif /* MAC_HW_UNIT_TEST_MODE */
+
+	WID_READ_ADDR_SDRAM = 0x0017,
+	WID_TX_POWER_LEVEL_11A = 0x0018,
+	WID_REKEY_POLICY = 0x0019,
+	WID_SHORT_SLOT_ALLOWED = 0x001A,
+	WID_PHY_ACTIVE_REG = 0x001B,
+	WID_PHY_ACTIVE_REG_VAL = 0x001C,
+	WID_TX_POWER_LEVEL_11B = 0x001D,
+	WID_START_SCAN_REQ = 0x001E,
+	WID_RSSI = 0x001F,
+	WID_JOIN_REQ = 0x0020,
+	WID_ANTENNA_SELECTION = 0x0021,
+	WID_USER_CONTROL_ON_TX_POWER = 0x0027,
+	WID_MEMORY_ACCESS_8BIT = 0x0029,
+	WID_UAPSD_SUPPORT_AP = 0x002A,
+	WID_CURRENT_MAC_STATUS = 0x0031,
+	WID_AUTO_RX_SENSITIVITY = 0x0032,
+	WID_DATAFLOW_CONTROL = 0x0033,
+	WID_SCAN_FILTER = 0x0036,
+	WID_LINK_LOSS_THRESHOLD = 0x0037,
+	WID_AUTORATE_TYPE = 0x0038,
+	WID_CCA_THRESHOLD = 0x0039,
+
+	WID_802_11H_DFS_MODE = 0x003B,
+	WID_802_11H_TPC_MODE = 0x003C,
+
+	WID_PHY_REG_ADDR = 0x0040,
+	WID_PHY_REG_VAL = 0x0041,
+	WID_PTA_MODE = 0x0042,
+	WID_TRAP_TEST = 0x0043,
+	WID_PTA_BLOCK_BT = 0x0044,
+	WID_NETWORK_INFO_EN = 0x0045,
+	WID_COOLSAND_HACK = 0x0046,
+	WID_CONTINENT = 0x0047,
+	WID_SDIO_INT_CLK_SEL = 0x0048,
+	WID_SDIO_TX_HANDSHAKE = 0x0049,
+	WID_BT_MAILBOX_ALARM_INTERVAL = 0x004A,
+	WID_RX_DATA_RATE = 0x004B,
+	WID_POWER_SAVE = 0x004C,
+	WID_NULL_PKT_INTERVAL = 0x004D,
+	WID_MAC_ROLE = 0x004E,
+	WID_PREASSO_TBTT_CON = 0x004F,
+
+	WID_WPS_ENABLE = 0x0053,
+	WID_WPS_START = 0x0054,
+	WID_WPS_DEV_MODE = 0x0055,
+	WID_OOB_RESET_REQ = 0x0056,
+	WID_ENABLE_INT_SUPP = 0x0057,
+	WID_DEVICE_MODE = 0x0058,
+
+	/*
+	 * NMAC Character WID list
+	 */
+	WID_11N_PROT_MECH = 0x0080,
+	WID_11N_ERP_PROT_TYPE = 0x0081,
+	WID_11N_ENABLE = 0x0082,
+	WID_11N_OPERATING_TYPE = 0x0083,
+	WID_11N_OBSS_NONHT_DETECTION = 0x0084,
+	WID_11N_HT_PROT_TYPE = 0x0085,
+	WID_11N_RIFS_PROT_ENABLE = 0x0086,
+	WID_11N_SMPS_MODE = 0x0087,
+	WID_11N_CURRENT_TX_MCS = 0x0088,
+	WID_11N_PRINT_STATS = 0x0089,
+	WID_HUT_FCS_CORRUPT_MODE = 0x008A,
+	WID_HUT_RESTART = 0x008B,
+	WID_HUT_TX_FORMAT = 0x008C,
+	WID_11N_SHORT_GI_ENABLE = 0x008D,
+	WID_HUT_BANDWIDTH = 0x008E,
+	WID_HUT_OP_BAND = 0x008F,
+	WID_HUT_STBC = 0x0090,
+	WID_HUT_ESS = 0x0091,
+	WID_HUT_ANTSET = 0x0092,
+	WID_HUT_HT_OP_MODE = 0x0093,
+	WID_RIFS_MODE = 0x0094,
+	WID_HUT_SMOOTHING_REC = 0x0095,
+	WID_HUT_SOUNDING_PKT = 0x0096,
+	WID_HUT_HT_CODING = 0x0097,
+	WID_HUT_TEST_DIR = 0x0098,
+	WID_HUT_PHY_TEST_MODE = 0x009A,
+	WID_HUT_PHY_TEST_RATE_HI = 0x009B,
+	WID_HUT_PHY_TEST_RATE_LO = 0x009C,
+	WID_HUT_DISABLE_RXQ_REPLENISH = 0x009D,
+	WID_HUT_KEY_ORIGIN = 0x009E,
+	WID_HUT_BCST_PERCENT = 0x009F,
+	WID_HUT_GROUP_CIPHER_TYPE = 0x00A0,
+	WID_TX_ABORT_CONFIG = 0x00A1,
+	WID_HOST_DATA_IF_TYPE = 0x00A2,
+	WID_HOST_CONFIG_IF_TYPE = 0x00A3,
+	WID_HUT_TSF_TEST_MODE = 0x00A4,
+	WID_HUT_PKT_TSSI_VALUE = 0x00A5,
+	WID_REG_TSSI_11B_VALUE = 0x00A6,
+	WID_REG_TSSI_11G_VALUE = 0x00A7,
+	WID_REG_TSSI_11N_VALUE = 0x00A8,
+	WID_TX_CALIBRATION = 0x00A9,
+	WID_DSCR_TSSI_11B_VALUE = 0x00AA,
+	WID_DSCR_TSSI_11G_VALUE = 0x00AB,
+	WID_DSCR_TSSI_11N_VALUE = 0x00AC,
+	WID_HUT_RSSI_EX = 0x00AD,
+	WID_HUT_ADJ_RSSI_EX = 0x00AE,
+	WID_11N_IMMEDIATE_BA_ENABLED = 0x00AF,
+	WID_11N_TXOP_PROT_DISABLE = 0x00B0,
+	WID_TX_POWER_LEVEL_11N = 0x00B1,
+	WID_HUT_FC_TXOP_MOD = 0x00C2,
+	WID_HUT_FC_PROT_TYPE = 0x00C3,
+	WID_HUT_SEC_CCA_ASSERT = 0x00C4,
+	WID_2040_40MHZ_INTOLERANT = 0x00C7,
+	WID_11N_CURRENT_TX_BW = 0x00C8,
+	WID_TX_POWER_LEVEL_11N_40MHZ = 0x00C9,
+	WID_11I_PTKSA_REPLAY_COUNTER = 0x00CA,
+	WID_11N_MINIMUM_MPDU_START_SPACING = 0x00CB,
+	WID_11N_MAX_RX_AMPDU_FACTOR = 0x00CC,
+	WID_11N_ADDBA_TID = 0x00CD,
+	WID_11N_AMPDU_TID = 0x00CE,
+	WID_11N_AMSDU_TID = 0x00CF,
+	WID_11N_AMSDU_ENABLE = 0x00D0,
+
+	/*
+	 * Custom Character WID list
+	 */
+	WID_P2P_ENABLE = 0x0201,
+	WID_P2P_DISCOVERABLE = 0x0202,
+	WID_P2P_LISTEN_CHAN = 0x0203,
+	WID_P2P_FIND_TO = 0x0204,
+	WID_P2P_GO_INT_VAL = 0x0205,
+	WID_P2P_PERSIST_GRP = 0x0206,
+	WID_P2P_AUTO_GO = 0x0207,
+	WID_P2P_INTRA_BSS = 0x0208,
+	WID_P2P_CT_WINDOW = 0x0209,
+	WID_P2P_LISTEN_MODE = 0x020A,
+
+	WID_MAX_CHAR_ID = 0x020B,	//last char id
+
+	/*
+	 * EMAC Short WID list
+	 */
+	WID_RTS_THRESHOLD = 0x1000,
+	WID_FRAG_THRESHOLD = 0x1001,
+	WID_SHORT_RETRY_LIMIT = 0x1002,
+	WID_LONG_RETRY_LIMIT = 0x1003,
+	WID_CFP_MAX_DUR = 0x1004,
+	WID_PHY_TEST_FRAME_LEN = 0x1005,
+	WID_BEACON_INTERVAL = 0x1006,
+	WID_MEMORY_ACCESS_16BIT = 0x1008,
+	WID_RX_SENSE = 0x100B,
+	WID_ACTIVE_SCAN_TIME = 0x100C,
+	WID_PASSIVE_SCAN_TIME = 0x100D,
+	WID_SITE_SURVEY_SCAN_TIME = 0x100E,
+	WID_JOIN_TIMEOUT = 0x100F,
+	WID_AUTH_TIMEOUT = 0x1010,
+	WID_ASOC_TIMEOUT = 0x1011,
+	WID_11I_PROTOCOL_TIMEOUT = 0x1012,
+	WID_EAPOL_RESPONSE_TIMEOUT = 0x1013,
+	WID_WPS_PASS_ID = 0x1014,
+	WID_WPS_CONFIG_METHOD = 0x1015,
+	WID_CCA_BUSY_STATUS = 0x1016,
+	WID_OFFSET_INTERVAL = 0x1017,
+	WID_SAMPLE_COUNT = 0x1018,
+	WID_CWWIN_MAX = 0x1019,
+	WID_PTA_WIFI_ACTIVE_TIME = 0x101A,
+	WID_MAX_SHORT_ID = 0x101B,	//last short id
+
+	/*
+	 * EMAC Integer WID list
+	 */
+	WID_FAILED_COUNT = 0x2000,
+	WID_RETRY_COUNT = 0x2001,
+	WID_MULTIPLE_RETRY_COUNT = 0x2002,
+	WID_FRAME_DUPLICATE_COUNT = 0x2003,
+	WID_ACK_FAILURE_COUNT = 0x2004,
+	WID_RECEIVED_FRAGMENT_COUNT = 0x2005,
+	WID_MULTICAST_RECEIVED_FRAME_COUNT = 0x2006,
+	WID_FCS_ERROR_COUNT = 0x2007,
+	WID_SUCCESS_FRAME_COUNT = 0x2008,
+	WID_PHY_TEST_PKT_CNT = 0x2009,
+	WID_PHY_TEST_TXD_PKT_CNT = 0x200A,
+	WID_TX_FRAGMENT_COUNT = 0x200B,
+	WID_TX_MULTICAST_FRAME_COUNT = 0x200C,
+	WID_RTS_SUCCESS_COUNT = 0x200D,
+	WID_RTS_FAILURE_COUNT = 0x200E,
+	WID_WEP_UNDECRYPTABLE_COUNT = 0x200F,
+	WID_REKEY_PERIOD = 0x2010,
+	WID_REKEY_PACKET_COUNT = 0x2011,
+
+#ifdef MAC_HW_UNIT_TEST_MODE
+	WID_Q_ENABLE_INFO = 0x2012,
+#else /* MAC_HW_UNIT_TEST_MODE */
+	WID_802_1X_SERV_ADDR = 0x2012,
+#endif /* MAC_HW_UNIT_TEST_MODE */
+
+	WID_STACK_IP_ADDR = 0x2013,
+	WID_STACK_NETMASK_ADDR = 0x2014,
+	WID_HW_RX_COUNT = 0x2015,
+	WID_MEMORY_ADDRESS = 0x201E,
+	WID_MEMORY_ACCESS_32BIT = 0x201F,
+	WID_RF_REG_VAL = 0x2021,
+	WID_FIRMWARE_INFO = 0x2023,
+	WID_NETWORK_EVENT_EN = 0x2100,
+
+	/*
+	 * NMAC Integer WID list
+	 */
+	WID_SYS_FW_VER = 0x2801,
+	WID_SYS_DBG_LVL = 0x2802,
+	WID_SYS_DBG_AREA = 0x2803,
+	WID_UT_MODE = 0x2804,
+	WID_UT_TX_LEN = 0x2805,
+	WID_PTA_CTS_FRAME_LEN = 0x2806,
+	WID_PREASSO_SLEEP = 0x2807,
+	WID_MAX_INTEGER_ID = 0x2808,	//last int id
+
+	/*
+	 * EMAC String WID list
+	 */
+	WID_SSID = 0x3000,
+	WID_FIRMWARE_VERSION = 0x3001,
+	WID_OPERATIONAL_RATE_SET = 0x3002,
+	WID_BSSID = 0x3003,
+	WID_WEP_KEY_VALUE0 = 0x3004,
+	WID_WEP_KEY_VALUE1 = 0x3005,
+	WID_WEP_KEY_VALUE2 = 0x3006,
+	WID_WEP_KEY_VALUE3 = 0x3007,
+	WID_802_11I_PSK = 0x3008,
+	WID_HCCA_ACTION_REQ = 0x3009,
+	WID_802_1X_KEY = 0x300A,
+	WID_HARDWARE_VERSION = 0x300B,
+	WID_MAC_ADDR = 0x300C,
+	WID_PHY_TEST_DEST_ADDR = 0x300D,
+	WID_PHY_TEST_STATS = 0x300E,
+	WID_PHY_VERSION = 0x300F,
+	WID_SUPP_USERNAME = 0x3010,
+	WID_SUPP_PASSWORD = 0x3011,
+	WID_SITE_SURVEY_RESULTS = 0x3012,
+	WID_RX_POWER_LEVEL = 0x3013,
+	WID_ADD_WEP_KEY = 0x3019,
+	WID_REMOVE_WEP_KEY = 0x301A,
+	WID_ADD_PTK = 0x301B,
+	WID_ADD_RX_GTK = 0x301C,
+	WID_ADD_TX_GTK = 0x301D,
+	WID_REMOVE_KEY = 0x301E,
+	WID_ASSOC_REQ_INFO = 0x301F,
+	WID_ASSOC_RES_INFO = 0x3020,
+	WID_UPDATE_RF_SUPPORTED_INFO = 0x3021,
+	WID_COUNTRY_IE = 0x3022,
+	WID_WAPI_ASSOC_IE = 0x3023,
+	WID_ADD_WAPI_PTK = 0x3024,
+	WID_ADD_WAPI_RX_GTK = 0x3025,
+	WID_ADD_WAPI_TX_GTK = 0x3026,
+	WID_HIDE_SSID = 0X3027,
+	WID_GEN_ASSOC_IE = 0x3028,
+	WID_WPS_STATUS = 0x302A,
+	WID_WPS_PIN = 0x302B,
+
+	WID_P2P_TARGET_DEV_ID = 0x302D,
+	WID_P2P_INVIT_DEV_ID = 0x302E,
+	WID_P2P_PERSIST_CRED = 0x3030,
+	WID_P2P_NOA_SCHEDULE = 0x3031,
+	WID_MAX_STRING_ID = 0x3032,	//last string id
+
+	/*
+	 * EMAC Binary WID List
+	 */
+	WID_CONFIG_HCCA_ACTION_REQ = 0x4000,
+	WID_UAPSD_CONFIG = 0x4001,
+	WID_UAPSD_STATUS = 0x4002,
+	WID_WMM_AP_AC_PARAMS = 0x4003,
+	WID_WMM_STA_AC_PARAMS = 0x4004,
+	WID_NETWORK_INFO = 0x4005,
+	WID_STA_JOIN_INFO = 0x4006,
+	WID_CONNECTED_STA_LIST = 0x4007,
+	WID_HUT_STATS = 0x4082,
+	WID_STATISTICS = 0x4008,
+	WID_MEMORY_DUMP = 0x4009,
+	WID_LOAD_TRAP_MAP = 0x400A,
+	WID_AGC_DGC_TBL = 0x400B,
+	WID_RX_FILTER = 0X400C,
+	WID_WPS_CRED_LIST = 0x400F,
+	// miaodefang for PTA
+	WID_PTA_PARAMETER = 0x4010,
+	WID_PRIM_DEV_TYPE = 0x4011,
+	/*
+	 * NMAC Binary WID list
+	 */
+	WID_11N_AUTORATE_TABLE = 0x4012,
+	WID_P2P_REQ_DEV_TYPE = 0x4013,
+	WID_MAX_BINARY_ID = 0x4014,	//last string id
+
+	/*
+	 * Miscellaneous WIDs
+	 */
+	WID_ALL = 0x7FFE,
+	WID_MAX = 0xFFFF
+};
+
+/*
+ * enum wland_fws_skb_state - indicates processing state of skb.
+ *
+ * @FWS_SKBSTATE_NEW: sk_buff is newly arrived in the driver.
+ * @FWS_SKBSTATE_DELAYED: sk_buff had to wait on queue.
+ * @FWS_SKBSTATE_SUPPRESSED: sk_buff has been suppressed by firmware.
+ * @FWS_SKBSTATE_TIM: allocated for TIM update info.
+ */
+enum wland_fws_skb_state {
+	FWS_SKBSTATE_NEW,
+	FWS_SKBSTATE_DELAYED,
+	FWS_SKBSTATE_SUPPRESSED,
+	FWS_SKBSTATE_TIM
+};
+
+/*
+ * struct wland_skbuff_cb - control buffer associated with skbuff.
+ *
+ * @if_flags: holds interface index and packet related flags.
+ * @htod: host to device packet identifier (used in PKTTAG tlv).
+ * @state: transmit state of the packet.
+ * @mac: descriptor related to destination for this packet.
+ *
+ * This information is stored in control buffer struct sk_buff::cb, which
+ * provides 48 bytes of storage so this structure should not exceed that.
+ */
+struct wland_skbuff_cb {
+	u16 if_flags;
+	u32 htod;
+	enum wland_fws_skb_state state;
+	struct wland_mac_descriptor *mac;
+};
+
+/*
+ * enum wland_fws_fifo - fifo indices used by dongle firmware.
+ *
+ * @WLAND_FWS_FIFO_FIRST: first fifo, ie. background.
+ * @WLAND_FWS_FIFO_AC_BK: fifo for background traffic.
+ * @WLAND_FWS_FIFO_AC_BE: fifo for best-effort traffic.
+ * @WLAND_FWS_FIFO_AC_VI: fifo for video traffic.
+ * @WLAND_FWS_FIFO_AC_VO: fifo for voice traffic.
+ * @WLAND_FWS_FIFO_BCMC : fifo for broadcast/multicast (AP only).
+ * @WLAND_FWS_FIFO_ATIM : fifo for ATIM (AP only).
+ * @FWS_FIFO_COUNT      : number of fifos.
+ */
+enum wland_fws_fifo {
+	WLAND_FWS_FIFO_FIRST,
+	WLAND_FWS_FIFO_AC_BK = WLAND_FWS_FIFO_FIRST,
+	WLAND_FWS_FIFO_AC_BE,
+	WLAND_FWS_FIFO_AC_VI,
+	WLAND_FWS_FIFO_AC_VO,
+	WLAND_FWS_FIFO_BCMC,
+	WLAND_FWS_FIFO_ATIM,
+	FWS_FIFO_COUNT
+};
+
+enum wland_fws_mac_desc_state {
+	FWS_STATE_OPEN = 1,
+	FWS_STATE_CLOSE
+};
+
+/*
+ * struct wland_mac_descriptor - firmware signalling data per node/interface
+ *
+ * @occupied:           slot is in use.
+ * @mac_handle:         handle for mac entry determined by firmware.
+ * @interface_id:       interface index.
+ * @state:              current state.
+ * @suppressed:         mac entry is suppressed.
+ * @generation:         generation bit.
+ * @ac_bitmap:          ac queue bitmap.
+ * @requested_credit:   credits requested by firmware.
+ * @ea:                 ethernet address.
+ * @seq:                per-node free-running sequence.
+ * @psq:                power-save queue.
+ * @transit_count:      packet in transit to firmware.
+ */
+struct wland_mac_descriptor {
+	char name[16];
+	u8 occupied;
+	u8 mac_handle;
+	u8 interface_id;
+	u8 state;
+	bool suppressed;
+	u8 generation;
+	u8 ac_bitmap;
+	u8 requested_credit;
+	u8 requested_packet;
+	u8 ea[ETH_ALEN];
+	u8 seq[FWS_FIFO_COUNT];
+	struct pktq psq;
+	int transit_count;
+	int suppr_transit_count;
+	bool send_tim_signal;
+	u8 traffic_pending_bmp;
+	u8 traffic_lastreported_bmp;
+};
+
+/*
+ * enum wland_fws_hanger_item_state - state of hanger item.
+ *
+ * @FWS_HANGER_ITEM_STATE_FREE  : item is free for use.
+ * @FWS_HANGER_ITEM_STATE_INUSE : item is in use.
+ * @FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED: item was suppressed.
+ */
+enum wland_fws_hanger_item_state {
+	FWS_HANGER_ITEM_STATE_FREE = 1,
+	FWS_HANGER_ITEM_STATE_INUSE,
+	FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED
+};
+
+/*
+ * struct wland_fws_hanger_item - single entry for tx pending packet.
+ *
+ * @state   : entry is either free or occupied.
+ * @pkt     : packet itself.
+ */
+struct wland_fws_hanger_item {
+	enum wland_fws_hanger_item_state state;
+	struct sk_buff *pkt;
+};
+
+/*
+ * struct wland_fws_hanger - holds packets awaiting firmware txstatus.
+ *
+ * @pushed          : packets pushed to await txstatus.
+ * @popped          : packets popped upon handling txstatus.
+ * @failed_to_push  : packets that could not be pushed.
+ * @failed_to_pop   : packets that could not be popped.
+ * @failed_slotfind : packets for which failed to find an entry.
+ * @slot_pos        : last returned item index for a free entry.
+ * @items           : array of hanger items.
+ */
+struct wland_fws_hanger {
+	u32 pushed;
+	u32 popped;
+	u32 failed_to_push;
+	u32 failed_to_pop;
+	u32 failed_slotfind;
+	u32 slot_pos;
+	struct wland_fws_hanger_item items[FWS_HANGER_MAXITEMS];
+};
+
+struct wland_fws_macdesc_table {
+	struct wland_mac_descriptor nodes[WLAND_FWS_MAC_DESC_TABLE_SIZE];
+	struct wland_mac_descriptor iface[WLAND_MAX_IFS];
+	struct wland_mac_descriptor other;	/* current mac descriptor */
+};
+
+struct wland_fws_info {
+	struct wland_private *drvr;
+	spinlock_t spinlock;
+	ulong flags;
+	struct wland_fws_stats stats;
+	struct wland_fws_hanger hanger;
+	struct wland_fws_macdesc_table desc;
+	u32 fifo_enqpkt[FWS_FIFO_COUNT];
+	u32 fifo_delay_map;
+};
+
+typedef enum {
+	PTA_NONE_PROTECT = 0,
+	PTA_NULL_DATA_PROTECT,
+	PTA_PS_POLL_PROTECT,
+	PTA_SELF_CTS_PROTECT,
+	PTA_AUTO_PROTECT
+} PTA_PROTECT_MODE_T;
+
+struct pta_param_s {
+	u8 prot_mode;
+	u8 mac_rate;		// 0: MIN_basic rate
+	u8 hw_retry;
+	u8 sw_retry;
+	u8 cca_bypass;
+
+	u8 restore;
+
+	u16 active_time;	/* Unit is 100us */
+	u16 thresh_time;	/* Unit is 100us */
+
+	u16 auto_prot_thresh_time;	/* Unit is 100us */
+
+	/*
+	 * BIT0: Check high priority Q NULL before send PS_Poll or NULL frame
+	 * BIT1: Check normal priority Q(AC_VO_Q) NULL before send PS_Poll or NULL frame
+	 * BIT2: Check AC_VI_Q NULL before send PS_Poll or NULL frame
+	 * BIT3: Check AC_BE_Q NULL before send PS_Poll or NULL frame
+	 * BIT4: Check AC_BK_Q NULL before send PS_Poll or NULL frame
+	 * BIT5: Check g_more_data_expected when send PS_Poll
+	 */
+	u16 flags;
+	u8 listen_interval;
+} __packed;
+
+/* return wid type by wid */
+static inline enum wid_type wland_get_wid_type(enum wland_firmw_wid firmw_wid)
+{
+	if (firmw_wid < WID_MAX_CHAR_ID) {
+		return WID_CHAR;
+	} else if (firmw_wid < WID_MAX_SHORT_ID) {
+		return WID_SHORT;
+	} else if (firmw_wid < WID_MAX_INTEGER_ID) {
+		return WID_INT;
+	} else if (firmw_wid < WID_MAX_STRING_ID) {
+		return WID_STR;
+	} else if (firmw_wid < WID_MAX_BINARY_ID) {
+		return WID_BIN;
+	} else {
+		return WID_UNKNOW;
+	}
+}
+
+static inline u8 wland_get_seqidx(struct wland_private *drvr)
+{
+	u8 idx = 0;
+	struct wland_proto *prot = drvr->prot;
+
+	/*
+	 * Fill MsgIdx
+	 */
+	if (prot) {
+		idx = prot->reqid;
+		++prot->reqid;
+	}
+
+	return idx;
+}
+
+static inline u16 wland_get_wid_size(enum wid_type type, u16 len)
+{
+	switch (type) {
+	case WID_CHAR:
+		return sizeof(u8);
+	case WID_SHORT:
+		return sizeof(u16);
+	case WID_INT:
+		return sizeof(u32);
+	case WID_STR:
+	case WID_BIN:
+	case WID_UNKNOW:
+		break;
+	default:
+		break;
+	}
+	return len;
+}
+
+/* attach proto module */
+extern int wland_proto_attach(struct wland_private *drvr);
+extern void wland_proto_detach(struct wland_private *drvr);
+
+/* Add any protocol-specific data header */
+extern int wland_proto_hdrpush(struct wland_private *drvr, s32 ifidx,
+	struct sk_buff *pktbuf);
+
+/* Remove any protocol-specific data header. */
+extern int wland_proto_hdrpull(struct wland_private *drvr, s32 * ifidx,
+	struct sk_buff *pktbuf);
+
+/* group cmd set scan parameters */
+extern s32 wland_set_scan_timeout(struct wland_if *ifp);
+
+/* enable scan for ap list*/
+extern s32 wland_start_scan_set(struct wland_if *ifp,
+	struct wland_ssid_le *scan_ssid, bool enable);
+
+extern s32 wland_start_ap_set(struct wland_if *ifp,
+	struct wland_cfg80211_profile *profile, bool is_p2p);
+
+extern s32 wland_fil_set_mgmt_ie(struct wland_if *ifp, u8 * vndr_ie_buf,
+	u16 vndr_ie_len);
+extern s32 wland_set_txrate(struct wland_if *ifp, u8 mbps);
+extern int wland_dev_get_rssi(struct net_device *ndev, s16 * pRssi);
+extern s32 wland_disconnect_bss(struct wland_if *ifp,
+	struct wland_scb_val_le *scbval);
+
+extern s32 wland_add_wep_key_bss_sta(struct wland_if *ifp, u8 * key, u8 wep_len,
+	u8 key_id);
+
+extern s32 wland_start_join(struct wland_if *ifp,
+	struct wland_cfg80211_profile *profile);
+
+/* set/get cmd */
+extern int wland_fil_set_cmd_data(struct wland_if *ifp, u16 cmd, void *data,
+	u16 len);
+extern int wland_fil_get_cmd_data(struct wland_if *ifp, u16 cmd, void *data,
+	u16 len);
+
+extern s32 wland_fil_iovar_data_set(struct wland_if *ifp, char *name,
+	void *data, u16 len);
+extern s32 wland_fil_iovar_data_get(struct wland_if *ifp, char *name,
+	void *data, u16 len);
+
+extern bool wland_prec_enq(struct device *dev, struct pktq *q,
+	struct sk_buff *pkt, int prec);
+
+/* Sets chip media info (drv_version, mac address). */
+extern int wland_start_chip(struct wland_if *ifp, u8 device_role);
+
+/* send the wid command send to chip */
+extern int wland_fws_init(struct wland_private *drvr);
+extern void wland_fws_deinit(struct wland_private *drvr);
+extern void wland_fws_add_interface(struct wland_if *ifp);
+extern void wland_fws_del_interface(struct wland_if *ifp);
+extern void wland_fws_macdesc_init(struct wland_mac_descriptor *desc, u8 * addr,
+	u8 ifidx);
+
+extern bool fws_macdesc_closed(struct wland_fws_info *fws,
+	struct wland_mac_descriptor *entry, int fifo);
+extern void fws_macdesc_cleanup(struct wland_fws_info *fws,
+	struct wland_mac_descriptor *entry, int ifidx);
+
+extern struct wland_mac_descriptor *fws_macdesc_find(struct wland_fws_info *fws,
+	struct wland_if *ifp, u8 * da);
+
+extern int wland_proto_cdc_data(struct wland_private *drvr, u16 wid_msg_len);
+
+/* Send packet to dongle via data channel */
+extern int wland_sendpkt(struct wland_if *ifp, struct sk_buff *skb);
+#endif /* _WLAND_WID_H_ */
